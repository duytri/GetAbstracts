1#Book Review: Discover Linux
2#MOSFET table look-up models for circuit simulation
3#The verification of the protection mechanisms of high-level language machines
4#Another view of functional and multivalued dependencies in the relational database model
5#Entity-relationship diagrams which are in BCNF
6#The computer comes of age
7#Computationally efficient algorithms for a one-time pad scheme
8#The hierarchical ordering in Multiattribute files
9#Insertion languages
10#The Three-Machine No-Wait Flow Shop is NP-Complete
11#Lower Bounds and Fast Algorithms for Sequence Acceleration
12#Space-Time Trade-Offs for Banded Matrix Problems
13#The VLSI Complexity of Selected Graph Problems
14#Computability with Pascal
15#Ambiguity and decision problems concerning number systems
16#The implication problem for functional and inclusion dependencies
17#Cynamic parallel memories
18#Succinct representations of graphs
19#On storage media with after effects
20#A necessary and sufficient condition in order that a Herbrand interpretation be expressive relative to recursive programs
21#Enclosing methods in perturbed nonlinear operator equations
22#On two more Eigenvalue methods for an alternating sequential parallel system
23#Random variate generation for unimodal and monotone densities
24#An approximation method of the local type. Application to a problem of heart potential mapping
25#Computing surfaces of constant mean curvature with singularities
26#Software engineering with MODULA-2 and ADA
27#Frame theory and computations
28#Natural language interface to the question-answering system for physicians
29#Some issues in the semantics and pragmatics of definite reference in the context of natural language database access
30#Stationary wave solutions of a system of reaction-diffusion equations derived from the Fitzhugh-Nagumo equations
31#Up and running: the small business computer implementation cookbook
32#Proc. IFIP working conference on Programming Languages and System Design
33#Fast automatic liveness analysis of hierarchical parallel systems
34#Concatenable type declarations: their applications and implementaion
35#On the coherence of programming language and programming methodology
36#On the design of data abstraction mechanisms for compiler description languages1)
37#The remodularization of a compiler by abstract data types
38#Experience with abstract data type specifications in a compiler project
39#XYZ: a program development environment based on temporal logic
40#Design and verification oriented microprogram transformations
41#ELSA - an extensible programming system
42#A skeleton interpreter for specialized languages
43#Comparing PASCAL and MODULA-2 as systems programming languages
44#ADA: Concurrent Programming
45#Computers, Data Processing, and The Law
46#A fundamental step in the software design process is the selection of a refinement (implementation) for a data abstraction. This step traditionally involves investigating the expected performance of a system under different refinements of an abstraction and then selecting a single alternative which minimizes some performance cost metric. In this paper we reformulate this design step to allow different refinements of the same data abstraction within a computation. This reformulation reflects the fact that the implementation appropriate for a data abstraction is dependent on the behavior exhibited by the objects of the abstraction. Since this behavior can vary among the objects of a computation, a single refinement is often inappropriate. Accordingly, three frameworks are presented for understanding and representing variations in the behavior of objects and, thus, the potential for multiple implementations. The three frameworks are based upon: 1) a static partitioning of objects into disjoint implementation classes; 2) static partitioning of classes into implementation regions; and 3) dynamic partitioning of classes into implementation regions. These frameworks and analytic tools useful in investigating expected performance under multiple implementations are described in detail.
47#Matings in matrices
48#on Automata, languages and programming
49#Register Allocation in Optimizing Compilers
50#Polymorphic programming languages: design and implementation
51#Analysis of speedup in distributed algorithms
52#Automated microcode synthesis
53#A class of generalized stochastic Petri nets for the performance evaluation of multiprocessor systems
54#Static grouping of small objects to enhance performance of a paged virtual memory
55#A supervised learning algorithm for hierarchical classification of fuzzy patterns
56#Quantifiers in the formulation of multiple objective decision functions
57#On the implication operator in fuzzy logic
58#The application of coding theory to the design of combinatorial filing schemes of any order
59#Algorithmic theories of data structures
60#Micro-PROLOG: programming in logic
61#The DISS methodology of distributed system simulation
62#Information Technology Research Development Applications
63#Special-purpose hardware and effective information processing
64#Relevance feedback and a fuzzy set of search terms in an information retrieval system
65#Direct file organization for lemmatized text retrieval
66#Soft evaluation of Boolean search queries in information retrieval systems
67#Augmented semantic networks for an enterprise knowledge base
68#Technology and Science of Informatics
69#A comparative study of some distributed systems
70#Controlled execution of timed petri nets
71#A two-level control structure for parallel heuristic programming
72#SCEPTRE: proposed standard for a real-time executive kernel
73#The application of human factors to the needs of the novice computer user
74#Type-checking in an untyped language
75#A methodology for interactive evaluation of user reactions to software packagesn empirical analysis of system performance, interaction, and run time
76#The depth/breadth trade-off in the design of menu-driven user interfaces
77#The influence of rule-generated stress on computer-synthesized speech
78#Formal specification of interactive graphics programming languages
79#VAX/VMS internals and data structures
80#Smalltalk-80: bits of history, words of advice
81#Overcoming computer illiteracy: a friendly introduction to computers
82#Electronic analog-to-digital converters: principles, circuits, devices, testing
83#A practical guide to designing expert systems
84#Parallel programming in ansi standard ADA
85#Introduction to computer science using the TURING programming language
86#Best approximate circles on integer grids
87#A multiresolution spline with application to image mosaics
88#Efficient polygon-filling algorithms for raster displays
89#Physical structures and application on Database design techniques II
90#Physical database design techniques
91#Design of optimal balanced filing schemes
92#Parallel join and sorting algorithms
93#A language for office and business automation
94#APAD: an application-adaptable database system - its architecture and design -
95#Specific requirements in engineering data base
96#Pattern databases
97#Memories that shaped an industry
98#Effective methods of EDP quality assurance
99#The data center disaster consultant
100#A structured approach to systems testing
101#Creating and planning the corporate data base system project
102#Managing systems maintenance
103#From the Preface (See Front Matter for full Preface) Advances in the design and production of computer hardware have brought many more people into direct contact with computers. Similar advances in the design and production of computer software are required in order that this increased contact be as rewarding as possible. The Smalltalk-80 system is a result of a decade of research into creating computer software that is appropriate for producing highly functional and interactive contact with personal computer systems. This book is the first detailed account of the Smalltalk-80 system. It is divided into four major parts: Part One -- an overview of the concepts and syntax of the programming language. Part Two -- an annotated and illustrated specification of the system's functionality. Part Three -- an example of the design and implementation of a moderate-size application. Part Four -- a specification of the Smalltalk-80 virtual machine.
104#Tree automata and attribute grammars
105#Commutative grammars: the complexity of uniform word problems
106#On the random oracle hypothesis
107#Deterministic process logic is elementary
108#Planning Routes through uncertain territory
109#Extended person-machine interface
110#Sequential program structures
111#LISP programming
112#Microcomputers and their commercial applications
113#From logic to computers
114#A first course in formal language theory
115#UNIX for users
116#Centralized versus decentralized computing: organizational considerations and management options
117#Principles of transaction-oriented database recovery
118#Voice response systems
119#The trie data structure has many properties which make it especially attractive for representing large files of data. These properties include fast retrieval time, quick unsuccessful search determination, and finding the longest match to a given identifier. The main drawback is the space requirement. In this paper the concept of trie compaction is formalized. An exact algorithm for optimal trie compaction and three algorithms for approximate trie compaction are given, and an analysis of the three algorithms is done. The analysis indicate that for actual tries, reductions of around 70 percent in the space required by the uncompacted trie can be expected. The quality of the compaction is shown to be insensitive to the number of nodes, while a more relevant parameter is the alphabet size of the key.
120#LISP: a gentle introduction to symbolic computation
121#Distributed databases principles and systems
122#Proc. of the symposium on A new approach to scientific computation
123#A new arithmetic for scientific computation
124#Computer demonstration packages for standard problems of numerical mathematics
125#Solving algebraic problems with high accuracy
126#Evaluation of arithmetic expressions with maximum accuracy
127#Solving function space problems with guaranteed close bounds
128#Ultra-arithmetic: the digital computer set in function space
129#A FORTRAN extension for scientific computation
130#An introduction to matrix PASCAL: a PASCAL extension for scientific computation
131#Realization of an optimal computer arithmetic
132#Features of a hardware implementation of an optimal arithmetic
133#Differentiation and generation of taylor coefficients in PASCAL-SC
134#MATRIX PASCAL
135#This work investigates one aspect of the performance of CODASYL database systems: the data reference behavior. We introduce a model of database traversals at three levels: the logical, internal, and physical levels. The mapping between the logical and internal levels is defined by the internal schema, whereas the mapping between the internal and the physical levels depends on cluster properties of the database. Our model explains the physical reference behavior for a given sequence of DML statements at the logical level.Software has been implemented to monitor references in two selected CODASYL DBMS applications. In a series of experiments the physical reference behavior was observed for varying internal schemas and cluster properties of the database. The measurements were limited to retrieval transactions, so that a variety of queries could be analyzed for the same well-known state of the database. Also, all databases were relatively small in order to allow fast reloading with varying internal schema parameters. In all cases, the database transactions showed less locality of reference than do programs under virtual memory operating systems; some databases showed no locality at all. No evidence of physical sequentiality was found. This suggests that standard page replacement strategies are not optimal for CODASYL database buffer management; instead, replacement decisions in a database buffer should be based on specific knowledge available from higher system layers.
136#This paper presents the design of a relational query processor. The query processor consists of only four processing PIPEs and a number of random-access memory modules. Each PIPE processes tuples of relations in a bit-serial, tuple-parallel manner for each of the primitive database operations which comprise a complex relational query. The design of the query processor meets three major objectives: the query processor must be manufacturable using existing and near-term LSI (VLSI) technology; it must support in a uniform manner both the numeric and nonnumeric processing requirements a high-level user interface like SQL presents; and it must support the query-processing strategy derived in the query optimizer to satisfy certain system-wide performance optimality criteria.
137#Guide to effective software technical writing
138#Electronic speech synthesis
139#Programming in C
140#Information systems for planning and decision making
141#Environments for VLSI and software engineering
142#Parallels between software and VLSI engineering
143#a decision-based framework for comparing hardware compilers
144#Application of a transformational software development methodology to VLSI design
145#ART-an automated requirements traceability system
146#Metrics to measure the complexity of partial programs
147#Pseudo-extensions of computable functions
148#Cognitive systems engineering: new wine in new bottles
149#The problem of statistical database confidentiality in releasing microdata is addressed through the use of approximate data-swapping. Here, a portion of the microdata is replaced with a database that has been selected with approximately the same statistics. The result guarantees the confidentiality of the original data, while providing microdata with accurate statistics. Methods for achieving such transformations are considered and analyzed through simulation.
150#Programmer-defined control operations
151#Several researchers (Beeri, Bernstein, Chiu, Fagin, Goodman, Maier, Mendelzon, Ullman, and Yannakakis) have introduced a special class of database schemes, called acyclic or tree schemes. Beeri et al. have shown that an acyclic join dependency, naturally defined by an acyclic database scheme, has several desirable properties, and that an acyclic join dependency is equivalent to a conflict-free set of multivalued dependencies. However, since their results are confined to multivalued and join dependencies, it is not clear whether we can handle functional dependencies independently of other dependencies.In the present paper we define an extension of a conflict-free set, called an extended conflict-free set, including multivalued dependencies and functional dependencies, and show the following two properties of an extended conflict-free set:There are three equivalent definitions of an extended conflict-free set. One of them is defined as a set including an acyclic joint dependency and a set of functional dependencies such that the left and right sides of each functional dependency are included in one of the attribute sets that construct the acyclic join dependency.For a relation scheme with an extended conflict-free set, there is a decomposition into third normal form with a lossless join and preservation of dependencies.
152#Medical Decision Making
153#Strategy of computer selection: a step-by-step approach
154#Database management systems
155#Result sequences
156#The contraction of control implementations
157#The use of combinators in translating a purely functional language to low-level data-flow graphs
158#Software system testing and quality assurance
159#Computer organization (2nd ed.)
160#Auditing EDP systems
161#A rational reconstruction of the MYCIN consultation system
162#Using an expert system in merging qualitative and quantitative data analysis
163#Spacetime representations of computational structures
164#Asymptotic error expansions for defect correction iterates
165#A quadratically convergent method for computing simple singular roots and its application to determining simple bifurcation points
166#On preconditioned iterative methods for solving (A-/lB)=0
167#The lsubp-solution of the linear matrix equation AX+YB=C
168#A numerical solution of the membrane eigenvalue problem
169#Computation of fourier transform integrals using Chebyshev series expansions
170#Parameter Nets
171#Domain-independent planning: representation and plan generation
172#A new use of an automated reasoning assistant: open questions in equivalential calculus and the study of infinite domains
173#Probabilities from fuzzy observations
174#The database designer's workbench
175#Cyclic multiple-valued filing schemes for higher-order queries
176#Semantic-syntax-directed translation and its application to image processing
177#Increasing robustness in global adaptive quadrature through interval selection heuristics
178#The computation and communication complexity of a parallel banded system solver
179#Two tapes are better than one for nondeterministic machines
180#Computation of matrix chain products. Part II
181#Parallel solution of certain toeplitz linear systems
182#Self-organizing heuristics for implicit data structures
183#Verification of probabilistic programs
184#Constrained optimum communication trees and sensitivity analysis
185#Immunity, relativizations, and nondeterminism
186#Fast algorithms for finding nearest common ancestors
187#Recursive programs as definitions in first order logic
188#Differentiation in PASCAL-SC: type GRADIENT
189#A weakest precondition semantics for communicating processes
190#Reduction graphs in the lambda calculus
191#Remarks on an example of jantzen
192#The Ehrenfeucht conjecture: a compactness claim for finitely generated free monoids
193#Optimal quadratures in H(sub)p spaces
194#Algorithm 614: a FORTRAN subroutine for numerical integration in H(sub)p
195#On solving almost block diagonal (staircase) linear systems
196#Fault-tolerant broadcasts
197#Structuring transformational developments: a case study based on Earley's recognizer
198#The Mathematical construction of a program
199#Cryptanalysis of a Maclaren-Marsaglia system
200#MODELLER: computer-assisted modelling of continuous systems
201#DPS - a digital simulation language for the process industries
202#EDP administration and control
203#The multibus design guidebook: structures, architectures, and applications
204#Digital system design and microprocessors
205#Hypernetworks as tools for modelling multiport systems
206#Synchronous debugging of real-time microprocessor-based control systems
207#Digital simulation of guidance and control system of an advanced supersonic fighter
208#A heuristic search algorithm with modifiable estimate
209#General branch and bound, and its relation to A* and AO*
210#An algebraic approach to shape-from-image problems
211#Using chunking to solve chess pawn endgames
212#Literate programming
213#The rainbow workstation
214#The implementation of abstract objects in a capability based addressing architecture
215#A lumped-state model of clustering in dynamic storage allocation
216#A dynamic file organization model
217#Backtrack programming with SIMULA
218#A problem with algebra systems - revisited
219#The performance of algorithms for colouring planar graphs
220#The Cyclic towers of Hanoi: a representation approach
221#On two problems reducible to topological sorting
222#An O(n) algorithm for the linear multiple choice knapsack problem and related problems
223#Experiments with a fast string searching algorithm
224#A technique for developing loop invariants
225#A fast VLSI conversion between binary and residue systems
226#On computing the determinant in small parallel time using a small number of processors
227#Pattern matching machine implementation of a fast test for unique decipherability
228#Algorithms for adaptive Huffman codes
229#Algebraic approach to p-adic conversion of rational numbers
230#ARIADNE: a knowledge-based interactive system for planning and decision support
231#Effectiveness analysis of C (super)3 systems
232#A fuzzy rule-based model of human problem solving
233#Human-oriented information acquisition in sequential pattern classification: part 1--single membership classification
234#A mathematical model of fish behavior in a water tank
235#Computers information and manufacturing systems
236#Distributed data processing: technology and critical issues
237#Large sparse numerical optimization
238#Channel selection and effective communication for managerial decision making
239#The dimensions of accessibility to online information: implications for implementing office information systems
240#The well-trained computer: designing systematic instructional materials for theclassroom microcomputer
241#Heuristics: intelligent search strategies for computer problem solving
242#The AI business: commercial uses of artificial intelligence
243#Prelude to programming: problem solving and algorithms
244#A very simple and efficient technique for the introduction of separate compilation facilities into compilers for block-structured languages is presented. Using this technique, programs may be compiled in parts while the compile-time checking advantages of compilation as a whole are retained. These features are simple for a programmer to understand and are easy to implement. Experience has shown this separate compilation mechanism to be a useful tool in the development of large programs in block-structured languages.
245#One of the requirements for building an operating system in a high-level operating system language, such as Ada, Concurrent Pascal, or Modula, is the construction of a language support system, or kernel. This paper presents a model that generalizes the concept of a kernel, and defines a kernel and the processes it supports to be at different levels of abstraction. A high-level language mechanism, the Execute statement, is then proposed as the basis of the interface between a kernel and the processes it supports. Software capabilities control access between levels and the Execute statement controls processor context switching between levels. The mechanisms rely on data typing for reliability and protection. They encourage systems that are well protected and exhibit an explicit hierarchical structure. Software capabilities and the Execute statement are illustrated with a pilot implementation on the Prime 650. An experimental operating system that encompasses their use is discussed. Extensions are presented which manage interrupts, timeslicing and preemption, and hardware protection mechanisms.
246#A new and flexible solution to the problem of multiple users accessing a single resource, such as communication bandwidth or composite object in memory, is derived. The means of communication consists of sending and receiving messages in known locations (or equivalently, mailboxes without queueing). Any particular user is able to deposit, and hence destroy, previous messages in a mailbox. It is assumed that exclusive access to a mailbox is supplied by an underlying system. The major results of this paper are: 1) a simple tree-based algorithm that guarantees 驴 no user or group of users can conspire to prevent access by some other user to the resource; 驴 only one user accesses the resource at a time; 驴 if there are N users, an individual user is guaranteed access, when requested, to the resource in no more than N-1 turns; Knuth's solution [6] can delay a user up to 2** (N-1)-1 turns; 2) an extension of Dekker's algorithm (2 users) [2] that allows the relative rates of reservations for access to the resource to be proportional to a set of N integers. When a reservation is not being used by its ``owner,'' it will be assigned to another contending request. The assignment is optimal for periodic requests.
247#The control of concurrent access to shared resources is an important feature of both centralized and distributed operating systems. In conventional systems, exclusive access is the rule while concurrent access is the exception. Dataflow computer systems, along with an applicative style of programming, provide an execution environment in which this philosophy is reversed. In these latter systems, it is necessary to reexamine the manner in which synchronization of access to shared resources is specified and implemented. A basic design for a dataflow resource manager is reviewed, illustrating the clear separation between access mechanism and scheduling policy. The semantics of the access mechanism is based solely on the principle of data dependency. Specifications are presented for a general scheduler to further constrain or order accesses to the resource. Using ``open path expressions'' as a very high-level specification language for synchronization, it is shown how to automatically synthesize a scheduler as a distributed network of communicating modules.
248#A control abstraction called atomic action is a powerful general mechanism for ensuring consistent behavior of a system in spite of failures of individual computations running in the system, and in spite of system crashes. However, because of the ``all-or-nothing'' property of atomic actions, an important amount of work might be abandoned needlessly when an internal error is encountered. This paper discusses how implementation of resilient distributed systems can be supported using a combination of nested atomic actions and stable checkpoints. Nested atomic actions form a tree structure. When an internal atomic action terminates, its results are not made permanent until the outermost atomic action commits, but they survive local node failures. Each subtree of atomic actions is recoverable individually. A checkpoint is established in stable storage as part of a remote request so that results of such a request can be reclaimed if the requesting node fails in the meantime, The paper shows how remote procedure call primitives with ``at-most-once'' semantics and recovery blocks can be built with these mechanisms.
249#A way of programming real-time systems is described which inverts the usual image of parallel processes: instead of processes which are ordinarily running and which wait occasionally in order to synchronize with other cooperating processes, ``intervention schedules'' are ordinarily waiting and run nonpreemptibly, triggered by events, which may be external (modeling hardware interrupts) or generated by other intervention schedules. In order for nonpreemptive scheduling to make sense, the maximum period of time for which any event in an intervention schedule runs must be carefully controlled. This and other aspects of the model are considered, and it is compared with more traditional models of parallel processes, and with message passing models. Programming language features to support this programmming model are discussed. Strengths and limitations of the model are discussed.
250#The problem of analyzing an initialized loop and verifying that the program computes some particular function of its inputs is addressed. A heuristic technique for solving these problems is proposed that appears to work well in many commonly occurring cases. The use of the technique is illustrated with a number of applications. An attribute of initialized loops is identified that corresponds to the ``effort'' required to apply this method in a deterministic (i.e., guaranteed to succeed) manner. It is explained that in any case, the success of the proposed heuristic relies on the loop exhibiting a ``reasonable'' form of behavior.
251#This paper discusses the current style of algebraic data type specifications. Some simple examples illustrate that whether or not two objects of the type being specified are equal can be implementation dependent, even for very simple objects of the type. To remedy this, it is proposed that specifications should be safe, where safety is a stronger requirement than Guttag's sufficient completeness. The paper also discusses when an operator should be part of a specification and when it should be introduced by extension, and concludes with safe specifications of some common data types.
252#In this experiment, seven software teams developed versions of the same small-size (2000-4000 source instruction) application software product. Four teams used the Specifying approach. Three teams used the Prototyping approach. The main results of the experiment were the following. 1) Prototyping yielded products with roughly equivalent performance, but with about 40 percent less code and 45 percent less effort. 2) The prototyped products rated somewhat lower on functionality and robustness, but higher on ease of use and ease of learning. 3) Specifying produced more coherent designs and software that was easier to integrate. The paper presents the experimental data supporting these and a number of additional conclusions.
253#Programming languages have traditionally had more data types than database systems. The flexibility of abstract types could make a database system more useful in supporting application development. Abstract types allow users to think about and manipulate data in terms and structures that they are familiar with. This paper proposes that databases have a type system interface and describes a representation of a type system in terms of relations. The type system model supports a variety of programming language constructs, such as user-defined parameterized data types and user-defined generic operations. The efficiency of the type system is compared to the access time of the database system.
254#Database management systems (DBMS's) today are usually built as subsystems on top of an operating system (OS). This design approach can lead to problems of unreliability and inefficient performance as well as forcing a duplication of functions between the DBMS and OS. A new design approach is proposed which eliminates much of this duplication by integrating the duplicated functions into independent subsystems used by both the DBMS and OS. Specifically, an I/O and file support subsystem and a security subsystem are defined. Both subsystems make use of a logical information model which models the stored information in secondary storage. The new database operating system organization and the logical information model are presented in detail. Design of the security subsystem is based on the access control model, and is extended with Boolean predicates to produce an access control model capable of enforcing content-dependent security policies. The access matrix is implemented using a combination of access lists and capabilities. Authorization models and multiple user processes are discussed in relation to the new system organization. The outline of a formal specification and proof of correctness of the security subsystem is also discussed.
255#A simple and general definition of denial-of-service in operating systems is presented. It is argued that no current protection mechanism nor model resolves this problem in any demonstrable way. The notion of interuser dependency is introduced and identified as the common cause for all problem instances. Decomposition of operating systems into hierarchies of services is assumed for the discovery of denial-of-service instances.
256#Holophrasted displays in an interactive environment
257#An investigation of the utility of flowcharts during computer program debugging
258#Natural artificial languages: low level processes
259#Optimal orientations of cells in slicing floorplan designs
260#Connections between two theories of concurrency: metric spaces and synchronization trees
261#Loops in combinator-based compilers
262#On the strength of "sometimes" and "always" in program verification
263#Some applications of a theorem of Shirshov to language theory
264#A Directly Executable Encoding for APL
265#Construction of data processing software
266#Using message passing for distributed programming: proof rules and disciplines
267#Modeling the distributed termination convention of CSP
268#Distributed algorithms for finding centers and medians in networks
269#Translation of attribute grammars into procedures
270#Algorithms for on-the-fly garbage collection
271#validating database updates
272#Performance of videbas in an operational environment
273#Lipski's approach to incomplete information data bases restated and generalized in the setting of Zadeh's possibility theory
274#Towards multi-level and modular conceptual schema specifications
275#A storage structure definition language for CODASYL databases
276#Data management support for database management
277#LALR(1, 1) parser generation for regular right part grammars
278#Optimal multiway search trees for variable size keys
279#Axiomatising finite delay operators
280#Maintaining order in a generalized linked list
281#Generalized binary split trees
282#LISPcraft
283#Transborder data flows: importance, impact, policies
284#An evaluation of the UNIVAC 1100/82 text editor as an alternative word processorfor generating a newspaper index
285#Optimizing convenient online access to bibliographic databases
286#Systems, Objectives, Solutions
287#Building effective multiple criteria decision models: a decision support systemapproach
288#Factors common to the successful implementation of twelve decision support systems and how they differ from three failures
289#MIS/DSS success measure
290#Handbook of software engineering
291#Operating systems principles (2nd ed.)
292#The coming computer industry shakeout: winners, losers, and survivors
293#Abstract algebra: a computational approach
294#Coordinated computing: tools and techniques for distributed software
295#Real-time clinical computing
296#Proc. of the third international conference on Entity-relationship approach to software engineering
297#Proc. of the second international conference on Entity-relationship approach to information modeling and analysis
298#Fire in the valley: the making of the personal computer
299#Some performance tests of convex hull algorithms
300#Improving worst-case behavior of heaps
301#Estimating the length of minimal spanning trees in compression of files
302#Loop-free algorithms for traversing binary trees
303#On the complexity of partitioning sparse matrix representations
304#A formal methodology using attributed grammars for multiprocessing-system software development. I. Design representation; II. Validation
305#A formal methodology using attributed grammars for multiprocessing-system software development. I. design representation
306#Fast compact prime number sieves (among others)
307#Structure, logic, and program design
308#Graphs and algorithms
309#Human factors in computer systems
310#Heuristics for designing enjoyable user interfaces: lessons from computer games
311#Learning to use a word processor: by doing, by thinking, and by knowing
312#Stochastic modeling of individual resource consumption during the programming phase of software development
313#An empirical investigation of the tacit plan knowledge in programming
314#An empirical evaluation of software documentation formats
315#A Multilevel menu-driven user interface: Design and evaluation through simulation
316#Statistical semantics: analysis of the potential performance of keyword information systems
317#An intuitive presentation of the trace method for the abstractspecification of software contains sample specifications, syntacticand semantic definitions of consistency and totalness, methods forproving specifications consistent and total, and a comparison ofthe method with the algebraic approach to specification. Thisintuitive presentation is underpinned by a formal syntax,semantics, and derivation system for the method. Completeness andsoundness theorems establish the correctness of the derivationsystem with respect to the semantics, the coextensiveness of thesyntactic definitions of consistency and totalness with theirsemantic counterparts, and the correctness of the proof methodspresented. Areas for future research are discussed.
318#The information-based study of the optimal solution of largelinear systems is initiated by studying the case of Krylovinformation. Among the algorithms that use Krylov information areminimal residual, conjugate gradient, Chebyshev, and successiveapproximation algorithms. A "sharp" lower bound on the number ofmatrix-vector multiplications required to compute anå-approximation is obtained for any orthogonally invariantclass of matrices. Examples of such classes include many ofpractical interest such as symmetric matrices, symmetric positivedefinite matrices, and matrices with bounded condition number. Itis shown that the minimal residual algorithm is within at most onematrix-vector multiplication of the lower bound. A similar resultis obtained for the generalized minimal residual algorithm. Thelower bound is computed for certain classes of orthogonallyinvariant matrices. How the lack of certam properties (symmetry,positive definiteness) increases the lower bound is shown. Aconjecture and a number of open problems are stated.
319#A mathematical theory for the study of data representation indatabases is introduced and developed. The theory focuses on threedata constructs (collection, composition and classification)."Formats" with semantically rich yet tractable structure are builtrecursively using these constructs. Using formats, we obtainseveral nontrivial results concerning notions of relativeinformation capacity and restructuring of data sets. As such, theformat model provides a new approach for the formal study of theconstruction of "user views" and other data manipulations indatabases.
320#A mathematical model for communicating sequential processes isgiven, and a number of its interesting and useful properties arestated and proved. The possibilities of nondetermimsm are fullytaken into account.
321#As users entrust more and more of their applications to computersystems, the need for systems that are continuously operational (24hours per day) has become even greater. This paper presents asurvey and analysis of representative architectures and techniquesthat have been developed for constructing highly available systemsfor database applications. It then proposes a design of adistributed software subsystem that can serve as a unifiedframework for constructing database application systems that meetvarious requirements for high availability.
322#During the past ten years, the field of multiple-accesscommunication has developed into a major area of both practical andtheoretical interest within the field of computer communications.The multiple-access problem arises from the necessity of sharing asingle communication channel among a community of distributedusers. The distributed algorithm used by the stations to share thechannel is known as the multiple-access protocol. In this paper weexamine the multiple-access problem and various approaches to itsresolution.In this survey we first define the multiple-access problem andthen present the underlying issues and difficulties in achievingmultiple-access communication. A taxonomy for multiple-accessprotocols is then developed in order to characterize commonapproaches and to provide a framework within which these protocolscan be compared and contrasted. Different proposed protocols arethen described and discussed, and aspects of their performance areexamined. The use of multiple-access protocols for "real- time" or"time-constrained" communication applications, such as voicetransmission, is examined next. Issues in time-constrainedcommunication are identified, and recent work in the design oftime-constrained multiple-access protocols is surveyed.
323#The rapidly evolving field of local network technology hasproduced a steady stream of local network products in recent years.The IEEE 802 standards that are now taking shape, because of theircomplexity, do little to narrow the range of alternative technicalapproaches and at the same time encourage more vendors into thefield. The purpose of this paper is to present a systematic,organized overview of the alternative architectures for and designapproaches to local networks.The key elements that determine the cost and performance of alocal network are its topology, transmission medium, and mediumaccess control protocol. Transmission media include twisted pair,baseband and broadband coaxial cable, and optical fiber. Topologiesinclude bus, tree, and ring. Medium access control protocolsinclude CSMA/CD, token bus, token ring, register insertion, andslotted ring. Each of these areas is examined in detail,comparisons are drawn between competing technologies, and thecurrent status of standards is reported.
324#Generating language-based environments
325#Computers and penal legislation: a study of the legal politics of a new technology
326#Sources and development of mathematical software
327#Several new methods are presented for selecting n records at random without replacement from a file containing N records. Each algorithm selects the records for the sample in a sequential manner—in the same order the records appear in the file. The algorithms are online in that the records for the sample are selected iteratively with no preprocessing. The algorithms require a constant amount of space and are short and easy to implement. The main result of this paper is the design and analysis of Algorithm D, which does the sampling in O(n) time, on the average; roughly n uniform random variates are generated, and approximately n exponentiation operations (of the form ab, for real numbers a and b) are performed during the sampling. This solves an open problem in the literature. CPU timings on a large mainframe computer indicate that Algorithm D is significantly faster than the sampling algorithms in use today.
328#Portability and style in ADA
329#Minimizing access pointers into trees and arrays
330#New trie data structures which support very fast search operations
331#The complexity of monadic recursion schemes: exponential time bounds
332#One-layer routing without component constraints
333#Advent of electronic digital computing
334#The discovery of linear programming
335#History of mathematical programming systems
336#Eliciting decision-makers' information requirements: application of the rep test methodology
337#Capturing more meaning in databases
338#Designing financial information systems for auditability
339#A database architecture for supporting business transactions
340#Problems in implementing and operating a manufacturing resource planning information system
341#Writing simple program generators: a case study in building productivity tools
342#Modelling degrees of item interest for a general database query system
343#Experimental study of a two-dimensional language vs. FORTRAN for first-course progammers
344#Rough classification
345#Expressive power of knowledge representation systems
346#Preserving the integrity of the medium: a method of measuring visual and auditory comprehension of electronic media
347#SMALLTALK-80: the interactive programming environment
348#Introduction to combinatorial theory
349#Reinventing man: the robot becomes reality
350#Computer applications to private office practice
351#Mr. Babbage's secret: the tale of a cypher-and APL
352#Learning and applying APL
353#Determination of the 3D border by repeated elimination of internal surfaces
354#Algorithms for smoothing data on the sphere with tensor product splines
355#An optimal algorithm for computing the minimum vertex distance between two crossing convex polygons
356#Advances in data base management, volume II
357#Computer simulation in management science
358#Coordinated computing: tools and techniques for distributed software
359#Fact-based data analysis and design
360#Translation of entity-relationship diagrams into relational structures
361#An entity-relationship algebra and its semantic description capabilities
362#Computer aided layout of entity relationship diagrams
363#DASS: a data administration support system
364#Integrating database and program descriptions using an ER-data dictionary
365#ID: an intelligent information dictionary system
366#Phases, methods, and tools: a triad of system development
367#ISMOS: an experimental database-oriented tool generator
368#The design and description of computer architectures
369#American university programs in computer science: their resources, facilities, and course offering
370#Introduction to computer engineering: hardware and software design (3rd ed.)
371#Computation and cognition: toward a foundation for cognitive science
372#An experiment in document representative modification
373#Downloading: piracy or panacea?
374#The Haitun dichotomy and the relevance of Bradford's law
375#Theory and explanation in information retrieval research
376#A fast file system for UNIX
377#A security model for military message systems
378#Applications of computer graphics in molecular biology
379#CAD for intelligent activity of an autonomous submersible system
380#A new method of curve parameterization with applications in computer aided design
381#A functional approach to picture manipulation
382#The Winchester graphics system: a technical overview
383#Managing multiple context-frames through GKS
384#Computer capacity: a production control approach
385#Telecommunications for management
386#Essential systems analysis
387#Discrete random process stabilization
388#Patterns and pattern-matching in trees: an analysis
389#Nontrivial definability by flow-chart programs
390#Relativizations comparing NP and exponential time
391#The complexity of evaluating relational queries
392#Parallel computation for well-endowed rings and space-bounded probabilistic machines
393#Area-time optimal VLSI integer multiplier with minimum computation time
394#On the computational complexity of ordinary differential equations
395#Colour gradation, shading and texture using a limited terminal
396#IDECAP: interactive pictorial information system for demographic and environmental planning applications
397#The logic designer's guidebook
398#An ordered minimal perfect hashing scheme based upon Euler's theorem
399#Towards a general theory of action and time
400#Foundations of a functional approach to knowledge representation.
401#Detection of surface orientation and motion from texture by a stereoogical technique.
402#Optimal speeding up of parallel algorithms based upon the divide-and-conquer strategy.
403#A generalized class of certainty and information measures.
404#Sequence acquistion using bit estimation techniques.
405#"NP-P?" and restricted partitions.
406#AM: A case study in AI methodology.
407#Why AM an EUISKO appear to work.
408#A polymorphic type system for PROLOG.
409#Comutations underlying the measuremnt of visual motion.
410#A software law primer.
411#Proc. of the international symposium on Semantics of data types
412#A kernel language for abstract data types and modules.
413#A semantics of multiple inheritance.
414#Understanding Russell–a first attempt
415#A basic abstract semantic algebra
416#The semantics of second order polymorphic lambda calculus.
417#A theory of data type representation independence.
418#Deriving structural induction in LCF.
419#Type inference and type containment.
420#The typechecking of programs with implicit type structure.
421#Partial implementations of abstract data types: a dissenting view on errors.
422#Building specifications in an arbitrary institution
423#A proof system for verifying composability of abstract implementation.
424#Dataflow computation
425#Software defect removal
426#Readings in medical artificial intelligence: the first decade
427#Deterministic two-way one-head pushdown automata are very powerful
428#Multiserialization of iterated transactions
429#An analytical comparison of two string searching algorithms
430#A note on lossless database decompositions
431#Scheduling independent 2-processor tasks to minimize schedule length
432#Some equivalent transformations of recursive programs based on their schematic properties
433#Some negative results concerning DPDAs
434#On the consecutive retrieval property for generalized binary queries
435#A storage-size selection problem
436#Programmed deallocation without dangling reference
437#A priority queue for the all pairs shortest path problem
438#The L(subscript 1) traveling salesman problem
439#A simple linear-time algorithm for in situ merging
440#A new combination of input and unit deductions for Horn sentences
441#Fairness and conspiracies
442#On verification of programs with goto statements
443#Computer and Control Abstracts
444#A fast voronoi-diagram algorithm with quaternary tree bucketing
445#Functional dependencies in relations with null values
446#How can we speed up matrix multiplication?
447#Quantitative relativizations of complexity classes
448#Convex partitions of polyhedra: a lower bound and worst-case optimal algorithm
449#Consistency and serializability in concurrent database systems
450#A mathematical model for the verification of systolic networks
451#Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs
452#Efficient parallel algorithms for a class of graph theoretic problems
453#Insertion and compaction algorithms in sequentially allocated storage
454#Movement problems for 2-dimensional linkages
455#On the optimum checkpoint selection problem
456#On some variants of the bandwidth minimization problem
457#A tutorial on the construction and operation of a high-quality audio conversion system
458#The making of octuor
459#Synchronizing shared abstract types
460#A model-management framework for mathematical programming
461#A collocation method for boundary value problems of differential equations with functional arguments
462#The PHS protocol
463#Experience with a portable debugging tool
464#A methodology and notation for compiler front end design
465#Attributed linear intermediate representations for retargetable code generators
466#Immediate files
467#Guarded and unguarded coroutines: an implementation in BCPL
468#Mixed language programming
469#The handbook of computers and computing
470#An architecture for object management in OIS
471#System/U is a universal relation database system under development at Standford University which uses the language C on UNIX. The system is intended to test the use of the universal view, in which the entire database is seen as one relation. This paper describes the theory behind System/U, in particular the theory of maximal objects and the connection between a set of attributes. We also describe the implementation of the DDL (Data Description Language) and the DML (Data Manipulation Language), and discuss in detail how the DDL finds maximal objects and how the DML determines the connection between the attributes that appear in a query.
472#Software portability and standards
473#Performance of heuristics for a computer resource allocation problem
474#Layouts for the shuffle-exchange graph based on the complex plane diagram
475#An investigation into the skeletonization approach of Hilditch
476#Linear quadtrees: a blocking technique for contour filling
477#Fingerprint pattern classification
478#2D object acquisition using circular scanning
479#A formulation and comparison of two linear feature selection techniques applicable to statistical classification
480#A linear time algorithm for computing the convex hull of an ordered crossing polygon
481#A decision theoretic approach to hierarchical classifier design
482#Robots: planning and implementation
483#A framework for the creation and management of national computing strategies in developing countries
484#Specifying integrity constraints in a network DBMS
485#Hash trees versus b-trees
486#Proof of correctness of decision table programs
487#The measurement of locality and the behaviour of programs
488#Architectural considerations of the parallel SIMULA machine
489#Sorting a random access file in situ
490#The worst case permutation for median-of-three quicksort
491#Teleconferencing and beyond: communications in the office of the future
492#Problem oriented programming languages
493#A systematic approach to language constructs for concurrent programs
494#Partial correctness: the term-wise approach
495#A proof system for concurrent ADA programs
496#Supporting control definition in programming languages
497#Using FP as a query language for relational data-bases
498#A new programming environment with a multi-display terminal and early experiences with it
499#A survey of syntactic error recovery and repair
500#Evolutionary trends in poetic style: the case of English metaphysical poetry
501#The authorship of "a lover's complaint": an application of statistical stylometry to poetry
502#Machine translation in the U.S.S.R.
503#Computer-assisted instruction as an integral part of a first-semester French curriculum
504#An acceptance-complement analogue of the mixture-plus-acceptance-rejection method for generating random variables
505#A program complex for solving systems of linear algebraic equations
506#Design and data structure of fully adaptive, multigrid, finite-element software
507#The query inference problem is to translate a sentence of a query language into an unambiguous representation of a query. A query is represented as an expression over a set of query trees. A metric is introduced for measuring the complexity of a query and also a proposal that a sentence be translated into the least complex query which “satisfies” the sentence. This method of query inference can be used to resolve ambiguous sentences and leads to easier formulation of sentences.
508#Procedures for optimization problems with a mixture of bounds and general linear constraints
509#Data communications: a comprehensive approach
510#A book on C
511#Data administration: a practical guide to successful data management
512#A modification of linear hashing is proposed for which the conventional use of overflow records is avoided. Furthermore, an implementation of linear hashing is presented for which the amount of physical storage claimed is only fractionally more than the minimum required. This implementation uses a fixed amount of in-core space. Simulation results are given which indicate that even for storage utilizations approaching 95 percent, the average successful search cost for this method is close to one disk access.
513#An experimental evaluation of delimiters in a command language syntax
514#On the complexity of recursion in problem-solving
515#An experimental comparison of tabular and graphic data presentation
516#A description of structural change in a central place system: a speculation using q-analysis
517#Cluster analysis and Q-analysis
518#Statistical failure analysis of system timing
519#Measures of ideal execution architectures
520#All points addressable raster display memory
521#Empty arrays in extended APL
522#Software reliability analysis models
523#The digital data exchange--a space-division switching system
524#Aspects of the traveling salesman problem
525#On the fixpoints of nondeterministic recursive definitions
526#Consistency in nondeterministic storage
527#Information Technology Research Development Applications
528#Computer animation primer
529#CLU reference manual
530#The engineering of numerical software
531#Computer-aided selection of ISO manufacturing limits for interference fit joints
532#Microcomputer real-time multi-tasking operating systems in control applications
533#Experience with the development and use of a CAD/CAM system
534#Graphic design for computer graphics
535#CAD/CAM: electrical engineering education
536#Extension of the Banker's algorithm for resource allocation in a distributed operating system
537#On converting character strings to integers
538#On the use of extendible hashing without hashing
539#Minimizing completion time for a class of scheduling problems
540#On the power of real-time two-way multihead finite automata with jumps
541#Dominating sets for split and bipartite graphs
542#On embedding functions in logic
543#An optimal algorithm for parallel selection
544#Comments, conjectures, and conclusions
545#A computer and communications network performance analysis primer
546#Into the heart of the mind: an American quest for artificial intelligence
547#Three degrees above zero: Bell Labs in the information age
548#Methods and applications of error-free computation
549#Graph algorithms and NP-completeness
550#In recent years the information processing requirements of business organizations have expanded tremendously. With this expansion, the design of databases to efficiently manage and protect business information has become critical. We analyze the impacts of record segmentation (the assignment of data items to segments defining subfiles), an efficiency-oriented design technique, and of backup and recovery strategies, a data protection technique, on the overall process of database design. A combined record segmentation/backup and recovery procedure is presented and an application of the procedure is discussed. Results in which problem characteristics are varied along three dimensions: update frequencies, available types of access paths, and the predominant type of data retrieval that must be supported by the database, are presented.
551#Task support in an office system
552#Managing transient internetwork links in the Xerox internet
553#38 offices: analyzing needs in individual offices
554#Using the nested loops method, this paper addresses the problem of minimizing the number of page fetches necessary to evaluate a given query to a relational database. We first propose a data structure whereby the number of page fetches required for query evaluation is substantially reduced and then derive a formula for the expected number of page fetches. An optimal solution to our problem is the nesting order of relations in the evaluation program, which minimizes the number of page fetches. Since the minimization of the formula is NP-hard, as shown in the Appendix, we propose a heuristic algorithm which produces a good suboptimal solution in polynomial time. For the special case where the input query is a “tree query,” we present an efficient algorithm for finding an optimal nesting order.
555#A protocol for transaction processing during partition failures is presented which guarantees mutual consistency between copies of data-items after repair is completed. The protocol is “optimistic” in that transactions are processed without restrictions during failure; conflicts are then detected at repair time using a precedence graph, and are resolved by backing out transactions according to some backout strategy. The resulting database state then corresponds to a serial execution of some subset of transactions run during the failure. Results from simulation and probabilistic modeling show that the optimistic protocol is a reasonable alternative in many cases. Conditions under which the protocol performs well are noted, and suggestions are made as to how performance can be improved. In particular, a backout strategy is presented which takes into account individual transaction costs and attempts to minimize total backout cost. Although the problem of choosing transactions to minimize total backout cost is, in general, NP-complete, the backout strategy is efficient and produces very good results.
556#The satisfiability problem for a class consisting of Horn sentences and some non-Horn sentences in porportional logic
557#Repetition of subwords in DOL languages
558#Synchronous and asynchronous experiments on processes
559#Mental poker with three or more players
560#Regular dynamic logic is not interpretable in deterministic context-free dynamic logic
561#Algebraic semantics of recursive flowchart schemes
562#Semantics for classical AUTOMATH and related systems
563#An N(superscript)3/2 lower bound on the monotone network complexity of the Boolean convolution
564#Software for estimating sparse Jacobian matrices
565#A constructive method for abstract algebraic software specification
566#Thinking FORTH: a language and philosophy for solving problems
567#A probabilistic lower bound for checking disjointness of sets
568#Proc. of the conference on 7th international conference on automated deduction
569#A portable environment for research in automated reasoning
570#A natural proof system based on rewriting techniques
571#EKL—a mathematically oriented proof checker
572#Computer number systems and arithmetic
573#Managing database: four critical factors
574#Local area networks: selection guidelines
575#The logic of programming
576#Connected components in binary images: the detection problem
577#The Motorola MC 68000 microprocessor family: assembly language, interface design, and system design
578#Computer message systems
579#16-bit modern microcomputers: the Intel I8086 family
580#A differential-equations algorithm for nonlinear equations
581#Algorithm 617: DAFNE: a differential-equations algorithm for nonlinear equations
582#Optimal Asynchronous Newton Method for the Solution of Nonlinear Equations
583#A Proof Procedure for Data Dependencies
584#Bounds for the Positive Eigenvectors of Nonnegative Matrices and for their Approximations by Decomposition
585#Optimum Head Separation in a Disk System with Two Read/Write Heads
586#Algebraic Structures with Hard Equivalence and Minimization Problems
587#Interactive message services: planning, designing, and implementing videotex
588#Computer mathematics
589#Data structures for personal computers
590#Games programming
591#On a model of distributed information retrieval systems based on thesauri
592#An integrated database design for accounting systems
593#Information processing in linear vector space
594#Toward native language software for information management
595#Shared memory performance of multi-computer terminals in distributed information systems
596#Systems design with ADA.
597#Partial match retrieval in implicit data structures
598#Communication problems on MIMD parallel computers
599#Approximating block accesses in database organizations
600#Integer linear programming for microprograms register allocation
601#A linear algorithm of a deadlock avoidance for nonpreemptible resources
602#Area-time tradeoff for rectangular matrix multiplication in VLSI models
603#An O(n log n) Manhattan path algorithm
604#The complexity of data flow criteria for test data selection
605#Choice of grammatical word-class without global syntactic analysis: tagging words in the LOB Corpus.
606#International Symposium on Symbolic and Algebraic Computation on EUROSAM 84
607#The promotion and accumulation strategies in transformational programming
608#Code selection through object code optimization
609#Magma2: a language oriented toward experiments in control
610#Unassigned objects
611#Selective and locally controlled transport of privileges
612#Optimization of parser tables for portable compilers
613#Transformations and reduction strategies for typed lambda expressions
614#The drinking philosophers problem
615#Axiomatic semantics of communicating sequential processes
616#Organization and learnability in computer languages
617#Perceptual structure cueing in a simple command language
618#Comprehension and recall of miniature programs
619#Speech-controlled text-editing: effects of input modality and of command structure
620#The doctor's use of a computer in the consulting room: an analysis
621#Software portability and standards
622#Technology and Science of Informatics
623#Control structures in expert systems
624#In my view, the most interesting aspect of thisexperiment with prototypes is its implications for software engineering:everyone talks about prototypes today, but is anyone really producingany? Or, amongst those who do produce prototypes, how many can resistthe temptation, once the prototype is complete, to treat it as thefinished product? The experiences described here present a clear cutcase: it would have been impossible to write the compiler immediately inits final form—the cost of perpetual modifications, in response torevisions to ADA, of a compiler written in a `traditional' languagewould have been intolerably high—designing a prototype seems tohave been the only way out.Finally, once a decision in favor of prototypes has been taken,either as a way of giving concrete expression to a set of specificationsor a way of `protecting' a particular design, a choice of language inwhich to write the prototype has to be made. The advantages of SETL areclearly demonstrated in this article, with particular stress laid on thefacilities it provides for using several semantic levels, and thereforerefining a prototype in successive stages until the final productemerges, or a program very close to the final product. Translation intoa language providing for a higher performance level, or at any rate intoa more common language, C in this case, is then a simple task. My guessis that a lot of TSI readers are going to want more information on SETLto enable them to use it in similar circumstances in the future.To sum up, this article is particularly interesting for threereasons: it provides a closer understanding of ADA, demonstrates thevalue of prototypes in software design, and makes a plea in favor ofSETL which does indeed appear wholly satisfactory as a language in whichto write such prototypes.—From the Commentary by E. Girard—Commentary recommended by E. A. Feustel, Sherborn, MA
625#Specification or how to give reality to abstraction
626#Access control lists in capability environments
627#Advances in data communications management: Vol. 2
628#Data communications hardware and software
629#Considerations in a distributed environment
630#An introduction to cryptography
631#Comparative evaluation of networks and protocols
632#Electronic mail
633#Videotex—a consumer information utility
634#The infotex service
635#Computer graphics and applications
636#A taxonomy of representations in information retrieval system design
637#Telecommuting and organizational change
638#Concepts of the document interchange protocol for the telematic services - CCITT draft recommendation s.a
639#State dependency issues in evaluating distributed database availability
640#Simulations of three adaptive, decentralized controlled, job scheduling algorithms
641#Planning techniques for systems management
642#Mathematical applications of electronic spreadsheets
643#Coping with computers in the elementary and middle schools
644#McGraw-Hill dictionary of electronics and computer technology
645#On graph rewritings
646#A linear-history semantics for languages for distributed programming
647#Linear indexed languages
648#The Nielsen reduction and P-complete problems in free groups
649#An extended direct branching algorithm for checking equivalence of deterministic pushdown automata
650#A parallel-design distributed-implementation (PDDI) general-purpose computer
651#Connections in acyclic hypergraphs
652#Biprefix codes, inverse semigroups and syntactic monoids of injective automata
653#Dictionary of computing and new information technology (2nd ed.)
654#Computer operations training: a strategy for change
655#Computer-based instruction: methods and development
656#Effective information management: developing information systems strategies
657#Art and the computer
658#Programming languages and their definition
659#Computer design and architecture
660#A Mechanical Proof of the Unsolvability of the Halting Problem
661#An End-to-End Approach to the Resequencing Problem
662#Storing a Sparse Table with 0(1) Worst Case Access Time
663#Incomplete Information in Relational Databases
664#Updates of Relational Views
665#Lower Bounds for Distributed Maximum-Finding Algorithms
666#Efficient Schemes for Parallel Communication
667#Introduction to simulation and SLAM II (2nd ed.)
668#AEDS Journal
669#Applied combinatorics
670#System design with Ada
671#Personal computers and the disabled
672#Data structures and algorithms 3: multi-dimensional searching and computational geometry
673#The personal computer in business book
674#Hackers: heroes of the computer revolution
675#Orbits for amateurs with a microcomputer
676#A practical guide to computer communications and networking 2nd ed.
677#Microcomputer displays, graphics, and animation
678#Microcomputer applications in structural engineering
679#Whole earth software catalog
680#On-line recognition of spoken words from a large vocabulary
681#Speaker-independent word recognition in connected speech on the basis of Phoneme recognition
682#Connected spoken word recognition algorithms by constant time delay DP, O (n) DP and augmented continuous DP matching
683#A system for understanding continuous German speech
684#An expert system for mapping acoustic cues into phonetic features
685#Optimal parallel algorithms for computing convex hulls and for sortng
686#Integrated concurrency control in shared B-trees
687#Rounding error analysis of interpolation procedures
688#A systems life cycle for office automation projects
689#A framework for systems analysis for decision support systems
690#Attitudes toward telecommuting: implications for work-at-home programs
691#The impact of DSS on organizational communication
692#System design with microprocessors (2nd ed.)
693#Applied combinatorics
694#Making computers work
695#The definitive word-processing book
696#An interactive decision support system for energy policy analysis
697#A theory of the learnable
698#An optimal contour algorithm for iso-oriented rectangles
699#On symmetric algorithms for bilinear forms over finite fields
700#A non-factorial algorithm for canonical numbering of a graph
701#Optimum split trees
702#Gauss codes, planar Hamiltonian graphs, and stack-sortable permutations
703#A separator theorem for graphs of bounded genus
704#An O(n log n) algorithm for finding all repetitions in a string
705#MODULA-2 for PASCAL programmers
706#Introduction to PEARL: process and experiment automation realtime language (2nd ed.)
707#Computers in crisis: how to avert the coming worldwide computer systems collapse
708#A structured approach to designing human-computer dialogues
709#On conflicts
710#The relationship of problem-solving ability and course performance among novice programmers
711#Conditional statements and program coding: an experimental evaluation
712#Basic concepts in knowledge-based systems
713#Performance in database systems is strongly influenced by buffer management and transaction recovery methods. This paper presents the principles of the database cache, which replaces the traditional buffer. In comparison to buffer management, cache management is more carefully coordinated with transaction management, and integrates transaction recovery. High throughput ofsmall- and medium-sized transactions is achieved by fast commit processing and low database traffic. Very fast handling of transaction failures and short restart time after system failure are guaranteed in such an environment. Very long retrieval and update transactions are also supported.
714#Various logging and recovery techniques for centralized transaction-oriented database systems under performance aspects are described and discussed. The classification of functional principles that has been developed in a companion paper is used as a terminological basis. In the main sections, a set of analytic models is introduced and evaluated in order to compare the performance characteristics of nine different recovery techniques with respect to four key parameters and a set of other parameters with less influence. Finally, the results of model evaluation as well as the limitations of the models themselves are discussed.
715#Computer - IEEE Centennial: the state of computing
716#First Page of the Article
717#First Page of the Article
718#First Page of the Article
719#First Page of the Article
720#First Page of the Article
721#First Page of the Article
722#First Page of the Article
723#First Page of the Article
724#First Page of the Article
725#First Page of the Article
726#First Page of the Article
727#First Page of the Article
728#First Page of the Article
729#First Page of the Article
730#First Page of the Article
731#First Page of the Article
732#First Page of the Article
733#First Page of the Article
734#First Page of the Article
735#This paper discusses the implementation of a database buffer manager as a component of a DBMS. The interface between calling components of higher system layers and the buffer manager is described; the principal differences between virtual memory paging and database buffer management are outlined; the notion of referencing versus addressing of database pages is introduced; and the concept of fixing pages in the buffer to prevent uncontrolled replacement is explained.Three basic tasks have to be performed by the buffer manager: buffer search, allocation of frames to concurrent transactions, and page replacement. For each of these tasks, implementation alternatives are discussed and illustrated by examples from a performance evaluation project of a CODASYL DBMS.
736#Two nonlinear lower bounds for on-line computations
737#Unbounded program memory adds to the expressive power of first-order programming logic
738#The complexity of sorting on distributed systems
739#On the complexity of concurrency control by locking in distributed database systems
740#A semantic approach to program modularity
741#How to write a computer manual: a handbook of software documentation
742#Manager's guide to small computers
743#How to copyright software
744#Artificial intelligence: tools, techniques, and applications
745#Single-chip microcomputers
746#Interactive FORTRAN 77: a hands-on approach
747#ADA: Language, compilers and bibliography
748#Observations on optimistic concurrency control schemes
749#Semantic integrity enforcement in centralized DBMS and distributed DBMS based on slow (geographically distributed) and fast (local area) networks
750#Constraint preserving and lossless database transformations
751#Information semantics and the conceptual schema
752#A pruned trie to index a sorted file and its evaluation
753#HOLMES: a deduction augmented database management system
754#Identifying subsystems in information systems analysis
755#Computer network analysis by using a generalized Petri network simulator
756#A general-purpose global optimizer: implementation and applications
757#Desynchronization of linear systems
758#Multidimensional state-space models: a comparative overview
759#A method for the calculation of eigenfunction expansions
760#Disk performance in a transaction-oriented system
761#Equivalence relations, invariants, and normal forms
762#Preemptive scheduling of a multiprocessor system with memories to minimize maximum lateness
763#Scheduling independent tasks on uniform processors
764#On relativized polynomial and exponential computations
765#The power of synchronization mechanisms
766#n-rational algebras II. varieties and logic of inequalities
767#Parallel algorithms for algebraic problems
768#Is the interesting part of process logic uninteresting? A translation from PL to PDL
769#Information transfer under different sets of protocols
770#How to generate cryptographically strong sequences of pseudo-random bits
771#Cylindrical algebraic decomposition I: the basic algorithm
772#Cylindrical algebraic decomposition II: an adjacency algorithm for the plane
773#Business computer systems: an introduction (2nd ed.)
774#Linear algebra with computer applications
775#Human factors in computer systems
776#Online communities
777#Machine intelligence and related topics
778#Turing's man: western culture in the computer age
779#How to design and develop business systems
780#Experience with Grapevine: the growth of a distributed system
781#Correctness Proofs of Communicating Processes: Three Illustrative Examples From the Literature
782#An analysis of the distributions and relationships derived from the change data collected during development of a medium-scale software project produces some surprising insights into the factors influencing software development. Among these are the tradeoffs between modifying an existing module as opposed to creating a new one, and the relationship between module size and error proneness.
783#Software complexity metric sensitivity to program structuring rules
784#Some new observations about software science indicators for estimating software quality
785#Practical suggestions are presented for effectively managing software development in small-project environments (i.e., no more than several million dollars per year). The suggestions are based on an approach to product development using a product assurance group that is independent from the development group. Within this check-and-balance management/development/product assurance structure, a design review process is described that effects an orderly transition from customer needs statement to software code. The testing activity that follows this process is then explained. Finally, the activities of a change control body (called a configuration control board) and supporting functions geared to maintaining delivered software are described. The suggested software management practices result from the experience of a small (approximately 100 employees) software engineering company that develops and maintains computer systems supporting real-time interactive commercial, industrial, and military applications.
786#Proc. of the NYU symposium on user interfaces on Human factors and interactive computer systems
787#The future of interactive systems and the emergence of direct manipulation
788#An experimental COBOL restructuring system
789#Organizing for human factors
790#Query languages—a taxonomy
791#Graphical user interfaces
792#A multi media approach to the user interface
793#Querying external databases
794#Ergonomic considerations in the design of command languages
795#Using restricted natural language for data retrieval: a plan for field evaluation
796#User interfaces for problem solving support
797#The user interface of a personal calendar program
798#A general user interface for creating and displaying tree-structures, hierarchies, decision trees, and nested menus
799#Interface design in computerized conferencing systems: a personal view
800#Consistent user interface
801#Number theory in science and communication
802#Methods and tools for compiler construction
803#Syntax analysis and error recovery
804#Contextual constraints
805#On cancellation properties of languages which are supports of rational power series
806#Equivalences among logics of programs
807#Multi-version concurrency control scheme for a database system
808#On the computational complexity of path cover problems
809#The performance of multilective VLSI algorithms
810#Simulation output analysis for local area computer networks
811#Randomized and deterministic simulations of PRAMs by parallel machines with restricted granularity of parallel memories
812#On real-time cellular automata and trellis automata
813#A performance guarantee for the greedy set-partitioning algorithm
814#Synthesis of a unification algorithm in a logic programming calculus
815#Alternation and the computational complexity of logic programs
816#On the sequential nature of unification
817#Negation as failure: a comparison of Clark's completed data base and Reiter's closed world assumption
818#Computing and organizations: what we know and what we don't know
819#The information system as a competitive weapon
820#An investigation of user-led system design: rational and political perspectives
821#Computer mediated work: the interplay between technology and structured jobs
822#An improved solution to the traveling salesman problem with thousands of nodes
823#Foreign keys decrease adaptability of database designs
824#Region representation: parallel connected stripes
825#A new class of similarity measures for robust image registration
826#Performance evaluation of shape matching via chord length distribution
827#Object detection based on gray level cooccurrence
828#A fast sequential method for polygonal approximation of digitized curves
829#Position determination using generalized multidirectional gradient codes
830#Microcomputer assembly language programming
831#Computer law for computer professionals
832#Attribute grammars : definitions, analysis of dependencies, proof methods
833#Attribute grammars: attribute evaluation methods
834#Recursive evaluators for attribute grammars : an implementation
835#Improving the performance guarantee for approximate graph coloring
836#Worst-case Analysis of Set Union Algorithms
837#The ω sequence problem for DOL systems is decidable
838#Finitely Specifiable Implicational Dependency Families
839#This paper presents a methodology for evaluating text editors on several dimensions: the time it takes experts to perform basic editing tasks, the time experts spend making and correcting errors, the rate at which novices learn to perform basic editing tasks, and the functionality of editors over more complex tasks. Time, errors, and learning are measured experimentally; functionality is measured analytically; time is also calculated analytically. The methodology has thus far been used to evaluate nine diverse text editors, producing an initial database of performance results. The database is used to tell us not only about the editors but also about the users—the magnitude of individual differences and the factors affecting novice learning.
840#Eliminating Redundant Recursive Calls.
841#Attribute grammar design using the compiler writing system HLP
842#A cooperation scheme for parallel compilation
843#Human information seeking and design of information systems.
844#Compiler generation from denotational semantics
845#Code generation and optimization
846#Empirical laws and theories of information and software sciences.
847#Data flow analysis and global optimization
848#STROBE: a structured approach to observation of the decision-making environment.
849#A high level intermediate code
850#Production quality ADA compilers
851#Minkowski matrices.
852#Compiling ADA
853#Algorithm design for computer system design
854#A block QR algorithm for partitioning stiff differential systems.
855#Navigational facilities for relational database.
856#Entity-relationship approach to logical database design.
857#Distributed database design using the entity-relationship model.
858#Computer algebra: symbolic and algebraic computation (2nd ed.)
859#Computing in transcendental extensions.
860#Complexity of exact and approximate solution of problems: an introduction
861#On the equivalence problem for binary DOL systems.
862#Models of the task assignment problem in distributed systems
863#Network design with non simultaneous flows
864#Minimal representations of directed hypergraphs and their application to database design
865#Parallel computer models: an introduction
866#Functional organization of MIMD machines
867#A VLSI sorter
868#Software engineering: reliability, development, and management.
869#The coalesced hashing method has been shown to be very fast for dynamic information storage and retrieval. This paper analyzes in a uniform way the performance of coalesced hashing and its variants, thus settling some open questions in the literature.In all the variants, the range of the hash function is called the address region, and extra space reserved for storing colliders is called the cellar. We refer to the unmodified method, which was analyzed previously, as late-insertion coalesced hashing. In this paper we analyze late insertion and two new variations called early insertion and varied insertion. When there is no cellar, the early-insertion method is better than late insertion; however, past experience has indicated that it might be worse when there is a cellar. Our analysis confirms that it is worse. The varied-insertion method was introduced as a means of combining the advantages of late insertion and early insertion. This paper shows that varied insertion requires fewer probes per search, on the average, than do the other variants.Each of these three coalesced hashing methods has a parameter that relates the sizes of the address region and the cellar. Techniques in this paper are designed for tuning the parameter in order to achieve optimum search times. We conclude with a list of open problems.
870#In a one-copy distributed database, each data item is stored at exactly one site. In a replicated database, some data items may be stored at multiple sites. The main motivation is improved reliability: by storing important data at multiple sites, the DBS can operate even though some sites have failed.This paper describes an algorithm for handling replicated data, which allows users to operate on data so long as one copy is “available.” A copy is “available” when (i) its site is up, and (ii) the copy is not out-of-date because of an earlier crash.The algorithm handles clean, detectable site failures, but not Byzantine failures or network partitions.
871#This paper studies the problem of storing single-level and multilevel clustered files. Necessary and sufficient conditions for a single-level clustered file to have the consecutive retrieval property (CRP) are developed. A linear time algorithm to test the CRP for a given clustered file and to identify the proper arrangement of objects, if CRP exists, is presented. For the single-level clustered files that do not have CRP, it is shown that the problem of identifying a storage organization with minimum redundancy is NP-complete.Consequently, an efficient heuristic algorithm to generate a good storage organization for such files is developed. Furthermore, it is shown that, for certain types of multilevel clustered files, there exists a storage organization such that the objects in each cluster, for all clusters in each level of the clustering, appear in consecutive locations.
872#This paper addresses the vertical partitioning of a set of logical records or a relation into fragments. The rationale behind vertical partitioning is to produce fragments, groups of attribute columns, that “closely match” the requirements of transactions.Vertical partitioning is applied in three contexts: a database stored on devices of a single type, a database stored in different memory levels, and a distributed database. In a two-level memory hierarchy, most transactions should be processed using the fragments in primary memory. In distributed databases, fragment allocation should maximize the amount of local transaction processing.Fragments may be nonoverlapping or overlapping. A two-phase approach for the determination of fragments is proposed; in the first phase, the design is driven by empirical objective functions which do not require specific cost information. The second phase performs cost optimization by incorporating the knowledge of a specific application environment. The algorithms presented in this paper have been implemented, and examples of their actual use are shown.
873#Security for computer networks: an introduction to data security in teleprocessing and electronic funds transfer
874#My personal computer and other family crises
875#How to multiply matrices faster
876#Procedural elements for computer graphics
877#Foundations of logic programming
878#Machine vision: the eyes of automation
879#Catalogue of artificial intelligence tools
880#PDP-11: structured assembly language programming
881#Successful data processing system analysis (2nd ed.)
882#Diagramming techniques for analysts and programmers
883#Algorithms, software and hardware of parallel computers
884#Synthesis of parallel numerical algorithms
885#Complexity of parallel algorithms
886#Formal models of parallel computations
887#On parallel languages
888#Proving correctness and automatic synthesis of parallel programs
889#Operating systems for modular partially reconfigurable multiprocessor systems
890#Algorithms for scheduling homogeneous multiprocessor computers
891#Algorithms for scheduling inhomogeneous multiprocessor computers
892#Parallel processors and multicomputer systems
893#Data flow computer architecture
894#Correlation of algorithms, software and hardware of parallel computers
895#Microprogram simulation using a structured microcode model
896#Reconfiguration in microprocessor schemes
897#Designing multibus priority resolver by means of a field programmable logic sequencer
898#An example of microprocessor's application in minicomputer systems: a copy volume design and implementation
899#A VLSI model for residue number system architectures
900#A recursive design methodology for VLSI theory and example
901#DIF: a framework for VLSI multi-level representation
902#On a case of symbiosis between systolic arrays
903#Cryptanalysis of certain variants of Rabin's signature scheme
904#Extensions to grid selector composition and compilation in APL
905#Non-partitionable point sets
906#Formal syntax methods for natural language
907#Another solution of the mutual exclusion problem
908#On synthesis of scheduling algorithms
909#Some variants of the take-grant protection model
910#On estimating access costs in relational databases
911#Office automation projects and their impact on organization, planning, and control
912#Logical routing specification in office information systems
913#A critical appraisal of task taxonomies as a tool for studying office activities
914#The simulation of logical networks (SLN)
915#Simulation of medical decisions: applications of SLN
916#Application prototyping: a requirements definition strategy for the 80s
917#Dynamic, first-fit packings in two or more dimensions
918#Randomness conservation inequalities; information and independence in mathematical theories
919#Compatibility and commutativity of lock modes
920#An economical approach to modeling speech recognition accuracy
921#A display editor with random access and continuous control
922#An analysis of formal logics as inference mechanisms in expert systems
923#Visual momentum: a concept to improve the cognitive coupling of person and computer
924#Users and experts in the document retrieval system model
925#Measuring the quality of linguistic forecasts
926#An experimental expert system for genetics
927#Reading continuous text from a one-line visual display
928#The relevance of microcomputers to health improvement in developing countries
929#An effective database formation for decision support systems
930#Complexity issues in VLSI: optimal layouts for the shuffle-exchange graph and other networks
931#Office automation in British Rail—on delivering value to end users
932#Effects of individual characteristics, organizational factors and task characteristics on computer programmer productivity and job satisfaction
933#The use of a commercial microcomputer database management system as the basis for bibliographic information retrieval
934#An analysis of ISLA and DEVIL—two experimental public information systems
935#First Page of the Article
936#First Page of the Article
937#First Page of the Article
938#Techniques of EDP project management: a book of readings
939#Simulation software and ADA
940#Expert systems and fuzzy systems
941#Writing and analyzing effective computer system documentation
942#Applied programming techniques in C
943#Software reliability measurement: prediction, estimation, and assessment
944#A comparison of time domains for software reliability models
945#Collecting and categorizing software error data in an industrial environment
946#Experimental evaluation of software design principles: an investigation into the effect of module coupling on system modifiability
947#Development and application of a white box approach to integration testing
948#High-level testing and example-directed development of software specifications
949#Module size: a standard or heuristic?
950#Optimal layer assignment for interconnect
951#The RISC II micro-architecture
952#The architecture of a programmable systolic chip
953#Local area networks: a user's guide for business professionals
954#The FFT fundamentals and concepts
955#CAD/CAM Systems: justification, implementation, productivity measurement
956#Office systems: a manager's guide to integrating word processing, data processing, and telecommunications for the automated office
957#Security for computer networks: an introduction to data security in teleprocessing and electronic funds transfer
958#Programming in Prolog (2nd ed.)
959#Information theory for information technologists
960#Programming languages: a grand tour (2nd ed.)
961#System design from provably correct constructs
962#The human factors of computer graphics interaction techniques
963#Physiological principles for the effective use of color
964#Human factors issues in VDT use: environmental and workstation design considerations
965#On linear context-free languages and one-way multihead automata
966#Probabilistic Turing machines and recursively enumerable Dedekind cuts
967#Towards a formal proof system for &ohgr;-rational expressions
968#A note on bounded-reversal multipushdown machines
969#How to produce all sentences from a two-level grammar
970#On software equations
971#Approximate storage utilisation of B-trees: a simple derivation and generalisations
972#How evenly should one divide to conquer quickly?
973#Throughput concavity and response time convexity
974#Several fairly large sets of programming rules have been developed recently. It is natural to ask whether the process of developing such rule bases may converge. Having developed sets of rules for specific programming tasks and domains, will they be helpful when other tasks and domains are considered? While it is too early to give definitive answers, experience with the rules of the PECOS system has been positive. Both during the process of developing the rule set and while developing rules for another domain, the existence of already codified rules proved very helpful.
975#A specification technique, formally equivalent to finite-state machines, is offered as an alternative because it is inherently distributed and more comprehensible. When applied to modules whose complexity is dominated by control, the technique guides the analyst to an effective decomposition of complexity, encourages well-structured error handling, and offers an opportunity for parallel computation. When applied to distributed protocols, the technique provides a unique perspective and facilitates automatic detection of some classes of error. These applications are illustrated by a controller for a distributed telephone system and the full-duplex alternating-bit protocol for data communication. Several schemes are presented for executing the resulting specifications.
976#Until recently, information-flow analysis has been used primarily to verify that information transmission between program variables cannot violate security requirements. Here, the notion of information flow is explored as an aid to program development and validation.Information-flow relations are presented for while-programs, which identify those program statements whose execution may cause information to be transmitted from or to particular input, internal, or output values. It is shown with examples how these flow relations can be helpful in writing, testing, and updating programs; they also usefully extend the class of errors which can be detected automatically in the “static analysis” of a program.
977#An efficient algorithm for communicating letter-shape information from a high-speed computer with a large memory to a typesetting device that has a limited memory is presented. The encoding is optimum, in the sense that the total time for typesetting is minimized, using a model that generalizes well-known “demand paging” strategies to the case where changes to the cache are allowed before the associated information is actually needed. Extensive empirical data show that good results are obtained even when difficult technical material is being typeset on a machine that can store information concerning only 100 characters. The methods of this paper are also applicable to other hardware and software caching applications with restricted lookahead.
978#Examination timetabling by computer
979#Microcomputer-assisted identification of bacteria and multicriteria decision models
980#Analysis of an infinite buffer system with random server interruptions
981#A heuristic approximation for reducing problem size in network file allocation models
982#Solution structures and sensitivity of special assignment problems
983#Restricted vertex generation applied as a crashing procedure for linear programming
984#Electronic funds transfer networks: modeling their impact on bank service goals
985#Configuration of VLSI Arrays in the Presence of Defects
986#Organization and VLSI implementation of MIPS
987#Parallel assignment revisited
988#Communicating Sequential Processes for Centralized and Distributed Operating System Design
989#Empirical investigation of COBOL features
990#User-defined types in a polymorphic language.
991#Parallel language recognition in constant time by cellular automata.
992#Optimizing chain queries in a distributed database system.
993#A linguistic preprocessor for record linkage in socio-economic historical research
994#Time-Space trade-offs for some algebraic problems
995#An application of Cohen's result on star height to the theory of control structures
996#Finding Euler tours in parallel
997#GYO reductions, canonical connections, tree and cyclic schemas, and tree projections
998#Optimization of distributed tree queries
999#Remarks on composite integration methods for ordinary differntial equations.
1000#A reorganization model based on the database entropy concept.
1001#A systematic study of models of abstract data types
1002#Conditional rewrite rules
1003#Expressive power of typed and type-free programming languages
1004#On compiling queries in recursive first-order databases
1005#Denotational semantics of CSP
1006#Deciding the inequivalence of context-free grammars with 1-letter terminal alphabet is &Sgr;p-2--complete
1007#Operating system design: the XINU approach
1008#Elements of simulation
1009#A multilayered operating system for microcomputers
1010#A multitasking operating system with explicit treatment of recovery points
1011#Digital filtering using the NEC &mgr;PD7720 signal processor
1012#Generative communication is the basis of a new distributed programming langauge that is intended for systems programming in distributed settings generally and on integrated network computers in particular. It differs from previous interprocess communication models in specifying that messages be added in tuple-structured form to the computation environment, where they exist as named, independent entities until some process chooses to receive them. Generative communication results in a number of distinguishing properties in the new language, Linda, that is built around it. Linda is fully distributed in space and distributed in time; it allows distributed sharing, continuation passing, and structured naming. We discuss these properties and their implications, then give a series of examples. Linda presents novel implementation problems that we discuss in Part II. We are particularly concerned with implementation of the dynamic global name space that the generative communication model requires.
1013#Expert systems: principles and case studies
1014#One aspect of network design is the extent to which memory is shared among the processing elements. In this paper a model with limited sharing (only two processors connected to each memory) is analyzed and its performance compared with the performance of two other models that have appeared in the literature. One of these is a model of multiple processors sharing a single memory; the other model considers a multiprocessor configuration in which each processor has its own dedicated memory. The tasks processed by these networks are described by both time and memory requirements. The largest-memory-first (LMF) scheduling algorithm is employed and its performance with respect to an enumerative optimal scheduling algorithm is bounded. On the basis of this measure we conclude that memory sharing is only desirable on very small networks and is disadvantageous on networks of larger size.
1015#Algorithms are described for maintaining clock synchrony in a distributed multiprocess system where each process has its own clock. These algorithms work in the presence of arbitrary clock or process failures, including “two-faced clocks” that present different values to different processes. Two of the algorithms require that fewer than one-third of the processes be faulty. A third algorithm works if fewer than half the processes are faulty, but requires digital signatures.
1016#Three different approaches to heuristic search in networks are analyzed. In the first approach, as formulated initially by Hart, Nilsson, and Raphael, and later modified by Martelli, the basic idea is to choose for expansion that node for which the evaluation function has a minimum value. A second approach has recently been suggested by Nilsson. In this method, in contrast to the earlier one, a node that is expanded once is not expanded again; instead, a “propagation” of values takes place. The third approach is an adaptation for networks of an AND/OR graph “marking” algorithm, originally due to Martelli and Montanari.Five algorithms are presented. Algorithms A and C illustrate the first approach; PropA and PropC, the second one; and MarkA, the third one. The performances of these algorithms are compared for both admissible and inadmissible heuristics using the following two criteria: (i) cost of the solution found; (ii) time of execution in the worst case, as measured by the number of node expansions (A, C), or node “selections” (PropA, PropC), or arc “markings” (MarkA).The relative merits and demerits of the algorithms are summarized and indications are given regarding which algorithm to use in different situations.
1017#Two new marking algorithms for AND/OR graphs called CF and CS are presented. For admissible heuristics CS is not needed, and CF is shown to be preferable to the marking algorithms of Martelli and Montanari. When the heuristic is not admissible, the analysis is carried out with the help of the notion of the first and second discriminants of an AND/OR graph. It is proved that in this case CF can be followed by CS to get optimal solutions, provided the sumcost criterion is used and the first discriminant equals the second. Estimates of time and storage requirements are given. Other cost measures, such as maxcost, are also considered, and a number of interesting open problems are enumerated.
1018#Since a nondeterministic and concurrent program may, in general, communicate repeatedly with its environment, its meaning cannot be presented naturally as an input/output function (as is often done in the denotational approach to semantics). In this paper, an alternative is put forth. First, a definition is given of what it is for two programs or program parts to be equivalent for all observers; then two program parts are said to be observation congruent if they are, in all program contexts, equivalent. The behavior of a program part, that is, its meaning, is defined to be its observation congruence class.The paper demonstrates, for a sequence of simple languages expressing finite (terminating) behaviors, that in each case observation congruence can be axiomatized algebraically. Moreover, with the addition of recursion and another simple extension, the algebraic language described here becomes a calculus for writing and specifying concurrent programs and for proving their properties.
1019#The subset sum problem is to decide whether or not the 0-l integer programming problem &Sgr;ni=l aixi = M, ∀I, xI = 0 or 1, has a solution, where the ai and M are given positive integers. This problem is NP-complete, and the difficulty of solving it is the basis of public-key cryptosystems of knapsack type. An algorithm is proposed that searches for a solution when given an instance of the subset sum problem. This algorithm always halts in polynomial time but does not always find a solution when one exists. It converts the problem to one of finding a particular short vector v in a lattice, and then uses a lattice basis reduction algorithm due to A. K. Lenstra, H. W. Lenstra, Jr., and L. Lovasz to attempt to find v. The performance of the proposed algorithm is analyzed. Let the density d of a subset sum problem be defined by d = n/log2(maxi ai). Then for “almost all” problems of density d d n, it is proved that the lattice basis reduction algorithm locates v. Extensive computational tests of the algorithm suggest that it works for densities d dc(n), where dc(n) is a cutoff value that is substantially larger than 1/n. This method gives a polynomial time attack on knapsack public-key cryptosystems that can be expected to break them if they transmit information at rates below dc(n), as n → ∞.
1020#An algebraic foundation of database schema design is presented. A new database operator, namely, disaggregation, is introduced. Beginning with “free” families, repeated applications of disaggregation and three other operators (matching function, Cartesian product, and selection) yield families of increasingly elaborate structure. In particular, families defined by one join dependency and several “embedded” functional dependencies can be obtained in this manner.
1021#Sixty-four small computers are connected by a network of point-to-point communication channels in the plan of a binary 6-cube. This “Cosmic Cube” computer is a hardware simulation of a future VLSI implementation that will consist of single-chip nodes. The machine offers high degrees of concurrency in applications and suggests that future machines with thousands of nodes are both feasible and attractive.
1022#The Manchester project has developed a powerful dataflow processor based on dynamic tagging. This processor is large enough to tackle realistic applications and exhibits impressive speedup for programs with sufficient parallelism.
1023#A large quantity of well-respected software is tested against a series of metrics designed to measure program lucidity, with intriguing results. Although slanted toward software written in the C language, the measures are adaptable for analyzing most high-level languages.
1024#Microcomputers, when properly programmed, have sufficient memory and speed to successfully perform serious calculations of modest size--linear equations, least squares, matrix inverse or generalized inverse, and the symmetric matrix eigenproblem.
1025#First Page of the Article
1026#First Page of the Article
1027#First Page of the Article
1028#First Page of the Article
1029#Advanced topics of a computer center audit
1030#User-friendly password methods for computer-mediated information systems
1031#ACTEN: A conceptual model for security systems design
1032#Information security: reality and fiction
1033#Cryptography for computer security: making the decision
1034#Data encryption in ISO, the international organization for standardization
1035#The value of information and computer-aided information seeking: problem formulation and application to fiction retrieval
1036#Thesaural relations in a concept-network management system for customizing of permuted index displays
1037#Structure of hierarchic clusterings: implications for information retrieval and for multivariate data analysis
1038#Automatic indexing of full texts
1039#Aspects and the overlap function
1040#A comparison of two methods for Boolean query relevancy feedback
1041#Incorporating codes of practice into reinforced concrete design programs
1042#Computer-aided hierarchical diagrams
1043#A wire-wrap design aid, written in PROLOG
1044#Two algorithms for three-layer channel routing
1045#Interactive computer program for the selection of interference fits
1046#A SPICE2 SCR model for power circuit analysis
1047#Finite element mesh generation
1048#Introduction to logic programming
1049#Linear programming: methods and applications (5th ed.)
1050#An experiment in applying the adaptive design approach to DSS development.
1051#Probabilistic Models of Database Locking: Solutions, Computational Algorithms, and Asymptotics
1052#A popular means of increasing the effective rate of main storageaccesses in a large computer is a multiplicity of memory modulesaccessible in parallel. Although such an organization usuallyachieves a net gain in access rate, it also creates new modes ofcongestion at the storage controller. This paper analyzes thevariables that describe such a congestion: queue lengths anddelays. A controller that maintains separate register sets toaccommodate the request queue of each module is considered. Thevarious processors attached to the storage are assumed to generate,in each memory cycle, a number of access requests with the samegiven distribution. The addresses specified by these requests(reduced to the module index) are further assumed to follow thestates of a first-order Markov chain. The analysis then becomes oneof a single-server queuing system with constant service time andindexed batch arrival process. Results are derived for severaldescriptors of the congestion and thus of the quality of serviceoffered by such an organization. The aim throughout is to embodythe results in a form readily suitable for numericalevaluation.
1053#Parallel graph algorithms
1054#A taxonomy of parallel sorting
1055#Response time and display rate in human performance with computers
1056#Introduction to computer engineering
1057#Management information systems: conceptual foundations, structure, and development (2nd ed.)
1058#On the overflow process from a finite Markovian queue
1059#An approach to program I/O reference behavior modeling
1060#An analysis of an approximation algorithm for queueing networks
1061#Buffer allocation strategies with blocking requirements
1062#Probability theory and computer science
1063#Mathematical analysis of combinatorial algorithms
1064#The traditional LALR analysis is reexamined using a new operator and an associated graph. An improved method that allows factoring out a crucial part of the computation for defining states of LR(0) canonical collection and for computing LALR(1) lookahead sets is presented. This factorization leads to significantly improved algorithms with respect to execution time as well as storage requirements. Experimental results including comparison with other known methods are presented.
1065#The significant intellectual cost of programming is for problem solving and explaining, not for coding. Yet programming systems offer mechanical assistance for the coding process exclusively. We illustrate the use of an implemented program development system, called PRL ("pearl"), that provides automated assistance with the difficult part. The problem and its explained solution are seen as formal objects in a constructive logic of the data domains. These formal explanations can be executed at various stages of completion. The most incomplete explanations resemble applicative programs, the most complete are formal proofs.
1066#Ethical issues in the use of computers
1067#The quest for a code of professional ethics: an intellectual and moral confusion
1068#WQhat should professional societies do about ethics?
1069#The study of information: interdisciplinary messages
1070#Information science: its roots and relation as viewed from the perspective of cognitive science
1071#Informatics (computer and information science): its ideology, methodology, and sociology
1072#Intellectual issues in the history of artificial intelligence
1073#Thirty years of information theory
1074#On system theory and its relevance to problems in information science
1075#On the application of rule-based techniques to the design of advice giving systems
1076#Liability for personal injury caused by defective medical computer programs
1077#Liability for malfunction of a computer program
1078#“Multi-programming” computer litigation
1079#Negligence: liability for defective software
1080#Punishment and responsibility
1081#Sua Culpa
1082#Are there decisions computers should never make?
1083#Privacy and security issues in information systems
1084#Data bases
1085#The right to privacy
1086#Privacy in the modern democratic state
1087#Why privacy is important
1088#Privacy, morality, and the law
1089#Introduction to personal privacy in an information society
1090#Excerpt from computer power and human reason
1091#Excerpts from conquest of the will: information processing in human affairs
1092#The consequences of computers for centralization and decentralization
1093#Computers and social power
1094#Peering into the poverty gap
1095#Computer systems: power for whom and for what?
1096#Solving elliptic problems using ELLPACK
1097#Fundamentals of operating systems (3rd ed.)
1098#A proposal for comparison of types in PASCAL and associated semantic models
1099#Anatomy of a text analysis package
1100#DFL: a data flow language
1101#An outline of the programming language SIMULA
1102#A generalized interval package and its use for semantic checking
1103#Interpolation of data on the surface of a sphere
1104#A bisection method for systems of nonlinear equations
1105#The problem of generalizing functional specifications for while loops is considered. This problem occurs frequently when trying to verify that an initialized loop satisfies some functional specification, i.e., produces outputs which are some function of the program inputs.The notion of a valid generalization of a loop specification is defined. A particularly simple valid generalization, a base generalization, is discussed. A property of many commonly occurring while loops, that of being uniformly implemented, is defined. A technique is presented which exploits this property in order to systematically achieve a valid generalization of the loop specification. Two classes of uniformly implemented loops that are particularly susceptible to this form of analysis are defined and discussed. The use of the proposed technique is illustrated with a number of applications. Finally, an implication of the concept of uniform loop implementation for the validation of the obtained generalization is explained.
1106#Goal-directed behaviour
1107#Inverse morphic equivalence on languages
1108#On linear-time algorithms for five-coloring planar graphs
1109#On derivation preservation
1110#The contour problem for rectilinear polygons
1111#How to estimate the sizes of domains
1112#An inductive number-theoretic characterization of NP
1113#Permutations of bounded degree generate groups of polynomial diameter
1114#Asserting the optimality of serial SJRPs in processing simple queries in chain networks
1115#A qualitative physics based on confluences
1116#Qualitative process theory
1117#Commonsense reasoning about causality: deriving behavior from structure
1118#How circuits work
1119#Qualitative analysis of MOS circuits
1120#Diagnostic reasoning based on structure and behavior
1121#The use of design descriptions in automated diagnosis
1122#VERIFY: a program for proving correctness of digital hardware designs
1123#Simulation to develop and test queue approximations: a case study
1124#Using the interactive financial planning system (IFPS) for stochastic simulation
1125#On the equivalence of DYNAMO and a financial planning language
1126#The crippled queen placement problem
1127#A simple livelock-free algorithm for packet switching
1128#Adequate proof principles for invariance and liveness properties of concurrent programs
1129#Terminating Turing Machine Computations and the Complexity and/or decidability of Correspondence Problems, Grammars, and Program Schemes
1130#Multiprecision integer division examples using arbitrary radix
1131#The most effective use of mesh-connected array processors is achieved by paying careful attention to the organization of data. Storage and movement of the elements of multidimensional arrays of data within a multidimensional store for a particular problem is a difficult task, often handled in an ad hoc way. For an important class of problems, considerable conceptual simplification arises from considering a specification of the mapping rather than the physical location of data.
1132#Effective design of CODASYL data base
1133#An average case analysis of Floyd's algorithm to construct heaps
1134#Diamond formulas: a fragment of dynamic logic with recursively enumerable validity problem
1135#The complexity of promise problems with applications to public-key cryptography
1136#Introductory theory of computer science
1137#A handbook of software development and operating procedures for microcomputers
1138#Computing contours by successive solution of quintic polynomial equations
1139#Data and computer communications
1140#Algorithm 626: TRICP: a contour plot program triangular meshes
1141#The second self: computers and the human spirit
1142#A model for the interpretation of verbal predictions
1143#Computer usability testing & evaluation
1144#Saturation, nonmonotonic reasoning and the closed-world assumption
1145#The complexity of some polynomial network consistency algorithms for constraint satisfaction problems
1146#Semantical considerations on nonmonotonic logic
1147#The analysis of algorithms
1148#Computer information systems: an introduction to data processing
1149#Digital computer fundamentals (6th ed.)
1150#Does Grosch's law, which postulated that the costs of computer systems increase at a rate equivalent to the square root of their power, still hold? The age of mini-, micro-, and supercomputers seems to have complicated the situation. When computers are grouped according to their size and power, Grosch's law seems to hold within each group, but not between different groups.
1151#The readability of the ten major computing periodicals is analyzed using the Flesch Reading Ease Index.
1152#From NELIAC (via ALGOL 60) to Euler and ALGOL W, to Pascal and Modula-2, and ultimately Lilith, Wirth's search for an appropriate formalism for systems programming yields intriguing insights and surprising results.
1153#Both the composition of the selection team and the choice of evaluation criteria should reflect the end-user orientation of DSS software.
1154#Psychometric scaling methods are applied to programmer productivity assessments of 20 tools to recommend a set of minimal, as well as more comprehensive, tools.
1155#Effective development environments for discrete event simulation models should reduce development costs and improve model performance. A model specification language used in a model development environment is defined. This approach is intended to reduce modeling costs by interposing an intermediate form between a conceptual model (the model as it exists in the mind of the modeler) and an executable representation of that model. As a model specification is constructed, the incomplete specification can be analyzed to detect some types of errors and to provide some types of model documentation. The primitives used in this specification language, called a condition specification (CS), are carefully defined. A specification for the classical patrolling repairman model is used to illustrate this language. Some possible diagnostics and some untestable model specification properties, based on such a representation, are summarized.
1156#In this article we study the amortized efficiency of the “move-to-front” and similar rules for dynamically maintaining a linear list. Under the assumption that accessing the ith element from the front of the list takes &thgr;(i) time, we show that move-to-front is within a constant factor of optimum among a wide class of list maintenance rules. Other natural heuristics, such as the transpose and frequency count rules, do not share this property. We generalize our results to show that move-to-front is within a constant factor of optimum as long as the access cost is a convex function. We also study paging, a setting in which the access cost is not convex. The paging rule corresponding to move-to-front is the “least recently used” (LRU) replacement rule. We analyze the amortized complexity of LRU, showing that its efficiency differs from that of the off-line paging rule (Belady's MIN algorithm) by a factor that depends on the size of fast memory. No on-line paging algorithm has better amortized performance.
1157#Data structures & program design
1158#Fundamentals of data structures in PASCAL
1159#An introduction to data structures with applications (2nd ed.)
1160#Systems: concepts, methodologies, and applications
1161#Personal computers for education
1162#On the factorization of block-tridiagonals without storage constraints
1163#Proc. of the 2nd European conference on Readings on cognitive ergonomics - mind and computers
1164#Representational frameworks and models for human-computer interfaces
1165#On models and modelling in human-computer co-operation
1166#Information systems design methodologies and their compliance with cognitive ergonomy
1167#Human cognition and human computer interaction
1168#Active help systems
1169#Fatal error in pass zero: how not to confuse novices
1170#Real time graphic simulation of visual effects of egomotion
1171#From surface form to the structure of the interface - studies in human computer interaction at INRIA
1172#Proc. of international conference on Tools, methods and languages for scientific and engineering computation
1173#An extensible toolset and environment for the production of mathematical software
1174#A programming environment approach to mathematical software development
1175#Testing multidimensional integration routines
1176#GEM2 - a program package for elliptic partial differential equations
1177#Development of scientific and engineering software for nuclear applications
1178#A portable environment for teaching mathematical software development
1179#A comparison of some parallel languages for the implementation of an eigenvalue algorithm
1180#Exception handling in scientific computation
1181#FORTRAN 8X: a continuing language for numerical software?
1182#Requirements and implementation of a highly optimizing FORTRAN 77 compiler
1183#Arithmetic specification in FORTRAN 8X
1184#Array features in FORTRAN-8X
1185#Papering over deficiencies in your language for convenience and portability: preprocessors vs. standards
1186#Information technology and civilization
1187#Distributed processors and intelligent workstations at Los Alamos
1188#The role of editors in the programming environment
1189#Automatic techniques in FORTRAN programming
1190#Integration: formal and numeric approaches
1191#Optimal information retrieval when queries are not random
1192#Proc. of the conference on Ninth colloquium on trees in algebra and programming
1193#Continuous structures and analytic methods in computer science
1194#Optimal VLSI-circuits for the basic arithmetic functions
1195#Logical aspects in the study of tree languages
1196#Partially ordered sorts in algebraic specifications
1197#Numeration models of &lgr;-calculus (extended abstract)
1198#Text processing
1199#Advanced programming: a practical course
1200#Learning assembly language: a guide for BASIC programmers
1201#A synopsis of present day practices concerning decision support systems
1202#Productive capacity of a system for software development
1203#The evolution of a distributed processing network
1204#A survey of applications systems prototyping in industry
1205#Computation of logical effort in high level languages
1206#An intermediate language to define dynamic semantics
1207#HUHU: the Hebrew University Hebrew understander
1208#Reverse execution in a generalized control regime
1209#Implementation of CSP-S for description of distributed algorithms
1210#A measure of program complexity
1211#The grand tour: a tool for viewing multidimensional data
1212#A simple and efficient method for processing general equijoin queries in a distributed relational database is described. The query is first decomposed into a set of simple queries, each being involved with only one of the joining domains and its relevant equijoins. An extended version of Hevner and Yao's STRATEGY PARALLEL or STRATEGY SERIAL is then applied on each of them for generating transmission schedules. These schedules will fully reduce (with respect to a simple query) some specified relations. The latter are then transmitted to the result site for final processing. In the case of minimizing total time, our method has a lower order of complexity than ALGORITHM GENERAL studied by Hevner and Apers. Examples show that our method gives better and more efficient solutions than theirs.
1213#Programming in C, for the microcomputer user
1214#Statistical software: a comparative review
1215#Systems analysis and design
1216#Proc. of the international NATO symposium on Artificial and human intelligence
1217#Expert behaviour and problem representations
1218#Is complexity theory of use to AI?
1219#Knowledge-based self-organizing memory for events
1220#GPS and the psychology of th Rubik cubist: a study in reasoning about actions
1221#Toward combining empirical and analytical methods for inferring heuristics
1222#Advice and planning in chess endgames
1223#ORBIT: a tool for building AI systems in an object-oriented style
1224#An integrated frame/rule architecture
1225#Beliefs, points of view and multiple environments
1226#A framework of a mechanical translation between Japanese and English by analogy principle
1227#Tools for creating intelligent computer tutors
1228#Benchmark and yardstick problems: a systematic approach
1229#Approaches to human reasoning: an analytic framework
1230#The distributed processing of knowledge and belief in the human brain
1231#The bilateral cooperative model of reading: a human paradigm for artificial intelligence
1232#Handling the unconscious
1233#An intrasystemic approach to belief
1234#An intelligent system can and must use declarative knowledge efficiently
1235#Common and uncommon issues in artificial intelligence an psychology
1236#A taxonomy for the social implications of computer technology
1237#Reasoning in natural language for designing a data base
1238#Computers: concepts and uses
1239#…the design of ADA is based on an implicitassumption of a hardware model with a single shared memory. This paperidentifies the ADA facilities influenced by this invalid assumption. Itproposes ways to overcome these weaknesses ...
1240#Evolution of a dataflow architecture
1241#OCCAM and the transputer
1242#…the design of ADA is based on an implicitassumption of a hardware model with a single shared memory. This paperidentifies the ADA facilities influenced by this invalid assumption. Itproposes ways to overcome these weaknesses while restricting the powerof the language as little as possible.—From the Author's Abstract
1243#Architecture for VHLL: a direct execution approach
1244#Implementing object based languages on distributed computers
1245#A geographically distributed multi-microprocessor system
1246#A fault tolerant LAN with integrated storage, as part of a distributed computing system
1247#Obtaining a secure, fault-tolerant, distributed system with maximized performance
1248#Implementing CHILL signals: a case study in performance measurement
1249#Performance of an interconnected microprocessor system designed for fast user-level communications
1250#Design aids for highly distributed hardware
1251#An architectural strategy for asynchronous processing
1252#Quantitative system performance: computer system analysis using queueing network models
1253#Systems analysis, design, and development: with structured concepts
1254#Introduction to non-linear optimization
1255#Application debugging: an MVS ABEND handbook for COBOL, ASSEMBLY, PL/I, and FORTRAN programmers
1256#Effective structured programming
1257#The role of context and adaptation in user interfaces
1258#Experience with the ZOG human-computer interface system
1259#Nonlinear programming: theory, algorithms, and applications
1260#What makes RABBIT run?
1261#The electronic classroom: workstations for teaching
1262#Stages and levels in human-machine interaction
1263#Ingredients of intelligent user interfaces
1264#Managing microcomputers in large organizations
1265#A problem-decomposition method using differences or equivalence relations between states
1266#A dictionary based on concept coherence
1267#Discovering patterns in sequences of events
1268#An efficient incremental LR parser for grammars with epislon productions
1269#Using Time Instead of Timeout for Fault-Tolerant Distributed Systems.
1270#Robustness of queuing network formulas
1271#What is the binary relationship approach?
1272#The management of information systems
1273#Proc. of the third joint BCS and ACM symposium on Research and development in information retrieval
1274#on Computer algebra: symbolic and algebraic computation (2nd ed.)
1275#Framework for the development of an experimental mixed-mode message system
1276#Computer algebra applications
1277#Evaluation of access methods to text documents in office systems
1278#An interactive database end user facility for the definition and manipulation of forms
1279#Nested transactions in a combined IRS-DBMS architecture
1280#A semantic model and schema notation for bibliographic retrieval systems
1281#The use of adaptive mechanisms for selection of search strategies in document retrieval systems
1282#Latest advances in computer aided design for the process industries
1283#The IIASA TPA/70—X.25 gateway-network promotes international flow of scientific information
1284#Query enhancement by user profiles
1285#The Utah text retrieval project -- a status report
1286#Shared processing with an advanced intelligent terminal
1287#A global approach to record clustering and file reorganization
1288#Two axioms for evaluation measures in information retrieval
1289#Monitoring and evaluation of information systems via transaction log analysis
1290#Bridging the gap between AI and IR
1291#Knowledge based systems versus thesaurus : an architecture problem about expert systems design
1292#Some remarks about the inference techniques of RESEDA, an “intelligent” information retrieval system
1293#Dependency parsing for information retrieval
1294#Computing text constituency: an algorithmic approach to the generation of text graphs
1295#Retrieval test evaluation of a rule based automatic indexing (AIR/PHYS)
1296#Microprocessor system design concepts
1297#A special purpose MIMD parallel processor
1298#An algorithm for local compaction of horizontal microprograms
1299#A new method for the computation of digital filter coefficients—Part I
1300#Foundations of computer music
1301#Robotics for engineers
1302#Recursion via PASCAL
1303#Principles of functional programming
1304#Computers and application software: an introduction
1305#Micro database management: practical techniques for application development
1306#Introduction to logic programming
1307#FUMBLE: a PASCAL program for initializing memory
1308#Communicating with databases in natural language
1309#Linear programming with BASIC and FORTRAN
1310#Human factors in software engineering: a review of the literature
1311#Applications of symbolic evaluation
1312#An analysis of static metrics and faults in C software
1313#Managing programming productivity
1314#A methodology to model the information structure of an organization
1315#Analysis of parallelism in nested DO loops
1316#Stepwise refinement revisited
1317#The problem of synthesizing a procedure from example computations is examined. An algorithm for this task is presented, and its success is considered. To do this, a model of procedures and example computations is introduced, and the class of acceptable examples is defined. The synthesis algorithm is shown to be successful, with respect to the model of procedures and examples, from two perspectives. First, it is shown to be sound, that is, that the procedure synthesized from a set of examples produces the same result as the intended one on the inputs used to generate that set of examples. Second, it is shown to be complete, that is, that for any procedure in the class of procedures, there exists a finite set of examples such that the procedure synthesized behaves as the intended one on all inputs for which the intended one halts.
1318#Many database systems maintain the consistency of the data by using a locking protocol to restrict access to data items. It has been previously shown that if no information is known about the method of accessing items in the database, then the two-phase protocol is optimal. However, the use of structural information about the database allows development of non-two-phase protocols, called graph protocols, that can potentially increase efficiency. Yannakakis developed a general class of protocols that included many of the graph protocols. Graph protocols either are only usable in certain types of databases or can incur the performance liability of cascading rollback. In this paper, it is demonstrated that if the system has a priori information as to which data items will be locked first by various transactions, a new graph protocol that is outside the previous classes of graph protocols and is applicable to arbitrarily structured databases can be constructed. This new protocol avoids cascading rollback and its accompanying performance degradation, and extends the class of serializable sequences allowed by non-two-phase protocols. This is the first protocol shown to be always as effective as the two-phase protocol, and it can be more effective for certain types of database systems.
1319#Parallel algorithms for data compression by textual substitution that are suitable for VLSI implementation are studied. Both “static” and “dynamic” dictionary schemes are considered.
1320#This paper analyzes decomposition properties of a graph that, when they occur, permit a polynomial solution of the traveling salesman problem and a description of the traveling salesman polytope by a system of linear equalities and inequalities. The central notion is that of a 3-edge cutset, namely, a set of 3 edges that, when removed, disconnects the graph. Conversely, our approach can be used to construct classes of graphs for which there exists a polynomial algorithm for the traveling salesman problem. The approach is illustrated on two examples, Halin graphs and prismatic graphs.
1321#Criteria for adequacy of a data flow semantics are discussed and Kahn's successful semantics for functional (deterministic) data flow is reviewed. Problems arising from nondeterminism are introduced and the paper's approach to overcoming them is introduced. The approach is based on generalizing the notion of input-output relation, essentially to a partially ordered multiset of input-output histories. The Brock-Ackerman anomalies concerning the input-output relation model of nondeterministic data flow are reviewed, and it is indicated how the proposed approach avoids them. A new anomaly is introduced to motivate the use of multisets. A formal theory of asynchronous processes is then developed. The main result is that the operation of forming a process from a network of component processes is associative. This result shows that the approach is not subject to anomalies such as that of Brock and Ackerman.
1322#A distributed computer system that consists of a set of heterogeneous host computers connected in an arbitrary fashion by a communications network is considered. A general model is developed for such a distributed computer system, in which the host computers and the communications network are represented by product-form queuing networks. In this model, a job may be either processed at the host to which it arrives or transferred to another host. In the latter case, a transferred job incurs a communication delay in addition to the queuing delay at the host on which the job is processed. It is assumed that the decision of transferring a job does not depend on the system state, and hence is static in nature. Performance is optimized by determining the load on each host that minimizes the mean job response time. A nonlinear optimization problem is formulated, and the properties of the optimal solution in the special case where the communication delay does not depend on the source-destination pair is shown.Two efficient algorithms that determine the optimal load on each host computer are presented. The first algorithm, called the parametric-study algorithm, generates the optimal solution as a function of the communication time. This algorithm is suited for the study of the effect of the speed of the communications network on the optimal solution. The second algorithm is a single-point algorithm; it yields the optimal solution for given system parameters. Queuing models of host computers, communications networks, and a numerical example are illustrated.
1323#Two of the most powerful classes of programs for which interesting decision problems are known to be solvable are the class of finite-memory programs and the class of programs that characterize the Presburger, or semilinear, sets. In this paper, a new class of programs that presents solvable decision problems similar to the other two classes of programs is introduced. However, the programs in the new class are shown to be computationally more powerful (i.e., capable of defining larger sets of input-output relations).
1324#A projection of a Boolean function is a function obtained by substituting for each of its variables a variable, the negation of a variable, or a constant. Reducibilities among computational problems under this relation of projection are considered. It is shown that much of what is of everyday relevance in Turing-machine-based complexity theory can be replicated easily and naturally in this elementary framework. Finer distinctions about the computational relationships among natural problems can be made than in previous formulations and some negative results are proved.
1325#The problem of finding a minimum cardinality feedback vertex set of a directed graph is considered. Of the classic NP-complete problems, this is one of the least understood. Although Karp showed the general problem to be NP-complete, a linear algorithm for its solution on reducible flow graphs was given by Shamir. The class of reducible flow graphs is the only nontrivial class of graphs for which a polynomial-time algorithm to solve this problem is known. The main result of this paper is to present a new class of graphs—the cyclically reducible graphs—for which minimum feedback vertex sets can be found in polynomial time. This class is not restricted to flow graphs, and most small graphs (10 or fewer nodes) fall into this class. The identification of this class is particularly important since there do not exist approximation algorithms for this problem having a provably good worst case performance. Along with the class and a simple polynomial-time algorithm for finding minimum feedback vertex sets of graphs in the class, several related results are presented. It is shown that there is no “forbidden subgraph” characterization of the class and that there is no particular inclusion relationship between this class and the reducible flow graphs. In addition, it is shown that a class of (general) graphs, which are related to the reducible flow graphs, are contained in the cyclically reducible class.
1326#Given the pairwise probability of conflict p among transactions in a transaction processing system, together with the total number of concurrent transactions n, the effective level of concurrency E(n,p) is defined as the expected number of the n transactions that can run concurrently and actually do useful work. Using a random graph model of concurrency, we show for three general classes of concurrency control methods, examples of which are (1) standard locking, (2) strict priority scheduling, and (3) optimistic methods, that (1) E(n, p) &les; n(1 - p/2)n-1, (2) E(n, p) &les; (1 - (1 - p)n)/p, and (3) 1 + ((1 - p)/p)ln(p(n - 1) + 1) &les; E(n, p) &les; 1 + (1/p)ln(p(n - 1) + 1). Thus, for fixed p, as n &rarrtl; ∞), (1) E &rarrtl; 0 for standard locking methods, (2) E &les; 1/p for strict priority scheduling methods, and (3) E &rarrtl; ∞ for optimistic methods. Also found are bounds on E in the case where conflicts are analyzed so as to maximize E.The predictions of the random graph model are confirmed by simulations of an abstract transaction processing system. In practice, though, there is a price to pay for the increased effective level of concurrency of methods (2) and (3): using these methods there is more wasted work (i.e., more steps executed by transactions that are later aborted). In response to this problem, three new concurrency control methods suggested by the random graph model analysis are developed. Two of these, called (a) running priority and (b) older or running priority, are shown by the simulation results to perform better than the previously known methods (l)-(3) for relatively large n or large p, in terms of achieving a high effective level of concurrency at a comparatively small cost in wasted work.
1327#In a distributed database system the partitioning and allocation of the database over the processor nodes of the network can be a critical aspect of the database design effort. In this paper we develop and evaluate algorithms that perform this task in a computationally feasible manner. The network we consider is characterized by a relatively high communication bandwidth, considering the processing and input output capacities in its processors. Such a balance is typical if the processors are connected via busses or local networks. The common constraint that transactions have a specific root node no longer exists, so that there are more distribution choices. However, a poor distribution leads to less efficient computation, higher costs, and higher loads in the nodes or in the communication network so that the system may not be able to handle the required set of transactions.Our approach is to first split the database into fragments which constitute appropriate units for allocation. The fragments to be allocated are selected based on maximal benefit criteria using a greedy heuristic. The assignment to processor nodes uses a first-fit algorithm. The complete algorithm, called GFF, is stated in a procedural form.The complexity of the problem and of its candidate solutions are analyzed and several interesting relationships are proven. Alternate benefit metrics are considered, since the execution cost of the allocation procedure varies by orders of magnitude with the alternatives of benefit evaluation. A mixed benefit evaluation strategy is eventually proposed.A model for evaluation is presented. Two of the strategies are experimentally evaluated, and the reported results support the discussion. The approach should be suitable for other cases where resources have to be allocated subject to resource constraints.
1328#Cubicaliy convergent iterative methods for the solution of nonlinear systems of the multivariate Halley method, require first and second partial derivatives of the of the functions comprising the system. Automatic differentiation is used to automate the Halley method, HESSIAN and routines for the required operators and functions. A Pascal-SC which implements this method in a single-step iteration mode. The program nonlinear systems, and the results are compared with Newton's method.
1329#In this paper we discuss the implementation of a primal simplex algorithm for network problems in the MPSIII mathematical programming system. Because of the need to interface with the rest of the MPS this implementation is unorthodox, but computationally effective, and has a number of advantages over “stand alone” network optimizers. It is argued that a similar approach is appropriate for other general-purpose mathematical programming systems, and has applications beyond pure network optimization.
1330#We present a method for comparing that part of optimization algorithms that chooses each step direction. It is an example of a general approach to algorithm evaluation in which one tests specific parts of the algorithm, rather than making overall evaluations on a set of standard test problems. Our testing procedure can he useful for developing new algorithms and for writing and evaluating optimization software.We use the method to compare two versions of the conjugate gradient algorithm, and to compare these with an algorithm based on conic functions.
1331#We introduce fast algorithms for selecting a random sample of n records without replacement from a pool of N records, where the value of N is unknown beforehand. The main result of the paper is the design and analysis of Algorithm Z; it does the sampling in one pass using constant space and in O(n(1 + log(N/n))) expected time, which is optimum, up to a constant factor. Several optimizations are studied that collectively improve the speed of the naive version of the algorithm by an order of magnitude. We give an efficient Pascal-like implementation that incorporates these modifications and that is suitable for general use. Theoretical and empirical results indicate that Algorithm Z outperforms current methods by a significant margin.
1332#A group of 269 first-semester freshmen was used to predict both performance in an introductory computer science course and first-semester college grade point average by using information regarding the students' programs and performance in high school along with American College Testing Program (ACT) test scores.
1333#Computer science in secondary schools is an area of increasing interest and concern to educators as well as to computer science professionals. Each of the next two reports addresses an issue of major importance regarding computer science in secondary schools. The first report recommends computer science courses for the secondary school curriculum, and the second report recommends requirements for teacher certification in computer science.In 1983 the ACM Education Board initiated efforts to formulate recommendations for secondary school computer science. Two task forces, one for curriculum recommendations and the other for teacher certification recommendations, were established under the Education Board's Elementary and Secondary Schools Subcommittee. The work of the two task forces was also supported by the IEEE Computer Society Educational Activities Board, and the final reports from the task forces were jointly approved by the ACM and IEEE-CS boards in July 1984. Thus the reports are significan't not only for the important issues that they address, but also because they represent a joint activity between ACM and the IEEE Computer Society.The work of the two task forces is summarized in the next two reports. The full reports are available as the publication Computer Science in Secondary Schools: Curriculum and Teacher Certification, Order Number 201850, from the ACM Order Department, P.O. Box 64145, Baltimore, MD 21264.
1334#An existing typesetting system is tied by bridging software to an existing page-presentation program to effect both hard (typeset) copy and interactive browsing. The typesetting system formats documents for a variety of output devices, and the “browsing” feature appears to the user as simply another output device that happens to be interactive.
1335#This article is both theoretical and empirical. Theoretically, it describes three principles of system design which we believe must be followed to produce a useful and easy to use computer system. These principles are: early and continual focus on users; empirical measurement of usage; and iterative design whereby the system (simulated, prototype, and real) is modified, tested, modified again, tested again, and the cycle is repeated again and again. This approach is contrasted to other principled design approaches, for example, get it right the first time, reliance on design guidelines. Empirically, the article presents data which show that our design principles are not always intuitive to designers; identifies the arguments which designers often offer for not using these principles—and answers them; and provides an example in which our principles have been used successfully.
1336#This article studies the effects of queueing delays, and users' related costs, on the management and control of computing resources. It offers a methodology for setting price, utilization, and capacity, taking into account the value of users' time, and it examines the implications of alternative control structures, determined by the financial responsibility assigned to the data processing manager.
1337#Properties, implementations and applications of rank filters
1338#Implicit convolution
1339#Three-dimensional hidden-surface removal for signal-return modelling: experimental results
1340#Efficient planar convex hull algorithm
1341#Three-dimensional surface mapping simulator: theory, capabilities and operation
1342#The elements of networking style: and other essays and animadversions on the art of intercomputer networking
1343#Preventing piracy: a business guide to software protection
1344#System software: an introduction to systems programming
1345#Intelligent machines: an introductory perspective of artificial intelligence and robotics
1346#Proc. of the ICOD-2 workshop on New applications of data bases
1347#Digital cartography and photo interpretation from a database viewpoint
1348#Managing the semantic content of graphical data
1349#Managing texts and facts in a mixed data base environment
1350#First steps to algebraic processing of text
1351#A model for word processing systems
1352#A natural language front end to databases with evaluative feedback
1353#Databases and expert systems: opportunities and architectures for integration
1354#The design of an expert system for database design
1355#Interfacing PROLOG and relational data base management systems
1356#Databases for computer-aided design
1357#Transaction management in the design environment
1358#An evaluation of a large, operational full-text document-retrieval system (containing roughly 350,000 pages of text) shows the system to be retrieving less than 20 percent of the documents relevant to a particular search. The findings are discussed in terms of the theory and practice of full-text document retrieval.
1359#Microchip technology: the past and the future
1360#Mathematics: people, problems, results
1361#Mathematics: people, problems, results Vol. I
1362#Mathematics: people, problems, results Vol. II
1363#Real zeroes of polynomials
1364#The foundations of program verification
1365#Data systems and management: an introduction to systems analysis and design (3rd Ed.)
1366#Fault tolerant and fault testable hardware design
1367#An intelligent interface for online interaction
1368#Using a cognitive model of dialogue for reference retrieval
1369#Dynamic non-dense indexes in relational databases
1370#A comprehensive model for the storage structure design of CODASYL databases
1371#Attribute equivalence in global schema design for heterogeneous distributed databases
1372#Nested set languages for functional databases
1373#A methodology for conceptual design of office data bases
1374#Education and Computing
1375#Computer education: the problem of policy implementation
1376#Technologies of the future
1377#Computers and information technology as a learning aid
1378#An approach to data encapsulation in the teaching of computing
1379#Computer-based education in banking: a conceptual introduction
1380#Mathematics: people, problems, results Vol. III
1381#Programmer productivity: achieving an urgent priority
1382#A major issue in many applications is how to preserve the consistency of data in the presence of concurrency and hardware failures. We suggest addressing this problem by implementing applications in terms of abstract data types with two properties: Their objects are atomic (they provide serializability and recoverability for activities using them) and resilient (they survive hardware failures with acceptably high probability). We define what it means for abstract data types to be atomic and resilient. We also discuss issues that arise in implementing such types, and describe a particular linguistic mechanism provided in the Argus programming language.
1383#This paper presents a new model for exception handling, called the replacement model. The replacement model, in contrast to other exception-handling proposals, supports all the handler responses of resumption, termination, retry, and exception propagation, within both statements and expressions, in a modular, simple, and uniform fashion. The model can be embedded in any expression-oriented language and can also be adapted to languages which are not expression oriented with almost all the above advantages. This paper presents the syntactic extensions for embedding the replacement model into Algol 68 and its operational semantics. An axiomatic semantic definition for the model can be found in [27].
1384#Most programming environments are much too complex. One way of simplifying them is to reduce the number of mode-dependent languages the user has to be familiar with. As a first step towards this end, the feasibility of unified command/programming/debugging languages, and the concepts on which such languages have to be based, are investigated. The unification process is accomplished in two phases. First, a unified command/programming framework is defined and, second, this framework is extended by adding an integrated debugging capability to it. Strict rules are laid down by which to judge language concepts presenting themselves as candidates for inclusion in the framework during each phase. On the basis of these rules many of the language design questions that have hitherto been resolved this way or that, depending on the taste of the designer, lose their vagueness and can be decided in an unambiguous manner.
1385#The CIRCAL calculus is presented as a mathematical framework in which to describe and analyze concurrent systems, whether hardware or software.The dot operator is used to compose CIRCAL descriptions, and it is this operator which permits the natural modeling of asynchronous and simultaneous behavior, thus allowing the representation and analysis of system timing properties such as those found in circuits.The CIRCAL framework uses an abstraction operator to permit the modeling of a system at different levels of detail. Behavioral complexity of real systems makes abstraction crucial when producing a tractable model, and we illustrate how abstraction introduces nondeterminisim into system representations.An operational semantics, acceptance semantics, is introduced, and it is in terms of this active experimentation that meaning is given to the CIRCAL syntax, thus allowing proof of system properties to be constructed.
1386#Sufficient criteria are given for replacing all occurrences of the store argument in a Scott-Strachey denotational definition of a programming language by a single global variable. The criteria and transformation are useful for transforming denotational definitions into compilers and interpreters for imperative machines, for optimizing applicative programs, and for judging the suitability of semantic notations for describing imperative languages. An example transformation of a semantics of a repeat-loop language to one which uses a global store variable is given to illustrate the technique.
1387#Linear hashing is a file structure for dynamic files. In this paper, a new, simple method for handling overflow records in connection with linear hashing is proposed. The method is based on linear probing and does not rely on chaining. No dedicated overflow area is required. The expansion sequence of liner hashing is modified to improve the performance, which requires changes in the address computation. A new address computation algorithm and an expansion algorithm are given. The performance of the method is studied by simulation. The algorithms for the basic file operations are very simple, and the overall performance is competitive with that of other variants of linear hashing.
1388#A graph model is presented to analyze the performance of a relational join. The amount of page reaccesses, the page access sequence, and the amount of buffer needed are represented in terms of graph parameters. By using the graph model formed from the index on the join attributes, we determine the relationships between these parameters. Two types of buffer allocation strategies are studied, and the upper bound on the buffer size with no page reaccess is given. This bound is shown to be the maximum cut value of a graph. Hence, the problem of computing this upper bound is NP-hard. We also give algorithms to determine a page access sequence requiring a near optimal buffer size with no page reaccess. The optimal page access sequence for a fixed buffer size has also been considered.
1389#Batching yields significant savings in access costs in sequential, tree structured, and random files. A direct and simple expression is developed for computing the average number of records/pages accessed to satisfy a batched query of a sequential tile. The advantages of batching for sequential and random files are discussed. A direct equation is provided for the number of nodes accessed in unhatched queries of hierarchical files. An exact recursive expression is developed for node accesses in batched queries of hierarchical files. In addition to the recursive relationship, good, closed-form upper- and lower-bound approximations are provided for the case of batched queries of hierarchical files.
1390#Database system support has become an essential part of many computer applications, which have extended beyond the more traditional commercial applications to, among others, engineering applications. Correspondingly, application programming with the need to access databases has progressively shifted to scientifically oriented languages.Modern developments in these languages are characterized by advanced mechanisms for the liberal declaration of data types, for type checking, and facilities for modularization of large programs. The present paper examines how a DBMS can be accessed from such a language in a way that conforms to its syntax and utilizes its type-checking facilities, without modifying the language specification itself, and hence its compilers. The basic idea is to rely on facilities for defining modules as separately compilable units, and to use these to declare user-defined abstract data types.The idea is demonstrated by an experiment in which a specific DBMS (ADABAS) is hosted in the programming language (LIS). The paper outlines a number of approaches and their problems, shows how to embed the DML into LIS, and how a more user-oriented DML can be provided in LIS.
1391#General multiple-objective decision functions and linguistically quantified statements
1392#Customers' requirements for natural language systems: results of an inquiry
1393#An approach to CAD system performance evaluation
1394#QWERTY and keyboard reform: the soft keyboard option
1395#An icon-driven end-user interface to UNIX
1396#An overview of automated reasoning and related fields
1397#Introduction to natural language processing
1398#As computers become more powerful and sophisticated, computational astrophysicists will be able to find out more about stellar evolution and other astronomical phenomena.
1399#Although lattice field theorists have been able to develop new approaches to the Monte Carlo method and to successfully apply them in Bosonic calculations, faster and larger computers are needed for Fermion-field evaluations.
1400#Since computers are able to simulate the equilibrium properties of model systems, they may also prove useful for solving the hard optimization problems that arise in the engineering of complex systems.
1401#Computers have expanded the range of nonlinear phenomena that can be explored mathematically. An “experimental mathematics facility,” containing both special-purpose dedicated machines and general-purpose mainframes, may someday provide the ideal context for complex nonlinear problems.
1402#Specially designed processors can provide a method for attacking some of the difficult computational problems facing theoretical physicists.
1403#Standard programming languages are inadequate for the kind of symbolic mathematical computations that theoretical physicists need to perform. Higher mathematics systems like SMP address this problem.
1404#Bsort, a variation of Quicksort, combines the interchange technique used in Bubble sort with the Quicksort algorithm to improve the average behavior of Quicksort and eliminate the worst case situation of O(n2) comparisons for sorted or nearly sorted lists. Bsort works best for nearly sorted lists or nearly sorted in reverse.
1405#The performance of sequential search can be enhanced by the use of heuristics that move elements closer to the front of the list as they are found. Previous analyses have characterized the performance of such heuristics probabilistically. In this article, we use amortization to analyze the heuristics in a worst-case sense; the relative merit of the heuristics in this analysis is different in the probabilistic analyses. Experiments show that the behavior of the heuristics on real data is more closely described by the amortized analyses than by the probabilistic analyses.
1406#A generalized algorithm for graph coloring by implicit enumeration is formulated. A number of backtracking sequential methods are discussed in terms of the generalized algorithm. Some are revealed to be partially correct and inexact. A few corrections to the invalid algorithms, which cause these algorithms to guarantee optimal solutions, are proposed. Finally, some computational results and remarks on the practical relevance of improved implicit enumeration algorithms are given.
1407#Communication with alien intelligence: it may not be as difficult as you think
1408#The quest to understand thinking: it begins not with complex issues but with the most trivial of processes
1409#The LISP tutor: it approaches the effectiveness of a human tutor
1410#PROUST: an automatic debugger for PASCAL programs
1411#Architectures for AI: hardware and software for efficient processing
1412#The challenge of open systems: current logic programming methods may be insufficient for developing the intelligent systems of the future
1413#Vision: biology challenges technology
1414#Learning in parallel networks: simulating learning in a probabilistic system
1415#Connections: massive parallelism in natural and artificial intelligence
1416#Reverse engineering the brain
1417#The technology of expert systems: transplanting expert knowledge to machines
1418#Inside an expert system: from index cards to PASCAL program
1419#Experimental results do not support some ergonomic standards for computer video terminal design
1420#The new CEPT-standard: another system or a solution
1421#A guide to open systems interconnection
1422#Designing microprocessor-based digital circuitry
1423#RS-232 made easy: connecting computers, printers, terminals, and modems
1424#Introducing CAL: a practical guide to writing computer-assisted learning programs
1425#Petri nets: an introduction
1426#Verification and validation of real-time software
1427#The information technology revolution
1428#Discrete mathematics
1429#Metamodeling: a study of approximations in queueing models
1430#McGraw-Hill personal computer programming encyclopedia: languages and operating systems
1431#CAD/CAM handbook
1432#Calculation of special functions: the gamma function, the exponential integrals and error-like functions
1433#An introduction to online searching
1434#System design with microprocessors (2nd ed.)
1435#Recursive estimation and time-series analysis: an introduction
1436#A new polynomial-time algorithm for linear programming
1437#Technological transition in cartography
1438#Algebraic specification and verification of communication protocols
1439#The design of divide and conquer algorithms
1440#A language of specified programs
1441#A general incremental evaluator for attribute grammars
1442#The METANET: a means for the specification of semantic networks as abstract data types
1443#An empirical investigation of voice as an input modality for computer programming
1444#Some cognitive aspects of interface design in a two-variable optimization task
1445#Voice-input aids for the physically disabled
1446#Given a general arithmetic expression, we find a computation binary tree representation in O(log n) time using n/log n processors on a concurrent-read, exclusive-write, parallel random-access machine.A new algorithm is introduced for this purpose. Unlike previous serial and parallel solutions, it is not based on using a stack.
1447#We introduce POINTY, an interactive system for constructing world-model-based programs for robots. POINTY combines an interactive programming environment with the teaching-by-guiding methodology that has been successful in industrial robotics. Owing to its ability to control robots in real time, and to interact with the user, POINTY provides a friendly and powerful programming environment for robot applications. In the past few years, POINTY has been in use at Stanford to write, test, and debug various robot programs.
1448#We describe a program transformation technique for programs in a general stream language L whereby a data-driven evaluation of the transformed program performs exactly the same computation as a demand-driven evaluation of the original program. The transformational technique suggests a simple denotational characterization of demand-driven evaluation.
1449#Is indexing trustworthy? classification of articles through co-word analysis
1450#Applications of analog integrated circuits
1451#Data structures and network algorithms
1452#The software revolution: trends, players, market dynamics in personal computer software
1453#Decision procedures and expressiveness in the temporal logic of branching time
1454#Tree pushdown automata
1455#A multiprocess network logic with temporal and spatial modalities
1456#A linear algorithm for embedding planar graphs using PQ-trees
1457#Variations on the technique of D&breve;uris&caron; and Galil
1458#Hierarchies of hyper-AFLs
1459#Routing, merging, and sorting on parallel models of computation
1460#Refutational theorem proving using term-rewriting systems
1461#Languages with self-reference I: foundations (or: we can have everything in first-order logic])
1462#Synthetic programming
1463#An intermediate machine technique for deciding equivalence between a DPDA and a linear DPDA
1464#Effectively given domains and lambda-calculus models
1465#Optimal hashing
1466#A program development tool
1467#The logical basis for computer programming. Volume 1: deductive reasoning
1468#The economics of computers: costs, benefits, policies, and strategies
1469#Creating computer software user guides: from manuals to menus
1470#Data administration: selected topics of data control
1471#Communicating with display terminals
1472#Artificial Intelligence - Lecture notes in computer science 178
1473#Planning english referring expressions
1474#Macro-operators: a weak method for learning
1475#Artificial intelligence and robotics
1476#Information Technology Research Development Applications - Lecture notes in computer science 178
1477#Simulation of a distributed expert-based information provision mechanism
1478#An integrated fact/document information system for office automation
1479#Technique for redundancy control in a distributed hierarchical filestore
1480#Experimental adaptive interface
1481#An approach to the functional description of an information retrieval system based on a generalized model
1482#Machine cryptography and modern cryptanalysis
1483#Operating system concepts (2nd ed.)
1484#Introduction to artificial intelligence
1485#System development standards
1486#Nested transactions: an approach to reliable distributed computing
1487#Efficient graph automorphism by vertex partitioning
1488#If the unique information-processing capabilities of protein enzymes could be adapted for computers, then evolvable, more efficient systems for such applications as pattern recognition and process control are in principle possible.
1489#A survey of application development techniques in 43 organizations identifies the methods and tools found most effective in application software development.
1490#Inexact or real-world queueing techniques are used to determine that the number of buffers provided in system design is indeed adequate to guard against message loss.
1491#Tested against extremes in the characteristics of arrival patterns to dynamic allocation software, the working-set approach outperforms the FIFO method except in the case of completely random request patterns—where the working-set method performs as well as the FIFO method.
1492#An empirical study of 282 users of home computers was conducted to explore the relationship between computer use and shifts in time allocation patterns in the household. Major changes in time allocated to various activities were detected. Prior experience with computers (i.e., prior to purchase of the home computer) was found to have a significant impact on the time allocation patterns in the household. The study provides evidence that significant behavior changes can occur when people adopt personal computers in their homes.
1493#A perfect hash function PHF is an injection F from a set W of M objects into the set consisting of the first N nonnegative integers where N &ges; M. If N = M, then F is a minimal perfect hash function, MPHF. PHFs are useful for the compact storage and fast retrieval of frequently used objects such as reserved words in a programming language or commonly employed words in a natural language.The mincycle algorithm for finding PHFs executes with an expected time complexity that is polynomial in M and has been used successfully on sets of cardinality up to 512. Given three pseudorandom functions h0, h1, and h2, the mincycle algorithm searches for a function g such that F(w) = (h0(w) + g ° h1(w) + g ° h2(w)) mod N is a PHF.
1494#Implementing a simulation tool in a high-level language with no multitasking facilities
1495#_cf_loadingtexthtml="";_cf_contextpath="";_cf_ajaxscriptsrc="/CFIDE/scripts/ajax";_cf_jsonprefix='//';_cf_clientid='B1635C99F93453C48833EF35FB746D23';Proc. of a symposium on Software validation: inspection-testing-verification-alternatives function settab() { var mytabs = ColdFusion.Layout.getTabLayout('citationdetails'); mytabs.on('tabchange', function(tabpanel,activetab) { document.cookie = 'picked=' + '3541' + ',' + activetab.id; }) }function letemknow(){ ColdFusion.Window.show('letemknow');}function testthis(){alert('test');}function loadalert(){ alert("I am in the load alert"); }function loadalert2(){ alert("I am in the load alert2"); } google.load('visualization', '1', {packages:['orgchart']}); google.setOnLoadCallback(drawChart); function drawChart() { var data = new google.visualization.DataTable(); data.addColumn('string', 'Name'); data.addColumn('string', 'Manager'); data.addColumn('string', 'ToolTip'); data.addRows([ [{v:'0', f:'CCS for this Proceeding
1496#An introduction to quality assurance and control of software
1497#Software inspections and the industrial production of software
1498#Application of software inspection methodology in design and code
1499#Integrated software validation in the view of inspections/reviews
1500#Introduction to the formal treatment of testing
1501#Integrating the testing, analysis and debugging of programs
1502#RXVP—today and tomorrow
1503#Analysis of concurrent software by cooperative application of static and dynamic techniques
1504#Symbolic evaluation -- an aid to testing and verification
1505#Symbolic evaluation as a basis for integrated validation
1506#Integrated program development and verification
1507#On the design of ANNA, a specification language for ADA
1508#Representation and refinement of visual specifications
1509#Quality management technology: practical applications
1510#Knowledge-based programming: an overview of data and control structure refinement
1511#What about CAD/CAM for software? the ARGUS concept
1512#Comments on practical constraints of software validation techniques
1513#Modeling production rules by means of predicate transition networks
1514#Estimation of fuzzy memberships from histograms
1515#Three-way automata on rectangular tapes over a one-letter alphabet
1516#A space-hierarchy result on two-dimensional alternating Turing machines with only universal states
1517#The VLSI optimality of the AKS sorting network
1518#Evaluating expressions with a queue
1519#A comment on the `basic security theorem' of Bell and LaPadula
1520#Translation of Turner combinators in O(n log n) space
1521#On the correspondence between two classes of reduction systems
1522#More on looping vs. repeating in dynamic logic
1523#Upper bounds on the size of LR(k) parsers
1524#An infinite square-free co-CFL
1525#How to detect tampering of data
1526#Complexity analyses of event set algorithms
1527#Adaptive signal processing
1528#Minimization methods for non-differentiable functions
1529#Proc. of the IFIP WG 6.5 working conference on Computer-based message services
1530#Implementing distribution lists in computer-based message systems
1531#A user-friendly naming convention for use in communication networks
1532#The domain name system
1533#Current ISO work on document profile
1534#Multimedia message content protocols for computer mail
1535#Initial experience with multimedia documents in Diamond
1536#An experimental internetwork multimedia mail system
1537#A user agent for multiple computer-based message services
1538#The active mailbox - your on-line secretary
1539#Structures for mailbox system applications
1540#User friendly interface for messaging systems
1541#You have 134 unread mail] do you want to read them now?
1542#A reference model for command and response languages
1543#Experiences with the KOMEX system as an inhouse CBMS
1544#EnvoyPost: a hybrid electronic mail service
1545#Making the right choice: public vs. private messaging systems
1546#Contracts made by electronic mail: legal issues, technology and services
1547#Designing secure message systems: the military message systems (MMS) project
1548#Integration of electronic mail and conferencing systems
1549#Interconnection of the IBM office system PROFS and GILT
1550#Implementation of a distributed CMBS on a minimum system
1551#MZnet: mail service for personal micro-computer systems
1552#A general purpose message gateway architecture
1553#A teletex based message handling server
1554#Computational models of natural language processing
1555#Competence and performance in the design of natural language systems
1556#Planning and understanding speech acts by interpersonal games
1557#A framework for integrating snytax and semantics
1558#Knowledge representation and natural language: extending the expressive power of proposition nodes
1559#Viewing parsing as word sense discrimination: a connectionist approach
1560#A propositional language for text representation
1561#From topic and focus of a sentence to linking in a text
1562#Language generation by computer
1563#Semantic primitives or meaning postulates: mental models or propositional representation?
1564#Narrative complexity based on summarization algorithms
1565#Using focus to constrain language generation
1566#Towards an integral model of language competence
1567#An object-oriented parser
1568#A new method for the computation of digital filter coefficients—Part II
1569#PARAGON: a language using type hierarchies for the specification, implementation and selection of abstract data types
1570#Interconnection networks for large-scale parallel processing: theory and case studies
1571#Artificial intelligence: applications to logical reasoning and historical reseach
1572#Evaluating ADA
1573#Expert systems: artificial intelligence in business
1574#Computer science: an overview
1575#Distributed systems: methods and tools for specification. An advanced course
1576#Learning the art of mathematical modelling
1577#Improved methods of estimating shape from shading using the light source coordinate system
1578#Understanding objects with curved surfaces from a single perspective view of boundaries
1579#Ordering conjunctive queries
1580#A mechanical solution of Schubert's steamroller by many-sorted resolution
1581#Pattern Recognition - Parallel and other image analysis methods
1582#A survey of curve and surface methods in CAGD
1583#Analysis of a model for parallel image processing
1584#A system organization for parallel image processing
1585#Parallel and sequential transformations on digital images
1586#Handwriter identification from one-bit quantized pressure patterns
1587#A syntactic method for image segmentation and object recognition
1588#Minutes of 1947 patent conference, Moore School of Electrical Engineering, University of Pennsylvania
1589#The scientific conceptualization of information: a survey
1590#A note on early Monte Carlo computations and scientific meetings
1591#The Federal computing machine program
1592#The evolution of intellectual technologies: applying product life-cycle models to MIS implementation
1593#Management applications of expert systems
1594#Microcomputer selection process for organizational information management
1595#A preliminary investigation of information systems team structures
1596#The complexity of distributed concurrency control
1597#An efficient formula for linear recurrences
1598#Sparse sets in NP-P: relativizations
1599#On the expected performance of path compression algorithms
1600#Finding extremal polygons
1601#Simplicity, relativizations and nondeterminism
1602#Polynomial time algorithms for the min cut problem on degree restricted trees
1603#The computational complexity of simultaneous diophantine approximation problems
1604#Arboricity and subgraph listing algorithms
1605#Maximum weight clique algorithms for circular-arc graphs and circle graphs
1606#New data structures for orthogonal range queries
1607#A management system for the information business: organizational analysis
1608#Parallel algorithms for the single source shortest path problem
1609#Attitudes towards specific uses of the computers quantitative, decision-making and record-keeping applications
1610#The numerical solution of nonlinear stiff initial value problems: an analysis of one step methods
1611#Information system specification & design road map
1612#Introduction to compiler construction with UNIX
1613#Basic VLSI design principles & applications
1614#Microcomputer systems: the 8086/8088 family: architecture, programming, and design
1615#The craft of computer programming
1616#Action diagrams: clearly structured program design
1617#Digital and data communications
1618#Analysis of a cyclic placement scheme
1619#Discrete structures: an introduction to mathematics for computer science
1620#Modern guide to EDP design and analysis techniques
1621#Strategy and computers
1622#A century of electrical engineering and computer science at MIT, 1882-1982
1623#Multiple processor systems for real-time applications
1624#Structured techniques for computing
1625#Data base management systems (2nd ed.)
1626#Information technologies and social transformation
1627#Programming principles using PASCAL
1628#Computer organization and assembly language programming for the PDP-11 and VAX-11
1629#Data flow computing
1630#Computer science: a mathematical introduction
1631#The computer modelling of mathematical reasoning
1632#Proc. of a discussion meeting of the Royal Society of London on Mathematical logic and programming languages
1633#The relation between logic programming and logic specification
1634#Functional programs as executable specifications
1635#Mechanical proofs about computer programs
1636#The use of machines to assist in rigorous proof
1637#The characterization problem for Hoare logics
1638#Deductive learning
1639#Programs are predicates
1640#Invariance and non-determinacy
1641#Constructive mathematics and computer programming
1642#Selected and updated papers from the proceedings of the 1982 European conference on Progress in artificial intelligence
1643#Inferring (mal) rules from pupils' protocols
1644#Naive algorithm design techniques—a case study
1645#Strategy acquisition governed by experimentation
1646#Logic as a computer language in education
1647#Special-purpose, but domain-independent, inference mechanisms
1648#Multiprocessing and duality in intelligence
1649#The implementation of UNIFORM—a knowledge-representation/programming language based upon equivalence of descriptions
1650#Constraints as consultants
1651#Constuction of a model for reasoning by analogy
1652#Toward computational models of emotion
1653#Conceptual analysis of partial metaphor
1654#A programming environment for the development of complex systems
1655#In defence of programming language design
1656#Artificial intelligence and industry
1657#An expert system for speech decoding
1658#Symbolic derivation of chess patterns
1659#Schemata for understanding of argumentation in newspaper texts
1660#Generating summaries using a script-based language analyser
1661#Looking at learning
1662#Online assessment of the value of information for searchers of a bibliographic data base
1663#Subjective trial of the performance of the information trace method
1664#Phrase structure rewrite systems in information retrieval
1665#A common interface for accessing document retrieval systems and dbms for retrieval of bibliographic data
1666#Simulation on three sizes of computers—an evaluation
1667#A CPM analysis of microbiology computerization project for hospital management information processing
1668#What non-programmers know about programming: natural language procedure specification
1669#The effect of microcomputer presentation and response medium on digit span
1670#Metaphor, computing systems, and active learning
1671#Combining functions for certainty degrees in consulting systems
1672#An empirical investigation into problem decomposition strategies used in program design
1673#Man-machine interface issues in the construction and use of an expert system
1674#A workstation assessor for crew operations-WOSTAS
1675#Efficient algorithms for combinatorial problems on graphs with bounded, decomposability—a survey
1676#The nature of data—from measurements to systems
1677#Automated theorem proving methods
1678#Significant improvements to the Ford-Johnson algorithm for sorting
1679#The power of geometric duality
1680#A language-driven generalized numerical database translator
1681#Analysis of the performance of the parallel Quicksort method
1682#Approximate counting: a detailed analysis
1683#On search by address computation
1684#A backtracking method for constructing perfect hash functions from a set of mapping functions
1685#Science of Computer Programming - Ellis Horwood series in artificial intelligence
1686#Showing programs on a screen
1687#Verifying the unification algorithm in LCF
1688#Top-down design and the algebra of communicating processes
1689#The use of microcomputers in accounting
1690#Office workstations in the home
1691#Videotex/teletext principles & practices
1692#The principles of computer organization
1693#Linear programming: active set analysis and computer programs
1694#Introduction to data structures
1695#Learning to solve problems by searching for macro-operators
1696#A critiquing approach to expert computer advice: Attending
1697#Searching with probabilities
1698#Knowledge-based interpretation of outdoor natural color scenes
1699#Nondeterministic dependencies in relations: an extention of the concept of functional dependency
1700#Modeling and integrating procedures in office information systems design
1701#GRDB: A general purpose relational database system
1702#DATAID-1: a database design methodology
1703#Design criteria for functional data bases
1704#Semantic and pragmatic processing in FIDO: a flexible interface for data-base operations
1705#The design of Apple—a language for modular programs
1706#A programming language engineered for beginners
1707#Modeling the ADA task system by Petri nets
1708#Program testing by specification mutation
1709#Knowledge-intensive rather than labor-intensive processes are being advanced to spur programming productivity.
1710#Models of large and complex systems can often be reduced to smaller sub-models, for easier analysis, by a process known as decomposition. Certain criteria for successful decompositions can be established.
1711#Both static and dynamic Huffman coding techniques are applied to test data consisting of 530 source programs in four different languages. The results indicate that, for small files, a savings of 22-91 percent in compression can be achieved by using the static instead of dynamic techniques.
1712#A display-screen management system for user interaction with an arbitrary application program is simple enough so that the end user controls the dialogue and screens yet powerful enough to provide for user specification of screen geometry, input constraints, computation facilities, and display logic—quite independently of the application system.
1713#A voice interactive natural language system, which allows users to solve problems with spoken English commands, has been constructed. The system utilizes a commercially available discrete speech recognizer which requires that each word be followed by approximately a 300 millisecond pause. In a test of the system, subjects were able to learn its use after about two hours of training. The system correctly processed about 77 percent of the over 6000 input sentences spoken in problem-solving sessions. Subjects spoke at the rate of about three sentences per minute and were able to effectively use the system to complete the given tasks. Subjects found the system relatively easy to learn and use, and gave a generally positive report of their experience.
1714#Randomized protocols for signing contracts, certified mail, and flipping a coin are presented. The protocols use a 1-out-of-2 oblivious transfer subprotocol which is axiomatically defined.The 1-out-of-2 oblivious transfer allows one party to transfer exactly one secret, out of two recognizable secrets, to his counterpart. The first (second) secret is received with probability one half, while the sender is ignorant of which secret has been received.An implementation of the 1-out-of-2 oblivious transfer, using any public key cryptosystem, is presented.
1715#Heuristic reasoning about uncertainty: an artificial intelligence approach
1716#Analysis of grid file algorithms
1717#A parallel algorithm for the monadic unification problem
1718#A language for linking modules into systems
1719#Multiple inheritance in simula-like languages
1720#Optimum allocation of places to students in a national university system
1721#In a nonnegative edge-weighted network, the weight of an edge represents the effort required by an attacker to destroy the edge, and the attacker derives a benefit for each new component created by destroying edges. The attacker may want to minimize over subsets of edges the difference between (or the ratio of) the effort incurred and the benefit received. This idea leads to the definition of the “strength” of the network, a measure of the resistance of the network to such attacks. Efficient algorithms for the optimal attack problem, the problem of computing the strength, and the problem of finding a minimum cost “reinforcement” to achieve a desired strength are given. These problems are also solved for a different model, in which the attacker wants to separate vertices from a fixed central vertex.
1722#This paper reports several properties of heuristic best-first search strategies whose scoring functions ƒ depend on all the information available from each candidate path, not merely on the current cost g and the estimated completion cost h. It is shown that several known properties of A* retain their form (with the minmax of f playing the role of the optimal cost), which helps establish general tests of admissibility and general conditions for node expansion for these strategies. On the basis of this framework the computational optimality of A*, in the sense of never expanding a node that can be skipped by some other algorithm having access to the same heuristic information that A* uses, is examined. A hierarchy of four optimality types is defined and three classes of algorithms and four domains of problem instances are considered. Computational performances relative to these algorithms and domains are appraised. For each class-domain combination, we then identify the strongest type of optimality that exists and the algorithm for achieving it. The main results of this paper relate to the class of algorithms that, like A*, return optimal solutions (i.e., admissible) when all cost estimates are optimistic (i.e., h ≤ h*). On this class, A* is shown to be not optimal and it is also shown that no optimal algorithm exists, but if the performance tests are confirmed to cases in which the estimates are also consistent, then A* is indeed optimal. Additionally, A* is also shown to be optimal over a subset of the latter class containing all best-first algorithms that are guided by path-dependent evaluation functions.
1723#A new performance model for dynamic locking is proposed. It is based on a flow diagram and uses only the steady state average values of the variables. It is general enough to handle nonuniform access, shared locks, static locking, multiple transaction classes, and transactions of indeterminate length. The analysis is restricted to the case in which all conflicts are resolved by restarts. It has been shown elsewhere that, under certain conditions, this pure restart policy is as good as, if not better than, a policy that uses both blocking and restarts.The analysis is straightforward, and the computational complexity of the solution, given some nonrestrictive approximations, does not depend on the input parameters. The solution is also well defined and well behaved. The model's predictions agree well with simulation results.The model shows that data contention can cause the throughput to thrash, and gives a limit on the workload that will prevent this. It also shows that systems with a particular kind of nonuniform access and systems in which transactions share locks are equivalent to systems in which there is uniform access and only exclusive locking. Static locking has higher throughput, but longer response time, than dynamic locking. Replacing updates by queries in a multiprogramming mix may degrade performance if the queries are longer than the updates.
1724#An analysis of structured flowcharts is presented, where size is measured by the number, n, of decision nodes (IF-THEN-ELSE and DO-WHILE nodes). For all classes of structured flowcharts considered, the number of charts is approximately, cn-3/2&ggr;n, for large n, where cand &ggr; are parameters that depend on the class. It is also shown that most large flowcharts consist of a short sequence of basic charts (IF-THEN-ELSE and DO-WHILE charts). The average length of such sequences is 2.5.
1725#The one-dimensional on-line bin-packing problem is considered, A simple O(1)-space and O(n)-time algorithm, called HARMONICM, is presented. It is shown that this algorithm can achieve a worst-case performance ratio of less than 1.692, which is better than that of the O(n)-space and O(n log n)-time algorithm FIRST FIT. Also shown is that 1.691 … is a lower bound for all 0(1)-space on-line bin-packing algorithms. Finally a revised version of HARMONICM , an O(n)-space and O(n)- time algorithm, is presented and is shown to have a worst-case performance ratio of less than 1.636.d
1726#A new model of computation for VLSI, based on the assumption that time for propagating information is at least linear in the distance, is proposed. While accommodating for basic laws of physics, the model is designed to be general and technology independent. Thus, from a complexity viewpoint, it is especially suited for deriving lower bounds and trade-offs. New results for a number of problems, including fan-in, transitive functions, matrix multiplication, and sorting are presented. As regards upper bounds, it must be noted that, because of communication costs, the model clearly favors regular and pipelined architectures (e.g., systolic arrays).
1727#The splay tree, a self-adjusting form of binary search tree, is developed and analyzed. The binary search tree is a data structure for representing tables and lists so that accessing, inserting, and deleting items is easy. On an n-node splay tree, all the standard search tree operations have an amortized time bound of O(log n) per operation, where by “amortized time” is meant the time per operation averaged over a worst-case sequence of operations. Thus splay trees are as efficient as balanced trees when total running time is the measure of interest. In addition, for sufficiently long access sequences, splay trees are as efficient, to within a constant factor, as static optimum search trees. The efficiency of splay trees comes not from an explicit structural constraint, as with balanced trees, but from applying a simple restructuring heuristic, called splaying, whenever the tree is accessed. Extensions of splaying give simplified forms of two other data structures: lexicographic or multidimensional search trees and link/cut trees.
1728#It was conjectured by J. Ullman that uniform hashing is optimal in its expected retrieval cost among all open-address hashing schemes [4]. In this paper, we show that, for any open-address hashing scheme, the expected cost of retrieving a record from a large table that is &agr;-fraction full is at least (1/&agr;) log (1/(1 - &agr;)) + o(1). This proves Ullman's conjecture to be true in the asymptotic sense.
1729#The complexity of satisfiability and determination of truth in a particular finite structure are considered for different propositional linear temporal logics. It is shown that these problems are NP-complete for the logic with F and are PSPACE-complete for the logics with F, X, with U, with U, S, X operators and for the extended logic with regular operators given by Wolper.
1730#This work generalizes decision trees in order to study lower bounds on the running times of algorithms that allow probabilistic, nondeterministic, or alternating control. It is shown that decision trees that are allowed internal randomization (at the expense of introducing a small probability of error) run no faster asymptotically than ordinary decision trees for a collection of natural problems. Two geometric techniques from the literature for proving lower bounds on the time required by ordinary decision trees are shown to be special cases of one unified technique that, in fact, applies to nondeterministic decision trees as well. Finally, it is shown that any lower bound on alternating decision tree time also applies to alternating Turing machine time.
1731#A database is said to allow range restrictions if one may request that only records with some specified field in a specified range be considered when answering a given query. A transformation is presented that enables range restrictions to be added to an arbitrary dynamic data structure on n elements, provided that the problem satisfies a certain decomposability condition and that one is willing to allow increases by a factor of O(log n) in the worst-case time for an operation and in the space used. This is a generalization of a known transformation that works for static structures. This transformation is then used to produce a data structure for range queries in k dimensions with worst-case times of O(logk n) for each insertion, deletion, or query operation.
1732#Design and analysis of distributed real-time systems
1733#Modern programming using REXX
1734#Operating systems: structures and mechanisms
1735#A survey of verification techniques for parallel programs
1736#On the complexity of some multi-attribute file design problems
1737#Design of a virtual database
1738#On the automatic generation of optimal internal schemata
1739#Data base design with the constrained multiple attribute tree
1740#Property of separability in physical design of network model databases
1741#A straightforward formalization of the relational model
1742#A formal framework for describing and classifying semantic data models
1743#A framework for application systems engineering
1744#A query language allowing conditions of relational type in queries
1745#We study restricted classes of B-trees, called H(&bgr;, &ggr;, &dgr;) trees. A class is defined by three parameters: &bgr;, the size of a node; &ggr;, the minimal number of grandsons a node must have; and &dgr;, the minimal number of leaves bottom nodes must have. This generalizes the brother condition of 2-3 brother trees in a uniform way to B-trees of higher order. The class of B-trees of order m is obtained by choosing &bgr; = m, &ggr; = (m/2)2 and &dgr; = m/2. An algorithm to construct H-trees for any given number of keys is given in Section 1. Insertion and deletion algorithms are given in Section 2. The costs of these algorithms increase smoothly as the parameters are increased. Furthermore, it is proved that the insertion can be done in time O(&bgr; + log N), where N is the number of nodes in the tree. Deletion can also be accomplished without reconstructing the entire tree. Properties of H-trees are given in Section 3. It is shown that the height of H-trees decreases as &ggr; increases, and the storage utilization increases significantly as &dgr; increases. Finally, comparisons with other restricted classes of B-trees are given in Section 4 to show the attractiveness of H-trees.
1746#Galileo, a programming language for database applications, is presented. Galileo is a strongly-typed, interactive programming language designed specifically to support semantic data model features (classification, aggregation, and specialization), as well as the abstraction mechanisms of modern programming languages (types, abstract types, and modularization). The main contributions of Galileo are (a) a flexible type system to model database structure and semantic integrity constraints; (b) the inclusion of type hierarchies to support the specialization abstraction mechanisms of semantic data models; (c) a modularization mechanism to structure data and operations into interrelated units (d) the integration of abstraction mechanisms into an expression-based language that allows interactive use of the database without resorting to a new stand-alone query language.Galileo will be used in the immediate future as a tool for database design and, in the long term, as a high-level interface for DBMSs.
1747#We propose a new class of schedulers, called cautious schedulers, that grant an input request if it will not necessitate any rollback in the future. In particular, we investigate cautious WRW-schedulers that output schedules in class WRW only. Class WRW consists of all schedules that are serializable, while preserving the write-read and read-write conflict, and is the largest polynomially recognizable subclass of serializable schedules currently known. It is shown, in this paper however, that cautious WRW-scheduling is, in general, NP-complete. Therefore, we introduce a special type (type 1R) of transaction, which consists of no more than one read step (an indivisible set of read operations) followed by multiple write steps. It is shown that cautious WRW-scheduling can be performed efficiently if all transactions are of type 1R and if admission control can be exercised. Admission control rejects a transaction unless its first request is immediately grantable.
1748#An algorithm for record clustering is presented. It is capable of detecting sudden changes in users' access patterns and then suggesting an appropriate assignment of records to blocks. It is conceptually simple, highly intuitive, does not need to classify queries into types, and avoids collecting individual query statistics. Experimental results indicate that it converges rapidly; its performance is about 50 percent better than that of the total sort method, and about 100 percent better than that of randomly assigning records to blocks.
1749#We introduce the notion of an I/O interface for optical digital (write-once) disks, which is quite different from earlier research. The purpose of an I/O interface is to allow existing operating systems and application programs that use magnetic disks to use optical disks instead, with minimal change. We define what it means for an I/O interface to be disk-efficient. We demonstrate a practical disk- efficient I/O interface and show that its I/O performance in many cases is optimum, up to a constant factor, among all disk-efficient interfaces. The interface is most effective for applications that are not update-intensive. An additional capability is a built-in history mechanism that provides software support for accessing previous versions of records. Even if not implemented, the I/O interface can be used as a programming tool to develop efficient special purpose applications for use with optical disks.
1750#In this paper, cost formulas are derived for the updates of data and indexes in a relational database. The costs depend on the data scan type and the predicates involved in the update statements. We show that update costs have a considerable influence, both in the context of the physical database design problem and in access path selection in query optimization for relational DBMSs.
1751#We describe a prototype electronic encyclopedia implemented on a powerful personal computer, in which user interface, media presentation, and knowledge representation techniques are applied to improving access to a knowledge resource. In itself, an electronic encyclopedia is an important information resource, but this work also illustrates the issues and approaches for many types of electronic information retrieval environments. In the prototype we make dynamic use of the structure and semantics of the text articles and index of an existing encyclopedia, while experimenting with other forms of representation, such as simulation and videodisc images. We present a long-term vision of an intelligent user-interface agent; summarize previous work related to futuristic encyclopedias, electronic books, decision support systems, and knowledge libraries; and outline current and potential research directions.
1752#Local area networks are becoming widely used as the database communication framework for sophisticated information systems. Databases can be distributed among stations on a network to achieve the advantages of performance, reliability, availability, and modularity. Efficient distributed query optimization algorithms are presented here for two types of local area networks: address ring networks and broadcast networks. Optimal algorithms are designed for simple queries. Optimization principles from these algorithms guide the development of effective heuristic algorithms for general queries on both types of networks. Several examples illustrate distributed query processing on local area networks.
1753#Nine participants used a full-screen computer text editor (XEDIT) with an IBM 3277 terminal to edit marked-up documents at each of three cursor speeds (3.3, 4.7, and 11.0 cm/s). These speeds occur when a user continuously holds down an arrow key to move the cursor more than one character position (i.e., in repeat or typamatic mode). Results show that cursor speed did not seem to act as a pacing device for the entire editing task. Since cursor speed is a form of system response, this finding is in contrast with the generally found positive relation between system-response time and user-response time. Participants preferred the Fast cursor speed, however. Overall, more than one-third of all keystrokes were used to move the cursor. We estimate that 9-14 percent of editing time was spent controlling and moving the cursor, regardless of cursor speed.
1754#Manufacturers of integrated electronic office systems have included electronic versions of the calendar in almost every system they offer. This paper describes a survey of office workers, carried out to examine their use both of paper calendars and of electronic calendars that are commercially available as part of integrated office systems. It assesses the degree to which electronic calendars meet the needs of users. Our survey shows that the simple paper calendar is a tool whose power and flexibility is matched by few, if any, of the current commercially available electronic calendars. Recommendations for features that should be included in electronic calendars and automatic schedulers are included.
1755#A model and methodology for describing the information objects in an office information system and how such objects flow among the components of such a system are presented. The model and methodology support the specification of information objects at multiple levels of abstraction. An interactive prototype design tool based on the methodology and model has been designed and experimentally implemented.
1756#Pushdown automata for user interface management
1757#File servers for network-based distributed systems
1758#Distributed query processing
1759#Ray tracing objects defined by sweeping planar cubic splines
1760#Proc. of an international conference on Research and development in information retrieval
1761#Simulation of bibliographic retrieval databases using hyperterms
1762#Application of SQL/N to the attribute-relation associations implicit in functional dependencies
1763#Artificial intelligence: concepts, techniques and applications
1764#Buying payroll software
1765#Buying financial accounting software
1766#Maintenance programming: improved productivity through motivation
1767#Learning to program
1768#LUCID, the dataflow programming language
1769#Introducing artificial intelligence
1770#Imaging the earth's interior
1771#The knowledge machine: artificial intelligence and the future of man
1772#Mapping situations within a system development project
1773#Decision support systems and expert systems: a comparison
1774#Structured systems analysis using SPSL/SPSA
1775#Investigating the buying process for the introduction of data processing in small and medium-sized firms
1776#Unless computer-mediated communication systems are structured, users will be overloaded with information. But structure should be imposed by individuals and user groups according to their needs and abilities, rather than through general software features.
1777#Strategic Computing, a 10-year initiative to build faster and more intelligent systems, is ambitious, flawed by overscheduling perhaps and problems of definition, but basically sound.
1778#A whole-system designer, fire fighter, mediator, and jack-of-all-trades, the system architect brings unity and continuity to a development project—offsetting the inevitable compartmentalization of modern modular designs.
1779#An examination of the respective advantages and disadvantages of three characteristic paradigms of design and implementation in Ada illustrates the importance of choosing the appropriate paradigm for a given set of circumstances.
1780#This article tests two competing theories of system development referred to here as environmental and institutional models. These models form the basis for most explanations of why systems are developed and utilized. We will examine both models in detail and apply them to a single set of data concerned with the emerging national computerized criminal history system (CCH). A hybrid model, which combines elements of environmental and institutional approaches, is also developed and tested. A substantive result of this new model will alter our understanding of why a national CCH system is being developed. At the theoretical level, we conclude that a hybrid model is more powerful than either an environmental or an institutional model taken separately and that future research must take this into account.
1781#The transient probabilistic structure of M/Em/1 and Em/M/1 queues initialized in an arbitrary deterministic state is derived in discrete time. Computational algorithms for obtaining the required probabilities are provided, and their application in calculating a variety of system performance measures is illustrated. The results are used to investigate the question of initializing simulations of systems such as these to promote rapid convergence to steady state, if that is the object of the simulation. These results are consistent with earlier studies for transient queueing systems, such as the M/M/s, but allow greater flexibility in specification of interarrival or service-time models inherent in the Erlang distributions.
1782#Algorithms are described and analyzed for the efficient evaluation of the primitive operators of a relational algebra on a database machine architecture. The architecture contains a RAM divided up into partitions, each partition having a separate server. Tuples from the first operand relation are stored in linked lists in the partitioned RAM via bit and pointer arrays based on hashed column values. Each tuple in the second operand relation is either deposited in the corresponding partition server queue based on the hashed value, or it is ignored. Cross-referencing involved in the operations is removed without performing a sorting operation, which significantly reduces the time complexity. A procedure is also presented for computing the optimal number of partition servers for different applications.
1783#In order to remain tractable, mhany reliability models do not include the states and transitions necessary to represent fault/error-handling details. Instead, the effectiveness of fault/ error-handling mechanisms is represented by the use of instantaneous coverage probabilities. This paper investigates the effect of the error introduced by the assumption of instantaneous coverage probabilities on the predictions of the reliability model, and it shows that the reliability estimates thus obtained are lower bounds on the reliability estimates of the composite model with embedded fault/error-handling states and transitions. The paper also discusses the choice of the calculation method for the instantaneous coverage probabilities and defines a near-coincident-fault coverage model that yields conservative instantaneous coverage probabilities.
1784#A computer system is modeled by an exponential queueing network with different classes of customers and a general class of service policies. The mean cost per unit time is taken as the loss function. Three lower bounds of the loss function under the whole class of service policies, as well as an upper bound of the minimal loss, are derived. The loss function is expressed in a convenient form from which we derive a simple heuristic service policy so called "Klimov policy." This policy is applied to several examples of computer systems and is evaluated by the bounds. The examples recommend using "Klimov policy" in any case; so we have a first rule for deciding how to provide service capacity to different customers in a network of queues.
1785#Two conversion techniques based on the Chinese remainder theorem are developed for use in residue number systems. The new implementations are fast and simple mainly because adders modulo a large and arbitrary integer M are effectively replaced by binary adders and possibly a lookup table of small address space. Although different in form, both techniques share the same principle that an appropriate representation of the summands must be employed in order to evaluate a sum modulo M efficiently. The first technique reduces the sum modulo M in the conversion formula to a sum modulo 2 through the use of fractional representation, which also exposes the sign bit of numbers. Thus, this technique is particularly useful for sign detection and for any operation requiring a comparison with a binary fraction of M. The other technique is preferable for the full conversion from residues to unsigned or 2's complement integers. By expressing the summands in terms of quotients and remainders with respect to a properly chosen divisor, the second technique systematically replaces the sum modulo M by two binary sums, one accumulating the quotients modulo a power of 2 and the other accumulating the remainders the ordinary way. A final recombination step is required but is easily implemented with a small lookup table and binary adders.
1786#This paper is concerned with some of the issues arising in the development of a domain-independent English interface to IBM SQL-based program products. The TQA system falls into the class of multilayered natural language processing systems. As a result, there is a large number of potential points at which customization to a particular database can be done. Of these, we discuss procedures that affect the reader, the lexicon, the lowest level of grammar rules, the semantic interpreter, and the output formatter. Our tests lead us to believe that the approach we are taking will make it possible for database administrators to generate robust English interfaces to particular databases without help from linguistic experts.
1787#Program transformations are frequently performed by optimizing compilers, and the correctness of applying them usually depends on data flow information. For language-to-same-language transformations, it is shown how a denotational setting can be useful for validating such program transformations.Strong equivalence is obtained for transformations that exploit information from a class of forward data flow analyses, whereas only weak equivalence is obtained for transformations that exploit information from a class of backward data flow analyses. To obtain strong equivalence, both the original and the transformed program must be data flow analysed, but consideration of a transformation-exploiting liveness of variables indicates that a more satisfactory approach may be possible.
1788#Computer-aided data analysis: a practical guide
1789#Computer graphics: a survey of current techniques and applications
1790#The art of managing software development people
1791#Communicating sequential processes
1792#Advanced UCSD PASCAL programming techniques
1793#Business in the age of information
1794#How to write simulations using microcomputers
1795#The design and analysis of VLSI circuits
1796#Commercial software engineering for productive program design
1797#Programming expert systems in OPS5: an introduction to rule-based programming
1798#Principles of CMOS VLSI design: a systems perspective
1799#A generalised mathematical theory of structured programming
1800#Complexity and decidability for chain code picture languages
1801#Fast algorithms constructing minimal subalgebras, congruences, and ideals in a finite algebra
1802#A classification of &ohgr;-regular languages
1803#Bounded-depth, polynomial-size circuits for symmetric functions
1804#DAL—a logic for data analysis
1805#The complexity of finding minimum-length generator sequences
1806#Alternating simple multihead finite automata
1807#Fast algorithms for the characteristic polynomial
1808#Natural language query processing in a temporal database
1809#Expressiveness and language choice
1810#The category concept: an extension to the entity-relationship model
1811#An efficient incremental LR parser for grammars with epsilon productions
1812#Computing in the home: a research paradigm
1813#Gender equity in computer learning environments
1814#Relational data base structures and concept formation in the social sciences
1815#Bayesian reliability evaluation of computer systems
1816#Hybrid reliability modeling of fault-tolerant computer systems
1817#On “O1-Class” computer programs
1818#A methodology for assessing the correctness of control programs
1819#Software reliability—theory and practice
1820#A new approach to program verification
1821#Analytic models based on closed queuing networks (CQNS) are widely used for performance prediction in practical systems. In using such models, there is always a prediction error, that is, a difference between the predicted performance and the actual outcome. This prediction error is due both to modeling errors and estimation errors, the latter being the difference between the estimated values of the CQN parameters and the actual outcomes. This paper considers the second class of errors; in particular, it studies the effect of small estimation errors and provides bounds on prediction errors based on bounds on estimation errors. Estimation errors may be divided into two types: (1) the difference between the estimated value and the average value of the outcome, and (2) the deviation of the actual value from its average. The analysis first studies the sum of both types of errors, then the second type alone. The results are illustrated with three examples.
1822#The current trend of computer system technology is toward CPUs with rapidly increasing processing power and toward disk drives of rapidly increasing density, but with disk performance increasing very slowly if at all. The implication of these trends is that at some point the processing power of computer systems will be limited by the throughput of the input/output (I/O) system.A solution to this problem, which is described and evaluated in this paper, is disk cache. The idea is to buffer recently used portions of the disk address space in electronic storage. Empirically, it is shown that a large (e.g., 80-90 percent) fraction of all I/O requests are captured by a cache of an 8-Mbyte order-of-magnitude size for our workload sample. This paper considers a number of design parameters for such a cache (called cache disk or disk cache), including those that can be examined experimentally (cache location, cache size, migration algorithms, block sizes, etc.) and others (access time, bandwidth, multipathing, technology, consistency, error recovery, etc.) for which we have no relevant data or experiments. Consideration is given to both caches located in the I/O system, as with the storage controller, and those located in the CPU main memory. Experimental results are based on extensive trace-driven simulations using traces taken from three large IBM or IBM-compatible mainframe data processing installations. We find that disk cache is a powerful means of extending the performance limits of high-end computer systems.
1823#Optimistic Recovery is a new technique supporting application-independent transparent recovery from processor failures in distributed systems. In optimistic recovery communication, computation and checkpointing proceed asynchronously. Synchronization is replaced by causal dependency tracking, which enables a posteriori reconstruction of a consistent distributed system state following a failure using process rollback and message replay.Because there is no synchronization among computation, communication, and checkpointing, optimistic recovery can tolerate the failure of an arbitrary number of processors and yields better throughput and response time than other general recovery techniques whenever failures are infrequent.
1824#MODULA-2 programming
1825#Programming in MODULA-2 (3rd corrected ed.)
1826#Machine-independent organic software tools (MINT) (2nd revised ed.)
1827#Computer: a challenge for business administration
1828#PasRo: PASCAL for robots
1829#Writing user-usable manuals: a practical guide to preparing user-friendly computer hardware and software documentation
1830#In Part I, Markov chains were shown to be associated with solutions to several standard problems in computer-aided geometric design. Constraints on these Markov chains were also derived. Examples are given here of Markov chains that either satisfy some of these constraints or solve one of these problems. Subdivision matrices are also studied in special detail.
1831#Quadtree representation of two-dimensional objects is performed with a tree that describes the recursive subdivision of the more complex parts of a picture until the desired resolution is reached. At the end, all the leaves of the tree are square cells that lie completely inside or outside the object. There are two great disadvantages in the use of quadtrees as a representation scheme for objects in geometric modeling system: The amount of memory required for polygonal objects is too great, and it is difficult to recompute the boundary representation of the object after some Boolean operations have been performed. In the present paper a new class of quadtrees, in which nodes may contain zero or one edge, is introduced. By using these quadtrees, storage requirements are reduced and it is possible to obtain the exact backward conversion to boundary representation. Algorithms for the generation of the quadtree, Boolean operations, and recomputation of the boundary representation are presented, and their complexities in time and space are discussed. Three-dimensional algorithms working on octrees are also presented. Their use in the geometric modeling of three-dimensional polyhedral objects is discussed.
1832#Two incremental linear interpolation algorithms are derived and analyzed for speed and accuracy. The first is a version of a “simple” digital differential analyzer (DDA) employing fixed-point arithmetic, whereas the second is a new algorithm that uses only integral arithmetic and is a generalization of Bresenham's line-drawing algorithm. The new algorithm is shown to achieve perfect accuracy and, depending on the underlying processor, may be faster than the fixed-point algorithm.
1833#Markov chains and computer-aided geometric design: part I - problems and constraints
1834#We examine methods of implementing queries about relational databases in the case where these queries are expressed in first-order logic as a collection of Horn clauses. Because queries may be defined recursively, straightforward methods of query evaluation do not always work, and a variety of strategies have been proposed to handle subsets of recursive queries. We express such query evaluation techniques as “capture rules” on a graph representing clauses and predicates. One essential property of capture rules is that they can be applied independently, thus providing a clean interface for query-evaluation systems that use several different strategies in different situations. Another is that there be an efficient test for the applicability of a given rule. We define basic capture rules corresponding to application of operators from relational algebra, a top-down capture rule corresponding to “backward chaining,” that is, repeated resolution of goals, a bottom-up rule, corresponding to “forward chaining,” where we attempt to deduce all true facts in a given class, and a “sideways” rule that allows us to pass results from one goal to another.
1835#We discuss a recently launched, long-term project in natural language processing, the primary concern of which is that natural language applications be transportable among human languages. In particular, we seek to develop system tools and linguistic processing techniques that are themselves language-independent to the maximum extent practical. In this paper we discuss our project goals and outline our intended approach, address some cross-linguistic requirements, and then present some new linguistic data that we feel support our approach.
1836#This paper presents a discussion of the techniques developed and problems encountered during the design, implementation, and experimental use of a portable natural language processor. Datalog (for “database dialogue") is an experimental natural language query system, which was designed to achieve a maximum degree of portability and extendibility. Datalog uses a three-level architecture to provide both portability of syntax to new and extended tasks and portability of semantics to new database applications. The implementation of each of the three levels, the structures and conventions that control the interactions among them, and the way in which different aspects of the design contribute to portability are described. Finally, two specific, implemented examples are presented, showing how it was possible to transport or extend Datalog by changing only one “layer” of the system's knowledge and achieve correct processing of the extended input by the entire system.
1837#This paper is a discussion of the technical issues and solutions encountered in making the ASK System transportable. A natural language system can be “transportable” in a number of ways. Although transportability to a new domain is most prominent, other ways are also important if the system is to have viability in the commercial marketplace.On the one hand, transporting a system to a new domain may start with the system prior to adding any domain of knowledge and extend it to incorporate the new domain. On the other hand, one may wish to add to a system that already has knowledge of one domain the knowledge concerning a second domain, that is, to extend the system to cover this second domain. In the context of ASK, it has been natural to implement extending and then achieve transportability as a special case.In this paper, we consider six ways in which the ASK System can be extended to include new capabilities:to a new domain,to a new object type,to access data from a foreign database,to a new natural language,to a new programming language,to a new computer family.Special-purpose applications, such as those to accommodate standard office tasks, would make use of these various means of extension.
1838#The Linguistic String Project (LSP) natural language processing system has been developed as a domain-independent natural language processing system. Initially utilized for processing sets of medical messages and other texts in the medical domain, it has been used at the Naval Research Laboratory for processing Navy messages about shipboard equipment failures. This paper describes the structure of the LSP system and the features that make it transportable from one domain to another. The processing procedures encourage the isolation of domain-specific information, yet take advantage of the syntactic and semantic similarities between the medical and Navy domains. From our experience in transporting the LSP system, we identify the features that are required for transportable natural language systems.
1839#PRE (Purposefully Restricted English) is a restricted English database query language whose implementation has addressed engineering goals, namely, habitability, interapplication transportability, performance, and use with a reliable database management system that supports large numbers of concurrent users and large databases. Habitability has not been demonstrated, but initial indications are encouraging. The other goals have clearly been achieved. The existence of the PRE system demonstrates that an explicitly “minimalist” approach to natural language processing can facilitate achievement of transportability.
1840#Our goal is to develop formal methods for abstracting a given set of programs into a program schemaand for instantiating a given schema to satisfy concrete specifications. Abstraction and instantiationare two important phases in software development which allow programmers to apply knowledgelearned in the solutions of past problems when faced with new situations. For example, from twoprograms using a linear (or binary) search technique, an abstract schema can be derived that embodiesthe shared idea and that can be instantiated to solve similar new problems. Along similar lines, thedevelopment and application of program transformations are considered.We suggest the formulation of analogies as a basic tool in program abstraction. An analogy is firstsought between the specifications of the given programs; this yields an abstract specification thatmay be instantiated to any of the given concrete specifications. The analogy is then used as a basisfor transforming the existing programs into an abstract schema that represents the embeddedtechnique, with the invariant assertions and correctness proofs of the given programs helping toverify and complete the analogy. A given concrete specification of a new problem may then becompared with the abstract specification of the schema to suggest an instantiation of the schemathat yields a correct program.
1841#An important goal of programming language research is to isolate the fundamenal concepts of languages, those basic ideas that allow us to understand the relationships among various language features. This paper examines one of these underlying notions, that of data type, with particular attention to the treatment of generic or polymorphic procedures and static type-checking.
1842#Virtual time is a new paradigm for organizing and synchronizing distributed systems which can be applied to such problems as distributed discrete event simulation and distributed database concurrency control. Virtual time provides a flexible abstraction of real time in much the same way that virtual memory provides an abstraction of real memory. It is implemented using the Time Warp mechanism, a synchronization protocol distinguished by its reliance on lookahead-rollback, and by its implementation of rollback via antimessages.
1843#In this paper we outline an approach to describing and analyzing designs for distributed software systems. A descriptive notation is introduced, and analysis techniques applicable to designs expressed in that notation are presented. The usefulness of the approach is illustrated by applying it to a realistic distributed software-system design problem involving mutual exclusion in a computer network.
1844#Reduced instruction set computer architectures for VLSI
1845#The cognitive computer: on language, learning, and artificial intelligence
1846#Designing with microprocessors
1847#Applied discrete structures for computer science
1848#Processor organization and microprogramming: a project case study
1849#Applied database logic. Volume I: fundamental database issues
1850#Effective FORTRAN 77
1851#Screen design strategies for computer-assisted instruction
1852#Model-based image matching using location
1853#Procedural operators considered as fundamental programming devices
1854#PROGRAPH: a preliminary report
1855#A portable syntax analyzer for microcomputers
1856#Deriving a compiler from an operational semantics written in VDL
1857#A blackboard architecture for control
1858#A method for managing evidential reasoning in a hierarchical hypothesis space
1859#Dynamic Huffman coding
1860#An analysis of optimum caching
1861#Pyramid computer solutions of the closest pair problem
1862#Computing the extreme distances between two convex polygons
1863#Binary tree gray codes
1864#Constructing trees with prescribed cardinalities for the components of their vertex deleted subgraphs
1865#On optimal arrangements of keys with double hashing
1866#An optimal algorithm for finding all the jumps of a monotone step-function
1867#A theoretical analysis of backtracking in the graph coloring problem
1868#This paper introduces data distortion by probability distribution, a probability distortion that involves three steps. The first step is to identify the underlying density function of the original series and to estimate the parameters of this density function. The second step is to generate a series of data from the estimated density function. And the final step is to map and replace the generated series for the original one. Because it is replaced by the distorted data set, probability distortion guards the privacy of an individual belonging to the original data set. At the same time, the probability distorted series provides asymptotically the same statistical properties as those of the original series, since both are under the same distribution. Unlike conventional point distortion, probability distortion is difficult to compromise by repeated queries, and provides a maximum exposure for statistical analysis.
1869#VLSI CAD applications deal with design objects that have an interface description and an implementation description. Versions of design objects have a common interface but differ in their implementations. A molecular object is a modeling construct which enables a database entity to be represented by two sets of heterogeneous records, one set describes the object's interface and the other describes its implementation. Thus a reasonable starting point for modeling design objects is to begin with the concept of molecular objects.In this paper, we identify modeling concepts that are fundamental to capturing the semantics of VLSI CAD design objects and versions in terms of molecular objects. A provisional set of user operations on design objects, consistent with these modeling concepts, is also defined. The modeling framework that we present has been found useful for investigating physical storage techniques and change notification problems in version control.
1870#A parser must be able to continue parsing after encountering a syntactic error to check the remainder of the input. To achieve this, it is not necessary to perform corrections on either the input text or the stack contents. A formal framework is provided in which noncorrecting syntax error recovery concepts are defined and investigated. The simplicity of these concepts allows the statement of provable properties, such as the absence of spurious error messages or the avoidance of skipping input text. These properties are due to the fact that no assumptions about the nature of the errors need be made to continue parsing.
1871#Decision making, models and algorithms: a first course
1872#The CIRRUS banking network makes coast-to-coast automatic banking transactions possible. The system will soon be able to handle international currency transactions and point-of-sale transactions in stores.
1873#ALGLIB—a library of procedures that perform analytic differentiation and other simple symbolic manipulations—has certain advantages over existing and more comprehensive packages. It can be implemented in a high-level language of the user's choice using a pseudocode available from the authors, and it is easily interfaced with the user's programs.
1874#A new simplified methodology for relational-database design overcomes the difficulties associated with nonloss decomposition. It states dependencies between data fields on a dependency list and then depicts them unambiguously as interlinked bubbles and doublebubbles on a dependency diagram. From the dependency diagram, a set of fully normalized tables is derived.
1875#In this article we develop some algorithms and tools for solving matrix problems on parallel processing computers. Operations are synchronized through data-flow alone, which makes global synchronization unnecessary and enables the algorithms to be implemented on machines with very simple operating systems and communication protocols. As examples, we present algorithms that form the main modules for solving Liapounov matrix equations. We compare this approach to wave front array processors and systolic arrays, and note its advantages in handling missized problems, in evaluating variations of algorithms or architectures, in moving algorithms from system to system, and in debugging parallel algorithms on sequential machines.
1876#Diehr and Faaland developed an algorithm that finds the minimum sum of key length pagination of a scroll of n items, and which uses O(n log n) time, solving a problem posed by McCreight. An improved algorithm is given which uses O(n) time.
1877#A graphical query language for entity-relationship databases
1878#Selected papers of the international conference on "foundations of computation theory" on Topics in the theory of computation
1879#Input driven languages are recognized in log n space
1880#Constructive mathematics as a programming logic I: some principles of theory
1881#Space and reversal complexity of probabilistic one-way Turing machines
1882#Recurring dominoes: making the highly undecidable highly understandable
1883#The logic of games and its applications
1884#A fast parallel construction of disjoint paths in networks
1885#The evolving factory of the future: integrating manufacturing and information systems
1886#Problem-solving strategies for DSS design
1887#An empirical study of users as application developers
1888#Computer usage in developing countries: case study Kuwait
1889#Information management for engineering design
1890#Synchronization of parallel programs
1891#Text generation: using discourse strategies and focus constraints to generate natural language text
1892#Databases: how to manage information on your micro
1893#Ada for multi-microprocessors
1894#Graphical evolution: an introduction to the theory of random graphs
1895#Reliable data structures in C
1896#Efficient C
1897#Model building is identified as the most important part of the analysis and design process for software systems. A set of primitives to support this process is presented, along with a formal language, MSG.84, for recording the results of analysis and design. The semantics of the notation is defined in terms of the actor formalism, which is based on a message passing paradigm. The automatic derivation of a graphical form of the specification for user review is discussed. Potentials for computer-aided design based on MSG.84 are indicated.
1898#Few examples of formal specification of the semantics of user interfaces exist in the literature. This paper presents a comparison of four axiomatic approaches which we have applied to the specification of a commercial user interface-the line editor for the Tandy PC-1 Pocket Computer. These techniques are shown to result in complete and relatively concise descriptions. A number of useful and nontrivial properties of the interface are formally deduced from one of the specifications. In addition, a direct implementation of the interface is constructed from a formal specification. Limitations of these specification examples are discussed along with future research work.
1899#Forms have become widely used as a user interface for database systems. By analyzing the components of forms, a unified treatment of aggregation operators, headings, subheadings, and internal logic of a form is possible. In this paper we present a theory and a system based on that theory which allows users to easily specify displays. Displays are composed of components and the user can specify geometry of the components and grouping relationships between the components which allow for the generation of the desired display.
1900#User Software Engineering is a methodology for the specification and implementation of interactive information systems. An early step in the methodology is the creation of a formal executable description of the user interaction with the system, based on augmented state transition diagrams. This paper shows the derivation of the USE transition diagrams based on perceived shortcomings of the "pure" state transition diagram approach. In this way, the features of the USE specification notation are gradually presented and illustrated. The paper shows both the graphical notation and the textual equivalent of the notation, and briefly describes the automated tools that support direct execution of the specification.
1901#Aesthetics in user interfaces addresses font definitions, typesetting conventions, color combinations, graphics design considerations, high resolution for viewscreens, and the shapes of windows. Computer viewscreens are evolving into pictorial media, communicating information with visual immediacy. The more interesting interfaces make use of multiple windows, menus, icons, and other visual effects to waken and sustain user interest and effectiveness. A pretty window is a viewscreen window with the dimensions of a golden rectangle, a rectangle whose width and height form the golden ratio of Euclid. Psychologists believe golden rectangles are aesthetically more pleasing than arbitrary rectangles, and subjects tend to select them in preference to other rectangles in tests.
1902#In the development of programs for novel applications, a series of design-implementation phases may be necessary in order to acquire a deeper understanding of the problem. This paper develops a feedback version development approach incorporating systematic knowledge integration techniques. Our experiences in applying these methods to various projects are also discussed.
1903#An office procedure is a structured set of office activities for accomplishing a specific office task. A unified model, called office procedure model (OPM), is presented to model office procedures. The OPM describes the relationships among messages, databases, alerters, and activities. The OPM can be used to coordinate and integrate the activities of an office procedure. The OPM also allows the specification of office protocols in an office information system. A methodology for the verification of office procedures is presented. With this methodology, potential problems in office procedure specification, such as deadlock, unspecified message reception, etc., can be analyzed effectively.
1904#When the state of a program in execution is accidentally altered, a recovery action may be needed before the execution can proceed on. Two approaches exist for the design of recovery actions: backward recovery consists of retrieving a previously saved correct state and restarting the computation; forward recovery consists of generating á (sufficiently) correct state from the current (not too) contaminated state. This paper presents a tentative framework for the study of forward error recovery and then discusses some preliminary results and some future research within the proposed framework.
1905#This paper examines the use of cluster analysis as a tool for system modularization. Several clustering techniques are discussed and used on two medium-size systems and a group of small projects. The small projects are presented because they provide examples (that will fit into a paper) of certain types of phenomena. Data bindings between the routines of the system provide the basis for the bindings. It appears that the clustering of data bindings provides a meaningful view of system modularization.
1906#The notion of a qualified function is introduced as a general means of representing the parameters of dynamic systems. Two specific types of qualified functions are defined for the analysis of the behavior and performance of structured programs. Transformation functions represent the values of variables during execution and timing algorithms express the execution times of programs symbolically. Complete rules of derivation for transformation functions and timing algorithms are given for the control mechanisms of sequence, selection, fixed loop, and while statement. Deterministic and stochastic simplification of transformation functions and timing algorithms are investigated and methods of eliminating recursion for expressions corresponding to while statements are studied.
1907#A distributed system is viewed as a set of objects and processes utilizing the objects. If a shared object, known as a resource, is accessed concurrently, some mechanism is necessary to control use of the resource in order to satisfy the consistency and fairness requirements associated with the resource. These mechanisms are termed resource controllers.
1908#A class of transformations of functional programs based on symbolic execution and simplification of conditionals is presented. The operational symbolic semantics of a family of functional languages is defined exploiting a set-theoretic notion of symbolic constants. An effective transformation able to simplify a functional program via removal of conditionals is discussed. Finally, it is shown that a structural approach, based on abstract data type specifications, provides a suitable representation for symbolic constants.
1909#This paper describes the query optimizer of the Mermaid system which provides a user with a unified view of multiple preexisting databases which may be stored under different DBMS's. The algorithm is designed for databases which may contain replicated or fragmented relations and for users who are primarily making interactive, ad hoc queries. Although the implementation of the algorithm is a front-end system, not an integrated distributed DBMS, it should be applicable to a distributed DBMS also.
1910#This paper describes a generic image processing language IPL, and a programming environment supporting the language primitives for an image information system. The central notion of IPL is that it allows the user to navigate through the image database and manipulate images using generalized icons. The image processing language IPL consists of three subsets: the logical image processing language LIPL, the interactive image processing language IIPL, and the physical image processing language PIPL. This paper presents the main concepts of this generic language, some examples, and a scenario.
1911#Numerical mathematics: theory and computer applications
1912#Optical disks and demand printing research at the Library of Congress
1913#Information for middle management decision making
1914#Citizens' rights to information: the role of government
1915#Computers and Security - Annals of discrete mathematics, 24
1916#Professional responsibility for information privacy
1917#Incorporating access control in forms systems
1918#Microcomputer security: data protection techniques
1919#The development of a specification language for a computer security system
1920#Mathematical models when simulating the behavior of physical, chemical, and biological systems often include one or more ordinary differential equations (ODEs). To study the system behavior predicted by a model, these equations are usually solved numerically.Although many of the current methods for solving ODEs were developed around the turn of the century, the past 15 years or so has been a period of intensive research. The emphasis of this survey is on the methods and techniques used in software for solving ODEs.ODEs can be classified as stiff or nonstiff, and may be stiff for some parts of an interval and nonstiff for others. We discuss stiff equations, why they are difficult to solve, and methods and software for solving both nonstiff and stiff equations. We conclude this review by looking at techniques for dealing with special problems that may arise in some ODEs, for example, discontinuities.Although important theoretical developments have also taken place, we report only those developments which have directly affected the software and provide a review of this research. We present the basic concepts involved but assume that the reader has some background in numerical computing, such as a first course in numerical methods.
1921#This paper compares text retrieval methods intended for office systems. The operational requirements of the office environment are discussed, and retrieval methods from database systems and from information retrieval systems are examined. We classify these methods and examine the most interesting representatives of each class. Attempts to speed up retrieval with special purpose hardware are also presented, and issues such as approximate string matching and compression are discussed. A qualitative comparison of the examined methods is presented. The signature file method is discussed in more detail.
1922#A general-purpose computer vision system must be capable of recognizing three-dimensional (3-D) objects. This paper proposes a precise definition of the 3-D object recognition problem, discusses basic concepts associated with this problem, and reviews the relevant literature. Because range images (or depth maps) are often used as sensor input instead of intensity images, techniques for obtaining, processing, and characterizing range data are also surveyed.
1923#Software engineering concepts
1924#The algorithmic process: an introduction to problem solving
1925#The elements of graphing data
1926#Digital systems and hardware/firmware algorithms
1927#Software engineering (2nd ed.)
1928#Computer science LOGO style. Vol. I: intermediate programming
1929#A region analysis algorithm for the live variables problem
1930#Convergence of method of lines approximations to partial differential equations
1931#A major portion of the effort expended in developing commercial software today is associated with program testing. Schedule and/ or resource constraints frequently require that testing be conducted so as to uncover the greatest number of errors possible in the time allowed. In this paper we describe a study undertaken to assess the potential usefulness of various product-and process-related measures in identifying error-prone software. Our goal was to establish an empirical basis for the efficient utilization of limited testing resources using objective, measurable criteria. Through a detailed analysis of three software products and their error discovery histories, we have found simple metrics related to the amount of data and the structural complexity of programs to be of value for this purpose.
1932#In this paper, we present a translator from a relevant subset of SQL into relational algebra. The translation is syntax-directed, with translation rules associated with grammar productions; each production corresponds to a particular type of SQL subquery.
1933#The performance of transaction processing systems is determined by the contention for hardware as well as software resources (database locks), due to the concurrency control mechanism of the database being accessed by transactions. We consider a transaction processing system with a set of dominant transcation classes. Each class needs to acquire a certain subset of the locks in the database before it can be processed, i.e., predeclared lock requests with static locking. Straightforward application of the decomposition method requires the numerical solution of a two-dimensional Markov chain. Equivalently, a hierarchical simulation method, where the computer system is represented by a composite queue with exponential service rates, can be used to analyze the system. We propose an inexpensive analytic solution method, also based on hierarchical decomposition, such that the throughput of the computer system ic characterized by the number of active transactions (regardless of class). Numerical results are provided to show that the new method is adequately accurate compared to the other two rather costly methods. It can be used to determine the effect of granularity of locking on system performance. The solution method is also applicable to multiresource queueing systems with multiple contention points.
1934#SEES is a database system to support program testing. The program database is automatically created during the compilation of the program by a compiler built using the YACC compiler-compiler.
1935#This paper defines a family of program test data selection criteria derived from data flow analysis techniques similar to those used in compiler optimization. It is argued that currently used path selection criteria, which examine only the control flow of a program, are inadequate quate. Our procedure associates with each point in a program at which a variable is defined, those points at which the value is used. Several test data selection criteria, differing in the type and number of these associations, are defined and compared.
1936#In this paper, an approach to the modeling of software testing is described. A major aim of this approach is to allow the assessment of the effects of different testing (and debugging) strategies in different situations. It is shown how the techniques developed can be used to estimate, prior to the commencement of testing, the optimum allocation of test effort for software which is to be nonuniformly executed in its operational phase. In addition, the question of application of statistical models in cases where the data environment undergoes changes is discussed. Finally, two models are presented for the assessment of the effects of imperfections in the debugging process.
1937#Researchers at Bell Labs have recently developed a silicon compiler, named Plex, that automatically generates VLSI layouts of high performance and area efficient microprocessors. Plex takes as input a specification of the function to be executed and generates a complete mask-level layout of a customized microprocessor to execute that function. The Plex microprocessor interacts with the external world, via input and output wires, and interrupts. The dedicated function performed by a Plex microprocessor typically involves real-time handling of inputs and interrupts-and the real-time generation of output signals.
1938#A distributed program is a collection of several processes which execute concurrently, possibly in different nodes of a distributed system, and which cooperate with each other to realize a common goal. In this paper, we present a design of communication and synchronization primitives for distributed programs. The primitives are designed such that they can be provided by a kernel of a distributed operating system. An important feature of the design is that the configuration of a process, i.e., identities of processes with which the process communicates, is specified separately from the computation performed by the process. This permits easy configuration and reconfiguration of processes. We identify different kinds of communication failures, and provide distinct mechanisms for handling them. The communication primitives are not atomic actions. To enable the construction of atomic actions, two new program components, atomic agent and manager are introduced. These are devoid of policy decisions regarding concurrency control and atomic commitment. We introduce the notion of conflicts relation using which a designer can construct either an optimistic or a pessimistic concurrency control scheme. The design also incorporates primitives for constructing nested atomic actions.
1939#Basic graph models of processes, such as Petri nets, have usually omitted the concept of time as a parameter. Time has been added to the Petri net model in two ways. The timed Petri net (TPN) uses a fixed number of discrete time intervals. The stochastic Petri net (SPN) uses an exponentially distributed random variable. In this paper, a discrete time stochastic Petri model is described. These discrete time SPN's fill the gap between TPN and normal SPN. However, the use of discrete time complicates the SPN model in that more than one transition may fire at a time step. Finally, an example of a live and bounded Petri net which has nonempty, disjoint, recurrent subsets of markings is given.
1940#Dynamic system configuration is the ability to modify and extend a system while it is running. The facility is a requirement in large distributed systems where it may not be possible or economic to stop the entire system to allow modification to part of its hardware or software. It is also useful during production of the system to aid incremental integration of component parts, and during operation to aid system evolution. The paper introduces a model of the configuration process which permits dynamic incremental modification and extension. Using this model we determine the properties required by languages and their execution environments to support dynamic configuration. CONIC, the distributed system which has been developed at Imperial College with the specific objective of supporting dynamic configuration, is described to illustrate the feasibility of the model.
1941#on Proc. of the third British national conference on databases (BNCOD3)
1942#Application of relational database and graphics to the molecular sciences
1943#Integrating data and metadata to enhance the user interface
1944#Do embedded dependencies always lead to a wild goose chase?
1945#A diagrammer for the automatic production of entity type models
1946#An analysis of certain data models with respect to their handling of selected integrity constraints
1947#Logic as a database language
1948#HERCULES: database query using natural language fragments
1949#The construction of interfaces to triple based databases
1950#An approach to interactive definition of database views
1951#Computer graphics—computer art (2nd ed.)
1952#A guide to expert systems
1953#Computer animation: theory and practice
1954#A dictionary of word processing and printers
1955#The big score: the billion dollar story of Silicon Valley
1956#A class of communication networks which is suitable for "multiple processor systems" was studied by Pradhan and Reddy. The underlying graph (to be called Shift and Replace graph or SRG) is based on DeBruijn digraphs and is a function of two parameters r and m. Pradhan and Reddy have shown that the node-connectivity of SRG is at least r. The same authors give a routing algorithm which generally requires 2m hops if the number of node failures is =(r -1). In this paper we show that the node-connectivity of SRG is (2r - 2). This would immediately imply that the system can tolerate up to (2r - 3) node failures. We then present routing methods for situations with a certain number of node failures. When this number is =(r - 2) our routing algorithm requires at most m + 3 + logr m hops if 3 + logr m =m. When the number of node failures is =(2r - 3) our routing algorithm requires at most m + 5 + logr m hops if 4 + logr m = m. In all the other situations our routing algorithm requires no more than 2m hops. The routing algorithms are shown to be computationally efficient.
1957#A high-speed VLSI multiplication algorithm internally using redundant binary representation is proposed. In n bit binary integer multiplication, n partial products are first generated and then added up pairwise by means of a binary tree of redundant binary adders. Since parallel addition of two n-digit redundant binary numbers can be performed in a constant time independent of n without carry propagation, n bit multiplication can be performed in a time proportional to log2 n. The computation time is almost the same as that by a multiplier with a Wallace tree, in which three partial products will be converted into two, in contrast to our two-to-one conversion, and is much shorter than that by an array multiplier for longer operands. The number of computation elements of an n bit multiplier based on the algorithm is proportional to n2. It is almost the same as those of conventional ones. Furthermore, since the multiplier has a regular cellular array structure similar to an array multiplier, it is suitable for VLSI implementation. Thus, the multiplier is excellent in both computation speed and regularity in layout. It can be implemented on a VLSI chip with an area proportional to n2 log2 n. The algorithm can be directly applied to both unsigned and 2's complement binary integer multiplication.
1958#A cryptographic scheme for controlling access to information within a group of users organized in a hierarchy was proposed in [1]. The scheme enables a user at some level to compute from his own cryptographic key the keys of the users below him in the organization.
1959#This paper presents several new properties of D sequences that have applications to encryption and error coding. It also considers the problem of joint encryption and error-correction coding and proposes a solution using D sequences. The encryption operation considered is equivalent to exponentiation, which forms the basis of several public-key schemes. An application of D sequences to generating events with specified probabilities is also presented.
1960#This paper specifies procedures for defining a monitor circuit that can detect faults in microprogram sequencers. The monitor and the sequencer operate in parallel and errors are detected by comparing outputs from the monitor circuit with outputs from the sequencer. Faults that cause errors in the flow of control are detectable, as well as some faults that cause errors only in the microinstruction fields. The design procedure presented for monitors consists of four parts. First, a model of the program flow is constructed that only retains the information required to define a monitor. Second, faults in a specified fault set are modeled by the errors they cause in the program flow model. Third, the functional requirements of the monitor are specified in terms of partitions on the states of the program flow model. Fourth, the logic design of the monitor is completed.
1961#We have designed and built the Orrery, a special computer for high-speed high-precision orbital mechanics computations. On the problems the Orrery was designed to solve, it achieves approximately 10 Mflops in about 1 ft3 of space while consuming 150 W of power. The specialized parallel architecture of the Orrery, which is well matched to orbital mechanics problems, is the key to obtaining such high performance. In this paper we discuss the design, construction, and programming of the Orrery.
1962#An evaluation stack, used exclusively to store temporary values in expression evaluation, is known to be an effective mechanism in the implementation of high level languages. This work considers the efficient management of evaluation stacks for concurrent programming languages. Techniques for sharing a single evaluation stack among many processes, without copying on process switches, are developed. The best strategy for managing the evaluation stack is shown to depend strongly upon the scheduling paradigm adopted by the run-time support of the language. Simulation studies, driven by synthetic workloads, show that the techniques described in this paper exhibit substantial performance improvements over traditional temporary storage management schemes for concurrent languages.
1963#A systolic binary tree machine which can handle all the dictionary machine and priority queue operations such as Insert, Delete, Extract-Min, Extract-Max, Member, and Near is designed in this paper. The operations can be fed into the tree machine in a pipeline manner at a constant rate and the output is correspondingly generated in a pipeline manner. Each processor in the machine stores at most one data element, which consists of a key value and a record associated with the key. The machine has optimal performance since if the number of data elements present in the tree is n, then each operation takes O(log n) steps. Unlike some recent designs, this machine does not use any links other than the binary tree links, provides optimal performance without the need to store data elements in any sorted order by exploiting dynamic rebalancing, has higher throughput, and keeps the logical last level of the tree on one physical level of the tree.
1964#Selecting a humanly understandable knowledge representation for reasoning about knowledge
1965#Decision trees: a contribution to automatic interpretation of GUHA results
1966#Natural-language interface for an instructable robot
1967#MOS: a multicomputer distributed operating system
1968#Software concurrency in real-time control systems: a software nucleus
1969#A general character to integer conversion method
1970#Combining MASCOT with MODULA-2 to aid the engineering of real-time systems
1971#A VLSI interactive layout editor (VILE)
1972#YACC in SASL—an exercise in functional programming
1973#Organization and management of a computer center
1974#Assembly language & systems programming for the IBM PC and compatibles
1975#Geometric modeling
1976#Computation and automata
1977#The INGRES papers: anatomy of a relational database system
1978#The design and implementation of INGRES
1979#Retrospection on a database system
1980#The commercial INGRES epilogue
1981#Locking granularity revisited
1982#The use of technological advances to enhance database system performance
1983#Performance enhancements to a relational database system
1984#Query processing in a relational database management system
1985#Operating system support for database management
1986#The design and implementation of distributed INGRES
1987#Distributed query processing in a relational database system
1988#Dynamic rematerialization: processing distributed queries using redundant data
1989#Nonblocking commit protocols
1990#Embedding a relational data sublanguage in a general purpose programming language
1991#Database portals: a new application program interface
1992#Data abstraction, views and updates in RIGEL
1993#A form application development system
1994#Application of abstract data types and abstract indices to CAD data
1995#An implementation of hypothetical relations
1996#Document processing in a relational database system
1997#QUEL as a data type
1998#Logical design and schema conversion for relational and DBTG databases
1999#An access path model for physical database design
2000#on Proceedings of the third joint ADA Europe/ADA TEC conference
2001#CAD of concurrent computers
2002#A hierarchical associative processing system
2003#Numerical optimization techniques
2004#Programming in MICRO-PROLOG
2005#Management workstations for greater productivity
2006#Learning APL: an array processing language
2007#Equational logic as a programming language
2008#An introduction to database systems: vol. I (4th ed.)
2009#Combinatorics for computer science
2010#Compact coding of syntactically correct source programs
2011#RCS—a system for version control
2012#The robust implementation of sequence-controlled iteration
2013#Implementation techniques for PROLOG databases
2014#A method of program transformation between variable sharing and message passing
2015#Dynamic storage allocation: experiments using the C language
2016#Experiences with writing library software for an attached processor
2017#Management of block-structured programs
2018#First Page of the Article
2019#First Page of the Article
2020#First Page of the Article
2021#First Page of the Article
2022#Decision support for marketing research and corporate planning
2023#Re-examining the proprietary software protection issue in the U.S.A. for the 1980s
2024#Assessing the organizational climate for OA implementation
2025#End-user computing: the MIS managers' perspective
2026#It has been a challenge for mathematicians to confirm theoretically the extremely good performance of simplex-type algorithms for linear programming. In this paper the average number of steps performed by a simplex algorithm, the so-called self-dual method, is analyzed. The algorithm is not started at the traditional point (1, … , l)T, but points of the form (1, &egr;, &egr;2, …)T, with &egr; sufficiently small, are used. The result is better, in two respects, than those of the previous analyses. First, it is shown that the expected number of steps is bounded between two quadratic functions c1(min(m, n))2 and c2(min(m, n))2 of the smaller dimension of the problem. This should be compared with the previous two major results in the field. Borgwardt proves an upper bound of O(n4m1/(n-1)) under a model that implies that the zero vector satisfies all the constraints, and also the algorithm under his consideration solves only problems from that particular subclass. Smale analyzes the self-dual algorithm starting at (1, … , 1)T. He shows that for any fixed m there is a constant c(m) such the expected number of steps is less than c(m)(ln n)m(m+1); Megiddo has shown that, under Smale's model, an upper bound C(m) exists. Thus, for the first time, a polynomial upper bound with no restrictions (except for nondegeneracy) on the problem is proved, and, for the first time, a nontrivial lower bound of precisely the same order of magnitude is established. Both Borgwardt and Smale require the input vectors to be drawn from spherically symmetric distributions. In the model in this paper, invariance is required only under certain
2027#In a distributed system, one strategy for achieving mutual exclusion of groups of nodes without communication is to assign to each node a number of votes. Only a group with a majority of votes can execute the critical operations, and mutual exclusion is achieved because at any given time there is at most one such group. A second strategy, which appears to be similar to votes, is to define a priori a set of groups that intersect each other. Any group of nodes that finds itself in this set can perform the restricted operations. In this paper, both of these strategies are studied in detail and it is shown that they are not equivalent in general (although they are in some cases). In doing so, a number of other interesting properties are proved. These properties will be of use to a system designer who is selecting a vote assignment or a set of groups for a specific application.
2028#Backtrack search is often used to solve constraint satisfaction problems. A relationship involving the structure of the constraints is described that provides a bound on the backtracking required to advance deeper into the backtrack tree. This analysis leads to upper bounds on the effort required for solution of a class of constraint satisfaction problems. The solutions involve a combination of relaxation preprocessing and backtrack search. The bounds are expressed in terms of the structure of the constraint connections. Specifically, the effort is shown to have a bound exponential in the size of the largest biconnected component of the constraint graph, as opposed to the size of the graph as a whole.
2029#A parallel algorithm is presented that accepts as input a graph G and produces a maximal independent set of vertices in G. On a P-RAM without the concurrent write or concurrent read features, the algorithm executes in O((log n)4) time and uses O((n/(log n))3) processors, where n is the number of vertices in G. The algorithm has several novel features that may find other applications. These include the use of balanced incomplete block designs to replace random sampling by deterministic sampling, and the use of a “dynamic pigeonhole principle” that generalizes the conventional pigeonhole principle.
2030#The problem of simulating a synchronous network by an asynchronous network is investigated. A new simulation technique, referred to as a synchronizer, which is a new, simple methodology for designing efficient distributed algorithms in asynchronous networks, is proposed. The synchronizer exhibits a trade-off between its communication and time complexities, which is proved to be within a constant factor of the lower bound.
2031#An algorithm is presented that finds a min-cut linear arrangement of a tree in O(n log n) time. An extension of the algorithm determines the number of pebbles needed to play the black and white pebble game on a tree.
2032#Previous research in modeling office activities has been primarily oriented toward office work that is structured and organized. In this paper we report on efforts to develop a new methodology for needs assessment evaluation. We use the Critical Task Method to identify the “bottleneck cognitive tasks” of principals with an unstructured work profile. Data were collected on the computer-support needs of faculty researchers, and the findings indicate that a “knowledge-based” design offers the most promise for delivering effective support. In addition, the systems design suggests the integration of text, data, voice, and images.
2033#Recently, office communication systems have begun to integrate voice recordings into their mail and data communications facilities. The study of usage patterns on one such system shows that voice is used for informal, person-to-person communications, as opposed to the formal content of typed messages. Voice messages are generally sent to fewer recipients (often only one), and sometimes replace face-to-face meetings.
2034#A prototype system has been implemented for electronic scanning, digitization, storage, retrieval, and display of images of biomedical documents. Paper documents are scanned and digitized at a scan density of 200 picture elements (pels) per inch by either a high-speed loose-leaf scanner with an automatic document transport or a book scanner with a manual book holder. Each scanner employs a high-resolution charge-coupled device (CCD) linear array operating at a sampling rate close to 10 MHz. The analog output signal of the CCD array is digitized into 1 bit per pixel two-tone images by means of dynamic thresholding. The digitized images are stored on magnetic disks to be processed and will eventually be transferred onto optical disks for archival storage. Existing on-line bibliographic databases developed by the National Library of Medicine are used as directories for the retrieval of document images. These images are displayed at a resolution of 200 pels/inch in both soft-copy (raster-refreshed CRT) and hard-copy forms.This prototype system, developed as part of a research and development program, offers the opportunity to investigate the areas of document image enhancement, image compression, and omnifont text recognition and to conduct experiments designed to answer key questions on the role of electronic document storage and retrieval technology in library information processing and the preservation of library documents.
2035#An approach to the coordinated sharing and interchange of computerized information is described emphasizing partial, controlled sharing among autonomous databases. Office information systems provide a particularly appropriate context for this type of information sharing and exchange. A federated database architecture is described in which a collection of independent database systems are united into a loosely coupled federation in order to share and exchange information. A federation consists of components (of which there may be any number) and a single federal dictionary. The components represent individual users, applications, workstations, or other components in an office information system. The federal dictionary is a specialized component that maintains the topology of the federation and oversees the entry of new components. Each component in the federation controls its interactions with other components by means of an export schema and an import schema. The export schema specifies the information that a component will share with other components, while the import schema specifies the nonlocal information that a component wishes to manipulate. The federated architecture provides mechanisms for sharing data, for sharing transactions (via message types) for combining information from several components, and for coordinating activities among autonomous components (via negotiation). A prototype implementation of the federated database mechanism is currently operational on an experimental basis.
2036#A network of personal computers may contain a large amount of distributed computing resources. For a number of reasons it is desirable to share these resources, but sharing is complicated by issues of security and autonomy. A process known as the Butler addresses these problems and provides support for resource sharing. The Butler relies upon a capability-based accounting system called the Banker to monitor the use of local resources.
2037#Dictionary of data communications (2nd Ed.)
2038#Illustrated dictionary of microcomputer terminology
2039#Expert systems—a practical introduction
2040#Introduction to microcomputer engineering
2041#Practical project management: restoring quality to DP projects and systems
2042#Jesse James at the terminal: the new computing environment presents many opportunities for a different kind of highway robbery
2043#Should COBOL support coroutines?
2044#MONET—The Monash University local area network
2045#The PORTA language—a portable medical record system
2046#A simple model, AT, for nondeterministic machines is presented which is based on certain types of trees. A set of operations, &Sgr;, is defined over AT and it is shown to be completely characterized by a set of inequations over &Sgr;. AT is used to define the denotational semantics of a language for defining nondeterministic machines. The significance of the model is demonstrated by showing that this semantics reflects an intuitive operational semantics of machines based on the idea that machines should only be differentiated if there is some experiment that differentiates between them.
2047#The problem of recognizing the language Ln(Ln, k) of solvable Diophantine linear equations with n variables (and solutions from {O, … , k}n) is considered. The languages ∪n&egr;N Ln, ∪n&egr;N Ln, l, the knapsack problem, are NP-complete. The &OHgr;(n2 lower bound for Ln,1 on linear search algorithms due to Dobkin and Lipton is generalized to an &OHgr;(n2log(k + 1)) lower bound for Ln, k. The method of Klein and Meyer auf der Heide is further improved to carry over the &OHgr;(n2) lower bound for Ln, 1 to random access machines (RAMS) in such a way that it holds for a large class of problems and for very small input sets. By this method, lower bounds that depend on the input size, as is necessary for Ln, are proved. Thereby, an &OHgr;(n2log(k + 1)) lower bound is obtained for RAMS recognizing Ln or Ln, k, for inputs from {0, … , (nk)0(n2)}n.
2048#A portable high-level database debugger and software performance monitor
2049#A debugger for concurrent programs
2050#Ada's derived types and units of measure
2051#On squeezing the UNIX quart into a data general eclipse pint pot
2052#A program design language based software maintenance tool
2053#The University of Salford LISP/PROLOG system
2054#HANDIN—a system for helping with the teaching of programming
2055#Combinatorial techniques for extending lower bound results for decision trees to general types of queries are presented. Problems that are defined by simple inequalities between inputs, called order invariant problems, are considered. A decision tree is called k-bounded if each query depends on at most k variables. No further assumptions on the type of queries are made. It is proved that one can replace the queries of any k-bounded decision tree that solves an order-invariant problem over a large enough input domain with k-bounded queries whose outcome depends only on the relative order of the inputs. As a consequence, all existing lower bounds for comparison-based algorithms are valid for general k-bounded decision trees, where k is a constant.An &OHgr;(n log n) lower bound for the element uniqueness problem and several other problems for any k-bounded decision tree, such that k = O(nc) and c n1/2-bounded decision trees of complexity O(n) that solve the element-uniqueness problem. All the lower bounds mentioned above are shown to hold for nondeterministic and probabilistic decision trees as well.
2056#This paper describes Omega, a prototype system designed to analyze data flow in C programs. Omega is capable of detecting certain types of common programming errors, or assuring their absence. Omega also addresses the problems of analyzing pointer variables.
2057#This paper proposes a method for assessing software reliability models and its application to the Musa and Littlewood-Verrall models. It is divided into two parts.
2058#The high cost of software during its life cycle can be attributer largely to software maintenance activities, and a major portion of these activities is to deal with the modifications of the software. In this paper, design stability measures which indicate the potential ripple effect characteristics due to modifications of the program at the design level are presented. These measures can be generated at any point in the design phase of the software life cycle which enables early maintainability feedback to the software developers. The validation of these measures and future research efforts involving the development of a user-oriented maintainability measure, which incorporates the design stability measures as well as other design measures, are discussed.
2059#The use of digital computers in critical process control systems requires the formal assessment of the system reliability. Failures can be due to either component malfunctions or design faults. Only the latter are relevant in evaluating software reliability. Although it is preferable to prove whether the program meets its specification, this is not yet practical for real-time control programs. Further, the specification itself can be incorrect or incomplete due to the complex requirements.
2060#When a crash occurs in a transaction processing system, the database can enter an unacceptable state. To continue the processing, the recovery system has three tasks: 1) verification of the database state for acceptability, 2) restoration of an acceptable database state, and 3) restoration of an acceptable history of transaction processing. Unfortunately these tasks are not trivial and the computational complexity of the algorithms for most of them is either NP-complete or NP-hard. In this paper we discuss the concepts and design issues of a construct called database integrity block (DIB). The implementation of this construct allows for efficient verification of the database state by employing a set of integrity assertions and restoration of transaction history by utilizing any database restoration technique such as audit trail or differential file. This paper presents approximation algorithms for minimizing the costs of evaluation of integrity assertions by modeling the problem as the directed traveling salesman problem, and presents a methodology to compare the costs of audit trail and differential file techniques for database restoration. The applicability of integrity verification research to the problem of multiple-query optimization is also included.
2061#In the past, a number of methods have been proposed to model and validate communication protocols that have already been designed. However, design criteria and design aids are still lacking for designing correct protocols. The objective of developing automated protocol synthesizers is to provide a systematic way of designing new communication protocols such that their correctness can be ensured.
2062#This paper describes a family of tools which not only supports software development, but also assures the quality of each software product from the requirements definition to the integrated system. It is based upon an explicit definition of the design objectives and includes specification verification, design evaluation, static program analysis, dynamic program analysis, integration test auditing, and configuration management.
2063#This paper deals with the use of Structured Analysis just prior to system acceptance testing. Specifically, the drawing of data flow diagrams (DFD) was done after integration testing. The DFD's provided a picture of the logical flow through the integrated system for thorough system acceptance testing. System test sets, were derived from the flows in the DFD's. System test repeatability was enhanced by the matrix which flowed from the test sets.
2064#Branch-and-bound algorithms are organized and intelligently structured searches of solutions in a combinatorially large problem space. In this paper, we propose an approximate stochastic model of branch-and-bound algorithms with a best-first search. We have estimated the average memory space required and have predicted the average number of subproblems expanded before the process terminates. Both measures are exponentials of sublinear exponent. In addition, we have also compared the number of subproblems expanded in a best-first search to that expanded in a depth-first search. Depth-first search has been found to have computational complexity comparable to best-first search when the lower-bound function is very accurate or very inaccurate; otherwise, best-fit search is usually better. The results obtained are useful in studying the efficient evaluation of branch-and-bound algorithms in a virtual memory environment. They also confirm that approximations are very effective in reducing the total number of iterations.
2065#The problems of developing software requirements and quality assurance techniques have basically dealt with an environment where a single organization acts as the designer, developer, and user of the software product. Since the mid-1970' s, however, there has been a great increase in the use of "packaged" software products designed and developed by one organization for use in a variety of other organizations. The great profusion of products has resulted in many products being peddled for generic applications (accounting, manufacturing, etc.) which are of questionable quality and/or "fit" to a given organization's environment. This paper describes some techniques that are being used to certify software produced by third parties and how to determine if the "fit" is there. Current quality assurance techniques deal with the "correctness" of a program as compared to its specifications [2], [4], [7], [8], [12]. The real issue for a purchaser of software is whether the software is "correct" for its environment.
2066#A research prototype software system for conceptual information retrieval has been developed. The goal of the system, called RUBRIC, is to provide more automated and relevant access to unformatted textual databases. The approach is to use production rules from artificial intelligence to define a hierarchy of retrieval subtopics, with fuzzy context expressions and specific word phrases at the bottom. RUBRIC allows the definition of detailed queries starting at a conceptual level, partial matching of a query and a document, selection of only the highest ranked documents for presentation to the user, and detailed explanation of how and why a particular document was selected. Initial experiments indicate that a RUBRIC rule set better matches human retrieval judgment than a standard Boolean keyword expression, given equal amounts of effort in defining each. The techniques presented may be useful in stand-alone retrieval systems, front-ends to existing information retrieval systems, or real-time document filtering and routing.
2067#The SPD (Structured Programming Diagram) is a documentation technology used to design well structured programs. With SPD, designers can easily express functional structure, control structure, and physical layout of a program on one sheet of paper. Its straightforward expression appeals to both document writers and readers. SPD concept and conventions are introduced in this paper. SPD usage is then explained with a program design example. Other documentation technologies used in coordination with SPD are briefly touched upon. Finally, SPD reputation and evolution in the last ten years are reviewed.
2068#In comparison to centralized database systems, distributed database systems have certain advantages depending on the manner in which data are redundantly distributed. These advantages are improvement in response time, better data availability, reduction in transmission cost, etc.
2069#In this paper, we study the allocation of files in a star network. Unlike previous algorithms which assume that files are independently accessed and independently assigned, the interaction of files during the processing of queries is directly incorporated into our cost model. We present an adaptive algorithm, which is much faster than existing algorithms on file allocation, obtains solutions which are on the average only 0.1 percent away from the optimal solutions, and possesses many desirable properties such as the satisfaction of some necessary and sufficient conditions for file allocation.
2070#This paper describes the Update Protocol Model (UPM), a formal language for the expression of database update semantics. UPM has been used primarily to capture and communicate in a precise and uniform notation the plethora of database semantics described by a variety of "fourth generation" models, many of which are imprecise when it comes to update semantics. Several computing trends-knowledge-based expert systems, distributed database management systems, and new applications based on higher order semantic models-point to the need for modeling techniques beyond that which current data models such as the relational and entity-relationship models provide.
2071#This paper describes research conducted by the Software Engineering Laboratory (SEL) on the use of dynamic variables as a tool to monitor software development. The intent of the project is to identify project independent measures which may be used in a management tool for monitoring software development. This study examines several Fortran projects with similar profiles. The staff was experienced in developing these types of projects. The projects developed serve similar functions. Because these projects are similar we believe some underlying relationships exist that are invariant between the projects. These relationships, once well defined, may be used to compare the development of different projects to determine whether they are evolving the same way previous projects in this environment evolved.
2072#A review of early work on a project to develop autonomous vehicle control technology is presented. The primary goal of this effort is the development of a generic capability that can be specialized to a wide range of DoD applications. The emphasis in this project is development of the fundamental Al-based technology required by autonomous systems and the implementation of a testbed environment to evaluate and demonstrate the system capabilities.
2073#In order to program SIMD (single instruction stream-multiple data stream) parallel machines used for tasks such as speech and image processing, a language with explicit parallel constructs is often desirable. The language Ada, developed by the Department of Defense, is used here as a basis for such a language. Extensions of Ada, which allow the user to specify such operations as interprocessor communications and activation of processors, are proposed. These features are demonstrated by showing their use in a common speech processing algorithm, the parallel FFT.
2074#Computer data center design: a guide for planning, designing, constructing, and operating computer data centers
2075#Applied statistics algorithms
2076#Programming the UNIX system
2077#Device-independent graphics: with examples from IBM personal computers
2078#A frame-based representation facility contributes to a knowledge system's ability to reason and can assist the system designer in determining strategies for controlling the system's reasoning.
2079#Rule-based systems automate problem-solving know-how, provide a means for capturing and refining human expertise, and are proving to be commercially viable.
2080#Logic programming is programming by description. The programmer describes the application area and lets the program choose specific operations. Logic programs are easier to create and enable machines to explain their results and actions.
2081#Lara, a text editor developed for the Lilith workstation, exemplifies the principles underlying modern text-editor design: a high degree of interactivity, an internal data structure that mirrors currently displayed text, and extensive use of bitmap controlled displays and facilities.
2082#Applications programmed using LR(1) parsers should be designed so that as many functions as possible are controlled by the driving parsing machine through conveniently staged reductions and associated primitive actions; in this paper this is achieved by making extensive use of null productions and nullable nonterminal symbols.
2083#A number of data structures for representing images by quadtrees without pointers are discussed. The image is treated as a collection of leaf nodes. Each leaf node is represented by use of a locational code corresponding to a sequence of directional codes that locate the leaf along a path from the root of the tree. Somewhat related is the concept of a forest which is a representation that consists of a collection of maximal blocks. It is reviewed and refined to enable the representation of a quadtree as a sequence of approximations. In essence, all BLACK and WHITE nodes are said to be of type GB and GW, respectively. GRAY nodes are of type GB if at least two of their sons are of type GB; otherwise, they are of type GW. Sequences of approximations using various combinations of locational codes of GB and GW nodes are proposed and shown to be superior to approximation methods based on truncation of nodes below a certain level in the tree. These approximations have two important properties. First, they are progressive in the sense that as more of the image is transmitted, the receiving device can construct a better approximation (contrast with facsimile methods which transmit the image one line at a time). Second, they are proved to lead to compression in the sense that they never require more than MIN(B, W) nodes where B and W correspond to the number of BLACK and WHITE nodes in the original quadtree. Algorithms are given for constructing the approximation sequences as well as decoding them to rebuild the original quadtree.
2084#We describe an expert system for resource allocation in a particular military domain. The system incorporates variants of several important techniques of artificial intelligence and makes the first use of the Merit system for question selection. This technique enables the system to direct the acquisition of information by finding questions with a high ratio of probable importance to difficulty. In the current application, each resource is a military weapon, each task to which such a resource can be allocated is firing at a military target, and the objective function is the expected reduction in value of targets. The coefficients that relate a particular resource to a particular task are not provided explicitly. Instead, in the first phase of the allocation process, the system uses a computation network to determine the effectiveness of each individual weapon against each prospective target. The network, built by a domain expert in advance, allows reasoning with logical, Bayesian, and expert-defined operators. After the calculation of individual effectiveness values, portions of an allocation tree are constructed to determine good allocation plans for the set of weapons. The individual effectiveness values are used to direct the traversal and pruning of the allocation tree.
2085#Conversational programming systems
2086#Documentation: the need for review
2087#First Page of the Article
2088#First Page of the Article
2089#First Page of the Article
2090#First Page of the Article
2091#First Page of the Article
2092#First Page of the Article
2093#First Page of the Article
2094#First Page of the Article
2095#We present an algebraic specification language (PLUSS) and a program construction method. Programs are built systematically from an algebraic specification of the data they deal with. The method was tested on a realistic problem (part of a telephone switching system). In these experiments, it turned out that error handling was the difficult part to specify and to program. This paper shows how to cope with this problem at the specification level and during the program development process.
2096#The discipline of software engineering can be extended in a natural way to deal with the issues raised by a systematic approach to the design of human-machine interfaces. Two main points are made: that the user should be treated as part of the system being designed, and that projects should be organized to take account of the current (small) state of a priori knowledge about how to design interfaces.
2097#This paper describes a program called PROUST which does on-line analysis and understanding of Pascal written by novice programmers. PROUST takes as input a program and a nonalgorithmic description of the program requirements, and finds the most likely mapping between the requirements and the code. This mapping is in essence a reconstruction of the design and implementation steps that the programmer went through in writing the program. A knowledge base of programming plans and strategies, together with common bugs associated with them, is used in constructing this mapping. Bugs are discovered in the process of relating plans to the code; PROUST can therefore give deep explanations of program bugs by relating the buggy code to its underlying intentions.
2098#This paper describes the PECAN family of program development systems. PECAN supports multiple views of the user's program. The views can be representations of the program or of the corresponding semantics. The primary program view is a syntax-directed editor. The current semantic views include expression trees, data type diagrams, flow graphs, and the symbol table. PECAN is designed to make effective use of powerful personal machines with high-resolution graphics displays and is currently implemented on APOLLO workstations.
2099#This paperlintroduces the reader to many of the salient features of the Cedar programming environment, a state-of-the-art progrmming system that combines in a single integrated environment: high quality graphics, a sophisticated editor and document preparation facility, and a variety of tools for the programmer to use in the construction and debugging of his programs. The Cedar programming language [8] is a strongly typed, compiler-oriented language of the Pascal family. What is especially interesting about the Cedar project is that it is one of the few examples where an interactive, experimental programming environment has been built for this kind of language. In the past, such environments have been confined to dynamically typed languages like Lisp and Smalltalk.
2100#Conceptual simplicity, tight coupling of tools, and effective support of host-target software development will characterize advanced Ada programming support environments. Several important principles have been demonstrated in the Arcturus system, including template-assisted Ada editing, command completion using Ada as a command language, and combining the advantages of interpretation and compilation. Other principles, relating to analysis, testing, and debugging of concurrent Ada programs, have appeared in other contexts. This paper discusses several of these topics, considers how they can be integrated, and argues for their inclusion in an environment appropriate for software development in the late 1980's.
2101#Using database machines in embedded computer systems
2102#An examination of decision-makers' utilization of decision support system output
2103#Executive workstations: issues and requirements
2104#Documenting information systems for management: a key to maintaining user satisfaction
2105#Use of machine-readable databases to support a large SDI service
2106#Browse and navigate: an advance in database access methods
2107#Storing and retrieving word phrases
2108#An algorithm for the calculation of exact term discrimination values
2109#Storage and retrieval considerations of binary data bases
2110#The valuing of management information. Part I: the Bayesian approach
2111#Application in practice of the results of library and information retrieval research—experience in consultancy
2112#An introduction to text processing: a systematic approach to the study of text structure and operations and the design of text processing software
2113#Software engineering with Ada
2114#Programming in Ada (2nd ed.)
2115#Computational geometry: an introduction
2116#Multiple processor systems for real-time applications
2117#System design with ADA
2118#A priority queue with interruptions of service permitted after a time quantum
2119#Short proofs for tricky formulas
2120#Decidable properties of monadic recursive schemas with a depth parameter
2121#Probabilistic bounds for dual bin-packing
2122#Proving properties of Pascal programs in MIZAR 2
2123#The answerability of database queries
2124#Causal dependencies in deadline requirements
2125#Removing redundant join operations in queries involving views
2126#Growing certainty with null values
2127#A methodology to model the dynamic structure of an organization
2128#Enabling local actions by global consensus
2129#Decomposition of select expressions
2130#Ontological aspects of logical databases
2131#A case study of database design using the DATAID approach
2132#Dynamic access control for relational views
2133#An evaluation of tagging
2134#Towards a language for concurrent processes
2135#A large scale network storage facility
2136#A distributed load-balancing policy for a multicomputer
2137#Video-slide: a presentation aid for the BBC microcomputer
2138#Business computer systems: an introduction (2nd ed.)
2139#Linear algebra with computer applications
2140#A method of measuring information in language, applied to medical texts
2141#Requirements for query evaluation in weighted information retrieval
2142#An information system for decision support in national information policy-making and planning
2143#Computers in crisis, how to avert the coming worldwide computer systems collapse
2144#A secure computer network design
2145#Data security and confidentiality in Europe
2146#The impact of the bell system breakup on DP disaster recovery planning
2147#The large-scale automated transaction systems of the near future can be designed to protect the privacy and maintain the security of both individuals and organizations.
2148#A systemic view of DSS can provide a concrete framework for effective design of DSS and can also serve as a basis for accumulating DSS research results.
2149#Orthogonal Latin squares—a new method for testing compilers—yields the informational equivalent of exhaustive testing at a fraction of the cost. The method has been used successfully in designing some of the tests in the Ada Compiler Validation Capability (ACVC) test suite.
2150#The generation of an embedded microprogram controlling a video display unit demonstrates how Jackson Structured Programming can be used effectively for both systems programming and microprocessor applications.
2151#For hash tables in which a strict physical separation exists between primary storage and storage for overflow records, with bucket capacity at least three, a complete probability model is described. A measure of hash table efficiency is introduced, called the table sufficiency index (TSI), and defined as the probability that the overflow space is sufficient assuming that the set of hashed keys has a uniform distribution. The constructed probability model may be used to compute the TSI for hash tables with parameters chosen from a restricted domain. The TSI is advocated as a tool for making decisions about the parameters of small hash tables.
2152#A heuristic algorithm is proposed for dynamic calculation of the median and other quantiles. The estimates are produced dynamically as the observations are generated. The observations are not stored; therefore, the algorithm has a very small and fixed storage requirement regardless of the number of observations. This makes it ideal for implementing in a quantile chip that can be used in industrial controllers and recorders. The algorithm is further extended to histogram plotting. The accuracy of the algorithm is analyzed.
2153#On the interaction of man and EDP use as work activity
2154#The use of modal default reasoning in information systems
2155#How to tell people where to go: comparing navigational aids
2156#On search in an incomplete database
2157#Analysis of a replicated data base
2158#On the analysis of a symmetric polling system with single-message buffers
2159#Memory management for B-trees
2160#The tree MVA algorithm
2161#The dynamics of computing
2162#Designing data networks
2163#Pattern recognition: human and mechanical
2164#How to sell computer services to government agencies
2165#Fourth-generation languages. Volume I: principles
2166#Data communications, networks, and systems
2167#On synchronous parallel computations with independent probabilistic choice
2168#An algorithm for automatic layout of entity-relationship diagrams
2169#Proc. international seminars on software engineering on Theory and practice of software technology
2170#Towards an integration between language and software development environment
2171#Towards an integration between language and software development environment
2172#Prime numbers and computer methods for factorization
2173#First Page of the Article
2174#First Page of the Article
2175#First Page of the Article
2176#First Page of the Article
2177#First Page of the Article
2178#First Page of the Article
2179#First Page of the Article
2180#The acquisition of syntactic knowledge
2181#A practical handbook for software development
2182#The analysis, design, and implementation of information systems (3rd ed.)
2183#MICRODOCTOR: personal computers for personal health
2184#Analytic methods in the analysis and design of number-theoretic algorithms
2185#Gate arrays: design techniques and applications
2186#Beyond mindstorms: teaching with IBM LOGO
2187#Multifacetted modelling and discrete event simulation
2188#Relational database systems
2189#Software engineering handbook
2190#Performance and evaluation of LISP systems
2191#Logic testing and design for testability
2192#Discourse strategies for generating natural-language text
2193#Top-down synthesis of divide-and-conquer algorithms
2194#Depth-first iterative-deepening: an optimal admissible tree search
2195#Efficient algorithms to create and maintain balanced and threaded binary search trees
2196#Design and implementation of the Wisconsin storage system
2197#The creation of a virtual NAG-ALGOL 68 program library
2198#A reliable stable storage system for UNIX
2199#Compilers—some good, some bad]
2200#Integration of diskless workstations in UNIX United
2201#DDA—a data definition facility for UNIX using Awk
2202#Producing good code for the case statement
2203#Information systems architecture: a system developer's primer
2204#Programming in Common LISP
2205#Database: step-by-step
2206#Memoirs of a computer pioneer
2207#An algorithm for finding a matroid basis which maximizes the product of the weights of the elements
2208#A note on one-pass evaluation of attribute grammars
2209#Sorting in linear expected time
2210#A fast line-sweep algorithm for hidden line elimination
2211#A note on two parallel algorithms to solve the stable marriage problem
2212#Partial match retrieval using recursive linear hashing
2213#Generalized Steiner problem in outerplanar networks
2214#Efficient computer-user interface in electronic mail systems
2215#Experimental evaluation of dialogue types for data entry
2216#Specification and generation of variable, personalized graphical interfaces
2217#Although the boundaries of artificial intelligence (AI) remain elusive, computers can now perform musical tasks that were formerly associated exclusively with naturally intelligent musicians. After a historical note, this paper sermonizes on the need for AI techniques in four areas of musical research: composition, performance, music theory, and digital sound processing. The next part surveys recent work involving AI and music. The discussion concentrates on applications in the four areas of research just mentioned. The final part examines how AI techniques of planning and learning could be used to expand the knowledge base and enrich the behavior of musically intelligent systems.
2218#This paper is a study of the unique problems posed by the use of computers by composers and performers of music. The paper begins with a presentation of the basic concepts involved in the musical interaction with computer devices, followed by a detailed discussion of three musical tasks: music manuscript preparation, music language interfaces for composition, and real-time performance interaction. Fundamental design principles are exposed through an examination of several early computer music systems, especially the Structured Sound Synthesis Project. A survey of numerous systems, based on the following categories, is presented: compositions and synthesis languages, graphics score editing, performance instruments, digital audio processing tools, and computer-aided instruction in music systems. An extensive reference list is provided for further study in the field.
2219#Computational vision and regularization theory
2220#DNP (dynamic networks of processes) is a variant of the language introduced by Kahn and MacQueen [11, 12]. In the language it is possible to create new processes dynamically. We present a complete, formal denotational semantics for the language, along the lines sketched by Kahn and MacQueen. An informal explanation of the formal semantics is also given.
2221#We present a different style of axiomatic definition for programming languages. It is oriented toward imperative languages, such as Algol 68, that do not distinguish between statements and expressions. Rather than basing the logic on a notion of pre- or postcondition, we use the value of a programming language expression as the underlying primitive.A number of language constructs are examined in this framework. We argue that this style of definition gives us a significantly different view of the notion of “easy axiomatixability.” Side effects in expressions as well as aliasing between variables are shown to be “easily axiomatizable” in our system.
2222#We argue for the need of supporting a symmetric select construct, in which entry calls as well as accepts can be alternatives. We present several situations in which a symmetric select leads to a more natural programming style. We show that several semantic principles are violated by a nonsymmetric select, while being satisfied by a symmetric one. In particular, the suggested symmetric intertask communication mechanism is fully abstract and composable, and has a distributed termination rule which reduces the risk of deadlock. Our discussion is in terms of Ada™.
2223#An editing by example system is an automatic program synthesis facility embedded in a text editor that can be used to solve repetitive text editing problems. The user provides the editor with a few examples of a text transformation. The system analyzes the examples and generalizes them into a program that can perform the transformation to the rest of the user's text. This paper presents an overview of the design, analysis, and implementation of a practical editing by example system. It studies the problem of synthesizing a text processing program that generalizes the transformation implicitly described by a small number of input/output examples. A class of text processing programs called gap programs is defined and the problems associated with synthesizing them from examples are examined, leading to an efficient heuristic that provably synthesizes a gap program from examples of its input/output behavior. The editing by example system derived from this analysis has been embedded in a production text editor. By developing an editing by example system that solves a useful class of text processing problems, this work demonstrates that program synthesis is feasible in the domain of text editing.
2224#A persistent programming environment, together with a language that supports first class procedures, may be used to provide the semantic features of other object modeling languages. In particular, the two concepts may be combined to implement abstract data types, modules, separate compilation, views, and data protection. Furthermore, the ideas may be used in system construction and version control, as demonstrated here.
2225#Multilisp is a version of the Lisp dialect Scheme extended with constructs for parallel execution. Like Scheme, Multilisp is oriented toward symbolic computation. Unlike some parallel programming languages, Multilisp incorporates constructs for causing side effects and for explicitly introducing parallelism. The potential complexity of dealing with side effects in a parallel context is mitigated by the nature of the parallelism constructs and by support for abstract data types: a recommended Multilisp programming style is presented which, if followed, should lead to highly parallel, easily understandable programs.Multilisp is being implemented on the 32-processor Concert multiprocessor; however, it is ultimately intended for use on larger multiprocessors. The current implementation, called Concert Multilisp, is complete enough to run the Multilisp compiler itself and has been run on Concert prototypes including up to eight processors. Concert Multilisp uses novel techniques for task scheduling and garbage collection. The task scheduler helps control excessive resource utilization by means of an unfair scheduling policy; the garbage collector uses a multiprocessor algorithm based on the incremental garbage collector of Baker.
2226#Proc. 26th annual symposium on Foundations of computer science
2227#The hitch-hiker's guide to artificial intelligence
2228#Artificial intelligence: a personal, commonsense journey
2229#The development of formal, descriptive, and procedural notations has become a practical concern within the field of music now that computers are being applied to musical tasks. Music combines the real-time demands of performance with the intellectual demands of highly developed symbolic systems that are quite different from natural language. The richness and variety of these demands makes the programming language paradigm a natural one in the musical application of computers. This paradigm provides musicians with a fresh perspective on their work. At the same time, music is a very advanced form of human endeavor, making computer music applications a worthy challenge for computer scientists. In this paper we outline the traditional tasks and forms of representation in music, then proceed with a survey of languages that deal with music programming.
2230#Affix grammars are used to describe the instruction set of a target architecture for purposes of compiler code generation. A code generator is obtained automatically for a compiler using attributed parsing techniques. A compiler built on this model can automatically perform most popular machine-dependent optimizations, including peephole optimizations. Code generators based on this model demonstrate retargetability for the VAX1-11, iAPX2-86, Z-80003, PDP4-11, MC-68000, NS32032, FOM, and IBM-370 architectures.
2231#Separating the polynomial-time hierarchy by oracles
2232#Description and improvement of iterative program transformations
2233#Distributed mutual exclusion on a ring of processes
2234#Automatic construction of CSP programs from sequential non-deterministic programs
2235#Distributed execution of functional programs using serial combinators
2236#Fat-trees: universal networks for hardware-efficient supercomputing
2237#Fault location techniques for distributed control interconnection networks
2238#A comparative study of unification algorithms for or-parallel execution of logic languages
2239#Bandwidth availability of multiple-bus multiprocessors
2240#An empirical study of automatic restructuring of nonnumerical programs for parallel processors
2241#A semi-markov model for the performance of multiple-bus systems
2242#On the effective bandwidth of interleaved memories in vector processor systems
2243#Previous attempts to apply Halstead's software metrics to APL have led to inconsistent and counter-intuitive results. This work is a further investigation into the application of software metrics to APL to try to resolve some of the inconsistency. The effect of variations in the counting rules on values calculated for the software metrics was studied. These rules were used to analyze a set of programs from a previous study. In addition, a large number of APL programs from a university environment were analyzed. Evidence is presented that verifies that APL has a higher language level than any other common programming language previously studied. Counting monadic and dyadic uses of the same APL symbol as an instance of a different operator was found to have a significant effect on the language level calculated for APL. However, decomposing derived APL functions into separate operators did not seem to have a significant effect on language level.
2244#When using MIMD (multiple instruction, multiple data) parallel computers, one is often confronted with solving a task composed of many independent subtasks where it is necessary to synchronize the processors after all the subtasks have been completed. This paper studies how the subtasks should be allocated to the processors in order to minimize the expected time it takes to finish all the subtasks (sometimes called the makespan). We assume that the running times of the subtasks are independent, identically distributed, increasing failure rate random variables, and that assigning one or more subtasks to a processor entails some overhead, or communication time, that is independent of the number of subtasks allocated. Our analyses, which use ideas from renewal theory, reliability theory, order statistics, and the theory of large deviations, are valid for a wide class of distributions. We show that allocating an equal number of subtasks to each processor all at once has good efficiency. This appears as a consequence of a rather general theorem which shows how some consequences of the central limit theorem hold even when we cannot prove that the central limit theorem applies.
2245#We propose an interface for use from within UNIX1 user programs for communicating over multiple and varied local and wide area networks. This interface aids the design of a distributed application program by hiding the actual communications protocols used over each network, and providing instead simple primitives for sending and receiving (possibly large) datagrams, using a simple standardized network addressing scheme based on a pair.
2246#Data abstraction is an effective tool in the design of complex systems, and the representation independence it provides is a key factor in the maintenance and adaptation of software systems. This paper describes a system development methodology based on the development of hierarchies of abstract data types (ADT's). The methodology preserves a high degree of representation independence throughout both the design and implementation of complex systems. The methodology is illustrated with examples from the design and implementation of a Vision Research Programming System. These examples include ADT specifications, ADT interface specifications, and partial implementation code for the system in two different programming languages, Ada1 and Fortran.
2247#The purpose of this paper is to summarize the research issues of statistical and scientific databases (SSDB's). It organizes the issues into four major groups: physical organization and access methods, operators, logical organization and user interfaces, and miscellaneous issues. It emphasizes the differences between SSDB's and traditional database applications, and motivates the need for new and innovative techniques for the support of SSDB's. In addition to describing current work in this field, it discusses open research areas and proposes possible approaches to their solution.
2248#Scientific and statistical database systems heavily depend on data compression techniques to make possible the management and storage of their large databases. The efficiency of data compression methods has a signficant impact on the overall performance of these systems. The purpose of this paper is to show the importance of data compression to scientific/statistical databases, to discuss the pros and cons of data compression, and to survey data compression techniques relevant to scientific/statistical databases. The emphasis is on the basic idea, motivation, and tradeoffs of each approach. Both software and hardware methods are covered. The paper is concluded by a discussion of several points of research that seem worthy of further investigation.
2249#Most research in statistical databases has concentrated on retrieval, sampling, and aggregation type statistical queries. Data management issues associated with computational statistical operations have been ignored. As a first step towards integrating database management support of statistical operations, we have analyzed the performance of X'X, the QR decomposition, and the Singular Value Factorization. Alternative implementation strategies with respect to the relational and transposed storage organizations are developed. Implementation strategies corresponding to vector building block, vector-matrix, and direct algorithms with explicit buffer management are compared in terms of efficiency in performance.
2250#Databases that are mainly used for statistical analysis are called statistical databases (SDB). A statistical database management system (SDBMS) may be defined as a database management system that provides capabilities 1) to model, store, and manipulate data in a manner suitable for the needs of SDB users, and 2) to apply statistical data analysis techniques that range from simple summary statistics to advanced procedures. This paper surveys the existing and proposed SDB data definition and data manipulation (i.e., query) languages.
2251#We survey a new way to get quick estimates of the values of simple statistks (like count, mean, standard deviation, maximum, median, and mode frequency) on a large data set. This approach is a comprehensive attempt (apparently the first) to estimate statistics without any sampling. Our "antisampling" techniques have analogies to those of sampling, and exhibit similar estimation accuracy, but can be done much faster than sampling with large computer databases. Antisampling exploits computer science ideas from database theory and expert systems, building an auxiliary structure called a "database abstract." We make detailed comparisons to several different kinds of sampling.
2252#The problem of optimal query processing in distributed database systems was shown to be NP-hard. However, for a special type of queries called star queries, we have developed a polynomial optimal algorithm. Semijoin tactics are applied for query processing. An execution graph is introduced to represent the semijoin programs associated with the distributed processing of the queries. We then identify optimality properties of semijoin programs for star queries, and use these properties to derive the optimal semijoin program. We have shown that the optimal semijoin program can be found from serial semijoin strategies, defined as serial semijoin programs which include each semijoin associated with the query exactly once. By making certain assumptions on the file sizes and the semijoin selectivities, we can obtain the optimal semijoin program from these strategies in polynomial time. Our assumption on selectivites is consistent in the sense that we consider the selectivity of a semijoin based on the current database state, i.e., we take into consideration the reduction effects of all prior semijoins.
2253#Concurrent broadcast involves the dissemination of a database, consisting of messages initially distributed among the nodes of a network, so that a copy of the entire database eventually resides at each node. One application is the dissemination of network status information for adaptive routing in a communications network. This paper examines the time complexity and communication complexity of several distributed procedures for concurrent broadcast. The procedures do not use information depending on the network topology. The worst-case time complexity of a flooding procedure for concurrent broadcast is shown to be linear in the number of nodes plus the number of messages, and no other procedure for concurrent broadcast has a better worst-case time complexity. A variant of flooding is proposed to eliminate redundant message receipts from the flooding process by real-time signaling between neighbors concerning messages residing at each. This variant can reduce communication complexity, while having a worst-case time complexity similar in form to that of the flooding procedure. Special properties of concurrent broadcast in a tree are also given. The present time complexity results can be used to bound the time during which inconsistent databases may reside at different nodes, to evaluate and compare procedures for (or including) concurrent broadcast, and to schedule a sequence of instances of concurrent broadcast so that the instances do not overlap and there is no need for sequence numbers.
2254#The issue of software partition deals with the process of mapping the given set of logical modules, which reflect the user's point of view, into a set of software tasks, which reflect the software implementor's point of view. It is shown in this paper that the software partitioning problem can be modeled as one that maximizes the efficiency in resource utilization while observing the constraints on CPU throughput, memory space available, maximally allowed task execution time, and the order of module execution. The CPU and memory constraints are implementation dependent. The maximum task execution time constraint is due to considerations on the response time performance. The constraint on module execution order is a logical one, and it is shown to have significant performance impact. It is proven that by employing the module precedence relation, which reflects the sequence of module execution, the order of module execution can be properly maintained during the software partitioning process. And thus the defined tasks can be guaranteed to be completely executable, once properly activated With completely executable tasks, the operating overhead cost and the response time delay can be minimized. The following four module precedence relations are explored: precede, succeed, parallel, and precede as well as succeed. The validity of the selected partitioning criterion of maximizing the resource utilization efficiency is also assessed through simulation experiments. The results of simulation show that performance of the selected criterion is insensitive to the application environment, as well as to the application requirements.
2255#Remote procedure call (RPC) is a programming primitive that makes building distributed programs easier. Atomicity, whkh implies totality and serializability, has been recognized as an important property to assure consistency in spite of computing node crashes. We have implemented an atomk remote procedure call mechanism which provides users a simple and reliable language primitive. Concurrency is controlled by attaching a call graph path identifier to each message representing a procedure call. Procedures keep their last accepted calling message paths to compare against incoming message paths. Only calls that can be serialized are accepted. Associated states of static variables are saved in backup processors on procedure entry and restored to corresponding variables in case of procedure crash. Detailed concurrency control and recovery algorithms are given, and illustrated with examples.
2256#An efficient decentralized algorithm for synchronized termination of a distributed computation is presented. It is assumed that distributed processes are connected via unidirectional channels into a strongly connected network, in which no central controller exists. The number of processes and the network configuration are not known a priori. The number of steps required to terminate distributed computation after all processes met their local termination conditions is proportional to the diameter D of the network (D + 1 steps).
2257#Many distributed scheduling algorithms have been developed and reported in the current literature. However, very few of them explicitly treat stability issues. This paper first discusses stability issues for distributed scheduling algorithms in general terms. Two very different distributed scheduling algorithms which contain explicit mechanisms for stability are then presented and evaluated with respect to individual specific stability issues. One of the agorithms is based on stochastic learning automata and the other on bidding. The results indicate how very specific the treatment of stability is to the algorithm and environnent under consideration.
2258#It is desirable for the load in a distributed system to be balanced evenly. A dynamic process migration protocol is needed in order to achieve load balancing in a user transparent manner. A distributed algorthim for load balancing which is network topology independent is proposed in this paper. Different network topologies and low-level communications protocols affect the choice of only some system design parameters. The "drafting" algorithm attempts to compromise two contradictory goals: maximize the processor utilization and minimize the communication overhead. The main objective of this paper is to describe the dynamic process migration protocol based on the proposed drafting algorithm. A sample distributed system is used to further illustrate the drafting algorithm and to show how to define system design parameters. The system performance is measured by simulation experiments based on the sample system.
2259#A major reason for the rarity of distributed applications, despite the proliferation of networks, is the sensitivity of their performance to various aspects of the network environment. We demonstrate that distributed applications can run faster than local ones, using common hardware. We also show that the primary factors affecting performance are, in approximate order of importance: speed of the user's workstation, speed of the remote host (if any), and the high-level (above the transport level) protocols used. In particular, the use of batching, pipelining, and structure in high-level protocols reduces the degradation often experienced between different bandwidth networks. Less significant, but still noticeable improvements result from proper design and implementation of the underlying transport protocols. Ultimately, with proper application of these techniques, network bandwidth is rendered virtually insignificant.
2260#Performance analysis studies of distributed database systems in the past have assumed that the message transmission time between any two nodes of a network is constant. They disregard the effect of communication network parameters such as network traffic, network topology, and capacity of transmission channels. In this paper, an analytical model is used to estimate the delays in transmission channels of the long haul network supporting the distributed database system. The analysis shows that the constant transmission time assumption cannot be justified in many cases, and that the response time is sensitive to the parameters mentioned above. Extensions and performance analysis in the context of interconnection networks are also discussed.
2261#The reliability of a distributed system depends on the reliabilities of its communication links and computing elements, as well as on the distribution of its resources, such as programs and data files. A useful measure of reliability in distributed systems is the terminal reliability between a pair of nodes which is the probability that at least one communication path exists between these nodes. An interesting optimization problem is that of maximizing the terminal reliability between a pair of computing elements under a given budget constraint. Analytical techniques to solve this problem are applicable only to special forms of reliability expressions. In this paper, three iterative algorithms for terminal reliability maximization are presented. The first two algorithms require the computation of terminal reliability expressions, and are therefore efficient for only small networks. The third algorithm, which is developed for large distributed systems, does not require the computation of terminal reliability expressions; this algorithm maximizes approximate objective functions and gives accurate results. Several examples are presented to illustrate the approximate optimization algorithm and an estimation of the error involved is also given.
2262#In this paper a technique called process merging is introduced. This technique allows the merging of two communicating sequential processes into a new single process. Thus, this technique can be used to reconfigure a distributed program after a faulty processing element has been detected. The technique is most applicable to dedicated multiple microprocessor systems where the need for continuous operation is critical. A process merging algorithm which operates on distributed programs using the CSP notation is presented in detail and its operation is discussed. In order to illustrate the merging technique, the algorithm's behavior is demonstrated using two classical distributed programs: the Bounded Buffer, Producer, Consumer program and the Dining Philosophers program. Finally, the merging technique is examined with respect to its demands on overall system operation and overhead. This examinatiQn leads to suggestions for future research.
2263#This paper deals with the analysis of large-scale closed queueing network (QN) models which are used for the performance analysis of computer communication networks (CCN's). The computer systems are interconnected by a wide-area network. Users accessing local/remote computers are affected by the contention (queueing delays) at the computer systems and the communication subnet. The computational cost of analyzing such models increases exponentially with the number of user classes (chains), even when the QN is tractable (product-form). In fact, the submodels of the integrated model are generally not product-form, e.g., due to blocking at computer systems (multiprogramming level constraints) and in the communication subnet (window flow control constraints). Two approximate solution methods are proposed in this paper to analyze the integrated QN model. Both methods use decomposition and iterative techniques to exploit the structure of the QN model such that computational cost is proportional to the number of chains. The accuracy of the solution methods is validated against each other and simulation. The model is used to study the effect that channel capacity assignments, window sizes for congestion control, and routing have on system performance.
2264#There has been a lot of interest in the past decade in using timed Petri nets to model computer systems. In this paper we show how such timed Petri nets can be used to great advantage in describing and algebraically specifying communication system performance. We make use of the time parameter of timed Petri nets to model the delay in performing certain operations of a communication protocol. The specification is borrowed from the recently reported AFFIRM language, and the protocol chosen for illustration is the ECMA transfer protocol, proposed for the ISO reference model. However, the methodology can be used with other protocols as well. We also show how liveness properties can be specified, easily using timed Petri nets.
2265#Distributed database systems (DDBS) have received considerable attention in recent years. Being a relatively young research field, there are still many problems associated with DDB systems that need solution. Concurrency control is one of these problems and, probably, the most extensively studied. However, most of the work has concentrated on the development of alternative solutions and the field seems to be ready for some comparative analysis work. This paper reports the results of a performance evaluation study on distributed database concurrency control algorithms. The research has resulted in the development of a formalism, based on Petri nets, for modeling and analysis purposes. The formalism, called the Extended Place/Transition Nets (EPTN), is both descriptively powerful in that it can be used to model various algorithms precisely and succinctly and to communicate them in a clear manner, while at the same time lending itself to be used as a performance evaluation tool. An EPTN simulator is implemented and various algorithms are studied using this tool. This paper describes both the formalism and the performance results that have been obtained.
2266#We model a systolic array as a network of, mostly identical, communicating finite state machines that exchange messages over one-to-one, unbounded, FIFO channels. Each machine has a cyclic behavior; in each cycle, a machine first receives one message from each of its input channels, then sends one message to each of its output channels. If in a cycle a machine does not have any data message to send to one of its output channels, it sends a null message instead; thus, machines exchange two types of messages, data and null. We characterize the liveness and termination properties for such networks, and discuss two algorithms that can be used to decide these properties for any given network. We apply these algorithms to establish the liveness and termination properties of four systolic array examples. These examples include a linear matrix-vector multiplier, a linear priority queue, and a search tree.
2267#A book on C
2268#The Apple writer II handbook
2269#Introduction to computer mathematics
2270#Using computers to create art
2271#Elements of practical performance modeling
2272#Introduction to machine and assembly language programming
2273#The design of a rule-based CAI tutorial
2274#Inference in a multivalued logic system
2275#Computer transcription of handwritten shorthand as an aid for the deaf—a feasibility study
2276#Speed of response using keyboard and screen-based microcomputer response media
2277#UMFE: a user modelling front-end subsystem
2278#Microcomputer implementation of an idiographic psychological instrument
2279#Organizing information: principles of data base and retrieval systems
2280#The architecture of small computer systems; 2nd ed.
2281#Ada: a life and a legacy
2282#Algorithms & data structures
2283#Seismology has burgeoned into a modern science—force-fed by federal funding to advance technology for detecting underground nuclear explosions and predicting earthquakes, and by industry to improve tools for gas and oil exploration. Computers, seismic instrument systems, telemetry, and data reduction have played key roles in this growth.
2284#The Search for Extraterrestrial Intelligence (SETI), now being planned at NASA, will require a prodigious amount of highly concurrent signal processing to be done in real time by special-purpose hardware.
2285#Sophisticated software tools are becoming increasingly important in helping biologists understand how nature operates. Symbolic pattern-recognition and artificial-intelligence methodologies are contributing to the development of such software.
2286#As more and more automation is incorporated in aircraft, the essential question becomes one of autonomy: Should the automated system serve as the human pilot's assistant, or vice versa?
2287#Growth of distributed systems has attained unstoppable momentum. If we better understood how to think about, analyze, and design distributed systems, we could direct their implementation with more confidence.
2288#Project Athena at MIT is an experiment to explore the potential uses of advanced computer technology in the university curriculum. About 60 different educational development projects, spanning virtually all of MIT's academic departments, are already in progress.
2289#The great challenge for computer science in this decade is to make computers usable by everyone. Computers, long viewed as a dehumanizing force, will become the most powerful means of personal creative expression and communication ever known.
2290#16-bit microprocessor systems: structure, behavior, programming
2291#Written communications for MIS/DP professionals
2292#Automatic programming consists not only of an automatic compiler, but also some means of acquiring the high-level specification to be compiled, some means of determining that it is the intended specification, and some (interactive) means of translating this high-level specification into a lower-level one which can be automatically compiled.
2293#Part 1: Codes of conduct for the computer professions
2294#The fifth generation: artificial intelligence and Japan's computer challenge to the world
2295#The complete computer maintenance handbook
2296#Data compression: techniques and applications
2297#Artificial intelligence and psychiatry
2298#Conceptual structures: information processing in mind and machine
2299#Principles of computer design
2300#Fundamentals of logic design and switching theory
2301#This paper reports on efforts to extend the transformational implementation (TI) model of software development [1]. In particular, we describe a system that uses AI techniques to automate major portions of a transformational implementation. The work has focused on the formalization of the goals, strategies, selection rationale, and finally the transformations used by expert human developers. A system has been constructed that includes representations for each of these problem-solving components, as well as machinery for handling human-system interaction and problem-solving control. We will present the system and illustrate automation issues through two annotated examples.
2302#We present a summary of the CHI project conducted at Kestrel Institute through mid-1984. The objective of this project was to perform research on knowledge-based software environments. Toward this end, key portions of a prototype environment, called CHI, were built that established the feasibility of this approach. One result of this research was the development of a wide-spectrum language that could be used to express all stages of the program development process in the system. Another result was that the prototype compiler was used to synthesize itself from very-high-level description of itself. In this way the system was bootstrapped. We describe the overall nature of the work done on this project, give highlights of implemented prototypes, and describe the implications that this work suggests for the future of software engineering. In addition to this historical perspective, current research projects at Kestrel Institute as well as commercial applications of the technology at Reasoning Systems are briefly surveyed.
2303#The Knowledge-Based Editor in Emacs (KBEmacs) is the current demonstration system implemented as part of the Programmer's Apprentice project. KBEmacs is capable of acting as a semiexpert assistant to a person who is writing a program-taking over some parts of the programming task. Using KBEmacs, it is possible to construct a program by issuing a series of high level comnmands. This series of commands can be as much as an order of magnitude shorter than the program it describes.
2304#Domain knowledge is crucial to an automatic programming system and the interaction between domain knowledge and programming at the current time. The NIX project at Schlumberger-Doll Research has been investigating this issue in the context of two application domains related to oil well logging. Based on these experiments we have developed a framework for domain-specific automatic programming. Within the framework, programming is modeled in terms of two activities, formalization and implementation, each of which transforms descriptions of the program as it proceeds through intermediate states of development. The activities and transformations may be used to characterize the interaction of programming knowledge and domain knowledge in an automatic programming system.
2305#Principled development techniques could greatly enhance the understandability of expert systems for both users and system developers. Current systems have limited explanatory capabilities and present maintenance problems because of a failure to explicitly represent the knowledge and reasoning that went into their design. This paper describes a paradigm for constructing expert systems which attempts to identify that tacit knowledge, provide means for capturing it in the knowledge bases of expert systems, and, apply it towards more perspicuous machine-generated explanations and more consistent and maintainable system organization.
2306#A designer's expertise rests on the knowledge and skills which develop with experience in a domain. As a result, when a designer is designing an object in an unfamiliar domain he will not have the same knowledge and skills available to him as when he is designing an object in a familiar domain. In this paper we look at the software designer's underlying constellation of knowledge and skills, and at the way in which this constellation is dependent upon experience in a domain. What skills drop out, what skills, or interactions of skills come forward as experience with the domain changes? To answer the above question, we studied expert designers in experimentally created design contexts with which they were differentially familiar. In this paper we describe the knowledge and skills we found were central to each of the above contexts and discuss the functional utility of each. In addition to discussing the knowledge and skills we observed in expert designers, we will also compare novice and expert behavior.
2307#Algorithm design is a challenging intellectual activity that provides a rich source of observation and a test domain for a theory of problem-solving behavior. This paper describes a theory of the algorithm design process based on observations of human design and also outlines a framework for automatic design. The adaptation of the theory of human design to a framework for automation in the DESIGNER system helps us understand human design better, and the implementation process helps validate the framework. Issues discussed in this paper include the problem spaces used for design, the loci of knowledge and problem-solving power, and the relationship to other methods of algorithm design and to automatic programming as a whole.
2308#The analysis and execution of partial algorithm descriptions is an important part of the algorithm design process (as is borne out by studying the behavior of human algorithm designers). In this paper, we describe a language for representing partially designed algorithms and a process, developmental evaluation, that can discover useful knowledge to guide design. Using these and other results from our research in artificial intelligence, we are building a system, DESIGNER, that automatically designs algorithms. This paper also compares developmental evaluation to execution and analysis techniques used for testing complete programs and for validation of abstract specifications; concepts similar to those found in developmental evaluation are thus shown to apply to all stages of the software life cycle.
2309#Elements of the artificial intelligence approach to expert systems offer great productivity advantages over traditional approaches to application systems development, even though the end result may be a program employing no AI techniques. These productivity advantages are the hidden truths behind the "myth" that symbolic reasoning programs are better than ordinary ones.
2310#This paper is a preliminary assessment of the viability of Prolog as a basis for the design of expert systems, where the major competition is assumed to be from Lisp and Lisp-based systems. We critically examine the basic features of Prolog from various perspectives to see to what extent they support (or hinder) expert system development. Our conclusion is that while Prolog has significant assets along several dimensions, Prolog as it exists today needs to be modified and appropriately enhanced to make it competitive to extant Lisp-based systems; we suggest the nature of some of these modifications.
2311#Knowledge programming, which makes use of the explicit representation and interpretation of knowledge to create intelligent programs, requires specialized languages and tools to help programmers. Prolog, an implementation of a logic programing language, provides some of these tools; it and other languages have been argued to be the "best" way to do such knowledge programming. This paper raises questions which suggest that any single paradigm of programming (e.g., logic programming or object-oriented programming) benefits by being integrated in a single environment with other paradigms of programming. Integration of these paradigms with each other, and within a flexible, user-friendly computing environment is also necessary. Such an environment must provide source level debugging and monitoring facilities, analysis and performance tuning tools, and an extended set of user communication programs.
2312#Generalized query-by-rule: a heterogeneous database query language
2313#The use of FORTH language in process control
2314#The ADA task system and real-time applications: an implementation schema
2315#Efficient combinator code
2316#An algorithm for generating abstract syntax trees
2317#Principles and practice of database systems
2318#The development of software for ballistic-missile defense
2319#A taxonomy of problems with fast parallel algorithms
2320#A new solution for the byzantine generals problem
2321#Pseudorandom number generation and space complexity
2322#Fast triangulation of the plane with respect to simple polygons
2323#How to search history
2324#Algorithms for approximate string matching
2325#Propositional dynamic logic of flowcharts
2326#Two complete axiom systems for a theory of communicating sequential processes
2327#Parallel computer architectures and problem solving strategies for the consistent labeling problem are studied. Problem solving factors include: processor intercommunication methods, passing order, and selection of the initial processor to receive the problem.
2328#Usually, higher programming languages provide a floating point arithmetic without specifying the accuracy of the operations. In contrast, ADA defines the operations by means of model numbers and rounding (see [2], [11]). Nevertheless, this definition is not strong enough to satisfy the modern requirement of maximum accuracy in all spaces of scientific computation (see [7]-[9]). By this we mean that no computer representable element lies between the actual and the computer generated result of an operation. The object of this paper is to specify the new arithmetic in ADA for all usual numerical data types. The new arithmetic is made available in a convenient operator form.
2329#The performance of various access control protocols for bit-serial local area computer network (LACN) rings is studied. Applications in which mnessage packets are of fixed length and shorter than the total inherent propagation delay around the ring are the focus of attention. Token, slotted, and static and dynamic insertion rings are included in the study. In all cases, the transmitting station is responsible for removing its transmitted packet from the ring. Under this type of removal rule, it is possible for the stations of all types of ring structures to execute their access control algorithms with only a short fixed in-line delay in each station. The insertion rings dynamically switch longer delays (insertion registers) into the ring when they are transmitting a packet. The transmitter-remove rule operates in such a way that hogging of the ring transmission facility by a subset of stations cannot occur. Expressions that approximate average transfer time as a function of utilization are derived for all ring types and are checked by simulation. The expressions are found to be quite accurate at low ring utilization levels, which is the case of most importance for LACN's; but some of them exhibit significant errors at high utilization levels. For the assumed, short-packet environment, it is found that token rings exhibit the slowest transfer times, while dynamic insertion rings are fastest.
2330#This paper presents an architectural design for a back-end database machine (DBM) suitable for supporting multiple-user, on-line, very large relational database systems (systems with capacities larger than 1010 bytes). This machine is called the Michigan Relational Database Machine (MIRDM). In designing such a machine a structured approach is followed. First, the DBM's proposed so far are reviewed using a novel classification scheme. Second, this review, the very large relational database system requirements, and the restrictions imposed by the current and near-future state of technology are used to formulate a set of design guidelines. Consequently, an architecture for a cost-effective DBM that meets this set of guidelines is synthesized. Some of the algorithms developed for implementing the primitives of the new machine are also presented. Finally, we highlight some of the important differences between the new DBM and some of the previously proposed ones.
2331#The theory and design of systematic t-unidirectional error-detecting codes are developed. Optimal systematic codes capable of detecting 2, 3, and 6 unidirectional errors using 2, 3, and 4 check bits, respectively, are given. For r =5 where r is the number of check bits, the systematic codes described here can detect up to 5· 2r-4 + r -4 unidirectional errors. Encoding/ decoding methods for these codes are also investigated.
2332#A new approach to the design of gracefully degradable processor arrays is discussed. Fault tolerance and graceful degradation are achieved by simultaneously reconfiguring the processor array and the algorithm in execution. Two types of algorithm reconfigurability are considered, namely, row reconfigurability (RR) and row-column reconfigurability (RCR). correspondingly, two array reconfiguration schemes are discussed, i.e., successive row elimination (SRE) and alternate row-column elimination (ARCE). It is shown that the computations of any algorithm executable in a processor array can always be (re) organized so that the resultant algorithm has the RR and/or RCR properties. Upper bounds on the increase in execution time of an algorithm due to reorganization of computations for reconfigurability are derived. Detailed analysis of performance and reliability is done for both SRE and ARCE reconfiguration schemes. These reconfiguration techniques are applicable to any processor array and suitable for VLSI technology.
2333#The paper examines the problem of counting all interferences between a set of rectangular paths. Tight upper bounds on the number of overlaps and intersections between two or more rectangular paths are derived both for the general case and the special cases where the backtracking is not allowed in one or both directions. An optimal algorithm for counting all interferences for both the special and general cases is presented.
2334#Arithmetic AN codes are useful for error correction in both arithmetic operations and digital data transmission. This paper presents a theoretical approach to a new class of nonbinary arithmetic AN codes using symmetric R-ary expressions and Lee-type arithmetic distance.
2335#Time-slot assignment for TDMA-systems
2336#Computing the characteristic polynomial of a tree
2337#Relative error in floating-point multiplication
2338#Accurate arithmetic results for decimal data on non-decimal computers
2339#Arithmetically improved algorithmic performance
2340#On higher order centered forms
2341#Enclosing the solution set of linear systems with inaccurate data by iterative methods based on incomplete LU-Decompositions
2342#Including iterations for the lambda-matrix eigenproblem
2343#Convex spline interpolants with minimal curvature
2344#Advanced UNIX programming
2345#Necessary and sufficient conditions for the universality of programming formalisms
2346#Complete problems for space bounded subclasses of NP
2347#Global storage cells for attributes in an attribute grammar
2348#Complexity of the word problem for commutative semigroups of fixed dimension
2349#Replaceability and computational equivalence for monotone Boolean functions
2350#On the worst case performance of buddy systems
2351#The formalization of the architecture of documents and text formatting are the central issues of this paper. Besides a fundamental and theoretical approach toward these topics, an overview is presented of the COBATEF system. The COBATEF system is a context-based text formatting system, for which a software, as well as a hardware, implementation is available.A unique feature of the system is its automatic text-element recognition mechanism, which is context based and consequently takes advantage of the implicit structure of text. A predefined layout for each type of text element then opens the way for a fully automatic text-processing system in which user control information can be reduced to an absolute minimum.
2352#DITROFF/FFORTID, a collection of pre- and postprocessors for the UNIX DITROFF (Device Independent Typesetter RunOFF) is described. DITROFF/FFORTID permits formatting of text involving a mixture of languages written from left to right and from right to left, such as English and Hebrew. The programs are table driven or macro-generated to permit them to be used for any languages written from left to right and from right to left so long as fonts with the proper character sets can be mounted on a typesetting device supported by DITROFF. The preprocessors are set up to permit phonetic, unidirectional input of all of the alphabets needed using only the two alphabets (each case counts as an alphabet) available on the input device. These macro-generated preprocessors can be adjusted to the user's pronunciation, the language's rules about a letter's form, depending on its position in the word, and the language of the user's input keyboard. The postprocessor is set up to properly change direction of formatting when the text switches to a language written in a different direction. The collection of programs is also designed to allow use of any of DITROFF's preprocessors, such as PIC, EQN, TBL, and the various device drivers.
2353#An informal methodology is described for optimizing the likelihood of computer-generated records being admissible in a U.S. court of law. This methodology is intended for individuals who are converting to automated office procedures, as well as for those whose businesses are already highly computerized. However, this paper does not purport to be a formal legal guide; rather, it is intended as an overview of this issue.
2354#An imperative sentence processor that enables a user to manipulate text with connected speech and touch-graphics input is described. The processor includes capabilities to follow dialogue focus, execute a variety of imperative commands, and handle nested noun groups, pronouns, and other phenomena. A micromodel of the system, giving enough of the structure to enable the reader to observe internal mechanisms in considerable detail, is included. This processor is designed to be transportable to a number of other office automation domains such as calendar management, message-passing, and desk calculation. Various examples and statistics related to its behavior in the text manipulation application are given. The system has been implemented in PASCAL and can run on any machine that supports this language.
2355#MODULA-2: a seafarer's guide and shipyard manual
2356#Run: computer education; 2nd ed.
2357#Assembly language programming for the VAX-11
2358#Proc. of the sixth int'l. symposium on Computing methods in applied sciences and engineering, VI
2359#Artificial intelligence in business, science, and industry. Vol. II: applications
2360#What every engineer should know about computer modeling and simulation
2361#MODULA-2: an introduction
2362#Document formatting and typesetting on the UNIX system
2363#Programming productivity
2364#Computer architecture (3rd. ed.)
2365#Programming languages (2nd ed.)
2366#Logic for computer science: foundations of automatic theorem proving
2367#Computer interpretation of natural language descriptions
2368#Introduction to data communications and computer networks
2369#Artificial intelligence: the very idea
2370#Normalization and axiomatization for numerical dependencies
2371#The equivalence problem and correctness formulas for a simple class of programs
2372#On simple programs with primitive conditional statements
2373#Sublattices of the polynomial time degrees
2374#NEGO—group decision support system
2375#Systems analysis in a complex environment: an interactive educational approach
2376#Managing the microcomputer movement on campus
2377#An IS case: the closed loop scenario
2378#The professional microcomputer handbook
2379#Online information systems: use and operating characteristics, limitations, and design alternatives
2380#Numerical methods for hope bifurcation and continuation of periodic solution paths
2381#On some multigrid finite difference schemes which describe everywhere non differentiable functions
2382#Partial differential equations with hysteresis functionals
2383#Normal forms for singularities of nonlinear ordinary differential equations
2384#Discrete asymptotic behavior for a nonlinear degenerate diffusion equation
2385#Software development based on multigrid techniques
2386#LOGO: MIT LOGO for the Apple
2387#Parabolic multi-grid methods
2388#Multigrid acceleration of an iterative method with application to transonic potential flow
2389#IBM PC/8088 assembly language programming
2390#Information management research in Europe
2391#The fifth generation computer systems and its computer architecture
2392#Information technology: practice, potential, limitations and effects on the profession
2393#Intelligent information retrieval
2394#Library and information networks in Western Europe
2395#Library automation: a current review
2396#Term banks for tomorrow's world: translating and the Computer 4
2397#The transition years: new initiatives in the education of professional information workers
2398#The translator's handbook
2399#UK online search services; second edition
2400#Increasing the performance of mathematical software through high-level modularity
2401#Vector preconditioning for the conjugate gradient on CRAY-I and CDC CYBER 205
2402#A generalization of the numerical schwarz algorithm
2403#Computing generalized inverses and eigenvalues of symmetric matrices using sytolic arrays
2404#Asymptotic expansions for finite element approximation of elliptic problem on polygonal domains
2405#On some applications of the particle method
2406#Recent advances in the analysis of chebyshev and legendre spectral methods for boundary value problems
2407#Vibrations with unilateral constraints
2408#Numerical solution of a model problem from collapse load analysis
2409#Global existence theorems on nonstationary stratified flow of incompressible vis
2410#Spatial discretization techniques for the navier-stokes equations: theoretical and computational results
2411#On a class of TVD schemes for gas dynamic calculations
2412#Multidimensional explicit difference schemes for hyperbolic conservation laws
2413#LISP: the language of artificial intelligence
2414#A proposal for an extended form of type checking of expressions
2415#The reliability of computer memories
2416#A history of computing technology
2417#POP-11: a practical language for artificial intelligence
2418#Program design using JSP: a practical introduction
2419#Algorithms for some design automation problems
2420#Proverbs for programming in Pascal
2421#Tailoring software for multiple processor systems
2422#Virtual memory management
2423#IDAM file organizations
2424#Handbook of design automation
2425#The artificial intelligence experience: an introduction
2426#Heuristic approach to network database external parameters design
2427#A comparison of a network structure and a database system used for document retrieval
2428#Performance of a multi-key access method based on descriptors and superimposed coding techniques
2429#Information systems with attribute decomposition
2430#Essential information structure diagrams and database schema design
2431#Design of a distributed CODASYL database
2432#An analytical comparison of some rule-learning programs
2433#Making compromises among antagonist constraints in a planner
2434#Processing of semantic nets on dataflow architectures
2435#Closed-world databases and circumscription
2436#Automating control for logic programs
2437#Negation as failure. II
2438#Metalogical control for logic programs
2439#Integrity constraints in logic databases
2440#A sweep-plane algorithm for computing the Euler-characteristic of polyhedra represented in Boolean form
2441#Elimination of redundant operations in relational queries with general selection operators
2442#On roundoff error distributions in floating point and logarithmic arithmetic
2443#Probabilistic error analysis of Gaussian elimination in floating point and logarithmic arithmetic
2444#Systems analysis and design: method & invention
2445#Logic, algebra and databases
2446#American standard handbook of software law
2447#Purchasing computer software products: a guide for users of computer software, based on the Institute of Purchasing and Supply model form of licence agreement for the use of computer software products
2448#Communication & information technologies: freedom of choice for Latin America?
2449#The multiple-processor PPS chip of the NON-VON 3 supercomputer
2450#Architectures for language recognition
2451#Some results on the design of regular structured sequential circuits
2452#VLSI implementation of iterative methods for the solution of linear systems
2453#A router for channels of nonuniform width containing preplaced wiring and obstacles
2454#A classification of the literature on computers and the social sciences
2455#The political character of computerization in service organizations: citizen interests or bureaucratic control
2456#Discrimination against females and minorities in microcomputer advertising
2457#Keyboarding as a social form
2458#New horizons in educational computing
2459#Tomorrow's classrooms
2460#Why LOGO?
2461#Designing computer-based microworlds
2462#Model building, mathematics and LOGO
2463#Two notions of dependency satisfaction, consistency and completeness, are introduced. Consistency is the natural generalization of weak-instance satisfaction and seems appropriate when only equality-generating dependencies are given, but disagrees with the standard notion in the presence of tuple-generating dependencies. Completeness is based on the intuitive semantics of tuple-generating dependencies but differs from the standard notion for equality-generating dependencies. It is argued that neither approach is the correct one, but rather that they correspond to different policies on constraint enforcement, and each one is appropriate in different circumstances. Consistency and completeness of a state are characterized in terms of the tableau associated with the state and in terms of logical properties of a set of first-order sentences associated with the state. A close relation between the problems of testing for consistency and completeness and of testing implication of dependencies is established, leading to lower and upper bounds for the complexity of consistency and completeness. The possibility of formalizing dependency satisfaction without using a universal relation scheme is examined.
2464#LOGO for teacher education
2465#A high-resolution raster-graphics display is usually combined with processing power and a memory organization that facilitates basic graphics operations. For many applications, including interactive text processing, the ability to quickly move or copy small rectangles of pixels is essential. This paper proposes a novel organization of raster-graphics memory that permits all small rectangles to be moved efficiently. The memory organization is based on a doubly periodic assignment of pixels to M memory chips according to a “Fibonacci” lattice. The memory organization guarantees that, if a rectilinearly oriented rectangle contains fewer than M/ @@@@5 pixels, then all pixels will reside in different memory chips and thus can be accessed simultaneously. Moreover, any M consecutive pixels, arranged either horizontally or vertically, can be accessed simultaneously.We also define a continuous analog of the problem, which can be posed as: “What is the maximum density of a set of points in the plane such that no two points are contained in the interior of a rectilinearly oriented rectangle of unit area?” We show the existence of such a set with density 1/ @@@@5, and prove this is optimal by giving a matching upper bound.
2466#Given a nonnegative, irreducible matrix P of spectral radius unity, there exists a positive vector &pgr; such that &pgr; = &pgr;P. If P also happens to be stochastic, then &pgr; gives the stationary distribution of the Markov chain that has state-transition probabilities given by the elements of P. This paper gives an algorithm for computing &pgr; that is particularly well suited for parallel processing. The main attraction of our algorithm is that the timing and sequencing restrictions on individual processors are almost entirely eliminated and, consequently, the necessary coordination between processors is negligible and the enforced idle time is also negligible.Under certain mild and easily satisfied restrictions on P and on the implementation of the algorithm, x(.), the vectors of computed values are proved to converge to within a positive, finite constant of proportionality of &pgr;. It is also proved that a natural measure of the projective distance of x(.) from &pgr; vanishes geometrically fast, and at a rate for which a lower bound is given. We have conducted extensive experiments on random matrices P, and the results show that the improvement over the parallel implementation of the synchronous version of the algorithm is substantial, sometimes exceeding the synchronization penalty to which the latter is always subject.
2467#A very friendly software environment for SOLO
2468#Modelling novice programmer behaviour
2469#Logic as a computer language for children
2470#A query-the-user facility for logic programming
2471#Teaching logic as a computer language in schools
2472#A grammar kit in PROLOG
2473#Pupils, computers and history teaching
2474#Experiencing computation: a tribute to Max Clowes
2475#Beginners need powerful systems
2476#POP-11: an AI programming language
2477#POP-11 for everyone
2478#UNIX and the naive user: children meet a grown-up operating system
2479#Creating a "good" programming language for beginners
2480#FSPICE: a tool for fault modelling in MOS circuits
2481#Inner product rounding error analysis in the presence of underflow
2482#Some techniques for solving linear equation systems with guarantee
2483#Studies in computer science
2484#The development of computer science
2485#Efficient construction and utilisation of approximate riemann solutions
2486#A shock-capturing finite element method
2487#Triangular finite element methods for the euler equations
2488#Numerical methods for the time dependent compressible navier-stokes equations
2489#Large eddy simulation: the next five years
2490#Convection of microstructures (II)
2491#Prediction of in-cylinder processes in reciprocating internal combustion engines
2492#Improved accuracy through superconvergence in the pressure in the simulation of miscible displacement
2493#Mixed finite element methods for petroleum reservoir engineering problems
2494#Some recent progress in steep front calculations for porous flow
2495#Finite-element solution of the semiconductor transport equations
2496#Some recent results and open questions in numerical simulation of semiconductor devices
2497#on Parallel MIMD computation: HEP supercomputer and its applications
2498#HEP architecture, programming and performance
2499#The architecture of HEP
2500#Performance characterization of the HEP
2501#A brief survey of implicit parallelism detection
2502#HEP SISAL: parallel functional programming
2503#Execution support for HEP SISAL
2504#Logic programming on the HEP
2505#Programming the HEP with large-grain data flow techniques
2506#Solving ordinary differential equations on the HEP computer
2507#A parallel linear algebra library for the denelcor HEP
2508#Parallel algorithms for recurrence and tridiagonal equations
2509#Hydrocodes on the HEP
2510#Los Alamos experiences with the HEP computer
2511#Solution of boundary-value problems on HEP
2512#Use of monitors in FORTRAN: a tutorial on the barrier, self-scheduling DO-loop, and askfor monitors
2513#Beginner's guide to microcomputer languages
2514#BASIC
2515#Pascal
2516#LOGO
2517#COMAL
2518#PROLOG
2519#FORTH
2520#Appendix: ASCII
2521#Robot technology and applications
2522#ESPRIT and Robotics Europe
2523#Performance characteristics and performance testing of industrial robots—stateof the art
2524#Project for development of a photogrammetric method for the evaluation of the dynamic performance of industrial robots
2525#Dynamic performance measurement of robot arms
2526#Application of the experimental modal-analysis in the performance testing procedure of industrial robots
2527#A review of safety standards
2528#Safety of robot installations in France
2529#Assessment of programmable electronic systems with particular reference to robotics
2530#Query optimization by semantic reasoning
2531#Occupational safety and industrial robots—present stage of discussions within the tripartite group on robotic safety
2532#Towards developing reliability and safety related standards using systematic methodologies
2533#International standards activities in the field of industrial robots
2534#Standardization in the industrial robot field
2535#A graphical engineering aid for VLSI systems
2536#International standardisation related to industrial robots
2537#Robot languages in the eighties
2538#Robot programming using a high-level language and CAD facilities
2539#Implicit robot programming based on a high level explicit system and using the robot database RODABAS
2540#Robot architecture for the integration of robots into manufacturing cells
2541#Fluid power with micro-processor control: an introduction
2542#The development of a European benchmark for the comparison of assembly robot programming systems
2543#Documenting an organization's computer requirements
2544#An analytic model is used to study the performance of dynamic locking. The analysis uses only the steady-state average values of the variables. The solution to the model is given by a cubic, which has exactly one valid root for the range of parametric values that is of interest. The model's predictions agree well with simulation results for transactions that require up to twenty locks. The model separates data contention from resource contention, thus facilitating an analysis of their separate effects and their interaction. It shows that systems with a particular form of nonuniform access, or with shared locks, are equivalent to systems with uniform access and only exclusive locks.Blocking due to conflicts is found to impose an upper bound on transaction throughput; this fact leads to a rule of thumb on how much data contention should be permitted in a system. Throughput can exceed this bound if a transaction is restarted whenever it encounters a conflict, provided restart costs and resource contention are low. It can also be exceeded by making transactions predeclare their locks. Raising the multiprogramming level to increase throughput also raises the number of restarts per completion. Transactions should minimize their lock requests, because data contention is proportional to the square of the number of requests. The choice of how much data to lock at a time depends on which part of a general granularity curve the system sees.
2545#A natural language information retrieval system with extentions towards fuzzy reasoning
2546#A research model for studying the gender/power aspects of human-computer communication
2547#Novice/expert differences in programming skills
2548#GENIE: a modifiable computer-based task for experiments in human-computer interaction
2549#Interactive fuzzy decision-making for multi-objective nonlinear programming using reference membership intervals
2550#Pictorial interfaces to data bases
2551#Unraveling K-page graphs
2552#On the relationships between Scott domains, synchronization trees, and metric spaces
2553#On relative completeness of Hoare logics
2554#An area-maximum edge length trade-off for VSLI layout
2555#The complexity of cubical graphs
2556#Implicit data structures for weighted elements
2557#A proof rule for fair termination of guarded commands
2558#The complexity of equivalence problems for commutative grammars
2559#Integrated manufacturing modeling system
2560#Simulation - The MIT Press scientific computation series
2561#Software engineering considerations for the design of simulation languages
2562#An introduction to digital image processing
2563#Networking and data communications
2564#Transducers for microprocessor systems
2565#Two deduction rules are introduced to give streamlined treatment to relations of special importance in an automated theorem-proving system. These rules, the relation replacement and relation matching rules, generalize to an arbitrary binary relation the paramodulation and E-resolution rules, respectively, for equality, and may operate within a nonclausal or clausal system. The new rules depend on an extension of the notion of polarity to apply to subterms as well as to subsentences, with respect to a given binary relation. The rules allow us to eliminate troublesome axioms, such as transitivity and monotonicity, from the system; proofs are shorter and more comprehensible, and the search space is correspondingly deflated.
2566#Proc. of the IFIP TC3 working conf. on The role of programming in teaching informatics
2567#A survey on teaching programming
2568#Teaching programming to everbody why? to whom? what?
2569#Teaching programming by correspondence
2570#Teaching programming in high schools
2571#Are there cultural reasons for teaching programming?
2572#A possible future for the teaching of programming in Canada
2573#Computer education for engineers: beyond programming languages
2574#Recent evolution in teaching programming in business schools
2575#Programming for teachers
2576#The importance of PROLOG
2577#Object oriented languages: a better way to teach programming?
2578#Impacts of functional languages on teaching and programming methodology
2579#Computing and the humanities
2580#Unity of informatics
2581#The importance of written reports in programming education
2582#Teaching programming at various levels of formality
2583#On the role of theory in teaching programming
2584#Teaching programming through abstract data types
2585#Tough nuts in teaching programming: software engineering
2586#The role of practical work in the teaching of programming
2587#Tough nuts in teaching programming: methodologies
2588#User environments for student programmers
2589#Teaching programming from the cultural angle: a tentative solution
2590#Exploring the PICK operating system
2591#Integrals and series of elementary functions
2592#Integrals and series of special functions
2593#Proc. of the first international conference on Rewriting techniques and applications
2594#Basic features and development of the critical-pair/completion procedure
2595#Contextual rewriting
2596#Thue systems as rewriting systems
2597#Deciding algebraic properties of monoids presented by finite Church-Rosser Thue systems
2598#Two applications of equational theories to database theory
2599#An experiment in partial evaluation: the generation of a compiler generator
2600#NARROWER: a new algorithm for unification and its application to logic programming
2601#Solving type equations by graph rewriting
2602#Termination
2603#Path of subterms ordering and recursive decomposition ordering revisited
2604#Associative path orderings
2605#A procedure for automatically proving the termination of a set of rewrite rules
2606#PETRIREVE: proving Petri net properties with rewriting systems
2607#Fairness in term rewriting systems
2608#Two results in term rewriting theorem proving
2609#Handling function definitions through innermost superposition and rewriting
2610#An ideal-theoretic approach to word problems and unification problems over finitely presented commutative algebras
2611#Combining unification algorithms for confined regular equational theories
2612#An algebraic approach to unification under associativity and commutativity
2613#Unification problems with one-sided distributivity
2614#Fast many-to-one matching algorithms
2615#Complexity of matching problems
2616#The set of unifiers in typed &lgr;-calculus as regular expression
2617#Formal techniques for data base design
2618#In spite of the wide variety of concurrency control and recovery mechanisms proposed during the past decade, the behavior and the performance of various concurrency control and recovery mechanisms remain largely not well understood. In addition, although concurrency control and recovery mechanisms are intimately related, the interaction between them has not been adequately explored. In this paper, we take a unified view of the problems associated with concurrency control and recovery for transaction-oriented multiuser centralized database management systems, and we present several integrated mechanisms. We then develop analytical models to study the behavior and compare the performance of these integrated mechanisms, and we present the results of our performance evaluation.
2619#Proc. of a symposium on Computer culture: the scientific, intellectual, and social impact of the computer
2620#The social impact of the computer
2621#Coping with complexity
2622#The information revolution: developments and consequences by 2000 A.D
2623#Experimental computer science
2624#Computer image synthesis: shapes
2625#Computer image synthesis: rendering techniques
2626#Democratic choice and technological change
2627#Alternatives for the organization of work in computer-assisted manufacturing
2628#Knowledge engineering: the applied side of artificial intelligence
2629#Knowledge technology: the promise
2630#Fifth generation computers: some theoretical issues
2631#Some expert systems need common sense
2632#Panel discussion: Has artificial intelligence research illuminated human thinking?
2633#Fundamental physical limitations of the computational process
2634#The formation of three-dimensional biological structures: computer uses and future needs
2635#Selective networks and recognition automata
2636#Taming and civilizing computers
2637#Worsening the knowledge gap: the mystique of computation builds unnecessary barriers
2638#Computer-assisted negotiations: a case history from the law of the sea negotiations and speculation regarding future uses
2639#The role of the computer metaphor in understanding the mind
2640#Homeostasis in synchronous distributed computation, a formal view
2641#Microcomputer art
2642#Analog-digital conversion handbook; 3rd ed.
2643#Robots: machines in man's image
2644#Electronic logic systems
2645#We consider networks of processors where each processor either has one in-link and one out-link, or two in-links and two out-links. We study three properties of such networks: 1) diameter, 2) connectivity, and 3) the ring property. We propose a class of networks which seem to achieve the optimum as far as these three properties are concerned.
2646#This note provides a design of a binary comparator with completion signal. The average propagation delay is a constant, independent of n, the number of inputs, while the logic complexity is a linear function of n.
2647#We give necessary and sufficient conditions in order that the infinite product or sum of the terms of a positive decreasing sequence generates the reals in a given interval.
2648#A constrained regularization program for inverting linear algebraic and integral equations (CONTIN) [l]-[3] has been implemented on an MC68000 based desktop computer supplemented with floating point accelerator hardware. Implementation of CONTIN on a desktop computer system enhances interactive capabilities and allows economical and time-efficient use of this program on a regular basis within the laboratory.
2649#Videotex is a system which provides users with low-cost real-time access to information. In such a system, user requests are forwarded to a service computer where the desired information is retrieved and sent back to the user. In this study, we investigate the response time behavior of a videotex system where information requested by one user is broadcast to all users. A novel queueing model for broadcast delivery is developed. Using this model, we first obtain an analytic expression for the mean response time, and then we develop an efficient algorithm for its computation. Numerical results illustrating the performance characteristics of broadcast delivery are presented.
2650#When there is no division circuit available, the arithmetical function of division is normally performed by a library subroutine. The library subroutine normally allows both the divisor and the dividend to be variables, and requires the execution of hundreds of assembly instructions. This correspondence provides a fast algorithm for performing the integer division of a variable by a predetermined divisor. Based upon this algorithm, an efficient division routine has been constructed for each odd divisor up to 55. These routines may be implemented in assembly languages, in microcodes, and in special-purpose circuits.
2651#The problem of diagnostic test scheduling (DTS) is to assign to each edge e of a diagnostic graph G a time interval of length l(e) so that intervals corresponding to edges at any given vertex do not overlap and the overall finishing time is minimum. In this correspondence we show that the DTS problem is NP-complete. Then we present a longest, first sequential scheduling algorithm which runs in worst case time O(dm log n) and uses O(m) space to produce a solution of length less than four times optimal. Then we show that the general performance bound can be strengthened to 3 * OPT(G) for low-degree graphs and to 2 ·OPT(G) in some special cases of binomial diagnostic graphs.
2652#An algorithm for computing bounds on the performance measures of multiple-class, product-form queuing networks is presented. The algorithm offers the user a hierarchy of bounds with differing accuracy levels and computational cost requirements. Unlike previously proposed bounding algorithms, the algorithm is applicable to all of the types of product-form queuing networks that are commonly used in computer system and computer-communication network applications.
2653#Elementary translations between various kinds of recursive trees are presented. It is shown that trees of either finite or countably infinite branching can be effectively put into one-one correspondence with infinitely branching trees in such a way that the infinite paths of the latter correspond to the “P-abiding” infinite paths of the former. Here P can be any member of a very wide class of properties of infinite paths. For many properties ??, the converse holds too. Two of the applications involve (a) the formulation of large classes of highly undecidable variants of classical computational problems, and in particular, easily describable domino problems that are III11-complete, and (b) the existence of a general method for proving termination of nondeterministic or concurrent programs under any reasonable notion of fairness.
2654#In this paper an O(N log N) algorithm for routing through a rectangle is presented. Consider an n-by-m rectangular grid and a set of N two-terminal nets. A net is a pair of points on the boundary of the rectangle. A layout is a set of edge-disjoint paths, one for each net. Our algorithm constructs a layout, if there is one, in O(N log N) time; this contrasts favorably with the area of the layout that might be as large as N2. The layout constructed can be wired using four layers of interconnect with only O(N) contact cuts. A partial extension to multiterminal nets is also discussed.
2655#An exception-handling facility suitable for languages used to implement database-intensive information systems is presented. Such a mechanism facilitates the development and maintenance of more flexible software systems by supporting the abstraction of details concerning special or abnormal occurrences. The type constraints imposed by the schema as well as various semantic integrity assertions are considered to be normalcy conditions, and the key contribution of this work is to allow exceptions to these constraints to persist. To achieve this, solutions are proposed to a range of problems, including sharing and computing with exceptional information, exception handling by users, the logic of constraints with exceptions, and implementation issues. The use of exception handling in dealing with null values, estimates, and measurement is also illustrated.
2656#Computer music is a relatively new field. While a large proportion of the public is aware of computer music in one form or another, there seems to be a need for a better understanding of its capabilities and limitations in terms of synthesis, performance, and recording hardware. This article addresses that need by surveying and discussing the architecture of existing computer music systems.System requirements vary according to what the system will be used for. Common uses for computer music systems include composition, performance, research, home entertainment, and studio recording/mixing. This paper outlines system components with this wide diversity of possible uses in mind.Current synthesis and analysis techniques, and the different way in which these techniques can be implemented in special-purpose hardware, are comprehensively reviewed. Design specifications are given for certain digital-to-analog (and analog-to-digital) converters, disk interfaces, system organization, control hardware and software, and numerical precision.Several synthesis systems are described in detail, with an emphasis on theoretical developments and innovative design. Commercial synthesizers and other architectures are also briefly mentioned.
2657#A hypergraph formalism is introduced to represent database schemata. In particular, a database schema B, described by one full join dependency and a set of functional dependencies, is represented by a (database) hypergraph H, containing both undirected and directed hyperedges. Undirected hyperedges correspond to the relations in the join dependency, and directed hyperedges correspond to the functional dependencies. In addition, two classes of database hypergraphs are defined: e-acyclic hypergraphs and e-independent hypergraphs. A hypergraph is e-acyclic if it is equivalent to some acyclic hypergraph; it is e-independent if it is equivalent to some independent (i.e., cover-embedding) hypergraph. Furthermore, the closure of a database hypergraph is defined as the extension of the transitive closure of a graph. By using a lower bound and an upper bound of the hypergraph closure (called L-closure and U-closure, respectively), it is proved that two e-acyclic (e-independent) hypergraphs are equivalent if and only if they have the same closure. Moreover, a hypergraph is e-acyclic (e-independent) if and only if its closure is acyclic (independent) and, in most cases, such a recognition can be done in polynomial time. Finally, it is shown how to use the database hypergraph closure to solve some database design problems.
2658#The optimization problem for linear functions on finite languages is studied, and an (almost) complete characterization of those functions for which a primal and a dual greedy algorithm work well with respect to a canonically associated linear programming problem is given. The discussion in this paper is within the framework of ordered languages, and the characterization uses the notion of rank feasibility of a weighting with respect to an ordered language. This yields a common generalization of a sufficient condition, obtained recently by Korte and Lovász for greedoids, and the greedy algorithm for ordered sets in Faigel's paper [6]. Ordered greedoids are considered the appropriate generalization of greedoids, and the connection is established between ordered languages, polygreedoids, and Coxeteroids. Answering a question of Björner, the author shows in particular that a polygreedoid is a Coxeteroid if and only if it is derived from an integral polymatroid.
2659#The differences between and appropriateness of branching versus linear time temporal logic for reasoning about concurrent programs are studied. These issues have been previously considered by Lamport. To facilitate a careful examination of these issues, a language, CTL*, in which a universal or existential path quantifier can prefix an arbitrary linear time assertion, is defined. The expressive power of a number of sublanguages is then compared. CTL* is also related to the logics MPL of Abrahamson and PL of Harel, Kozen, and Parikh. The paper concludes with a comparison of the utility of branching and linear time temporal logics.
2660#The age of access: information technology and social revolution: posthumous papers of Colin Cherry
2661#Consider a network of communicating finite state machines that exchange messages over unbounded FIFO channels. Each machine in the network can be defined by a directed graph whose nodes represent the machine states and whose edges represent its transitions. In general, for a node in one of the machines to be live (i.e., encountered infinitely often during the course of communication), each machine in the network should progress in some fair fashion. We define three graduated notions of fair progress (namely, node fairness, edge fairness, and network fairness), and on this basis we define three corresponding degrees of node liveness. We discuss techniques to verify that a given node is live under each of these fairness assumptions. These techniques can be automated; and they are effective even if the network under consideration has an infinite number of reachable states. We use our techniques to establish the liveness of some practical communication protocols; these include an unbounded start-stop protocol, an unbounded alternating bit protocol, and a simplified version of the CSMA/CD protocol for local area networks.
2662#In Part 1 of this paper [5], we presented a scheme whereby a compiler could propagate demands through programs in a powerful stream language L. A data-driven evaluation of the transformed program performed exactly the same computation as a demand-driven evaluation of the original program. In this paper we explore a different transformation, which trades the complexity of demand propagation for a bounded amount of extra computation on some data lines.
2663#The “referential transparency” principle of applicative language expressions stipulates that a single value exists for all occurrences of an expression in a given context (where a context is a set of bindings of variables to values). In principle, each such value therefore need to be computed only once. However, in applicative language systems supporting recursive programming or tasking notions, the bindings are not all precomputed and explicit. As a result, textual recognition of all multipleoccurrences is precluded, with the unfortunate consequence that such occurrences are recomputed. We elaborate upon the early notion of “memo function” for solving this problem. We suggest syntactic and semantic constructs providing programmer control for avoiding recomputation, which is incorporated into a “building-block” approach.
2664#A framework is presented for adding a general Undo facility to programming languages. A discussion of relevant literature is provided to show that the idea of Undoing pervades several areas in computer science, and even other disciplines. A simple model of computation is introduced, and it is augmented with a minimal amount of additional structure needed for recovery and reversal. Two different interpretations of Undo are motivated with examples. Then, four primitives are defined in a language-independent manner; they are sufficient to support a wide range of Undo capability. Two of these primitives carry out state saving, and the others mirror the two versions of the Undo operation. Properties of and relationships between these primitives are explored, and there are some preliminary remarks on how one could implement a system based on this formalism. The main conclusion is that the notions of recovery and reversal of actions can become part of the programming process.
2665#The problem of concurrent accesses to registers by asynchronous components is considered. A set of axioms about the values in a register during concurrent accesses is proposed. It is shown that if these axioms are met by a register, then concurrent accesses to it may be viewed as nonconcurrent, thus making it possible to analyze asynchronous algorithms without elaborate timing analysis of operations. These axioms are shown, in a certain sense, to be the weakest. Motivation for this work came from analyzing low-level hardware components in a VLSI chip which concurrently accesses a flip-flop.
2666#The three c's: children, computers, and communication
2667#Medicine in the age of the computer
2668#Proc. of a conference on The analysis of concurrent systems
2669#Using algebra for concurrency: some approaches
2670#Some aspects of net theory
2671#From state machines to temporal logic: specification methods for protocol standards
2672#A practical approach to the analysis of concurrent systems
2673#An analysis of humanists' requests received by an information service for the humanities
2674#Costing management information—a more formal approach
2675#Promoting the concept of information management within organisations
2676#The history of computer use in libraries based on bibliographic inferences
2677#The valuing of management information. Part II: using the cost of not having information
2678#Phasing into the communications revolution
2679#International standard for an office document architecture model
2680#Comparison of search techniques (printed and computerised) with specific reference to the RTECS databank
2681#The valuing of management information. Part III: estimation heuristics
2682#Information as the possible
2683#In search of searching skills
2684#Using the micro-computer to simplify database access: designing interfaces to complex files
2685#Towards a new pricing structure for online databases
2686#The valuing of management information. Part IV: a practical approach
2687#Notions and dynamics of information
2688#Sophisticated science in a small country: a scientometric analysis of superconductivity research in Israel
2689#“Sources of information on specific subjects”
2690#Patent novelty; proposals for change and their possible impact on information scientists
2691#An adaptation of a root finding method to searching ordered disk files
2692#Implementation of the grid file: design concepts and experience
2693#Compression of character strings by an adaptive dictionary
2694#On permutative grammars generating context-free languages
2695#Notes on the complexity of sorting in abstract machines
2696#Recent developments in parallel and vector processing
2697#Remarks on homogenization
2698#Efficient algorithms for post buckling computation
2699#IBM LOGO primer
2700#On the order of the error in discretization methods for weakly singular second kind volterra integral equations with non-smooth solutions
2701#The accurate solution of certain continuous problems using only single precision arithmetic
2702#B-convergence of the implicit midpoint rule and the trapezoidal rule
2703#On the number of polynomials over GF(2) that factor into 2, 3 or 4 prime polynomials
2704#Reducible runge-kutta methods
2705#A modification of the classical quadrature method for locating zeros of analytic functions
2706#Integration methods for solving equations
2707#A study in string processing languages
2708#Videotex and education: current developments in screen design, data structure, and access control
2709#Development of a hand-held computerized vocabulary tutor
2710#Embedded training: the new look of computer-based instruction
2711#on Proceedings of the fourth British national conference on databases (BNCOD 4)
2712#Higher level relational objects
2713#An access control system for database languages
2714#Towards a flexible mechanism for concurrency control in database systems
2715#The qualified binary relationship model of information
2716#Action modelling: a symmetry of data and behaviour modelling
2717#Bidirectional mapping between a user-oriented conceptual schema and a target logical schema: the ACS
2718#Modelling-primitives for a software engineering database
2719#A flexible DBMS for research and teaching (PRECI/C)
2720#Distributed data management in a real-time environment
2721#The integration of the network and relational approaches in a DBMS
2722#Some observations on user interface design and user performance
2723#Databases and office automation
2724#Proc. of a symposium to explore the computer's impact on society on The computer culture
2725#Why people think computers can't
2726#The problem of natural language
2727#Models, simulation, and system dynamics
2728#Computers and communication
2729#Computers, armaments, and stability
2730#Privacy, technology, and regulation
2731#Postscript: computers and the modeling of mind
2732#Your office is where you are
2733#A critique of UNIX
2734#Specifications and an implementation of the type-ambiguity problem in PASCAL
2735#A high level language based system for cross-assembler definition
2736#Implementation of an interpreter for abstract equations
2737#Compact recursive-descent parsing of expressions
2738#Perception of transparency in man and machine
2739#Early vision: from computational structure to algorithms and parallel hardware
2740#Preattentive processing in vision
2741#Connectionist models and parallelism in high level vision
2742#Generative systems of analyzers
2743#Perception of organization in a random stimulus
2744#Environment-centered and viewer-centered perception of surface orientation
2745#The method of resolvents: a technique for the implicitization, inversion, and intersection of non-planar, parametric, rational cubic curves
2746#Exact offset procedures for simple solids
2747#Derivative generation from multivariate scattered data by functional minimization
2748#Smooth closed surfaces with discrete triangular interpolants
2749#Some remarks concerning B-splines
2750#Curvature continuous curves and surfaces
2751#Some remarks on V2-splines
2752#The design algorithm of a differential group programmable logic array (DGPLA) to generate the precise binary logarithm function is suggested. It can reach an optimal condition such that the number of bits in a PLA is minimized, while the error is still kept as small as possible. Thus, the space in the PLA is saved, estimated at only 15.94 percent of the space for a readonly memory (ROM) counterpart.
2753#The VAX-11/7801 was designed specifically to implement the VAX architecture. As such, it does not support the IEEE standard for floating point arithmetic. A project was undertaken to provide this support by modifying the 11/780 microarchitecture. Our objective was to produce a microengine that would efficiently execute the VAX instruction set, modified to handle VAX floating point instructions in accordance with the IEEE standard. Our methodology was to make minimal changes to the 11/780 hardware, relying primarily on changes to the microcode. This paper describes the modifications required to implement the IEEE standard, examines the various design alternatives available to us, presents measurements of our implementation, and analyzes our results. We also offer some comments on the matter of retrofitting an existing architecture to a new unintended use.
2754#Finite field arithmetic logic is central in the implementation of Reed-Solomon coders and in some cryptographic algorithms. There is a need for good multiplication and inversion algorithms that can be easily realized on VLSI chips. Massey and Omura [1] recently developed a new multiplication algorithm for Galois fields based on a normal basis representation. In this paper, a pipeline structure is developed to realize the Massey-Omura multiplier in the finite field GF(2m). With the simple squaring property of the normal basis representation used together with this multiplier, a pipeline architecture is also developed for computing inverse elements in GF(2m). The designs developed for the Massey-Omura multiplier and the computation of inverse elements are regular, simple, expandable, and therefore, naturally suitable for VLSI implementation.
2755#In this paper, a new class of diagnosable systems, called tp-self-implicating systems, which is a special case of the well-known tp-diagnosable systems introduced by Preparata et al. [1], is described. If there are no more than tp faulty units and the faults are assumed to be permanent, then the faulty units in a tp-self-implicating system can always be identified using at least one of two straight forward criteria associated with test outcomes. In each case, the given faulty unit in effect implicates itself as faulty. Necessary and sufficient conditions are given on the structures of PMC models for self-implication. Finally, an algorithm for identifying the set of faulty units in a tp-self-implicating system is given which is linear in the number of tests in the system, rendering it more efficient than the most efficient known algorithm for the general class of tp-diagnosable systems.
2756#Two binary algorithms for the square rooting of a number or of a sum of two numbers are presented. They are based on the classical nonrestoring method. The main difference lies in the replacement of subtractions and additions by a parallel reduction f three summands, which may be positive and negative, to two summands to eliminate the carry propagation. Two of three summands form the successive partial remainder. Their most significant bit triples, sometimes together with a sign bit of the earlier partial remainder, are used to determine digits -1,0, +1 of a redundant square-root notation. These digits are transformed during the square-rooting process into the conventional notation square-root bits which are next used in further square-rooting steps to form the third reduced summands.
2757#Highly parallel VLSI computing structures consist of many processing elements operating simultaneously. In order for such processing elements to communicate among themselves, some provision must be made for synchronization of data transfer. The simplest means of synchronization is the use of a global clock. Unfortunately, large clocked systems can be difficult to implement because of the inevitable problem of clock skews and delays, which can be especially acute in VLSI systems as feature sizes shrink. For the near term, good engineering and technology improvements can be expected to maintain the feasibility of clocking in such systems; however, clock distribution problems crop up in any technology as systems grow. An alternative means of enforcing necessary synchronization is the use of self-timed asynchronous schemes, at the cost of increased design complexity and hardware cost. Realizing that different circumstances call for different synchronization methods, this paper provides a spectrum of synchronization models; based on the assumptions made for each model, theoretical lower bounds on clock skew are derived, and appropriate or best possible synchronization schemes for large processor arrays are proposed.
2758#A fast serial-parallel (FSP) multiplier design is derived from the carry-save add-shift (CSAS) multiplier structure. The CSAS technique accepts multiplier bits serially (lsb first) and produces outputs serially (lsb first). Multiplication of two n bit unsigned numbers requires 2n clock cycles to complete the process out of which n clocks are used for n-row carry-save additions, and the other n clocks are utilized only to propagate the remaining carries. This CSAS structure is modified so that it operates as a CSAS unit for the first n clocks and reconfigures itself as an n bit ripple-carry parallel adder at the (n + 1)st clock, thus allowing the carries to ripple through, eliminating the delay due to storage elements during the last n clocks. It is shown that this modification results in an about one-third increase in speed for an approximately one-third increase in hardware. The technique is extended to signed numbers represented in 2's complement form. Also, it is shown how these implementations can be modularized.
2759#This correspondence seeks to generalize and clarify the general model for memory interference (GMI) in multiprocessors as proposed by Hoogendoorn. The interference model creates a queueing network where some service centers are FCFS with constant service times; therefore, we also apply the mean value analysis (MVA) approxdmation suggested by Reiser to solve this model. Furthermore, we reduce the computations in this approximation by applying the iterative scheme suggested by Schweitzer. Although many authors have studied the memory interference problem, nobody has used the above-mentioned MVA approximations. We study these MVA approximations in the context of the memory interference problem and show that they produce better results with much less computation.
2760#Processors within a real-time multiprocessor system must be synchronized with as little overhead as possible. Although synchronization can be achieved via both software (e.g., interactive convergence and interactive consistency algorithms) and hardware (e.g., multistage synchronizers and phase-locked clocks), phase-locked clocks are most attractive due to their small overheads.
2761#A recently proposed test for uniform random number generators is based on the mean and variance of the outcome of a sequence of iterations. This note points out that many nonuniform random number generators would pass such a test, and derives an improved test based on the exact distribution of the outcome.
2762#This correspondence presents a totally self-checking error indicator for solving the practical problem of monitoring the TSC checkers. We consider TSC checkers designed for checking coded information (data or address) or periodic signals with tolerable transient failures smaller than a constant time limit T, which depends on the propagation delay of the used logic elements. This circuit provides normal indication outputs (01) or (10) and error indication outputs (11) or (00). Permanent failures or transient failures with time duration greater than T result in a permanent error indication, which remains until reset. Provided that an assumed fault occurs within the checker, the permanent error indication output is produced at most after four input changes from (01) to (10) or from (10) to (01).
2763#This correspondence presents a method for proof of correctness of register transfer level (RTL) parallel control sequences that describe hardware behavior. An RTL language endowed with parallel constructs is presented and its semantics is defined. The semantics includes temporal behavior. An assertion-based proof method is presented for verification of parallel control sequences described in this language. An example is given and comparisons are drawn between proofs of parallel register transfer level sequences and parallel programs. The temporal semantics associated with the language permits the construction and proof of parallel sequences that are not possible with parallel programs. Accessing shared resources outside critical regions is possible and is illustrated.
2764#A variation of the tree structure interconnection network for the message switching multiprocessor system is presented in this correspondence. It mainly consists of four binary tree structures, pairs of which are touched by their leaf nodes; in addition, there are four nodes which interface with external environments. The proposed network is left-right and top-down symmetric and is planar. Every node in the interconnection network has the same number of degree, 3. There are multiple paths between any two nodes in the network. Results of the message traffic analysis of the network are presented.
2765#A generalization of the cube-connected cycles of Preparata and Vuillemin is described which retains the symmetry of these architectures while allowing for constructions of greater density and of arbitrary degree. These constructions are of a type known as Cayley graphs, and their analysis is greatly facilitated by the applicability of methods from abstract algebra.
2766#The correspondence examines the functional relations within a class of multistage interconnection networks. It is known that these networks are not rearrangeable. This fact has led to some research on interconnection network relations. The correspondence deals with one aspect of this research, namely, that of constructing an equivalence map between two interconnection networks. Procedures are given to test whether two such networks are equivalent. Whenever they are, these procedures also produce a map to conjugate one network onto the other.
2767#Completeness results for inequality provers
2768#Heuristic classification
2769#A model for the protocol design of back-end storage networks
2770#Software project development cost estimation
2771#The impact of programming methodology on program complexity
2772#STRAPS: A Software TRAnsPort System for low-level software
2773#Musicians make a standard: the MIDI phenomenon
2774#Personal composer
2775#Ensemble timing in computer music
2776#LASSO: an intelligent computer-based tutorial in sixteenth-century counterpoint
2777#Interview with Robert Moog
2778#Reasoning with imprecise knowledge in expert systems
2779#Relational-product architectures for information processing
2780#A model for an expert system for medium access control in a local area network
2781#Symbolic normalized acquisition and representation of knowledge
2782#Detection, decision, and missing information
2783#Implementing imprecision in information systems
2784#Emergency-oriented expert systems: a fuzzy approach
2785#File handling for detail and extent and for subtasks in the implementation of decision processes
2786#Frame representation of physical systems for expert system use
2787#Generalized network modeling and diagnosis using financial ratios
2788#Specialized speech: a first prose for language expert systems
2789#The development of a medical expert system and the treatment of imprecision in the framework of possibility theory
2790#A formal model of diagnostic inference. I. Problem formulation and decomposition
2791#A formal model of diagnostic inference. II. Algorithmic solution and application
2792#Identifying and quantifying the company-wide benefits of CAD within the structure of a comprehensive investment program
2793#Modified adaptive controllers for improving the transients in adaptive control
2794#A hierarchical data structure for representing assemblies: part I
2795#Inference of the positions of components in an assembly: part 2
2796#Computer-generated multi-row schematics
2797#Classification of edges and its application in determining visibility
2798#Table-driven algorithms for generating space-filling curves
2799#Technical note: raster applications with GKS
2800#Advanced information society and telecommunications
2801#ISDN and value-added services in public and private networks
2802#ISDN protocol and architecture models
2803#A step to ISDN planning: from user traffic to service cost comparison
2804#Computer-aided planning of public packet-switched networks
2805#Statistics of mixed data traffic on a local area network
2806#Traffic models for large ISDN-PABX's
2807#Traffic characteristics of control signals in an ISDN switching system
2808#An integrated circuit/packet switching local area network—performance analysis and comparison of strategies
2809#Traffic models for telecommunication services with advance capacity reservation
2810#Attacking a complex distributed algorithm from different sides: an experience wih complementary validation tools
2811#MAC layer interconnection of IEEE 802 local area networks
2812#On the capacity of disjointly shared networks
2813#An optimal election protocol for channel allocation
2814#Proc. of the Third int'l seminar on Distributed data sharing systems
2815#Modeling rule-based systems by stochastic programmed production systems
2816#Fuzzy and probability vectors as elements of a vector space
2817#Context dependent Table matrix L systems
2818#Fuzzy relations and fuzzy groups
2819#Entropy and set covering
2820#The artificial intelligence approach to pattern recognition—a perspective and an overview
2821#Multidimensional attribute analysis and pattern recognition for seismic interpretation
2822#Segmentation of a seismic section using image processing and artificial intelligence techniques
2823#Syntactic pattern recognition for the recognition of bright spots
2824#Image processing of seismograms: (A) Hough transformation for the detection of seismic patterns; (B) thinning processing in the seismogram
2825#Statistical modeling and feature selection for seismic pattern recognition
2826#Identification of seismic stratigraphic traps using statistical pattern recognition
2827#A rule-based system for automatic seismic discrimination
2828#On constructing an expert system for contact localization and tracking
2829#Acoustic signal interpretation: reasoning with non-specific and uncertain information
2830#Recognition of underwater transient patterns
2831#An automatic programming system for signal processing applications
2832#Relativized circuit complexity
2833#Probabilistic counting algorithms for data base applications
2834#Improved upper bounds on Shellsort
2835#Irreducibility of multivariate polynomials
2836#Factoring sparse multivariate polynomials
2837#Games against nature
2838#A technique for partitioning and mapping algorithms into VLSI systolic arrays is presented in this paper. Algorithm partitioning is essential when the size of a computational problem is larger than the size of the VLSI array intended for that problem. Computational models are introduced for systolic arrays and iterative algorithms. First, we discuss the mapping of algorithms into arbitrarily large size VLSI arrays. This mapping is based on the idea of algorithm transformations. Then, we present an approach to algorithm partitioning which is also based on algorithm transformations. Our approach to the partitioning problem is to divide the algorithm index set into bands and to map these bands into the processor space. The partitioning and mapping technique developed throughout the paper is summarized as a six step procedure. A computer program implementing this procedure was developed and some results obtained with this program are presented.
2839#Two sets of conditions are derived that make one- dimensional bilateral arrays of combinational cells testable for single faulty cells. The test sequences are preset and, in the worst case, grow quadratically with the size of the array. Conditions for testability in linear time are also derived. The basic cell can operate at the bit or at the word level. An implementation of FIR filters using (systolic) one-dimensional bilateral arrays of cells, which can be considered combinational at the word level, is presented as an example. A straightforward generalization for the two- dimensional case is made; a systolic array used for matrix multiplication is presented as an example for this case.
2840#The concept of data flow computing is applied to digital signal processing (DSP). A data flow signal processor (DFSP) architecture is presented. The principles of data flow computing are carefully considered in order to conform with the special properties of DSP. The bus oriented architecture is easily configured to meet various performance requirements. The DFSP architecture is most suitable for nonrecursive algorithms. Typical tasks of this nature are transforms and FIR filters. A simulation model of the DFSP architecture has been developed. Simulation results of two application examples are given.
2841#The suffix problem has appeared in solutions of recurrence systems for parallel and pipelined machines and more recently in the design of gate and silicon compilers. In this paper we present two algorithms. The first algorithm generates parallel suffix solutions with minimum cost for a given length, time delay, availability of initial values, and fanout. This algorithm generates a minimal solution for any length n and depth range from log2 n to n. The second algorithm reduces the size of the solutions generated by the first algorithm.
2842#One class of reconfigurable parallel processing systems is based on the use of a large number of processing elements which can be partitioned into multiple virtual machines. Each virtual machine is controlled by one or more control units. The multiple control units in such a system share a common secondary storage for programs. The control units use paging to transfer programs to their primary memories. One design problem is determining the optimal service rate for the secondary storage of the control units, where the "optimal" is characterized by maximum processor utilization. The PASM parallel processing system is used as a example system to study this problem. The implementation of virtual memory on the PASM control system memory hierarchy is discussed and a queueing network model for the memory hierarchy is developed. Based on assumed values for parameters that characterize the expected task environment, an optimal service rate is derived from the model. The values of the parameters in the model can be varied to determine the impact these changes would have on system performance. Simulation results verifying various aspects of the model are presented and the results are generalized.
2843#An approximation for the distribution of time delays experienced by a customer in a network of queues is presented. Approximate analytical models are necessary since exact solutions are only available for a very restricted class of networks, and are too complex computationally to be viable in practice. Approximations have so far often proved inadequate, particularly for closed networks with first come first served queueing disciplines. We also prove that the correlation between the sojourn times at successive servers on a customer's path in a closed queueing network with exponential servers is negative.
2844#The short description given below of the scope, goal, and structure of the Journal of Symbolic Computation is the result of intensive discussions among the persons involved in initiating this journal, The editors will use it as a guide for the development of the journal and potential authors can use it to decide whether to make this journal a forum for their research results.
2845#We show that the application of the resolution principle to a set of clauses can be regarded as the construction of a term rewriting system confluent on valid formulas. This result allows the extension of usual properties and methods of equational theories (such as Birkhoff's theorem and the Knuth and Bendix completion algorithm) to quantifier-free first order theories. These results are extended to first order predicate calculus in an equational theory, as studied by Plotkin (1972), Slagle (1974) and Lankford (1975). This paper is a continuation of the work of Hsiang & Dershowitz (1983), who have already shown that rewrite methods can be used in first order predicate calculus. The main difference is the following: Hsiang uses rewrite methods only as a refutational proof technique, the initial set of formulas being unsatisfiable iff the equation TRUE = FALSE is generated by the completion algorithm. We generalise these methods to satisfiable theories; in particular, we show that the concept of confluent rewriting system, which is the main tool for studying equational theories, can be extended to any quantifier-free first order theory. Furthermore, we show that rewrite methods can be used even if formulas are kept in clausal form.
2846#In this paper the set of first order substitutions with a partial ordering ''more general than'' is investigated. It is proved that the set of equivalence classes of idempotent substitutions together with an added greatest element is a complete lattice. A simultaneous unification of finitely many finite sets of terms can be reduced to unifying each of the sets of terms separately and to building the supremum of the most general unifiers in this lattice afterwards. This saves time in an automatic proof procedure when combined with the concept of weak unification also introduced in this paper.
2847#Let P be a set of n points in the Euclidean plane and let C be a convex figure. We study the problem of preprocessing P so that for any query point q, the points of P in C+q can be retrieved efficiently. If constant time sumces for deciding the inclusion of a point in C, we then demonstrate the existence of an optimal solution: the algorithm requires O(n) space and O(k + log n) time for a query with output size k. If C is a disk, the problem becomes the wellknown fixed-radius neighbour problem, to which we thus provide the first known optimal solution.
2848#We present a fast parallel deterministic algorithm for testing multivariate integral polynomials for absolute irreducibility, that is irreducibility over the complex numbers. More precisely, we establish that the set of absolutely irreducible integral polynomials belongs to the complexity class NC of Boolean circuits of polynomial size and logarithmic depth. Therefore it also belongs to the class of sequentially polynomial-time problems. Our algorithm can be extended to compute in parallel one irreducible complex factor of a multivariate integral polynomial. However, the coeffieients of the computed factor are only represented modulo a not necessarily irreducible polynomial specifying a splitting field. A consequence of our algorithm is that multivariate polynomials over finite fields can be tested for absolute irreducibility in deterministic sequential polynomial time in the size of the input. We also obtain a sharp bound for the last prime p for which, when taking an absolute irreducible integral polynomial modulo p, the polynomial's irreducibility in the algebraic closure of the finite field of order p is not preserved.
2849#A descriptive, non-technical tutorial on MACSYMA, a well-known and widely used Computer Algebra system, is presented. Several examples of its capabilities are exhibited using actual MACSYMA input and output. A discussion of computer-based symbolic mathematical computation is motivated by pointing out inherent difficulties with familiar numeric computations. The inner workings of Computer Algebra systems are briefly discussed in addition to some on-going work on MACSYMA and future directions.
2850#In [10] a method is proposed for decomposing join dependencies (jds) in a relational database using the notion of a hinge. This method was subsequently studied in [11] and [12]. We show how the technique of decomposition can be used to make integrity checking more efficient. It turns out that it is important to find a decomposition that minimizes the number of edges of its largest element. We show that the decompositions obtained with the method described in [10] are optimal in this respect. This minimality criterion leads to the definition of the degree of cyclicity, which allows us to classify jds and leads to the notion of n-cyclicity, of which acyclicity is a special case for n = 2. We then show that, for a fixed value of n (which may be greater than 2). integrity checking can be performed in polynomial time provided we restrict ourselves to n-cyclic jds. Finally, we generalize a well-known characterization for acyclic jds by proving that n-cyclicity is equivalent to “n-wise consistency implies global consistency.” As a consequence, consistency checking can be performed in polynomial time if we restrict ourselves to n-cyclic jds, for a tired value of n, not necessarily equal to 2.
2851#Security of computer based information systems
2852#This paper analyzes the problem of joining two horizontally partitioned relations in a distributed database system. Two types of semijoin strategies are introduced, local and remote. Local semijoins are performed at the site of the restricted relation (or fragment), and remote semijoins can be performed at an arbitrary site. A mathematical model of a semijoin strategy for the case of remote semijoins is developed, and lower bounding and heuristic procedures are proposed. The results of computational experiments are reported. The experiments include an analysis of the heuristics' performance relative to the lower bounds, sensitivity analysis, and error analysis. These results reveal a good performance of the heuristic procedures, and demonstrate the benefit of using semijoin operations to reduce the size of fragments prior to their transmission. The algorithms for the case of remote semijoins were found to be superior to the algorithms for the case of local semijoins. In addition, we found that the estimation accuracy of the selectivity factors has a significant effect on the incurred communication cost.
2853#The growing acceptance of database systems makes their performance increasingly more important. One way to gain performance is to off-load some of the functions of the database system to aback-end computer. The problem is what functions should be off-loaded to maximize the benefits of distributed processing.Our approach to this problem consisted of constructing several variants of an existing relational database system. INGRES, that partition the database system software into two parts, and assigning these two parts to two computers connected by a local area network. For the purposes of this experiment, six different variants of the database software were constructed to test the sir most interesting functional subdivisions. Each variant was then benchmarked using two different databases and query streams. The communication medium and the communication software were also benchmarked to measure their contribution to the performance of each configuration.Combining the database and network measurement results, various conclusions were reached about the viability of the configurations, the desirable properties of the communications mechanisms to he used, the operating system interface and overhead, and the performance of the database system. The variants to be preferred depend on the hardware technology, operating system features, database system internal structure, and network software overhead.
2854#In this paper we study when and how B Byzantine agreement protocol can he used in general-purpose database management systems. We present an overview of the failure model used for Byzantine agreement, and of the protocol itself. We then present correctness criteria for database processing in this failure environment and discuss strategies for satisfying them. In doing this, we present new failure models for input/output nodes and study ways to distribute input transactions to processing nodes under these models. Finally, we investigate applications of Byzantine agreement protocols in the more common failure environment where processors are assumed to halt after a failure.
2855#Computer speech processing
2856#Understanding computers and cognition
2857#C at a glance
2858#Results and problems in combinatorial geometry
2859#Intelligent instrumentation
2860#Getting computers to talk like you and me
2861#Pulse: an ada-based distributed operating system (apic studies in data processing No 26)
2862#Introduction to discrete structures
2863#A model for decision making under fuzzy conditions
2864#An implementation of the expert system DIGS for diagnostics
2865#On one-way two-head deterministic finite state automata
2866#Operating alphabet complexity of homogeneous trellis automata and symmetric functions
2867#Tight chip area bounds for sorting
2868#Eliminating redundant modifications in dictionary machines
2869#Projects of the new generation computer systems and informatics
2870#Scaling algorithms for network problems
2871#Screen design strategies for computer-assisted instruction
2872#Making computers work
2873#A robust procedure for discontinuity handling in continuous system simulation
2874#Rootfinding and interpolation with Runge-Kutta-Sarafyan methods
2875#Mathematical Model of the Fluidized Bed Catalytic Cracking Plant
2876#An Illustration of the Sample Space Definition of Simulation & Variance Reduction.
2877#Block bond graphs for simulation of nonlinear systems: A technical note
2878#On the use of several compact methods for the study of unsteady incompressible viscous flow round a circular cylinder
2879#Power system static state estimation based upon nodal voltages
2880#Decentralized stabilization of large electric power systems
2881#Computer-aided design optimization of polyphase induction motors
2882#A study of two on-line prediction algorithms
2883#Power flow solution using the modified quasilinearization method
2884#Computation of conductor inductances of arbitary shape and position
2885#A semantical database for analysis and control of power systems
2886#Spreadsheet applications in financial accounting
2887#Proc. of a conference on Functional programming languages and computer architecture
2888#Miranda: a non-strict functional language with polymorphic types
2889#Data flow graph optimization in ifi
2890#Strictness analysis—a practical approach
2891#The categorical abstract machine
2892#High order programming in extended FP
2893#Secd-m: a virtual machine for applicative programming
2894#COBWEB—a combinator reduction architecture
2895#How to replace failure by a list of successes
2896#Lazy memo-functions
2897#An architecture for fast data movement in the FFP machine
2898#An architecture that efficiently updates associative aggregates in applicative programming languages
2899#Lambda lifting: transforming programs to recursive equations
2900#Optimizing almost-tail-recursive PROLOG programs
2901#Designing regular array architectures using higher order functions
2902#VFP: an environment for the multi-level specification, analysis, and synthesis of hardware algorithms.
2903#A distributed garbage collection algorithm
2904#Cyclic reference counting for combinator machines
2905#Design for a multiprocessing heap with on-board reference counting
2906#A functional language and modular architecture for scientific computing
2907#Practical polymorphism
2908#Program verification in a logical theory of construction
2909#Transforming recursive programs for execution on parallel machines
2910#Compiling pattern matching
2911#Serial combinators: “optimal” grains of parallelism
2912#The g-machine: a fast, graph-reduction evaluator
2913#Computerized ECG interpretation in ambulatory health care services—optimal configuration of the “heart station”
2914#Optimal student-patient assignment in dental education
2915#Strategic management of technostress: The chaining of Prometheus
2916#Laboratory equipment maintenance contracts
2917#ARMIS: a microcomputer-based hospital risk management information system
2918#A microcomputer program for record keeping in the pharmacy of King Fahad Hospital, Jeddah, Saudi Arabia
2919#Multiprocessing computer system for sensory evoked potentials and EEG spectral analysis for clinical neurophysiology laboratory
2920#Forecasting staffing needs for productivity management in hospital laboratories
2921#Evaluating RECONSIDER: a computer program for diagnostic prompting
2922#Use of outpatient somatic health services by patients who use or need mental health services in three provider plans.
2923#Diagnostic library support system for medical practice
2924#Use of an expert model to test diagnostic criteria in CHARGE syndrome
2925#Legal aspects of computer use
2926#Visible surface calculation for complex unstructured polygonal scenes
2927#Pseudo-recursive procedures
2928#Symbolic calculation of the trace of the power of a tridiagonal matrix
2929#Calculation of Minkowski-reduced lattice bases
2930#Computing simple bifurcation points using a minimally extended system of nonlinear equations
2931#On the solution of discretized obstacle problems by an adapted penalty method
2932#An adaptive multi-grid algorithm for the numerical solution of quasilinear potential equations
2933#Nonlinear stability and phase analysis for adaptive Nystro¨m-Runge-Kutta methods
2934#Invitation to MODULA-2
2935#On the approximate computation of certain strongly singular integrals
2936#Accelerating Krawczyk-like interval algorithms for the solution of nonlinear systems of equations by using second derivatives
2937#Short communications/kurze mitteilungen better extrapolation codes*
2938#A remark on Frank Matrices
2939#Legal protection of microcode and beyond: a discussion of the applicability of the Semiconductor Chip Protection Act and the copyright laws to microcode
2940#Proceedings of landtronics conference held February 15 and 16, 1985 at the annenberg school of communication, University of Southern California.
2941#The “new” local communications: office networks and private cable
2942#Federal, state, and local regulation of video and telecommunications informationsystems-the actual and the ideal.
2943#Technology and the future of central business districts
2944#The new urban telecommunications infrastructure
2945#The prospects for telecommuting
2946#The computer in a finite world
2947#Architects' encounters with computers
2948#Some planning and design considerations for the home office
2949#Electronic village: information technology creates new space
2950#Programming with turbo pascal
2951#Separate compilation in a Modula-2 compiler
2952#A crash resistant UNIX file system
2953#Routines: an argument against the conventional approach to functions and procedures
2954#SOFTLIB—A documentation management system
2955#A new list compaction method
2956#Printing Arabic text using dot matrix printers
2957#Template design for file processing applications
2958#A distributed programs monitor for Berkeley UNIX
2959#An approximation for the inverse distribution function of a combination of random variables, with an application to operating theatres
2960#Decomposition of some well-known variance reduction techniques
2961#A constrained EM algorithm for univariate normal mixtures
2962#A note on approximate convex hulls
2963#EDISON-80, a language for modular programming of parallel processes
2964#A lower bound to the complexity of Euclidean and rectilinear matching algorithms
2965#A fast and simple randomized parallel algorithm for maximal matching
2966#Lower bounds on parallel algorithms for finding the first maximal independent set
2967#Some remarks on the possibility of extending resolution proof procedures to intuitionistic logic
2968#Verifying nonrigidity
2969#Exact balancing is not always good
2970#A class of differential equations for testing variable step-size integration
2971#Prime numbers and computer methods for factorization
2972#Parametric versus rank transform procedures in the two-way factorial experiment: a comparative study
2973#An investigation of Morton's method to distinguish Elizabethan playwrights
2974#Word frequency and text type: some observations based on the LOB corpus of British English texts
2975#Intelligent knowledge-based systems in archaeology: a computerized simulation of reasoning by means of an expert system
2976#Human language and computers
2977#Computers, bibliography, and foreign language typography
2978#Computational lexicography
2979#Terminology: teaming up homo faber and homo linguisticus
2980#Machine translation
2981#A novel formal theory of concurrent systems that does not assume any atomic operations is introduced. The execution of a concurrent program is modeled as an abstract set of operation executions with two temporal ordering relations: “precedence” and “can causally affect”. A primitive interprocess communication mechanism is then defined. In Part II, the mutual exclusion is expressed precisely in terms of this model, and solutions using the communication mechanism are given.
2982#The theory developed in Part I is used to state the mutual exclusion problem and several additional fairness and failure-tolerance requirements. Four “distributed” N-process solutions are given, ranging from a solution requiring only one communication bit per process that permits individual starvation, to one requiring about N! communication bits per process that satisfies every reasonable fairness and failure-tolerance requirement that we can conceive of.
2983#The problem of partitioning a polygonal region into a minimum number of trapezoids with two horizontal sides is discussed. A triangle with a horizontal side is considered to be a trapezoid with two horizontal sides one of which is degenerate. First, a method of achieving a minimum partition is presented. The number M* of the trapezoids in the minimum partition of a polygonal region P is shown to be M* = n + w - h - d - 1, where n, w, and h are the number of vertices, windows (holes), and horizontal edges of P, respectively, and d is the cardinality of a maximum independent set of the straight-lines-in-the-plane graph associated with P. Next, this problem is shown to be polynomially equivalent to the problem of finding a maximum independent set of a straight-lines-in-the-plane graph, and consequently, it is shown to be NP-complete. However, for a polygonal region without windows, an O(n2)-time algorithm for partitioning it into a minimum number of trapezoids is presented. Finally, an O(n log n)-time approximation algorithm with the performance bound 3 is presented.
2984#A sound and, in certain cases, complete method is described for evaluating queries in relational databases with null values where these nulls represent existing but unknown individuals. The soundness and completeness results are proved relative to a formalization of such databases as suitable theories of first-order logic. Because the algorithm conforms to the relational algebra, it may easily be incorporated into existing relational systems.
2985#A major event in automated reasoning was the introduction by Robinson of resolution as an inference principle that is complete for the first-order predicate calculus. Here the theory of binary resolution, based strictly on unification, is recast to incorporate the axioms of equality. Equality-based binary resolution is complete without making use of paramodulation and leads to refutations that are less than half as long as standard refutations with the equality axioms. A detailed discussion is given of the first major use of a theorem prover based on this new method.
2986#PARLOG is a logic programming language in the sense that nearly every definition and query can be read as a sentence of predicate logic. It differs from PROLOG in incorporating parallel modes of evaluation. For reasons of efficient implementation, it distinguishes and separates and-parallel and or-parallel evaluation.PARLOG relations are divided into two types: single-solution relations and all-solutions relations. A conjunction of single-solution relation calls can be evaluated in parallel with shared variables acting as communication channels for the passing of partial bindings. Only one solution to each call is computed, using committed choice nondeterminism.A conjunction of all-solutions relation calls is evaluated without communication of partial bindings, but all the solutions may be found by an or-parallel exploration of the different evaluation paths. A set constructor provides the main interface between single-solution relations and all-solutions relations.This paper is a tutorial introduction to PARLOG. It assumes familiarity with logic programming. Categories and Subject Descriptors: D.l.l [Programming Techniques]: Applicative (Functional)
2987#An explicit steady-state solution is given for any queuing loop made up of two general servers, whose distribution functions have rational Laplace transforms. The solution is in matrix geometric form over a vector space that is itself a direct or Kronecker product of the internal state spaces of the two servers. The algebraic properties of relevant entities in this space are given in an appendix. The closed-form solution yields simple recursive relations that in turn lead to an efficient algorithm for calculating various performance measures such as queue length and throughput. A computational-complexity analysis shows that the algorithm requires at least an order of magnitude less computational effort than any previously reported algorithm.
2988#Modeling the storage structures of a DBMS is a prerequisite to understanding and optimizing database performance. Previously, such modeling was very difficult because the fundamental role of conceptual-to-internal mappings in DBMS implementations went unrecognized.In this paper we present a model of physical databases, called the transformation model, that makes conceptual-to-internal mappings explicit. By exposing such mappings, we show that it is possible to model the storage architectures (i.e., the storage structures and mappings) of many commercial DBMSs in a precise, systematic, and comprehendible way. Models of the INQUIRE, ADABAS, and SYSTEM 2000 storage architectures are presented as examples of the model's utility.We believe the transformation model helps bridge the gap between physical database theory and practice. It also reveals the possibility of a technology to automate the development of physical database software.
2989#Computer applications and algorithms
2990#A PMS level notation for the description and simulation of digital systems
2991#We give an efficient procedure for verifying that a finite-state concurrent system meets a specification expressed in a (propositional, branching-time) temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global state graph for the concurrent system. We also show how this approach can be adapted to handle fairness. We argue that our technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite-state concurrent systems. Experimental results show that state machines with several hundred states can be checked in a matter of seconds.
2992#Textnet is a new system for structuring text. The Textnet approach uses one uniform data structure to capture graphlike pools of text, as well as embedded hierarchical structures. By using a semantic network formalism of nodes connected by typed links, the relationships between neighboring pieces of text are made explicit. Also described is our partial implementation of the Textnet approach, which makes use of an object-oriented window/menu-driven user interface. Users peruse the network by moving among object menus or by reading text along a path through the network. In addition, critiquing, reader linking, searching, and jumping are easily accessible operations. Finally, the results of a short trial with users are presented.
2993#The “Whiteboards” system is intended to be an electronic equivalent of the whiteboards and corkboards that we have in our offices. A Whiteboard database has similar qualities of storing disparate collections of data and saving their spatial location in a window to help with organization. A Whiteboard database can contain references to arbitrary entities: text files, notes, programs, tools, pictures, etc. Whiteboards runs as an application in the Cedar programming environment developed at the Xerox Palo Alto Research Center.
2994#The logical routing of a message in a computer mail system involves the identification and location of the set of intended recipients for that message. This function is carried out by the naming and addressing mechanism of the mail system. An important property of that mechanism is that it should be able to identify and locate all the intended recipients of a message, so that, once submitted, a message will not become lost or stuck in the system. We first discuss message addressing schemes, which are a framework for dealing with the naming and addressing problem. Message addressing schemes can also serve as a basis for the analysis of some of the properties of logical message routing within a system. We examine the conditions necessary for a complete message addressing scheme, that is, one that guarantees to deliver all possible messages.
2995#The enduring dichotomy between spatial and symbolic modes of representation and retrieval acquires an added pragmatic dimension through recent developments in computer-based information retrieval. The standard name-based approach to object reference is now supplemented on some systems by a spatial alternative-often driven by an office or desktop metaphor. Little rigorous evidence is available, however, to support the supposition that spatial memory in itself is more effective than symbolic memory.The accuracy of spatial versus symbolic reference was assessed in three experiments. In Experiment 1 accuracy of location reference in a location-only filing condition was initially comparable to that in a name-only condition, but deteriorated much more rapidly with increases in the number of objects filed. In Experiment 2 subjects placed objects in a two-dimensional space containing landmarks (drawings of a desk, table, filing cabinets, etc.) designed to evoke an office metaphor, and in Experiment 3 subjects placed objects in an actual, three-dimensional mock office. Neither of these enhancements served to improve significantly the accuracy of location reference, and performance remained below that of a name-only condition in Experiment 1. The results raise questions about the utility of spatial metaphor over symbolic filing and highlight the need for continuing research in which considerations of technological and economic feasibility are balanced by considerations of psychological utility.
2996#The role of standards in network evolution
2997#Information processing standardization in the People's Republic of China
2998#The architecture of fifth generation inference computers
2999#Overview of international standards for transmission impairments affecting digital telecommunications networks
3000#Some issues in the international standardization of CHILL and ADA
3001#Techniques for verification and validation of safety-related software
3002#Guide to the draft American national standard for human factors engineering of visual display terminal workstations
3003#Supercomputers—past, present, prospects
3004#Relational thesauri in information retrieval
3005#PROLOG programming and applications
3006#Robot technology: theory, design and applications
3007#The rise of managerial computing: the best of the Center for Information Systems Research
3008#The writer and the computer
3009#Artificial intelligence and the humanities
3010#The "new" logics and natural language processing
3011#Software engineering and artificial intelligence in new generaton computing
3012#Legislation of co-operative R&D efforts in the U.S.A.
3013#An alvey survey: advanced information technology in the U.K.
3014#Robert Kowalski on logic programming
3015#Macro-11 assembly language: architecture and structured programming
3016#Programming language landscape: syntax, semantics, and implementation
3017#Computers in focus
3018#Visual cognition
3019#A query interface for IMAGE databases based on relational algebra
3020#Quokka: a translator generator using denotational semantics
3021#A clause indexing system for PROLOG based on superimposed coding
3022#A control and data flow multiprocessor
3023#Insecurities in FORTRAN DO-loops
3024#CONTEXT: an on-line documentation system
3025#A probe effect in concurrent programs
3026#File updating revisited
3027#An almost path-free very high-level interactive data manipulation language for a microcomputer-based database system
3028#A communication system supporting large datagrams on a local area network
3029#Interactive documentation
3030#Introduction to nMOS & VLSI systems design
3031#Computer animation: theory and practice
3032#The SUPREM architecture: a new intelligent paradigm
3033#Conceptual clustering of structured objects: a goal-oriented approach
3034#Probabilistic logic
3035#Applications of circumscription to formalizing common-sense knowledge
3036#A precise analysis of partial match retrieval of multidimensional data is presented. The structures considered here are multidimensional search trees (k-d-trees) and digital tries (k-d-tries), as well as structures designed for efficient retrieval of information stored on external devices. The methods used include a detailed study of a differential system around a regular singular point in conjunction with suitable contour integration techniques for the analysis of k-d-trees, and properties of the Mellin integral transform for k-d-tries and extendible cell algorithms.
3037#Analysis of manufacturing systems by the Research Queueing Package
3038#Coding and information theory (2nd ed.)
3039#Foiling the system breakers: computer security and access control
3040#A robust storage structure is intended to provide the ability to detect and possibly correct damage to the structure. One possible source of damage is the partial completion of an update operation, due to a "crash" of the program or system performing the update. Since adding redundancy to a structure increases the number of fields which must be changed, it is not clear whether adding redundancy will help or hinder crash recovery. This paper examines some of the general principles of using robust storage structures for crash recovery. It also describes a particular class of linked list structures which can be made arbitrarily robust, and which are all suitable for crash recovery.
3041#An important consideration in the design of high- performance multiple processor systems should be in ensuring the correctness of results computed by such complex systems which are extremely prone to transient and intermittent failures. The detection and location of faults and errors concurrently with normal system operation can be achieved through the application of appropriate on-line checks on the results of the computations. This is the domain of algorithm-based fault tolerance, which deals with low-cost system-level fault-tolerance techniques to produce reliable computations in multiple processor systems, by tailoring the fault-tolerance techniques toward specific algorithms. This paper presents a graph-theoretic model for determining upper and lower bounds on the number of checks needed for achieving concurrent fault detection and location. The objective is to estimate ate the overhead in time and the number of processors required for such a scheme. Faults in processors, errors in the data, and checks on the data to detect and locate errors are represented as a tripartite graph. Bounds on the time and processor overhead are obtained by considering a series of subproblems. First, using some crude concepts for t-fault detection and t-fault location, bounds on the maximum size of the error patterns that can arise from such fault patterns are obtained. Using these results, bounds are derived on the number of checks required for error detection and location. Some numerical results are derived from a linear programming formulation.
3042#In this paper, we study fault-tolerant multiprocessor systems employing redundant-path multistage interconnection networks. Such systems permit interprocessor communication in the presence of faulty components in the network. The interconnection network considered is a delta network augmented with an extra switching stage in front. When the first and last stages are fault-free, the extra-stage delta networks continue to provide full access in the presence of all single and many multiple faults in switching elements of the intermediate stages. In this paper, we use graph-theoretic techniques to study the problem of routing permutations in extra-stage delta networks when faults are present in the network. We first formulate the problem of performing an arbitrary permutation on the fault-free network as a vertex-coloring problem and later extend this to networks with noncritical faults. Although the general problem of realizing a permutation in the minimum number of passes is intractable, classes of permutations with some regularity can be routed optimally. To illustrate the idea, we consider the class of BPC (bit permute-complement) permutations: algorithms for performing arbitrary permutations in this class on the extra-stage delta network are given, both for the fault-free network and for a network with noncritical faults.
3043#A new test data reduction technique called accumulator compression testng (ACT) is proposed. ACT is an extension of syndrome testing. It is shown that the enumeration of errors missed by ACT for a unit under test is equivalent to the number of restricted partitions of a number. Asymptotic results are obtained for independent and dependent error modes. Comparison is made between signature analysis (SA) and ACT. Theoretical results indicate that with ACT a better control over fault coverage can be obtained than with SA. Experimental results are supportive of this indication. Built-in self test for processor environments may be feasible with ACT. However, for general VLSI circuits the complexity of ACT may be a problem as an adder is necessary.
3044#We consider repairable computer systems, those for which repair can be performed to put the system back in operation. The behavior of the system is assumed to be modeled as a homogeneous Markov process. We calculate numerically the distribution of cumulative operational time, which is the distribution of the total time during which the system was in operation over a finite observation period. The method is based on the randomization technique. The main advantages include the ability to specify error tolerances in advance, numerical stability, and simplicity of implementation. We also show that other quantities of interest can be calculated as a byproduct of the method without any significant extra computational effort.
3045#Provably conservative (and optimistic) reliability models can be systematically derived from more complex models. These derived models incorporate a reduced state space and fewer transitions, and, therefore, have solutions that are more cost- effective than those of the original complex models. The designer can extensively explore the design space without incurring the expense of solving multiple complex models. A conservative- optimistic pair of derived models produces a band that includes the solution to the complex model. Sensitivity analysis can be performed on this pair of models to determine those parameters of the original model that are most sensitive to change (i.e., uncertainty) and hence warrant further expense in obtaining tighter specifications.
3046#This paper describes a new fault-tolerant computer architecture based on a "distributed implementation" of a symbol- error correcting code. In this, as at is called, (N, K) concept the faults are masked by this code. The (N, K) concept is described in detail for N = 4 and K = 2. It is shown that symbol-error correcting codes having additional bit-error correcting capabilities make additional memory protection by means of bit-error correcting codes superfluous and a newly designed symbol-and bit- error correcting code for the
3047#As societies have become more dependent on information systems to conduct and record transactions between organizations and individuals, interorganizational computer systems have become a widely used method of coordinating the actions of independent organizations. This article examines the quality of data in one important interorganizational system—the criminal-record system of the United States.
3048#Building and prototyping an agricultural electronic marketing system involved experimenting with distributed synchronization, atomic activity, and commit protocols and recovery algorithms.
3049#By introducing the concept of an abstract graphics device called the workstation, an existing graphics system is generalized to support multiple devices in applications software.
3050#A total of 840 junior and senior-level undergraduate business students particpated in three experiments that compared computer-generated graphical forms of data presentation to traditional tabular reports. The first experiment compared tables and bar charts for their effects on readability, interpretation accuracy, and decision making. No differences in interpretation accuracy or decision quality were observed for the two groups, although tabular reports were rated as "easier to read and understand" than graphical reports. The second experiment compared line plots to tables for their effects on interpretation accuracy and decision quality. Subjects with graphical reports outperformed those with tables. There were no meaningful differences in interpretation accuracy across treatment groups. The third experiment compared graphical and tabular reports for their ability to convey a "message" to the reader. Only in situations in which a vast amount of information was presented and relatively simple impressions were to be made, did subjects given graphs outperform those using tables.This program of cumulative experiments indicates that generalized claims of superiority of graphic presentation are unsupported, at least for decision-related activities. In fact, the experiments suggest that the effectiveness of the data display format is largely a function of the characteristics of the task at hand, and that impressions gleaned from "one shot" studies of the effectiveness of the use of graphs may be nothing more than situationally dependent artifacts.
3051#Prior research has identified two psychological processes that appear to be used by programmers when they perform design and coding tasks: (a) taxonomizing—identifying the conditions that evoke particular actions; and (b) sequencing—converting the taxa into a linear sequence of program code. Three structured tools—structured English, decision tables, and decision trees—were investigated in a laboratory experiment to determine how they facilitated these two processes. When taxonomizing had to be undertaken, structured English outperformed decision tables, and decision trees outperformed structured English. When sequencing had to be undertaken, decision trees and structured English outperformed decision tables, but decision trees and structured English evoked the same level of performance.
3052#Modern methods of music analysis using computers
3053#Interactive critical path analysis (ICPA)—microcomputer implementation of a project management and knowledge engineering tool
3054#An automated office for the laboratory scientist
3055#A microprocessor-based high availability irrigation control system
3056#Analysis of stopped-flow data for consecutive reactions using a microprocessor-based system
3057#A dedicated microcomputer for handwritten interaction with a software tool: system prototyping
3058#A taxonomic classification of dedicated microprocessor applications
3059#Kurt Godel: collected works. Vol. 1: Publications 1929-1936
3060#Library Hi Tech - The MIT Press scientific computation series
3061#Write-once laser disc technology
3062#The effect of number of Hamiltonian paths on the complexity of a vertex-coloring problem
3063#Coding and information theory; 2nd ed.
3064#Microcomputers in the corporate environment
3065#Robot technology and applications
3066#Performance analysis of local computer networks
3067#Compiler construction: theory and practice (2nd ed.)
3068#Computer models for management science
3069#Sloan Management Review - The MIT Press scientific computation series
3070#Information systems organizations—keeping pace with the pressures
3071#Telecommuting the organizational and behavioral effects of working at home
3072#Mathematics for computer technology
3073#The accountant and the personal commputer
3074#Designing digital filters
3075#Linked local area networks (2nd ed.)
3076#Introducing microcomputers to managers in the People's Republic of China
3077#Impact of design methods on decision support systems success: an empirical assessment
3078#Information systems research centers: an initial survey
3079#Developing an intervention strategy to promote enhanced public service performance by agent institutions
3080#Differential and difference equations through computer experiments
3081#This paper presents a systematic approach to matching categories of query language interfaces with the requirements of certain user types. The method is based on a trend model of query language development on the dimensions of functional capabilities and usability. From the trend model the following are derived: a classification scheme for query languages, a criterion hierarchy for query language evaluation, a comprehensive classification scheme of query language users and their requirements, and preliminary recommendations for allocating language classes to user types.The method integrates the results of existing human factors studies and provides a structured framework for future research in this area. Current and expected developments are exemplified by the description of "new generation" database query languages. In a practical query language selection problem, the results of this paper can be used for preselecting suitable query language types; the final selection decision will also depend on organization-specific factors, such as the available database management system, hardware and software strategies, and financial system costs.
3082#Algorithms that modify the order of linear search lists are surveyed. First the problem, including assumptions and restrictions, is defined. Next a summary of analysis techniques and measurements that apply to these algorithms is given. The main portion of the survey presents algorithms in the literature with absolute analyses when available. The following section gives relative measures that are applied between two or more algorithms. The final section presents open questions.
3083#Recently, several strategies have been proposed for transaction processing in partitioned distributed database systems with replicated data. These strategies are surveyed in light of the competing goals of maintaining correctness and achieving high availability. Extensions and combinations are then discussed, and guidelines are presented for selecting strategies for particular applications.
3084#Matrix analysis
3085#Managerial considerations in participative design of MIS/DSS
3086#Power: a critical systems development factor
3087#Edge detection with image enhancement via dynamic programming
3088#Light diffusion through clouds and haze
3089#Model-based strategies for high-level robot vision
3090#Decomposition and approximation of three-dimensional solids
3091#Distributed computing systems
3092#Communications in the modern corporate environment
3093#Computer organization: hardware/software (2nd ed.)
3094#Critical issues in office automation
3095#On digital approximation of moment invariants
3096#Three adaptive discrete least squares cubic spline procedures for the compression of data
3097#Automatic curve fitting with quadratic B-spline functions and its applications to computer-assisted animation
3098#Combined local color and texture analysis of stained cells
3099#Edge detection using median comparisons
3100#The automatic inversion of attribute grammars
3101#Efficient decentralized consensus protocols
3102#The Cloze procedure and software comprehensibility measurement
3103#ARES: a relational database with the capability of performing flexible interpretation of queries
3104#Principles of interactive computer graphics (2nd ed.)
3105#Privilege transfer and revocation in a port-based system
3106#Direct implementation of abstract data types from abstract specifications
3107#Adaptive load sharing in homogeneous distributed systems
3108#The Hartley transform
3109#Perceptions of equity, job satisfaction, and intention to quit among data processors
3110#An empirical study of occupational stress, attitudes and health among information systems personnel
3111#A laboratory study of user characteristics and decision-making performance in end-user computing
3112#Videotex: anatomy of a failure
3113#Computer communications. Vol. II: systems and applications
3114#Optimization of data/computer networks
3115#Packet radio: an area-coverage digital radio network
3116#Local networks
3117#Computer networks: a survey
3118#Internetworking
3119#Packet, circuit, and virtual circuit switching
3120#Integrating data, voice, and image
3121#Digitization techniques
3122#CAM Developments in computer-integrated manufacturing
3123#Personal computing vs. personal computers
3124#Change, attitude to change, and decision support system success
3125#Distributed computer system design: an interactive procedure
3126#IBM's early computers
3127#Replacing units whose components have normal life distributions
3128#Scheduling of routine maintenance using production schedules and equipment failure history
3129#Optimal inventory policies when the quantity backordered is uncertain
3130#Using simulation to test the feasibility of robotic assembly
3131#A program package for simulation of coupled chemical reactions in flow reactors
3132#Flowshop with no idle machine time allowed
3133#A multiple criteria approach to the location-allocation problem
3134#Semirings, automata, languages
3135#Complexity and structure
3136#Optimum decision trees—an optimal variable theorem and its related applications
3137#Truly prefix-correct chain-free LR(1) parsers
3138#On the algebraic specification of infinite objects—ordered and continuous models of algebraic types
3139#The family of one-counter languages is closed under quotient
3140#Fooling a two-way nondeterministic multihead automaton with reversal number restriction
3141#Telecommunications and data communication system design with troubleshooting
3142#The concept of information in ordinary discourse
3143#Principles, procedures and rules in an expert system for information retrieval
3144#A theoretical framework for defining similarity measures for boolean search request formulations, including some experimental results
3145#A cost comparison of manual and automated circulation systems in university libraries: the case of the Ibadan University Library
3146#A supporting system for effective construction and sharing of scientific databases by general researchers
3147#On a circle placement problem
3148#A study of B-convergence of Runge-Kutta methods
3149#The order of B-convergence of the Gaussian Runge-Kutta method
3150#On Stetter`s global error estimation in the smooth phase of stiff differential equations
3151#A second order monotone upwind scheme
3152#On the extrapolation for a singularly perturbed boundary value problem
3153#On the monotone convergence of Newton`s method
3154#Extended univariate algorithms for n-dimensional global optimization
3155#Report on test matrices for generalized inverses
3156#The legal guide to developing, protecting and marketing software: dealing with problems raised by customers, competitors and employees
3157#The connection machine
3158#Computational methods for integral equations
3159#Signal routing in integrated circuit layout
3160#Systems analysis and design: alternative structured approaches
3161#The prototyping methodology
3162#Local area networks: a user's guide for business professionals
3163#Guide to popular operating systems
3164#Microlithography: process technology for IC fabrication
3165#Transform coding of images
3166#[The] program contains a number of topics that have been discussedin previous symposia, but still remain matters of concern. In addition,the program contains sessions dealing with issues at the precollegelevel, and in information systems, fourth generation languages,graphics, studies of student performance, and career preparation.Several panel sessions are jointly listed with the ACM Computer ScienceConference…. [The] program includes tutorials: one on teachingconcepts related to programming and the other on Ada, jointly sponsoredby SIGAda….—From the Chairperson's Message
3167#The little LISPer (2nd ed.)
3168#An introduction to LISP
3169#Robot vision
3170#An undergraduate course in database design is described. The need for such a course, and its appropriateness in the undergraduate information systems curriculum is discussed. Finally, a number of general instructional difficulties are identified. It is claimed that a course like it is needed in the undergraduate information systems curriculum and that remedies to problems teaching it may have to be found outside the traditional business and computing curricula.
3171#Many tools have been developed to aid in the systems analysis and design process. These same tools are used in teaching to help students better understand the process. This paper will discuss ways in which one tool, Entity Relationship (ER) models, can be used in teaching data analysis and design. The role of ER models in database design will be reviewed. ER models will be considered as a framework for also dealing with file design. An example of an ER model will be given with a description of how it might be used in discussing file design issues with students.
3172#A second course in Database Management which stresses database design principles is described. The first course emphasizes database implementation utilizing both a relational and a CODASYL database management system. Students become familiar with the usage of a database management system as a implementation framework for databases. The second course provides the student with tools to perform logical database design and with techniques for converting logical designs into efficient physical implementations.
3173#Implementing computer literacy: the year after
3174#What are the opinions and biases of students entering this course today? What do these students think they know, what do they think they should be learning? Have their opinions been altered by the technological and software trends? Do younger and older students have similar or markedly differing views and computer experiences. Can the needs of the students be met by such courses, or are the students actually more technologically literate than we believe? Noting the changes that have taken place over the last three or four years in the literacy course, the authors prepared a survey that was completed by all the students in two universities (317 students) during the first class of the fall 1985 semester. The results of that survey are the basis of this paper.
3175#“Computerphobia” among adult learners is analogous to communication apprehension among adult speakers; consequently, techniques used by teachers of public speaking to ease stagefright can be adapted to the problem of overcoming fear of computers in novice adult learners. Six specific solutions are suggested and explained.
3176#This paper presents the background of computer science programs in the Dominican Republic and show how the curriculum at Universidad Catolica Madre y Maestra was chosen.
3177#Discrete mathematics for computer scientists & mathematicians (2nd ed.)
3178#4GL: fourth-generation languages; vol. II: representative 4GLs
3179#Job-shop scheduling using automated reasoning: a case study of the car-sequencing problem
3180#Elements of the history, state of the art, and probable future of Machine Translation (MT) are discussed. The treatment is largely tutorial, based on the assumption that this audience is, for the most part, ignorant of matters pertaining to translation in general, and MT in particular. The paper covers some of the major MT R&D groups, the general techniques they employ(ed), and the roles they play(ed) in the development of the field. The conclusions concern the seeming permanence of the translation problem, and potential re-integration of MT with mainstream Computational Linguistics.
3181#Intelligent backtracking in deduction systems by means of extended unification graphs
3182#Proving termination of normalization functions for conditional expressions
3183#Unification in datastructure multisets
3184#The grammatical basis of linguistic performance: language use and acquisition
3185#Discrete mathematics with computer science applications
3186#Digital systems: from gates to microprocessors
3187#Proposal writing for the data processing consultant
3188#The synthesis of specialty narratives from co-citation clusters
3189#Computers and data processing today with BASIC (2nd ed.)
3190#Which computer languages should we be teaching our students — and why? This paper examines the multitude of languages now available from three perspectives: classificatory, predictive, and pedagogical. It offers a “linguistic” analysis of computer languages in terms of their structure, their function, and their genealogy. Using these classifications, the paper then analyzes current and future trends for each language type. The classifications and predictions suggest a fundamental distinction between two sorts of languages: those appropriate for public computing (i.e. programming done by most professional computer scientists) and those appropriate for private computing (computing by individuals for their own purposes). The paper suggests that while would-be computer scientists need to learn public computing languages, private computing languages may be especially appropriate for non-professional computer users.
3191#Many colleges and universities offer an introductory computer science course based on a specific programming language. The Department of Computer Science at the University of Kansas has recently created a new environment in order to better teach such topics as problem solving, algorithmic design, elementary programming techniques, and elementary computer techniques. This paper will discuss the transition from a time-sharing environment to a modern microcomputer laboratory. It will also discuss the pedagogic techniques used in the new environment. It is hoped that others will benefit from our experiences.
3192#Modula-2 has been adopted as the primary programming language at New Mexico State University. This paper discusses the reasons which led to this choice of a new primary programming language. It compares some of the features of Pascal, Modula-2 and Ada. It also gives the results of our implementation efforts.
3193#Programming projects in an operating systems course expose students to issues involved in the design and implementation of operating systems. The Modula-2 language provides features needed in such projects. This paper overviews the capabilities of Modula-2 and describes a programming project in which students implement a process manager for an operating system. The process manager supports concurrent processes and provides operations for their synchronization and communication.
3194#A Modula-2-based project series is presented. This three-project sequence is suitable for an undergraduate course in operating systems or systems programming, and embodies the three important principles of concurrent programming, algorithm animation, and code modification. Heavy use is made of the Modula-2 module; much of the code in the projects is given away to the students, who must then adapt it for the purpose. The project series requires the animation of several sort algorithms, which are invoked as independent tasks under Modula-2 and display their state in different screen windows. These projects do not require special hardware and can be run using a “dumb terminal” 24 x 80 screen.
3195#For several years, the introductory assembly language course at Indiana-Purdue at Fort Wayne has used “structured” assembly language on an IBM System 370. A later course makes use of VAX-11 MACRO assembly language on a VAX 11/780. This paper shows how the major constructs for structured programming may be implemented in VAX-11 MACRO. The scheme involves assembly language templates for each of the constructs, a standard labeling scheme, and a commenting method which reflects the structure of the program.
3196#A model for computer science courseware development within universities is proposed. This model asserts that masters level graduate and undergraduate students are a valuable software development resource that can be utilized to design, prototype, field test, and refine quality courseware. To support this contention four prototype courseware packages are used to briefly describe the Visible Algorithms project at Northridge. These packages provide tutorials on, and graphic animations of: linked list, binary tree, B-tree, and memory management algorithms.
3197#A set of procedures to graphically display ordered and unordered trees has been developed. The procedures have been used in several class demonstration programs to illustrate tree insertion, deletion, and balancing algorithms. The procedures are available for inclusion in student programs so that they can determine if their programs are working correctly. The procedures are written in Turbo Pascal for an IBM PC.
3198#This paper presents a learning-research based argument for the integration of computer programming into the science and mathematics curricula in pre-college education as well as college. Students who generate solutions to science and mathematics problems develop a procedural understanding of the fundamental theories of these disciplines. Students should be taught to use programming languages for these solutions for the same reasons they are taught the universal tools of arithmetic and algebra, and because only a computer provides the means to describe solutions in explicit, correct, and executable form. Programming should be integrated into all mathematics and science teaching from the earliest years. In precollege education, programming should be taught over a period of eight to ten years, rather than as a 6-12 week separate topic, and should be matched to the level of complexity of the science and mathematics content.
3199#The REXX language: a practical approach to programming
3200#A “divide and conquer” strategy to compute natural joins by sequential scans on unordered relations is described. This strategy is shown to always he better than merging SCBIIS when both relations must he sorted before joining, and generally better in practical cases when only the largest relation mutt be sorted.
3201#Probability, random processes, and estimation theory for engineers
3202#Immediately or soon after an introductory course in programming, traditional computer science education usually includes a course on data structures. Such courses, however, have suffered from a lack of non-textual materials for classroom and non-classroom use. Consequently, it is difficult for students to comprehend the abstractions involved in implementing and applying fundamental data structures without laboriously employing printed materials.The work discussed herein addresses the problem by developing software for the IBM PC that will allow data structure users to view graphically the effects of primitive operations and application programs on basic data structures. Several such structures and applications are examined and plans for a program interface are discussed.
3203#Effects of mathematics preparation and prior language exposure on perceived performance in introductory computer science courses
3204#Modern programming practice advocates the use of abstract data types to aid in design, coding, and maintenance of programs [1]. Many students who are not computer majors will write programs as part of their jobs. Therefore, it is important to expose those students who will take only one or two programming courses to the idea of abstract data types. The paper below illustrates how this was done in one of our beginning Pascal classes.
3205#The specification of a system is a major problem. One useful technique is to involve users in the design process. This requires considerable skill on the part of the software professionals. As one component of our software engineering course we are trying to develop this skill.We ask our students to design a system, and as a part of developing the system specification we give them an opportunity to interview a “user.” Since real users are often not very helpful, we deliberately arrange that our “users” will be obtuse regarding technical details of the system. We then conduct follow-up classroom discussion which, we hope, will leave the students with a much more realistic idea of what to expect from a user. A skillful interviewer can often gain valuable insights from users into which aspects of the system are most important to the specifications.
3206#A scheme is presented for classifying recursive problems based upon an analysis of their parameters. Several well known recursive algorithms are then classified according to this scheme. The classification is used to determine if strategies for effecting significant savings in computation time of a recursive algorithm can be developed. Such strategies and the results of applying them are also discussed.
3207#The maturation of Computer System Performance Courses is briefly described giving excerpts from the two major ACM curriculum documents and providing a list of possible texts for such a course. It is then proposed that a course in performance evaluation contain a component on the role of performance work in the product life cycle. A prototype model for this is described in detail. The description includes the need for such work, who accomplishes it, what sort of interactions are necessary and appropriate, and what steps comprise integrating performance work into a product life cycle.
3208#This paper describes an original method for introducing linear recurrence relations. Boolean expressions are represented by binary trees and the counting of the internal nodes of these trees yield linear recurrence relations. The method allows the students to create their own family of Boolean expressions, to draw the corresponding binary trees, to deduce the recurrence relation representing the number of nodes in the trees, and finally, to solve and check the solutions of these relations.
3209#In February, 1984, the Computer Science Department at Brigham Young University began working on a project that would automate the delivery of a beginning programming class. This project known as THE ELROND PROJECT, was funded by the university with the expectation that the instructional delivery costs and the need for additional faculty for this course could be reduced.This paper describes the system design and principles that were used and presents strategies for creating computer automated courseware.
3210#Testing a model of program quality
3211#The purpose of this paper is to describe a project in a course on Operating Systems. The project is designed to reinforce the concepts of memory management, process management and processor management that are discussed in most Operating Systems texts. Each student is to design and write a program that will simulate these major components of an operating system. This project is presented to the student in 3 phases and is written in Pascal although it can be adapted to other languages. The first phase requires the design of memory management routines for an operating system which schedules jobs through the use of a combined round robin/FIFO philosophy. The major concerns are the allocation and deallocation of memory pages as programs are submitted to the system and are removed from the system as they finish. The second phase takes into account various scheduling techniques, I/O requests, and swapping. Having already worked out the bugs in the memory management routines, the student now must be concerned with the management of the jobs that pass through the system. The third and last phase is the implementation of job synchronization. Several events are described, any of which may be the object of a WAIT or SIGNAL directive issued by an executing program. The project must synchronize jobs that issue a WAIT and SIGNAL directive on the same event.The project is part of a 3 credit course in Operating Systems taught to Juniors and Seniors. Successful completion of the project includes not only the correct implementation of a well documented and logically designed operating system, but also a comparative study, within each phase, of the efficiency and effectiveness of the operating system as a variety of parameters, which describe the environment, are changed. Observations are submitted in a report that is required with each phase.
3212#Students think that security is crime prevention, someone else's business. In fact, security is error prevention and is everybody's business.At government and industrial conferences employers complain that C.S. and C.I.S. graduates1) don't see security as a significant factor in getting their jobs done, and2) don't have a clear conception of what constitutes ethical professional behavior.This article, demonstrates ways to integrate into existing courses activities that promote students' awareness of professional responsibilities to protect the integrity of the systems and data they work with, and of accepted professional ethical standards.
3213#Data structures using MODULA-2
3214#A functional model for describing and reasoning about time behaviour of computing systems
3215#Non-deterministic data types: models and implementations
3216#Minimal coverings for incompletely specified sequential machines
3217#Investigations on Hotz groups for arbitrary grammars
3218#The 1985 Turing Award winner presents his perspective on the development of the field that has come to be called theoretical computer science.
3219#The advantages of user-defined distfix operators—a syntactic convenience that enhances the readability of programs—can be obtained as an extension of almost any programming language without requiring dynamic changes to the parser.
3220#A modification of the Berry-Meekings "style metric"—applied to software from the corporate environment—finds little relationship between this style metric and error proneness.
3221#Analyzing program style may be properly considered an integral part of program compilation—as successfully implemented in two style-analysis tools for Fortran 77: AUTOMARK and ASSESS. The authors look forward to the day when all major language compilers routinely provide a standard style-analysis vector for users to interpret as they see fit.
3222#Two new procedures for manipulating multiple stacks which share sequential memory locations are discussed. The first is the dynamic initial allocation procedure in which each stack is allocated as its first element arrives rather than having every stack preallocated at the very beginning of the entire process. The second is the local reallocation procedure; in this scheme, when a stack overflows, only its neighboring stacks, rather than the entire memory area, are reorganized provided that a certain condition is satisfied. The results of simulation appear to suggest that these new approaches improve the operational performance in many applications. With appropriate modifications, these concepts may also be applied to any other type of multiple linear lists (e.g., multiple queues) sharing sequential memory locations.
3223#In a recent application of the theory of strategic contingencies in three large multinational firms, Lucas found that information services departments were perceived by others as having low levels of power and influence and suggested a variety of reasons for the results. This note continues the application of the theory of strategic contingencies to the information services department by describing a study of intraorganizational power that uses basically the same procedures as the Lucas study and obtains similar results. In an effort to stimulate future power-related research in the information systems area, this note concludes by suggesting several reasons, beyond those given by Lucas, for the levels of power attributed to information services departments.
3224#Applied and computational complex analysis. Vol. 3: discrete Fourier analysis—Cauchy integrals—construction of conformal maps---univalent functions
3225#Geophysical signal processing
3226#This report proposes developing a rigorous undergraduate curriculum for a B.A.-degree program in computer science. The curriculum is intended as a model not only for high-quality undergraduate colleges and universities, but also for larger universities with strong computer science programs in a liberal arts setting.
3227#With an understanding of the structure of microcomputer file systems and what causes incompatibilities between them, it is possible to write software that will enable one system to read files written by another—provided they have physically compatible hardware.
3228#"User involvement" in information system development is generally considered an important mechanism for improving system quality and ensuring successful system implementation. The common assumption that user involvement leads to system usage and/or information satisfaction is examined in a survey of 200 production managers. Alternative models exploring the causal ordering of the three variables are developed and tested via path analysis. The results demonstrate that user involvement in the development of information systems will enhance both system usage and the user's satisfaction with the system. Further, the study provides evidence that the user's satisfaction with the system will lead to greater system usage.
3229#A fast parallel thinning algorithm for digital patterns is presented. This algorithm is an improved version of the algorithms introduced by Zhang and Suen [5] and Stefanelli and Rosenfeld [3]. An experiment using an Apple II and an Epson printer was conducted. The results show that the improved algorithm overcomes some of the disadvantages found in [5] by preserving necessary and essential structures for certain patterns which should not be deleted and maintains very fast speed, from about 1.5 to 2.3 times faster than the four-step and two-step methods described in [3] although the resulting skeletons look basically the same.
3230#The Information Technology Center (ITC), a collaborative effort between IBM and Carnegie-Mellon University, is in the process of creating Andrew, a prototype computing and communication system for universities. This article traces the origins of Andrew, discusses its goals and strategies, and gives an overview of the current status of its implementation and usage.
3231#A highly accurate model predicts microcomputer price based on benchmark performance by analyzing the impact on predicted price of fluctuations in system configuration and benchmark results.
3232#Using the arithmetic mean to summarize normalized benchmark results leads to mistaken conclusions that can be avoided by using the preferred method: the geometric mean.
3233#Thinking recursively
3234#Astronomy with your personal computer
3235#JCL for IMB VSE systems: a self teaching guide
3236#This paper presents a methodology for trading-off the cost of incomplete information against the data-related costs in the design of database systems. It investigates how the usage patterns of the database, defined by the characteristics of information requests presented to it, affect its conceptual design. The construction of minimum-cost answers to information requests for a variety of query types and cost structures is also studied. The resulting costs of incomplete database information are balanced against the data-related costs in the derivation of the optimal design.
3237#Experiments with VLSI ensemble machines
3238#A retrospective on the Dorado, a high-performance personal computer
3239#Optimal partitioning of sequential jobs on a network computer
3240#An efficient systolic array for the 1D recursive convolution problem
3241#Twentieth-century techniques such as computer-aided engineering and finite-element analysis were used to restore the nineteenth-century monument.
3242#Execution times for a variety of priority-queue implementations are compared under the hold model, showing many to be faster than implicit heaps.
3243#In many situations, embedded menus represent an attractive alternative to the more traditional explicit menus, particularly in touchtext, spelling checkers, language-based program editors, and graphics-based systems.
3244#A data compression scheme that exploits locality of reference, such as occurs when words are used frequently over short intervals and then fall into long periods of disuse, is described. The scheme is based on a simple heuristic for self-organizing sequential search and on variable-length encodings of integers. We prove that it never performs much worse than Huffman coding and can perform substantially better; experiments on real files show that its performance is usually quite close to that of Huffman coding. Our scheme has many implementation advantages: it is simple, allows fast encoding and decoding, and requires only one pass over the data to be compressed (static Huffman coding takes two passes).
3245#A music-description language designed to facilitate both electronic communication and publication-quality printing of musical scores incorporates a syntax for expressing concurrency and two-dimensionality and places new demands on text formatters.
3246#A five-year experience with abstraction-based software-development techniques in the university environment indicates that the investment required to support the paradigm in practice is returned in terms of greater ability to control complexity in large projects—provided there exists a set of software tools sufficient to support the approach.
3247#There are a number of techniques for representing pictorial information, among them are borders, arrays, and skeletons. Quadtrees are often used to store black and white picture information. A variety of techniques have been suggested for improving quadtrees, including linear quadtrees, QMATs (quadtree medial axis transform), forests of quadtrees, etc. The major purpose of these improvements is to reduce the storage required without greatly increasing the processing costs. All of these methods suffer from the fact that the structure of the underlying quadtree can be very sensitive to the placement of the origin.In this paper we discuss a translation invariant data structure (which we name TID) for storing and processing images based on the medial axis transform of the image that consists of all the maximal black squares contained in the image. We also discuss the performance of TID with other existing structures such as QMATs, forests of quadtrees, and normalized quadtrees. Some discussion on the union and intersection of images using TID is included.
3248#Many computer science curricula use Special Topics courses as a vehicle to introduce students to new concepts and technologies. Although the same policy is practiced at our institution, one course required of our Associate Degree students provides a forum for surveying contemporary trends in computing. Such a course is essential for providing “a foundation of knowledge and skills sufficient to serve as a base for continued learning.” [1] The purpose and content of this course is the topic that follows.
3249#This paper describes a Senior Team Project Design course required of all Computer Science majors at our institution. The course is somewhat unique in that the students are divided into teams, all working on some aspect of the same problem. Thus, there is an emphasis on communication between teams, an emphasis on ensuring that the design of the various subteams interface, and an emphasis on learning to work as part of a group.The team concept described is an attempt to simulate an actual industrial or commercial environment within the structure and safety of the college classroom. To the students' surprise, the goal is not to implement a program (although we do that) but to illustrate the need for clear design techniques, the need for proper testing procedures and, above all, the need for precise communication.
3250#To be a successful business data processing professional, one should possess effective written and oral communication skills; therefore, any program which prepares computing students for the business world should effectively train them in this area. Of the programs that attempt to handle this situation, most merely require their students to take several English/communication courses. From experience, this method is less effective than additionally reinforcing the students' communication skills within the entire range of the computing curriculum. This paper presents a methodology for accomplishing the task of implementing writing into an introductory data processing course.
3251#An introductory computer science course is presented which uses new techniques appropriate for a liberal arts college. Students learn standard topics by means of a series of guided labs in which they are active participants. The students learn to question, analyse, and construct examples, thereby acquiring the means for further inquiry and understanding. Irrelevant stumbling blocks are minimized in the hope that the positive learning process will be something they continue on their own.
3252#In this paper we discuss our experiences using a translator writing system in the compiler construction course. We have found that such a system provides a great deal of flexibility to the instructor. Students can easily construct a complete compiler including code generation for a small language. We believe our tools and experiences are transferable to other translator writing systems.
3253#The paper describes the experience gained by teaching a project-based course in Compiler Construction. The course is a blend of theoretical concepts and practical considerations that go into the development of a compiler. A project in compiler writing is an important component of this course. ASP, a subset of standard PASCAL, is used as the source language. The compiler for ASP is to be developed in various phases: character manipulator, lexical analyzer, syntax analyzer, semantic analyzer, and code generator. Recursive descent method is used to parse the various syntactic entities. The code generator emits code for a hypothetical machine called AOC (ALGOL Object Code). A simulator executes this code.
3254#During the 1983-84 academic year, the University of Scranton instituted an experimental two semester discrete mathematics course for freshman students majoring in computer science. Approximately one-third of them were enrolled in this sequence while the remaining freshmen were enrolled in a traditional algebra-calculus mathematics sequence. At the end of the academic year the records of the freshman computer science majors were examined to see if there was any difference in performance between those who took discrete mathematics and those who did not.There is a strong indication that students who take discrete mathematics make higher grades in computer science than do the students who take the algebra-calculus sequence of courses. There is no indication that students who take discrete mathematics are more (or less) likely to change majors during the freshman year than those who take a traditional mathematics course.
3255#This paper extends research on the use of the cloze test in the domain of computer software. In this study the cloze blanks were divided for the purposes of analysis into five structural subcategories. The relationships of the total cloze score and the subcategory scores to two criterion test measures were found to be positive, with the strongest and most consistent relationships being found for the variable subcategory. Use of the cloze test for both instructional and assessment purposes was discussed.
3256#This study investigated the relationship between the student's grade in a beginning computer science course and their sex, age, high school and college academic performance, number of mathematics courses, and work experience. Standard measures of cognitive development, cognitive style, and personality factors were also given to 58 students in three sections of the beginning Pascal programming class.Significant relationships were found between the letter grade and the students' college grades, the number of hours worked and the number of high school mathematics classes. Both the Group Embedded Figures Test (GEFT) and the measure of Piagetian intellectual development stages were also significantly correlated with grade in the course. There was no relationship between grade and the personality type, as measured by the Myers-Briggs Type Indicator (MBTI); however, an interesting and distinctive personality profile was evident.
3257#Readability and comprehensibility are among the most important attributes of a program. A program that is easy to read and understand is easier to test, maintain, and modify. Many factors affect program readability and comprehensibility, including variable names, internal documentation, modularity, and so on. This paper investigates the influence of color on program readability and comprehension. Three color schemes were used: Color-scheme-A used different colors to indicate the different blocks in a program; Color-scheme-B used different colors to identify the various statements function in the program; and the third color scheme was the usual black-and-white programs. This study showed that subjects who used programs with Color-scheme-B had the highest mean score for program comprehension, followed by those who used Color-scheme-A. Subjects who used black-and-white programs scored the lowest on the comprehension quiz.
3258#The author has been actively involved in the retraining of college faculty to teach computing science for six years. He is presently recruiting a fifth class for a two-summer masters degree program which addresses this goal, and is preparing for a seventh offering of a week-long, non-credit summer institute. This paper reflects upon the experience of having worked first-hand with nearly 200 faculty members from a great variety of disciplines. It also incorporates interchanges with directors of other formal retraining efforts around the country, and the comments made by some of the nearly 500 faculty who have participated in formal summer retraining programs. From these sources the author tries to clarify the phenomena of retraining and suggests some areas which merit further study.
3259#This paper outlines a set of workshops to provide training for certified high school computer science teachers. Upon the completion of the four core workshops, a high school teacher would have an excellent background to teach high school computer science as detailed in the new proposed ACM Curriculum for high school certification. The workshops should also do a good job upgrading the background of high school computer science and computer math teachers to teach courses currently in the high school curriculum. One workshop, PASCAL with Applications to Data Structures, was specifically designed to prepare current high school teachers to teach a PASCAL course whose goal is to prepare students for the advanced placement test. Each of the six workshops is a three semester hour course and most carry graduate credit. Three of the six courses have already been offered and more should be taught next summer. The reception of the high school teachers to the workshops has been very enthusiastic.
3260#The Computer Science Department at Northwest Missouri State University sponsors a computer programming contest each spring for area high school students. The contest draws about 250 people each year. The Olympiad has provided valuable student contact for the Computer Science faculty. The Computer Science Department views the Olympiad as a very powerful recruiting tool for the university. This paper will address the development of the Computer Science Olympiad at Northwest Missouri State University.
3261#This paper describes our experience in using Ada as a vehicle for teaching Software Engineering concepts in a course for first year undergraduate students at the University of Montreal.We first review the curriculum at our university and then give an idea of the hardware and software at our disposition. We describe the goals we had in mind in using Ada as a teaching language and then we detail the topics and the assignments chosen in our course. We conclude by describing a few lessons learned from that experience. All in all, we are very satisfied with this experiment and we intend to carry on next year.
3262#This paper discusses the implementation of a project to provide microcomputing resource to all students and faculty in an effort to integrate computer-assisted-learning with traditional teaching/learning methods across the curriculum of a comprehensive university. Also discussed is the structure and staffing of the project, initial hardware and software selection and the project's impact on a Computer Science Department.
3263#An introductory computer science course is frequently the most difficult course in the curriculum to teach. Computer science educators must stay abreast of rapidly changing trends, text books, technology and teaching techniques. This paper provides an overview and perspective of introductory computer science courses, surveys some trends, and presents new alternative approaches regarding organization, foundations and material. It is based on the premise that the introductory course should create strong foundations upon which students can build, and that the curriculum should teach students to build software systems which people use and maintain, not just toy computer programs. The paper presents personal views and insights, motivates underlying concepts, and provides many useful suggestions which have been successfully employed in such introductory courses.
3264#FORTH: a text and reference
3265#Rapid electrical estimating and pricing
3266#Financial management with lotus 1-2-3
3267#The Apple Writer word processing book: applications for the Apple II/IIe
3268#Programming in IBM PC DOS Pascal
3269#Introduction to data processing; 3rd ed.
3270#Engineering and scientific computations in Pascal
3271#Computing and problem-solving with Pascal
3272#Programming for people/Pascal
3273#Problem solving and structured programming in Pascal; 2nd ed.
3274#Pascal syntax
3275#Compilers: their design and construction using Pascal
3276#Data structures using Pascal
3277#Pascal: problem solving & programming with style
3278#Programming in Pascal: communicating with computers
3279#Proceedings of the IFIP WG 9.1 First Working Conference on Woman, Work and Compu on Women, work and computerization: opportunities and disadvantages
3280#Women, work and computerization: a conference report
3281#Office automation, work and skill
3282#Computerization and the skill in women`s work
3283#Office work and skills
3284#Women in the automated office: contradictory experiences-individual and collective coping strategies
3285#Office computerization and work structures
3286#Information processing and career opportunities for women
3287#Policy guidelines for the introduction or non-introduction of computer-based technologies in office work
3288#Telecommuting: between myth and reality
3289#Remote work/telecommuting-means to enhance quality of life or just another method to make business more brisk?
3290#Is remote work the way to "the good life" for women as well as men?
3291#Flexibility in women`s remote office work
3292#Telecommuting—a new word but still the same old story
3293#Do we need legal protection for remote work ("terminal homework")?
3294#E.D.P. within industry: the role of female labour
3295#The advance of microelectronics in assembly operations: new opportunities for working women?
3296#New technologies-possibilities for a new valuation of women`s work
3297#Practice and participation in systems design
3298#System development in a women`s perspective
3299#Women and work in the age of computers: (many problems) one opportunity and two challenges
3300#Women, work, and computerization or "still dancing after all these years"
3301#Facilitation the participation of working women in the introduction of computers
3302#Pascal with applications in science and engineering
3303#Beginner's guide to Multiplan for the MacIntosh
3304#Apple LOGO: programming and problem solving
3305#ProDOS and beyond: Applesoft file techniques
3306#Computing without mathematics: basic Pascal applications
3307#Pascal with program design
3308#Problem solving with Pascal: programming methods, algorithms, and data structures
3309#UCSD Pascal for the IBM PC
3310#Problem solving using IBM PC Pascal
3311#Pascal as a second language
3312#Personal Pascal: Compiled Pascal for the IBM personal computer
3313#Pascal user manual and report; 3rd ed.
3314#Pascal: understanding programming and problem solving
3315#Learning Macintosh Pascal
3316#Pascal for the Macintosh
3317#A model implementation of standard Pascal
3318#Pascal applications for the sciences: a self-teaching guide
3319#An introduction to Pascal and precalculus: Apple Pascal version
3320#Computer graphics with Pascal
3321#Pascal: structure and style
3322#Qualitative reasoning about physical systems
3323#Proc. of IFIP WG 6.1 4th Int'l Workshop on Protocol specification, testing, and verification, IV
3324#The hidden messages in computer networks
3325#Not only windmills: female service workers and new technologies
3326#Computers and work content, work load and stress-analyses and women's participation strategies
3327#Participation of women: a report of working group 2
3328#Education and training: some introductory comments
3329#Computer jobs: career formation of female computer experts and selection for the occupation - reflections from a longitudinal study in Finland (1965-1982)
3330#Resisters or outsiders? A study of female engineering students at the Technical Univ. of Norway, NHT
3331#Womencentred strategies for education and training. A report from working-group 3
3332#The country reports: some comments
3333#Austria: a report on women and computerization
3334#France: a report on women and computerization
3335#Denmark: a report on women and computerization
3336#Finland: a report on women and computerization
3337#Norway: a report on women and computerization
3338#Sweden: a report on women and computerization
3339#Procedural elements for computer graphics
3340#Things the manual never told you: IBM PC ed
3341#Proc. of the fifth technical conference of the British Computer Society Specialist Group on Expert Systems on Expert systems 85
3342#Expert systems-some problems and opportunities
3343#What do users ask? Some thoughts on diagnostic advice
3344#Relevant criteria for choosing an inference engine in expert systems
3345#Generalised alpha-beta pruning as a guide to expert system question selection
3346#Expert systems techniques: an application in statistics
3347#A model based expert system for HW troubleshooting driven by compiled control knowledge
3348#ESCORT: the application of causal knowledge to real-time process control
3349#A review of knowledge-based planning techniques
3350#Allocation abilities to actors
3351#Choice making in planning systems
3352#The ECO browser
3353#A CAD/CAPP expert system shell
3354#Symbolic uncertain inference: a study of possible modalities
3355#Inference under uncertainty
3356#SOJA: a daily workshop scheduling system, SOJA's system and inference engine
3357#Real time multiple-motive expert systems
3358#O-Plan: control in the open planning architecture
3359#An expert system for efficient office object management
3360#Comprehension by model-building as a basis for an expert system
3361#Acquisition of control and domain knowledge by watching in a blackboard environment
3362#Altering the description space for focussing
3363#Deep knowledge representation techniques
3364#An application of knowledge based techniques to VLSI design
3365#Where's the expertise? Expert systems as a medium of knowledge transfer
3366#Introduction to computer theory
3367#Database analysis and design
3368#Using the IBM PC: organization and assembly language programming
3369#Executable description of the OSI transport service in Prolog
3370#What arbitrators think about technology replacing labor
3371#The ATARI 104OST
3372#Finding the Titanic
3373#Real-time clocks: a view toward the future
3374#A simple windowing system, part 1: basic principles
3375#An ANSI standard for the C language
3376#Macintosh explorer
3377#Working at home with computers
3378#Using images to generate speech
3379#The electronic university network
3380#The technology of the Kurzweil voice writer
3381#Increasing independence for the aging
3382#Computing for the blind user
3383#Kaypro 286i
3384#Modula-2 system for Z80 CP/M
3385#Pocket APL
3386#Arity/Prolog
3387#Braille-Edit
3388#Printit
3389#All sorts of software
3390#First in a series
3391#68000 Wars: round 1
3392#A new language and a laptop
3393#The Amstrad PCW 8256
3394#Diophantine equations
3395#A heuristic is given for finding minimal perfect hash functions without extensive searching. The procedure is to construct a set of graph (or hypergraph) models for the dictionary, then choose one of the models for use in constructing the minimal perfect hashing function. The construction of this function relies on a backtracking algorithm for numbering the vertices of the graph. Careful selection of the graph model limits the time spent searching. Good results have been obtained for dictionaries of up to 181 words. Using the same techniques, non-minimal perfect has functions have been found for sets of up to 667 words.
3396#An overview of information engineering: objectives, principles, methodologies, and techniques; precedes an outline with some suggestions for a course on information engineering. The course will be offered in Puerto Rico for the first time on the Spring semester. The author plans to present on a future date a critique on the course and his experiences.
3397#The purpose of this paper is to report on some experiences in the planning and implementation of an introductory course on computer graphics. The course focused on topics of concern to the computer science major interested in developing graphics system software.
3398#The design and implementation of graphics packages has been widely studied and discussed. The special needs of the teaching environment change the requirements of a package in some interesting ways because the details usually hidden from the user are of interest to the students. Here the design of such a package is considered. In order to identify the needs of the package, the structures of CORE (which is used throughout as an example of an applications-oriented package) are compared with a list of topics covered in an elementary graphics course. Some of the nonessential flexibility of CORE can be thrown away, and procedures needed to handle hierarchy and manipulation of the structured display file can be added. A package (the Northwestern University Simple Graphics Package) resulting from this analysis is described. Specific suggestions are made for pruning CORE to a manageable size. A natural way of accessing the structured display files and a system of symbols are included. The resulting package is small, manageable and useful.During the summer of 1983 I was given the opportunity to teach the first computer graphics course to be offered at the University of Chicago. The only available software was PLOT-10 [11], in a version designed to interface to FORTRAN on the DEC-20. The only prerequisite for the course was an elementary programming course which taught PASCAL, hence the students could not be expected to program in FORTRAN. Some experimentation with the versions of FORTRAN, PASCAL, and PLOT-10 on the DEC-20 revealed that interfacing the PLOT-10 routines to PASCAL wasn't going to work. A second, more important, reason for rejecting this option was the lack of segmentation capability in PLOT-10. I was planning to use Principles of Interactive Computer Graphics by Foley and Van Dam [3] and I wanted the students to be able to program in the spirit of the ACM CORE [4] inspired Simple Graphics Package (SGP) used in the text. My solution was to implement this SGP in PASCAL on the DEC-20, with drivers for two of the terminal types available on campus. During the quarter I taught the course I realized that this was not an adequate solution. There were some things I just couldn't demonstrate for the students and some things that I couldn't put into the programming assignments.For example, a fair amount of time was spent discussing package implementation: clipping algorithms, coordinate transformations, the segment data (visibility, detectability), etc. It was impossible, in the UC SGP, to look at this information as an image was constructed and modified. It was equally impossible for the students to manipulate these constructs directly.I would have had similar problems with a full implementation of CORE and with any other package with which I am familiar. Basically, the packages designed for graphics applications hide the details of the implementation and present a high level view to the user. This is great when implementing an interactive graphics program but it is not so great when trying to teach how the packages work.This should not be taken as a blanket condemnation of the use of packages for computer graphics classes, nor as a suggestion that students should always be reduced to programming at the display processor level. There are good reasons for using packages, or at least package-like systems, in an elementary graphics course. Packages provide the user-friendly environment needed to start the students in computer graphics, and to allow the students to become familiar with graphics software as it exists in the real world. The students will learn the style and format of CORE, GKS [6, 12, 13, 14], PLOT-10, or whatever package is chosen. Last, but perhaps most important to a busy instructor (and is there any other kind?), using a package means writing a minimum of new software.Learning from the experience of writing and using the UC SGP, I modified the package to include some extra capabilities. At this time the package was also moved to a VAX 11/780 at Northwestern University. The design described in this paper includes slightly more than either of these packages. (Throughout the discussion the first package is called UC SGP and the second NU SGP.)The design and implementation of a graphics teaching system depends on the available tools. If there is already a sophisticated package, a little bit of extra software may suffice. I'm going to consider the situation in which a new package will be written expressly for use in teaching. Similar considerations are valid when extending an extant package. There are certain objectives to keep in mind. The package should be small so that it runs efficiently and so that it can be implemented with a reasonable effort. The features which will make it a good learning tool should be emphasized and those which further flexibility but not insight can be de-emphasized. The system should be designed to work with dumb terminals, if those are the ones likely to be available in sufficient quantity for student use. (If there are enough smart terminals the package can do a little more and may be easier to produce.) When designing a small system like this one, it is a good idea to keep the available hardware in mind, retaining sufficient flexibility to include other hardware later. (In the real world the flexibility of the package depends somewhat on the shortness of the time available for the implementation.)I'd like to start with the ACM CORE, a well documented and well known system, and sculpt it to the needs of teaching carving away some excess and adding some new capabilities.
3399#The SIGGRAPH Education Committee has been considering recommendations for inclusion of graphics in various curricula for higher education. Several issues of computer graphics in computer science or computer science/engineering curricula are identified here. In particular the course content and support facilities necessary and the status of graphics courses within programs are discussed. A basic premise is stated that Curriculum '78[1] and other guidelines[2, 3, 4, 5, 6] for educational programs are flawed in their lack of computer graphics content. The reasons for this are not immediately apparent, but might in part be attributed to the lower profile of graphics during the time of their initial development. Since that time the significant technical advancements and standardization of terms and concepts have not been incorporated as changes in recommended curricula designs.
3400#There is ambivalence among computer science educators regarding the degree to which ethical and value questions should be incorporated in the computer science curriculum. This paper states a philosophical case for substantive treatment of these topics in colleges committed to the liberal arts, and goes on to consider some of the practical difficulties involved.
3401#This paper describes a research project which commenced recently at the NIHE, L. The project investigates the use of micro-computer software to teach aspects of computer science. Spreadsheets are the subject of this report. The potential of spreadsheet systems for teaching assembler programming is considered. We outline a model for enabling students to acquire fundamental computer science concepts using a simplistic “language machine”. The language machine is embedded in a programmable spreadsheet package which acts as the host language. The aim of the project is to explore the possibility of creating interactive, robust and instructional computer models using some of the more powerful spreadsheet packages in an imaginative fashion.
3402#Visual models help to convey programming insights and computer science principles. This paper describes the design criteria for a software system which automatically constructs visual models as a program runs. Line-by-line execution and data structures are dynamically updated on a display screen. The system can be used either by an instructor in class demonstrations, or by the student in running his or her own programs.Motivations for the design criteria are discussed, along with tradeoffs in implementation. A system has been developed for the Pascal programming language, running on a variety of popular microcomputers.
3403#How to write a really good user's manual
3404#Cost estimation with microcomputers
3405#Using computers: human factors in information systems
3406#Bulldog: a compiler for VLSI architectures
3407#Softwar
3408#The genesis of microprogramming
3409#Marketing the monster: advertising computer technology
3410#Early transistor computers in Japan
3411#System/360: a retrospective view
3412#The start of IFIP—personal recollections
3413#The ideal computer language is seen as one that would be as readable as natural language, and so adaptable that it could serve as the only language a user need ever know. An approach to language design has emerged that shows promise of allowing one to come much closer to that ideal than might reasonably have been expected. Using this approach, a language referred to as ML has been developed, and has been implemented as a language-creation system in which user-defined procedures invoked at translation time translate the source to some object code. In this way the user can define both the syntax and the semantics of the source language. Both language and implementation are capable of further development. This paper describes the approach, the language, and the implementation and recommends areas for further work.
3414#Problems in engineering drawing for design and production; vol. I (9th ed.)
3415#The formalization of legislation and the development of computer systems to assist with legal problem solving provide a rich domain for developing and testing artificial-intelligence technology.
3416#By ensuring entry to subsystems (zones) with different facilities and security levels, log-in procedures can do more than simply delay illicit access.
3417#File organizations based on conventional hash functions provide faster access to the stored records in comparison with tree-like file structures. Tree structures such as B+-trees and ISAM do provide for sequential processing, but require considerable storage for the indices. When sequential processing is needed a table that performs an order-preserving transformation on keys can be used. H is an order-preserving key transform if H(K1) &ges; H(K2), for all keys K1 K2. We present methodologies for constructing such key transforms, and illustrate them for some real-life key sets. Storage requirements for the table needed to carry out the transformation are less than those needed for the indices.
3418#A record-based, algebraically-oriented model is introduced for describing data for “object histories” (with computation), such as checking accounts, credit card accounts, taxes, schedules, and so on. The model consists of sequences of computation tuples defined by a computation-tuple sequence scheme (CSS). The CSS has three major features (in addition to input data): computation (involving previous computation tuples), “uniform” constraints (whose satisfaction by a computation-tuple sequence u implies satisfaction by every interval of u), and specific sequences with which to start the valid computation-tuple sequences. A special type of CSS, called “local,” is singled out for its relative simplicity in maintaining the validity of a computation-tuple sequence. A necessary and sufficient condition for a CSS to be equivalent to at least one local CSS is given. Finally, the notion of “local bisimulatability” is introduced for regarding two CSS as conveying the same information, and two results on local bisimulatability in connection with local CSS are established.
3419#The concept of a tuple sequence is introduced in order to investigate structure connected with relational model implementation. Analogs are presented for the relational operations of projection, join, and selection, and the decomposition problem for tuple sequences is considered. The lexicographical ordering of tuple sequences is studied via the notion of (lexicographic) index. A sound and complete set of inference rules for indexes is exhibited, and two algorithmic questions related to indexes examined. Finally, indexes and functional dependencies in combination are studied.
3420#The desirability of acyclic (conflict-free) schemes is well argued in [8] and [13]. When a scheme is described by multivalued dependencies, acyclicity means that the dependencies do not split each other's left-hand side and do not form intersection anomalies. It is shown that if the second condition fails to hold, the scheme can be amended so that it does hold. The basic step is to add one attribute and some dependencies to resolve one intersection anomaly. This step generates an extension of the given scheme in which the anomaly does not exist. Also, the iterative use of the basic step is analyzed and it is proved that the transformation so defined terminates and removes all intersection anomalies.
3421#The basic inference problem is defined as follows: For a finite set X = {xi, 聟 , xn}, we wish to infer properties of elements of X on the basis of sets of "queries" regarding subsets of X. By restricting these queries to statistical queries, the statistical database (SDB) security problem is obtained. The security problem for the SDB is to limit the use of the SDB so that only statistical information is available and no sequence of queries is sufficient to infer protected information about any individual. When such information is obtained the SDB is said to be compromised. In this paper, two applications concerning the security of the SDB are considered: On-line application. The queries are answered one by one in sequence and it is necessary to determine whether the SDB is compromised if a new query is answered. Off-line application. All queries are available at the same time and it is necessary to determine the maximum subset of queries to be answered without compromising the SDB. The complexity of these two applications, when the set of queries consists of (a) a single type of SUM query, (b) a single type of MAX/MIN query, (c) mixed types of MAX and MIN queries, (d) mixed types of SUM and MAX/MIN queries, and (e) mixed types of SUM, MAX, and MIN queries, is studied. Efficient algorithms are designed for some of these situations while others are shown to be NP-hard.
3422#The notion of sort set is introduced here to formalize the fact that certain database relations can be sorted so that two or more columns are simultaneously listed in order. This notion is shown to be applicable in several ways to enhance the efficiency of an implemented database. A characterization of when order dependency implies the existence of sort sets in a database is presented, along with several corollaries concerning complexity, Armstrong relations, and cliques of certain graphs. Sort-set dependencies are then introduced. A (finite) sound and complete set of inference rules for sort-set dependencies is presented, as well as a proof that there is no such set for functional and sort-set dependencies taken together. Deciding logical implication for sort-set dependencies is proved to be polynomial, but if functional dependencies are included the problem is co-NP-complete. Each set of sort-set and functional dependencies is shown to have an Armstrong relation. A natural generalization of Armstrong relation, here called separator, is given and then used to study the relationship between order and sort-set dependencies.
3423#Let Hn be the height of a binary search tree with n nodes constructed by standard insertions from a random permutation of 1, … , n. It is shown that Hn/log n → c = 4.31107 … in probability as n → ∞, where c is the unique solution of c log((2e)/c) = 1, c ≥ 2. Also, for all p 0, limn→∞E(Hpn)/ logpn = cp. Finally, it is proved that Sn/log n → c* = 0.3733 … , in probability, where c* is defined by c log((2e)/c) = 1, c ≤ 1, and Sn is the saturation level of the same tree, that is, the number of full levels in the tree.
3424#This paper considers a variant of the Byzantine Generals problem, in which processes start with arbitrary real values rather than Boolean values or values from some bounded range, and in which approximate, rather than exact, agreement is the desired goal. Algorithms are presented to reach approximate agreement in asynchronous, as well as synchronous systems. The asynchronous agreement algorithm is an interesting contrast to a result of Fischer et al, who show that exact agreement with guaranteed termination is not attainable in an asynchronous system with as few as one faulty process. The algorithms work by successive approximation, with a provable convergence rate that depends on the ratio between the number of faulty processes and the total number of processes. Lower bounds on the convergence rate for algorithms of this form are proved, and the algorithms presented are shown to be optimal.
3425#In solving large sparse linear least squares problems A x &sime; b, several different numeric methods involve computing the same upper triangular factor R of A. It is of interest to be able to compute the nonzero structure of R, given only the structure of A. The solution to this problem comes from the theory of matchings in bipartite graphs. The structure of A is modeled with a bipartite graph, and it is shown how the rows and columns of A can be rearranged into a structure from which the structure of its upper triangular factor can be correctly computed. Also, a new method for solving sparse least squares problems, called block back-substitution, is presented. This method assures that no unnecessary space is allocated for fill, and that no unnecessary space is needed for intermediate fill.
3426#In this paper a powerful, and yet simple, technique for devising approximation algorithms for a wide variety of NP-complete problems in routing, location, and communication network design is investigated. Each of the algorithms presented here delivers an approximate solution guaranteed to be within a constant factor of the optimal solution. In addition, for several of these problems we can show that unless P = NP, there does not exist a polynomial-time algorithm that has a better performance guarantee.
3427#Currently, network codes based on the primal simplex algorithm are believed to be computationally superior to those based on other methods. Some modifications of the out-of-kilter algorithm of Ford and Fulkerson are given, together with proofs of their correctness and computer implementations using appropriate data structures. The computational tests in this paper indicate that the final code based on these modifications is superior to any previously implemented version of this algorithm. Although this code is not competitive with state-of-the-art primal simplex codes, its performance is encouraging, especially in the case of assignment problems.
3428#A method is presented for calculating the partition function, and from it, performance measures, for closed Markovian stochastic networks with queuing centers in which the service or processing rate depends on the center's state or load. The analysis on which this method is based is new and a major extension of our earlier work on load-independent queuing networks. The method gives asymptotic expansions for the partition function in powers of 1/N, where N is a parameter that reflects the size of the network. The expansions are particularly useful for large networks with many classes, each class having many customers. The end result is a decomposition by which expansion coefficients are obtained exactly by linear combinations of partition function values of small network constructs called pseudonetworks. Effectively computable bounds are given for errors arising from the use of a finite number of expansion terms. This method is important because load dependence is at once an essential element of sophisticated network models of computers, computer communications, and switching, teletraffic, and manufacturing systems, and the cause of very intensive computations in conventional techniques. With this method, very large load-dependent networks can be analyzed, whereas previously only small networks were computationally tractable.
3429#A queuing system with infinitely many servers, and with the following queuing discipline is considered: For any two jobs i and j in the system, such that i arrived later than j, there is a fixed probability p that i will have to wait for j's execution to terminate before i starts executing. This queuing system is a very simple model for database concurrency control via “static” locking, as well as of parallel execution of programs consisting of several interdependent processes. The problem of determining the maximum arrival rate (as a function of p) that can be sustained before this system becomes unstable is studied. It is shown that this rate is inversely proportional to p, and close upper and lower bounds on the constant for the case of deterministic departures are found. The result suggests that the degree of multiprogramming of multiuser databases, or the level of parallelism of concurrent programs, is inversely proportional to the probability of conflict, and that the constant is small and known within a factor of 2. The technique used involves the computation of certain asymptotic parameters of a random infinite directed acyclic graph (dag) that seem of interest by themselves.
3430#Questions about the polynomial-time hierarchy are studied. In particular, the questions, “Does the polynomial-time hierarchy collapse?” and “Is the union of the hierarchy equal to PSPACE?” are considered, along with others comparing the union of the hierarchy with certain probabilistic classes. In each case it is shown that the answer is “yes” if and only if for every sparse set S, the answer is “yes” when the classes are relativized to S if and only if there exists a sparse set S such that the answer is “yes” when the classes are relativized to S. Thus, in each case the question is answered if it is answered for any arbitrary sparse oracle set.Long and Selman first proved that the polynomial-time hierarchy collapses if and only if for every sparse set S, the hierarchy relative to S collapses. This result is re-proved here by a different technique.
3431#Baker, Gill, and Solovay constructed sparse sets A and B such that P(A) ≠ NP(A) and NP(B) ≠ co-NP(B). In contrast to their results, we prove that P = NP if and only if for every tally language T, P(T) = NP( T), and that NP = co-NP if and only if for every tally language T, NP(T) = co-NP(T). We show that the polynomial hierarchy collapses if and only if there is a sparse set S such that the polynomial hierarchy relative to S collapses. Similar results are obtained for several other complexity classes.
3432#Two issues in public key cryptography: RSA bit security and a new knapsack type system
3433#Network structure and the firing squad synchronization problem
3434#A guide to packet-switched, value-added networks
3435#Local-area networks with fiber-optic applications
3436#Principles of distributed data-base design
3437#Digital, analog, and data communication (2nd ed.)
3438#A. M. Turing's ACE report of 1946 and other papers
3439#Design of geosynchronous spacecraft
3440#The rapid development of robotics and the resulting need for computer scientists to be better trained in traditional mathematics necessitate changes in computer science curricula.
3441#Research on legged machines can lead to the construction of useful legged vehicles and help us to understand legged locomotion in animals.
3442#Numerical control (NC) machining could be reinvigorated by adapting robotic software technology. Regrettably, pressures are mounting in industry to constrain robots to NC standards, and the academic community views NC as an obsolete, solved problem, with little remaining scholarly challenge. Grossman examines the current status of APT, an NC language, and proposes the merging of APT with a modern robotics language.
3443#A program for the normalization of relations that is written in Prolog has several advantages relative to programs written in conventional programming languages: notably, conciseness and clarity. The program presented here implements several normalization algorithms and is suitable for the interactive design of small database applications and as a teaching aid.
3444#Recent research has shown that key DP/IS personnel job outcomes (e.g., turnover, organizational commitment, job satisfaction) are affected by job design, leadership characteristics, and role variables. This study investigates another class of variables, the technological environment faced by DP/IS personnel, that might impact these job outcomes. The technological environment includes (1) development methodologies employed, (2) project teams and reporting relationships, and (3) work characteristics. Variables from all classes were found to impact DP/IS job outcomes. Over 11 percent of the variance in DP/IS job satisfaction is explained by these variables.
3445#An Ethernet compatible protocol for real-time voice/data integration
3446#A supercompiler is a program transformer of a certain type. It traces the possible generalized histories of computation by the original program, and compiles an equivalent program, reducing in the process the redundancy that could be present in the original program. The nature of the redundancy that can be eliminated by supercompilation may be various, e.g., some variables might have predefined values (as in partial evaluation), or the structure of control transfer could be made more efficient (as in lazy evaluation), or it could simply be the fact that the same variable is used more than once. The general principles of supercompilation are described and compared with the usual approach to program transformation as a stepwise application of a number of equivalence rules. It is argued that the language Refal serves the needs of supercompilation best. Refal is formally defined and compared with Prolog and other languages. Examples are given of the operation of a Refal supercompiler implemented at CCNY on an IBM/370.
3447#We propose a methodology for the development of concurrent programs and apply it to an important class of problems: quiescence detection. The methodology is based on a novel view of programs. A key feature of the methodology is the separation of concerns between the core problem to be solved and details of the forms of concurrency employed in the target architecture and programming language. We begin development of concurrent programs by ignoring issues dealing with concurrency and introduce such concerns in manageable doses. The class of problems solved includes termination and deadlock detection.
3448#With current compiler technology, changing a single line in a large software system may trigger massive recompilations. If the change occurs in a file with shared declarations, all compilation units depending upon that file must be recompiled to assure consistency. However, many of those recompilations may be redundant, because the change may affect only a small fraction of the overall system.Smart recompilation is a method for reducing the set of modules that must be recompiled after a change. The method determines whether recompilation is necessary by isolating the differences among program modules and analyzing the effect of changes. The method is applicable to languages with and without overloading. A prototype demonstrates that the method is efficient and can be added with modest effort to existing compilers.
3449#Methods are known for the exact computation of the solution of integer systems of linear equations AX = B with a nonsingular coefficient matrix A by congruence techniques. These methods are now generalized for systems with an arbitrary integer coefficient matrix A. To make congruence techniques applicable, a common denominator of all elements of the solution X = A+B must be computed. This is achieved by defining the natural denominator CODE of A+ and describing it by some formulas. Methods for the exact computation of additional results (consistency, null space, solution of at most R nonzero elements), a recursive test to save computing time, and a comparison with some results from the literature are presented.
3450#The program package ACRITH (High-Accuracy Arithmetic Subroutine Library) provides FORTRAN subroutines for the solution of several standard mathematical problems. The routines use floating point operations with extended precision and interval arithmetic and are designated especially for the solution of ill-conditioned problems. Test results for most of the routines are presented with emphasis on the practical usability of the package. It turns out that not all routines are of equal high quality and reliability; in the documentation, hints to the implemented numerical algorithms are completely missing, and the error messages are not always concise. Some possible alternatives like symbolic algebra systems or multiple precision packages are mentioned.
3451#A symbolic node-addition model for matrix factorization of symmetric positive definite matrices is described. In this model, the nodes are added onto the filled graph one at a time. The advantage of the node-addition model is its simplicity and flexibility. The model can be immediately incorporated into finite element analysis programs. The model can also be extended to determine modification patterns in the matrix factors due to changes in the original matrix. For a given matrix K(=LDLt), the time complexity of the algorithm for constructing the structure of the lower triangular matrix factor L is O(&eegr;(L)) where &eegr;(L) is the number of nonzero entries in L.
3452#Popular codes for the numerical solution of nonstiff ordinary differential equations (ODEs) are based on a (fixed order) Runge-Kutta method, a variable order Adams method, or an extrapolation method. Extrapolation can be viewed as a variable order Runge-Kutta method. It is plausible that variation of order could lead to a much more efficient Runge-Kutta code, but numerical comparisons have been contradictory.We reconcile previous comparisons by exposing differences in testing methodology and incompatibilities of the implementations tested. An experimental Runge-Kutta code is compared to a state-of-the-art extrapolation code. With some qualifications, the extrapolation code shows no advantage. Extrapolation does not appear to be a particularly effective way to vary the order of Runge-Kutta methods. Although an acceptable way to solve nonstiff problems, our tests raise the question as to whether there is any point in pursuing it as a separate method.
3453#An algorithm for displaying a class of space-filling curves
3454#Processing variable length abbreviations: some observations
3455#A distributed real-time operating system
3456#Experimenting with data structures
3457#A Modula-2 kernel for supporting monitors
3458#The cost of lexical analysis
3459#Inter-process communications in MVS/XA and applications for scientific and engineering information processing
3460#An assumption-based TMS
3461#Extending the ATMS
3462#Problem solving with the ATMS
3463#Arc and path consistence revisited
3464#Inside the IBM PC: access to advanced features and programming; new and enlarged
3465#Considerations on the insularity of performance evaluation
3466#An approach to decentralized computer systems
3467#Operational survivability in gracefully degrading distributed processing systems
3468#The last 10 percent
3469#A survey of software design techniques
3470#AFIPS 1961-1986: 25th anniversary (introduction)
3471#AFIPS 1961-1986: prologue
3472#Harry H. Goode, June 30, 1909-October 30, 1960
3473#Personal recollections on the first quarter-century of AFIPS
3474#Why AFIPS invested in history
3475#AFIPS in retrospect
3476#A new concept in passive ranging to moving objects is described which is based on the comparison of multiple image flows. It is well known that if a static scene is viewed by an observer undergoing a known relative translation through space, then the distance to objects in the scene can be easily obtained from the measured image velocities associated with features on the objects (i.e., motion stereo). But in general, individual objects are translating and rotating at unknown rates with respect to a moving observer whose own motion may not be accurately monitored. The net effect is a complicated image flow field in which absolute range information is lost. However, if a second image flow field is produced by a camera whose motion through space differs from that of the first camera by a known amount, the range information can be recovered by subtracting the first image flow from the second. This ``difference flow'' must then be corrected for the known relative rotation between the two cameras, resulting in a divergent relative flow from a known focus of expansion. This passive ranging process may be termed Dynamic Stereo, the known difference in camera motions playing the role of the stereo baseline. We present the basic theory of this ranging process, along with some examples for simulated scenes.
3477#Inverse problems, such as the reconstruction problems that arise in early vision, tend to be mathematically ill-posed. Through regularization, they may be reformulated as well-posed variational principles whose solutions are computable. Standard regularization theory employs quadratic stabilizing functionals that impose global smoothness constraints on possible solutions. Discontinuities present serious difficulties to standard regularization, however, since their reconstruction requires a precise spatial control over the smoothing properties of stabilizers. This paper proposes a general class of controlled-continuity stabilizers which provide the necessary control over smoothness. These nonquadratic stabilizing functionals comprise multiple generalized spline kernels combined with (noncontinuous) continuity control functions. In the context of computational vision, they may be thought of as controlled-continuity constraints. These generic constraints are applicable to visual reconstruction problems that involve both continuous regions and discontinuities, for which global smoothness constraints fail.
3478#This paper presents a new approach to the extraction of straight lines in intensity images. Pixels are grouped into line-support regions of similar gradient orientation, and then the structure of the associated intensity surface is used to determine the location and properties of the edge. The resulting regions and extracted edge parameters form a low-level representation of the intensity variations in the image that can be used for a variety of purposes. The algorithm appears to be more effective than previous techniques for two key reasons: 1) the gradient orientation (rather than gradient magnitude) is used as the initial organizing criterion prior to the extraction of straight lines, and 2) the global context of the intensity variations associated with a straight line is determined prior to any local decisions about participating edge elements.
3479#This paper discusses how polyhedron interpretation techniques are simplified if the objects are rectangular trihedral polyhedra. This restriction enables one to compute the spatial orientation of a given corner and its motion from its image in terms of polar coordinates, Eulerian angles, and quaternions. One can also interpret the shape and the face adjacency from local information only. The necessary constraints are listed, and some examples are given to compare the presented scheme to existing ones. The possible nonuniqueness of the interpretation is also discussed.
3480#Primality and cryptography
3481#Mastering CAD with the ROBO systems CAD-2; Apple II version
3482#A language for describing communicating systems is described. It is sufficiently expressive to describe both the desired behavior of systems, their specifications, and their actual implementations in terms of simpler components. We say I satisfies S if 1 is a correct implementation of the specification S. We briefly discuss a semantic treatment of this notion of satisfaction, but the main emphasis of the paper is on a proof technique for proving statements of the form I satisfies S, based on syntactic transformations and induction. Two examples are given, both systolic systems from the literature.
3483#The problem of correctness of the solutions to the distributed termination problem of Francez [7] is addressed. Correctness criteria are formalized in the customary framework for program correctness. A very simple proof method is proposed and applied to show correctness of a solution to the problem. It allows us to reason about liveness properties of temporal logic (see, e.g., Manna and Pnueli [12]) using a new notion of weak total correctness.
3484#Computer - Computer science education in the US
3485#First Page of the Article
3486#First Page of the Article
3487#First Page of the Article
3488#First Page of the Article
3489#First Page of the Article
3490#First Page of the Article
3491#First Page of the Article
3492#First Page of the Article
3493#First Page of the Article
3494#First Page of the Article
3495#Proceedings of the fifth ACM SIGACT-SIGMOD symposium on Principles of database systems
3496#On the implementation of a simple class of logic queries for databases
3497#Order preserving linear hashing using dynamic key statistics
3498#Balanced multidimensional extendible hash tree
3499#Alpha-acyclic decompositions of relational database schemes
3500#Constant time maintenance or the triumph of the FD.
3501#Computers: promise and challenge in education
3502#Mechanical theorem proving in the USSR; the Leningrad school
3503#Making The Magic Egg: a personal account
3504#Tour of computer graphics in Japan
3505#Creation of Omnimax animation by computer opens up fantastic new visual possibilities. Unfortunately, the fish-eye distortion of Omnimax film images complicates synthesis by computer, since most image-synthesis programs can create only perspective views. As an alternative to modifying existing image-synthesis programs to produce Omnimax projections directly, we present a method for creating them from multiple perspective views. Four perspective views of the environment are created, each a projection onto a face of a cube centered at the camera, and then a mapping program creates an Omnimax projection from them. To minimize aliasing during resampling, the mapping program uses the elliptical weighted average filter, a space-variant filter we developed for this application that computes a weighted average over an arbitrarily oriented elliptical area. This filter can also be used for texture mapping 3D surfaces.
3506#Computation of the union, intersection, and difference of n-dimensional objects plays a central role in several computer-aided geometric design problems. An algorithm for computing these operations that uses a boundary classification technique is presented here. The algorithm is recursive in structure, with the recursion being on the dimensions of objects dealt with at each stage. The representation treats all entities as objects, making no distinction between faces, edges, or vertices. The objects produced are "regularized"; that is, there are no degenerate boundaries such as dangling edges. The sample application given involves hidden-surface removal.
3507#Existing specification systems, such as the hue/ lighness/saturation system, use triples of numbers to spec1fy color, which can be tedious to work with. The Color Naming system allows users to specify color in natural lanuage phrases or words and is a siperior way for humans to select colors. the problems addressed in this article is how to map the linguistic values of the CNS to the numerical values of the HLS system so that the CNS can be part of an integrated graphics system. The algorithm used is based on fuzzy set theory and is implemented for the Tektronix 4027 color display terminal.
3508#Ordinary bitmaps allow pixels to be black or white. We introduce a second bitmap, the "alpha" bitmap, which allows pixels to be transparent as well. The alpha bitmap makes it possible to have black-and-white images that are nonrectangular or that have holes in them. It also provides a richer set of operations for working with bitmaps. We present the mathematics for a two-bit compositing algebra, and suggest extensions for two-bit compositing, painting, and region filling. Each of these operations can be implemented with ordinary bitblts and presented on ordinary bitmap displays. We analyze the cost of each two-bit operation in terms of the number of bitblts it requires.
3509#Classical algebraic geometry has been virtually ignored in computer-aided geometric design. However, because it deals strictly with algorithms, it is really more suited to this field than is modern algebraic geometry, which introduces abstractions far removed from the algorithmic nature of computer-aided design. This tutorial examines resultants, curve implicitization, curve inversion, and curve intersection. Discussion follows a series of examples simple enough for those with only a modest algebra background to follow.
3510#Classroom computers: a practical guide for effective teaching
3511#The computer and the child: a Montessori approach
3512#The SUPREM architecture: a new intelligent paradigm
3513#On evidential reasoning in a hierarchy of hypotheses
3514#On the satisfiability of circumscription
3515#Similarity and stability analysis of the two Partitioning type clustering algorithms
3516#Structural equivalence in a journal network
3517#Critical thresholds in co-citation graphs
3518#Cosmology and the changing role of libraries: an analogy and reflections
3519#The changing environment of personal information systems
3520#Transferring a national information system from the public sector to the private sector—how the Administration on Aging did it
3521#Schubert's steamroller problem: formulations and solutions
3522#The compilation and analysis of data collected from 125 business schools reveal important trends and identify problems that arise when computers are integrated into education.
3523#Our objective is to understand the notion of type in programming languages, present a model of typed, polymorphic programming languages that reflects recent research in type theory, and examine the relevance of recent research to the design of practical programming languages.Object-oriented languages provide both a framework and a motivation for exploring the interaction among the concepts of type, data abstraction, and polymorphism, since they extend the notion of type to data abstraction and since type inheritance is an important form of polymorphism. We develop a &lgr;-calculus-based model for type systems that allows us to explore these interactions in a simple setting, unencumbered by complexities of production programming languages.The evolution of languages from untyped universes to monomorphic and then polymorphic type systems is reviewed. Mechanisms for polymorphism such as overloading, coercion, subtyping, and parameterization are examined. A unifying framework for polymorphic type systems is developed in terms of the typed &lgr;-calculus augmented to include binding of types by quantification as well as binding of values by abstraction.The typed &lgr;-calculus is augmented by universal quantification to model generic functions with type parameters, existential quantification and packaging (information hiding) to model abstract data types, and bounded quantification to model subtypes and type inheritance. In this way we obtain a simple and precise characterization of a powerful type system that includes abstract data types, parametric polymorphism, and multiple inheritance in a single consistent framework. The mechanisms for type checking for the augmented &lgr;-calculus are discussed.The augmented typed &lgr;-calculus is used as a programming language for a variety of illustrative examples. We christen this language Fun because fun instead of &lgr; is the functional abstraction keyword and because it is pleasant to deal with.Fun is mathematically simple and can serve as a basis for the design and implementation of real programming languages with type facilities that are more powerful and expressive than those of existing programming languages. In particular, it provides a basis for the design of strongly typed object-oriented languages.
3524#This paper presents an in-depth examination of the 4.2 Berkeley Software Distribution, Virtual VAX-11 Version (4.2BSD), which is a version of the UNIX Time-Sharing System. There are notes throughout on 4.3BSD, the forthcoming system from the University of California at Berkeley. We trace the historical development of the UNIX system from its conception in 1969 until today, and describe the design principles that have guided this development. We then present the internal data structures and algorithms used by the kernel to support the user interface. In particular, we describe process management, memory management, the file system, the I/O system, and communications. These are treated in as much detail as the UNIX licenses will allow. We conclude with a brief description of the user interface and a set of bibliographic notes.
3525#Data-flow languages have been hailed as the solution to the programmability of general-purpose multiprocessors. However, data-flow semantics introduce constructs that lead to much overhead at compilation, allocation, and execution time. Indeed, due to its functionality, the data-flow model of computation does not handle repetitive program constructs very efficiently. This is due to the fact that the cornerstone of data flow, namely the concept of single assignment, is opposed to the idea of reexecution of a portion of program as in a loop. A corollary of this problem is the effective representation, storage, and processing of data structures, as these will most often be used in loops. In this paper, various aspects of this issue are explailned in detail. Several solutions that have been put forward in the current literature are then surveyed and analyzed. In order to offset some of the disadvantages presented by these, we introduce new methods for handling arrays. In the first one, we raise the level of computation to that of arrays for more efficient operation. In the two others, the opposite approach is taken, and the notion of array is done away with entirely at the execution level in order to take advantage of the data-flow semantics at their best logical level of performance.
3526#In this paper, a new approach to identifying faulty units in ti-diagnosable systems is described. This approach exploits special properties of the highly structured ti-diagnosable systems to produce a faulty unit identification algorithm which is shown to be of time complexity O(|E|) where |E| corresponds to the number of tests in the system. The diagnosis quality of the algorithm is as follows: 1) if the algorithm identifies a unit as faulty, it is always correct; 2) if the collection of test outcomes takes on a form that is compatible with a permanent fault situation, the algorithm identifies all of the corresponding faulty units; and 3) the algorithm identifies at least one faulty unit over collections of test outcomes significantly larger than those that are compatible with permanent fault situations.
3527#This paper proposes and validates a methodology to measure explicitly the increase in the risk of a processor error with increasing workload. By relating the occurrence of a CPU related error to the system activity just prior to the occurrence of an error, the approach measures the dynamic CPU workload/failure relationship. The measurements show that the probability of a CPU related error (the load hazard) increases nonlinearly with increasing workload; i.e., the CPU rapidly deteriorates as end points are reached. The load hazard is observed to be most sensitive to system CPU utilization, the I/O rate, and the interrupt rates. The results are significant because they indicate that it may not be useful to push a system close to its performance limits (the previously accepted operating goal) since what we gain in slightly improved performance is more than offset by the degradation in reliability. Importantly, they also indicate that conventional reliability models need to be reevaluated so as to take system work-load explicity into account.
3528#Previous models of program speedup on parallel architectures tend to ignore I/O activity and other important issues. In this paper we derive analytic speedup models including I/O activities. We show that ignoring I/O yields conservative speedup results. We explore the effectiveness of using hardware format conversion units in multiprocessors [33]. We prove that hardware parallel format conversion loses its edge over software parallel format conversion if the ratio of the number of processors to I/O bandwidth increases. For a given number of processors, program speedup is more sensitive to the available I/O bandwidth rather than the format conversion speed. Ninety-one Fortran programs are used in various experiments to verify our models and conclusions. Most of the programs are I/O bound. Our empirical results show that including I/O activity improves the speedup factor for 78 percent of the programs, and 18 percent of the programs are sped up only due to faster I/O activities. For a serial machine, using hardware format conversion units designed in [13] reduces program execution time by an average factor of three. The software format conversion speed used is obtained from direct measurements on an IBM 4341 running CMS and a CDC Cyber 175 running NOS. For multiprocessor systems a factor of eight increase in the processors to I/O bandwidth ratio reduces the effectiveness of hardware format conversion to an average factor of 1.36.
3529#We present a tool that is useful in the design and analysis of systolic systems. Specifically, we give characterizations of systolic arrays in terms of (single processor) sequential machines which are easier to program and to analyze. We give several examples to illustrate the utility of the design tool. In particular, we show how systolic designs for such problems as integer bitwise multiplication, dynamic programming, and language recognition can easily be derived using the characterizations. We also present some new results concerning the properties and computational power of systolic arrays which can be obtained using the characterizations.
3530#The problem of connecting a set of terminals that lie on the sides of a rectangle to minimize the total area is discussed. We present an O(nm) approximation algorithm to solve this problem where n is the number of terminals and m is the number of signal nets. Our algorithm generates a solution with an area 驴1.69* OPT where OPT is the area of an optimal solution. Our algorithm routes some of the nets by a simple greedy strategy. The remaining nets are routed using several strategies and four layouts are obtained. The best of these layouts is the solution generated by our algorithm.
3531#When we design networks with NOR or NAND gates which are implemented with bipolar and MOS transistors, wired logic is usually allowed. The usage of wired logic reduces the network cost and possibly improves the speed because of shorter delays on wired logic than on a gate. Typical logic functions performed by wired logic are AND and OR, which are called wired-AND and wired-OR, respectively. Properties of networks with NOR gates and wired-AND (or wired-OR) are discussed. Some of these properties are used in developing synthesis procedures of optimum networks by the integer programming logic design method. For all three-variable functions, the optimum networks with NOR gates and wired-OR's, designed by this synthesis approach, are shown.
3532#In order to be able to take full advantage of a distributed computing facility it is important not only to distribute the hardware but also to distribute the control of these resources. However, distributed control is very different from centralized control since at any time, several processes or several controllers may observe different and inconsistent views of the global system state. The task of scheduling jobs in a distributed system must also be done Without full knowledge of the system state. In this correspondence we define a totally new distributed scheduling algorithm LP (linear predictive). scheduling, which not only implements distributed control of task scheduling but is also able to adapt itself to workload fluctuations. Using a general-purpose distributed system simulator we have shown the performance rnitince advantages of this new algorithm.
3533#A general technique that can be used to solve a wide variety of discrete optimization problems is the branch-and-bound algorithm. We have adapted and extended branch-and-bound algorithms for parallel processing. The computational efficiency of these algorithms depends on the allowance function, the data structure, and the search strategies. Anomalies owing to parallelism may occur. In this correspondence, anomalies of parallel branch-and-bound algorithms using the same search strategy as the corresponding serial algorithms are studied. Sufficient conditions to guarantee no degradation in performance due to parallelism and necessary conditions for allowing parallelism to have a speedup greater than the number of processors are presented.
3534#The throughput of unbuffered shuffle-exchange networks (also known as delta networks) is related to the arrival rate by a quadratic recurrence relation. Lower and upper bounds on the solution of this recurrence relation are derived in this paper. Two approaches for improving the throughput of unbuffered delta networks are investigated. The first approach combines multiple delta subnetworks of size N x N each, in parallel, to obtain a network of size N x N. Three policies used to distribute the incoming packets between the subnetworks are discussed and the relative effect of each on the throughput is compared. The second approach replaces each link of the simple delta networks by K parallel links (K equals 2,4,...,). The throughput of such networks is analyzed and one possible implementation for crossbar switches that could be used in these networks is discussed. The throughput of such networks with four parallel links is almost equal to the throughput of crossbars.
3535#A new multistage interconnection network is presented in this paper. It is able to handle the communications between the connected devices correctly, even in the presence of fault(s) in the network. This goal is achieved by using redundant paths with a fast procedure able to dynamically reroute the message. It is also shown that the rerouting properties are still valid when broadcasting transmission is used.
3536#Computer-assisted business plans
3537#The practitioner's blueprint for logical and physical database design
3538#A standard for testing application software
3539#Decision support systems: putting theory into practice
3540#On the design of ALEPH
3541#MIS, concept and design (2nd ed.)
3542#Business programming logic: a structured approach (3rd ed.)
3543#Assembly with robots
3544#Information structures: a uniform approach using Pascal
3545#Perceptual organization and the representation of natural form
3546#A syntactic theory of belief and action
3547#Subjective inference with multiple evidence
3548#Management, information and expert systems
3549#Information structures: implementing imagination
3550#MH: a multifarious user agent
3551#Fault diagnosis and automatic reconfiguration for a ring subsystem
3552#A unified analysis of steady state behavior in random access schemes
3553#Distributed operating systems have many aspects in common with centralized ones, but they also differ in certain ways. This paper is intended as an introduction to distributed operating systems, and especially to current university research about them. After a discussion of what constitutes a distributed operating system and how it is distinguished from a computer network, various key design issues are discussed. Then several examples of current research projects are examined in some detail, namely, the Cambridge Distributed Computing System, Amoeba, V, and Eden.
3554#A workbook for software entrepreneurs
3555#Design of distributed computer systems is a complex task requiring solutions for several difficult problems. Location of computing resources and databases in a wide-area network is one of these problems which has not yet been solved satisfactorily. Solution of this problem involves determining number and size of computer facilities and their locations, configuring databases and allocating these databases among computer facilities. An integer programming formulation of the problem is presented. Heuristic and optimal solution procedures are developed and computational experience with these procedures is reported. Implications of the model for designing distributed systems are discussed.
3556#In this paper, we present a new model, finite permutation machine (FPM), to describe the permutation networks. A set of theorems are developed to capture the theory of operations for the permutation networks. Using this new framework, an interesting problem is attacked: are 2n - 1 passes of shuffle exchange necessary and sufficient to realize all permutations? where n = log2 N and N is the number of inputs and outputs interconnected by the network. We prove that to realize all permutations, 2n - 1 passes of shuffle exchange are necessary and that 3n - 3 passes are sufficient. This reduces the sufficient number of passes by 2 from the best-known result.
3557#A new class of switch-level logic circuits intended for modeling digital MOS VLSI circuits is presented. These circuits, which are called pseudo-Boolean, are composed of a single (voltage) source, connectors, switches, attenuators, and wells. The latter two devices are digital versions of resistors and capacitors, respectively, and may assume an arbitrary but finite number of different sizes. Signals are bidirectional, and are assigned a finite set of values of the form (v, s) where v corresponds to voltage level and s corresponds to electrical current or charge level (logical strength). It is shown that these signal values and the associated logical operations form a generalization of Boolean algebra called pseudo-Boolean or Heyting algebra. The analysis of pseudo- Boolean circuits using discrete counterparts of Kirchoff's current law and the superposition principle is discussed, as well as the application of pseudo-Boolean techniques to digital simulation.
3558#One of the significant differences between the CRAY X-MP and its predecessor, the CRAY-1S, is a considerably increased memory bandwidth for vector operations. Up to three vector streams in each of the two processors may be active simultaneously. These streams contend for memory banks as well as data paths. All memory conflicts are resolved dynamically by the memory system. This paper describes a simulation study of the CRAY X-MP interleaved memory system with attention focused on steady state performance for sequences of vector operations. Because it is more amenable to analysis, we first study the interaction of vector streams issued from a single processor. We identify the occurrence of linked conflicts, repeating sequences of conflicts between two or more vector streams that result in reduced steady state performance. Both worst case and average case performance measures are given. The discussion then turns to dual processor interactions. Finally, based on our simulations, possible modifications to the CRAY X-MP memory system are proposed and compared. These modifications are intended to eliminate or reduce the effects of linked conflicts.
3559#A well-known technique for providing tolerance against single hardware component failures is triplication of the component, called triple modular redundancy (TMR). In this paper a component is taken to be a processor-memory configuration where the memory is organized in a bit-sliced way. If voting is performed bitwise in an orthodox TMR configuration consisting of three of these components, failure of a complete component or failure of bit-slices not on corresponding positions in the memories can be tolerated. We present a TMR technique, not using more redundancy than orthodox TMR, that can tolerate the failure of arbitrary bit-slices (including those on corresponding positions) up to a certain amount. Additionally it can tolerate the failure of arbitrary bit-slices up to a certain amount whenever one component is known to be malfunctioning or whenever one component is disabled. This generalized TMR technique is described for processor-memory configurations processing 4-, 8-, and 16-bit words, respectively.
3560#A low-level parallel processor (LLPP) is one in which two or more machine-level operations are executed in parallel. This paper analyzes the use of linearly connected LLPP's for parallel evaluation of program fragments. A graph-theoretic model is presented which describes the communication constraints of linearly connected parallel processors. A tight, necessary condition for finding assignments of program fragments to linearly connected LLPP's that require no communication delays is presented. Also, several weak sufficient conditions have been found and efficient heuristics for determining optimal assignments have been developed.
3561#Data structured program design
3562#An adaptive shooting method for singularly perturbed boundary value problems
3563#Consider a classical PMC system composed of n units [1] where it is assumed that at most t1 of these units are faulty. Such a system is said to be t1/t1-diagnosable [3] if, given any complete collection of test results, the set of faulty units can be isolated to within a set of at most t1 units. This paper exposes some new, important properties of general t1/t1-diagnosable systems to present an O(n2.5) algorithm by which all the faulty units except at most one can be correctly identified and all the faulty units can be isolated to within a set of t1 or fewer units in which at most one can possibly be fault free.
3564#This paper considers the possibility of achieving improvements in the reliability of synchronizing an asynchronous signal, by exploiting redundancy and masking. Redundancy and masking techniques have been applied successfully to mask both permanent and transient hardware faults. However, it is shown in this paper that redundancy and masking techniques are ineffective against synchronization failures which arise because of metastable behavior of synchronizing elements.
3565#Byte-oriented error-correcting codes are useful in correcting and detecting errors in a memory system organized in multiple-bit-perchip fashion. This paper presents the construction of new single-byte error-correcting and double-byte error-detecting codes.
3566#Recently, a new algebra for manipulating complex residue numbers was reported. Its advantage over traditional methods is a reduced complex multiplication budget. In this work a complex integer to complex residue encoder is developed for use with this new numbering system.
3567#Computing max{a1+ b1, a2+ b2, ... ,an+ bn} trivially takes n additions. We show that if we are given the ranking for the a's and the b's separately, then an algorithm exists which will compute the maximum in ?2n additions on the average. This can be generalized to yield an efficient algorithm to compute max{h(a1,b1
3568#The problem of testing sequential machines using checking experiments is investigated. A method of modifying sequential machines by adding a controllable input is presented. A procedure is given to construct checking experiments for the modified machine and it is shown that only one output observation is sufficient to determine whether the machine is fault free.
3569#Performing permutations of data on SIMD computers efficiently is important for high-speed execution of parallel algorithms. In this correspondence we consider realizing permutations such as perfect shuffle, matrix transpose, bit-reversal, the class of bit-permute- complement (BPC), the class of Omega, and inverse Omega permutations on N = 2n processors with Illiac IV-type interconnection network, where each processor is connected to processors at distances of ± 1 and ± N. The minimum number of data transfer operations required for realizing any of these permutations on such a network is shown to be 2(N − 1). We provide a general three-phase strategy for realizing permutations and derive routing algorithms for performing perfect shuffle, Omega, Inverse Omega, bit reversal, and matrix-transpose permutations in 2(N − 1) steps. Our approach is quite simple, and unlike previous approaches, makes efficient use of the topology of the Illiac IV-type network to realize these permutations using the optimum number of data transfers. Our strategy is quite powerful: any permutation can be realized using this strategy in 3(N − 1) steps.
3570#Image processing operations require that an image or partial image be stored in a memory system that permits access to p 脳 q, 1 脳 pq, and/or pq 脳 1 subarrays of an image array where p and q are design parameters.
3571#Pseudorandom arrays for built-in tests
3572#Database history: from dinosaurs to compact discs
3573#Natural language processing in information retrieval
3574#Views on end-user searching
3575#Computer environments for children: a reflection on theories of learning and education
3576#Electronics applications sourcebook; 1986 ed.; vol. 1.
3577#Electronics applications sourcebook; 1986 ed.; vol. 2.
3578#Making computers talk: an introduction to speech synthesis
3579#An objective method of “weeding” bibliographic databases
3580#Calibrating databases
3581#Observations of end-user online searching behavior over eleven years
3582#Transparent information systems through gateways, front ends, intermediaries, and interfaces
3583#Future generation information systems
3584#The dual of Bradford's Law
3585#Test of methods for evaluating bibliographic databases: an analysis of the National Library of Medicine's handling of literatures in the medical behavioral sciences
3586#Alpine is a file system that supports atomic transactions and is designed to operate as a service on a computer network. Alpine's primary purpose is to store files that represent databases. An important secondary goal is to store ordinary files representing documents, program modules, and the like.Unlike other file servers described in the literature, Alpine uses a log-based technique to implement atomic file update. Another unusual aspect of Alpine is that it performs all communication via a general-purpose remote procedure call facility. Both of these decisions have worked out well. This paper describes Alpine's design and implementation, and evaluates the system in light of our experience to date.Alpine is written in Cedar, a strongly typed modular programming language that includes garbage-collected storage. We report on using the Cedar language and programming environment to develop Alpine.
3587#Microcomputer application diagnostic system for identification and evaluation of user satisfaction factors of purchasing software
3588#Designing a computer workstation for researchers in the quantitative social sciences
3589#Transient fault management in systems based on the AMD 2900 microprocessors
3590#Superimposition of two image data sets allows the spatial distribution of one to be directly related to that of the other. If the two data sets have different spatial structures, the composite image is generally confusing and difficult to interpret. A method of representing image data sets in the form of naturally occurring variables in a realistic apparently three-dimensional scene is presented. One data set is represented by the topography of a surface, depicted by shaded-relief methods, while another is represented by the color of the surface, or by the color of an overlaid transparency. Presentation in this form exploits the normal scene decomposition abilities of the human visual system, allowing intuitive appreciation and separation of the scene, and hence data set, variables. The method relies on techniques for the modeling of surfaces and surface reflectance to render the synthesised scenes realistically.
3591#An algorithm is presented for ray tracing generalized cylinders, that is, objects defined by sweeping a two-dimensional contour along a three-dimensional trajectory. The contour can be any 'well-behaved' curve in the sense that it is continuous, and that the points where the tangent is horizontal or vertical can be determined, the trajectory can be any spline curve. First a definition is given of generalized cylinders in terms of the Frenet frame of the trajectory. Then the main problem in ray tracing these objects, the computation of the intersection points with a ray, is reduced to the problem of intersecting two two-dimensional curves. This problem is solved by a subdivision algorithm. The three-dimensional normal at the intersection point closest to the eye point, necessary to perform shading, is obtained by transforming the two-dimensional normal at the corresponding intersection point of the two two-dimensional curves. In this way it is possible to obtain highly realistic images for a very broad class of objects.
3592#The definitions of polynomial and rational Bernstein-Bézier curves are reviewed and extended to include homogeneous parametrizations. Then the effects of a projective transformation of the parameter space are described in terms of a group representation. This representation is used to answer the following questions: (1) If the control points are held fixed, when do two different sets of weights determine the same rational curve? (2) How do we find the control points for a subdivision of the original curve?
3593#Ada for experienced programmers
3594#Ada: an advanced introduction
3595#Building your first expert system using Micro-PS
3596#Building expert systems
3597#Computer dictionary (4th ed.)
3598#The Pengiun dictionary of computers (3rd ed.)
3599#The illustrated computer dictionary, revised edition
3600#Dictionary of computers, data processing & telecommunications
3601#Your personal computer dictionary
3602#Computer dictionary for everyone, new edition
3603#Webster's new world dictionary of computer terms
3604#Dictionary of computing
3605#The new American computer dictionary
3606#Tech talk, coming to terms with the information age
3607#A dictionary of minicomputing and microcomputing
3608#Illustrated dictionary of microcomputer terminology
3609#Computer dictionary, the guide to computing terms and concepts
3610#McGraw-Hill dictionary of computers
3611#Most computer scientists know that the Department of Defense (DOD) supplies most of the funds for academic research, but few know how profoundly the funding situation has changed over the last decade. In 1976 most basic research in academic computer science was funded by the National Science Foundation (NSF) [see Figure 1]. In 1985 NSF's "market share" is much less than DoD's.When applied research money is added in, as in Figure 2 (on the next page), DOD'S preeminence is even more marked. Allowing $25 million for industrial, state, institutional, and other support in 1985 (exact data are unavailable), I conclude that most academic computer science (CS) research is now directed by military agencies.
3612#The results of a user questionnaire are used to determine the effects of 17 different independent variables on user satisfaction.
3613#Appropriate mnemonic feedback built into a natural-language interface can act as a teacher to help users acquire formal-language skills as they work, without a large initial investment of effort in a learning period.
3614#Focusing on thinking skills that are cognitive components of programming—rather than on intellectual ability—can illuminate the relationship between learning a programming language and learning more about thinking processes.
3615#Although many informal surveys in the business press have contended that computer anxiety has a significant adverse impact on managers' willingness to use microcomputers, the problem is neither as extensive nor as severe as once believed.
3616#Many novel features of Ada present programmers with a formidable learning task. The study of four first-time Ada programmers suggests that a background in the software engineering practices supported by Ada is necessary to learn to use the features of the language.
3617#An evaluation of two folk wisdoms serves to elucidate the underlying or "deep-structure" reasons for novice errors.
3618#Although human proofreading is still necessary, small, topic-specific word lists in spelling programs will minimize the occurrence of undetected typing errors.
3619#Three measures of operator mental work load were tested with a large, interactive computer system. Two—operator rating of time stress, and the ratio of the time required to time allowed for each subtask—proved to be significant and easy to use.
3620#The elimination of unused instruction sets would encourage more uniform programming practices and could allow the inclusion of more useful instructions.
3621#Evidence from available studies comparing manual and automatic text-retrieval systems does not support the conclusion that intellectual content analysis produces better results than comparable automatic systems.
3622#Concentrating on those aspects of software development peculiar to real-time systems, this collection of development methods and tools emphasizes incremental development; the testing of tusk interfaces during integration testing, as well as unit and partial integration testing on the development system; and the development of automated tools to assist in the testing process.
3623#A classical problem in computational geometry is the planar point location problem. This problem calls for preprocessing a polygonal subdivision of the plane defined by n line segments so that, given a sequence of points, the polygon containing each point can be determined quickly on-line. Several ways of solving this problem in O(log n) query time and O(n) space are known, but they are all rather complicated. We propose a simple O(log n)-query-time, O(n)-space solution, using persistent search trees. A persistent search tree differs from an ordinary search tree in that after an insertion or deletion, the old version of the tree can still be accessed. We develop a persistent form of binary search tree that supports insertions and deletions in the present and queries in the past. The time per query or update is O(log m), where m is the total number of updates, and the space needed is O(1) per update. Our planar point location algorithm is an immediate application of this data structure. The structure also provides an alternative to Chazelle's "hive graph" structure, which has a variety of applications in geometric retrieval.
3624#Legged robots that balance
3625#Systems software tools
3626#Microprocessors in instrumentation and control
3627#An integrated approach to software development
3628#How to test software packages: a step-by-step guide to assuring they do what you want
3629#Office automation: a social and organizational perspective
3630#Structured programming logic: a flowcharting approach
3631#The LOCUS distributed system architecture
3632#Information systems development: a data base approach
3633#A first course in computability
3634#The soft side of software: a management approach to computer documentation
3635#Computer integrated manufacturing
3636#Data structures in Pascal
3637#Controlling software development: a guide for information resource managers
3638#File design & programming
3639#Software design and development
3640#Decision Support Systems (DSSs), computer-based systems intended to assist managers in preparing and analyzing decisions, have been single-user systems for most of the past decade. Only recently has DSS research begun to study the implications of the fact that most complex managerial decisions involve multiple decision makers and analysts. A number of tools for facilitating group decisions have been proposed under the label Group Decision Support Systems (GDSSs).One of the most important functions of a GDSS is to provide problem-oriented services for communication among decision makers. On the basis of an analysis of the communication requirements in various group decision settings, this paper presents an architecture for defining and enforcing dynamic application-level protocols that organize decision group interaction. The architecture has been implemented on a network of personal computers in Co-oP, a GDSS for cooperative group decision making based on interactive, multiple-criteria decision methods.
3641#A society model, which characterizes the behavior and procedure of offices, is proposed. It is our belief that an office system capable of dealing with all real office problems only through the modeling of the internal behavior of an office can be developed. In this society model, office entities are viewed as agents. An agent is modeled as a microsociety of interacting knowledge sources. Within the microsociety, there exists a microknowledge exchange system, which provides a set of microknowledge exchange protocols as a coordination system among those knowledge sources during their cooperative reasoning process. An office is then modeled as a society of various interacting agents using their knowledge to complete the office goals cooperatively. It is this unified view that allows offices to be modeled in a flexible and general way.
3642#A system for generating direct manipulation office systems is described. In these systems, the user directly manipulates graphical representations of office entities instead of dealing with these entities abstractly through a command language or menu system. These systems employ a new semantic data model to describe office entities. New techniques based on attribute grammars and incremental attribute evaluation are used to implement this data model in an efficient manner. In addition, the system provides a means of generating sophisticated graphics-based user interfaces that are integrated with the underlying semantic model. Finally, the generated systems contain a general user reversal and recovery (or undo) mechanism that allows them to be much more tolerant of human errors.
3643#The standard, most efficient method to retrieve information from databases can be described as systematic retrieval: The needs of the user are described in a formal query, and the database management system retrieves the data promptly. There are several situations, however, in which systematic retrieval is difficult or even impossible. In such situations exploratory search (browsing) is a helpful alternative. This paper describes a new user interface, called BAROQUE, that implements exploratory searches in relational databases. BAROQUE requires few formal skills from its users. It does not assume knowledge of the principles of the relational data model or familiarity with the organization of the particular database being accessed. It is especially helpful when retrieval targets are vague or cannot be specified satisfactorily. BAROQUE establishes a view of the relational database that resembles a semantic network, and provides several intuitive functions for scanning it. The network integrates both schema and data, and supports access by value. BAROQUE can be implemented on top of any basic relational database management system but can be modified to take advantage of additional capabilities and enhancements often present in relational systems.
3644#Software configuration management: coordination for team productivity
3645#The theory of database concurrency control
3646#Handbook for developing computer user manuals
3647#Software engineering metrics and models
3648#Logic programming: functions, relations, and equations
3649#Practical data communications: modems, networks and protocols
3650#The scholar's personal computing handbook: a practical guide
3651#Abstraction and specification in program development
3652#Introduction to Simulation and SLAM II (3rd ed.)
3653#Mainframe and microcomputer-based business graphics: What satisfies users?
3654#A conceptual architecture for DSS generators
3655#Acceptance of management science recommendations: the role of cognitive styles and dogmatism
3656#Don't hang up: organizational diffusion of the intelligent telephone
3657#The Guide to Available Mathematical Software (GAMS) provides a framework for both a scientist-end-user and a librarian-maintainer to deal with large quantities of mathematical and statistical software. This framework includes a classification scheme for mathematical and statistical software, a database system to manage information about this software, and both an on-line interactive consulting system and a printed catalog for providing users with access to this information. A description is given of GAMS and its use at the National Bureau of Standards.
3658#It is proved that, under the usual restrictions, the denominator of the integral of a purely logarithmic function is the expected one, that is, all factors of the denominator of the integrand have their multiplicity decreased by one. Furthermore, it is determined which new logarithms may appear in the integration.
3659#The solution of a nonlinear optimization problem often requires an estimate of the Hessian matrix for a function f. In large scale problems, the Hessian matrix is usually sparse, and then estimation by differences of gradients is attractive because the number of differences can be small compared to the dimension of the problem. In this paper we describe a set of subroutines whose purpose is to estimate the Hessian matrix with the least possible number of gradient evaluations.
3660#We consider the collocation method for linear, second-order elliptic problems on rectangular and general two-dimensional domains. An overview of the method is given for general domains, followed by a discussion of the improved efficiencies and simplifications possible for rectangular domains. A very-high-level description is given of three specific collocation algorithms that use Hermite bicubic basic functions, (1) GENCOL (collocation on general two-dimensional domains), (2) HERMCOL (collocation on rectangular domains with general linear boundary conditions), and (3) INTCOL (collocation on rectangular domains with uncoupled boundary conditions). The linear system resulting from INTCOL has half the bandwidth of that from HERMCOL, which provides substantial benefit in solving the system. We provide some examples showing the range of applicability of the algorithms and some performance profiles illustrating their efficiency. Fortran implementations of these algorithms are given in the companion papers [10, 11].
3661#We describe a new package, UNCMIN, for finding a local minimizer of a real valued function of more than one variable. The novel feature of UNCMIN is that it is a modular system of algorithms, containing three different step selection strategies (line search, dogleg, and optimal step) that may be combined with either analytic or finite difference gradient evaluation and with either analytic, finite difference, or BFGS Hessian approximation. We present the results of a comparison of the three step selection strategies on the problems in More, Garbow, and Hillstrom in two separate cases: using finite difference gradients and Hessians, and using finite difference gradients with BFGS Hessian approximations. We also describe a second package, REVMIN, that uses optimization algorithms identical to UNCMIN but obtains values of user-supplied functions by reverse communication.
3662#Algorithm 636: FORTRAN subroutines for estimating sparse Hessian matrices
3663#Algorithm 637: GENCOL: collocation of general domains with bicubic hermite polynomials
3664#Algorithm 638: INTCOL and HERMCOL: collocation on rectangular domains with bicubic hermite polynomials
3665#Programming languages for the implementation of text data bases
3666#Information processing (4th ed.)
3667#Complete C language programming for the IBM–PC
3668#Intermediate problem solving and data structures: walls and mirrors
3669#Local-area networks and their architectures
3670#CICS/VS command level with ANS COBOL examples (2nd ed.)
3671#The UNIX C shell field guide
3672#Principles of information systems for management (2nd ed.)
3673#Database system concepts
3674#Computer-assisted business plans
3675#U.S. military communications: a C3I force multiplier
3676#Advanced C programming
3677#File systems: design & implementation
3678#Computers and the information society
3679#Database machines and database management
3680#Algorithms: the constuction, proof, and analysis of programs
3681#Microcomputers for management decision making
3682#Databases: a primer for retrieving information by computer
3683#APL: an introduction
3684#Nations at risk: the impact of the computer revolution
3685#Modern control systems: a manual of design methods
3686#Infotrends: profiting from your information resources
3687#Executable semantic descriptions
3688#Using coroutines in Pascal
3689#Communication parallel processes
3690#Implementing ALGOL 68 predicates
3691#Dynamic file structure for partial match retrieval based on overflow bucket sharing
3692#Introduction to computing and computer science with Pascal
3693#Biosensors: today's technology, tomorrow's products
3694#Parallel processing: the technology of fifth generation computers
3695#Molecular electronics: beyond the silicon chip (2nd. ed. revised)
3696#Manufacturing simulation: a new tool for robotics, FMS and industrial process design
3697#C wizard's programming reference
3698#Geometric modeling
3699#PC-DOS: fundamentals for diskette-based operation
3700#Cash flow management with framework
3701#The picture book of quantum mechanics
3702#Logic testing and design for testability
3703#Executing temporal logic programs
3704#Discrete mathematics
3705#Graphics for architects and planners
3706#Microcomputer graphics using Pascal: for the IBM PC and compatibles
3707#Graphics with the IBM PC
3708#Relevance: communication and cognition
3709#Teleoperations and robotics: applications and technology
3710#Teleoperations and robotics: applications and technology
3711#Systems design: Vol. II of VLSI systems design for digital signal processing
3712#Handbook of software maintenance
3713#Computer graphics
3714#Learning Apple FORTRAN
3715#Introduction to machine and assembly language programming
3716#IIc BASIC paint: graphics for the Apple II family: a self-teaching guide
3717#Computer aided design in magnetics
3718#Electronic logic sytems
3719#Documenting an organization's computer requirements
3720#BASIC programming
3721#Self, symbols and society: an introduction to mas communication
3722#User guide to COBOL 85
3723#The principles of computer hardware
3724#Designing with microprocessors
3725#Digital logic testing and simulation
3726#Structured FORTRAN for business
3727#Elements of engineering design: an integrated approach
3728#analog and digital communication systems, 2nd. ed.
3729#Polytopes, graphs and optimisation
3730#Physics with computers
3731#Computer technology for the handicapped in sspecial education and rehabilitation: a resource guide; vol. II.
3732#Statistics and optimization; vol. 11
3733#Modern multivariate statistical analysis, a graduate course and handbook
3734#Modern digtal simulation methodology; vol. 12
3735#Error recovery in asynchronous systems
3736#Mechanical verification and automatic implementation of communication protocols
3737#Optimal allocation of file servers in a local network environment
3738#SODOS: a software documentation support environment—its definition
3739#A formal method for composing a network command language
3740#Dynamic analysis of the effects access rule modifications have upon security
3741#A comparison of computed chaining to predictors
3742#The Function of T and NIL in LISP
3743#A new algorithm for generation hilbert curves
3744#Computers and the Social Sciences - A special double issue on the social impact of computers
3745#The new division of labor: the mobility of new technology and its impact on work
3746#The effects of computers and the computer industry on the development of Third World nations
3747#The inept and the computer revolution: some clues from other innovations
3748#The computer imperative among owners of home computers: explanation by social factors
3749#Computer technology and organizational culture
3750#The effects of a computerized information system on a hospital
3751#Faculty responses to the computerization of a university
3752#Students' attitudes toward computers
3753#The social use of electronic communication at a major university
3754#The microcomputer and social relationships
3755#Computer technology and social relations
3756#Emerging privacy issues
3757#Security modules: potent information security system components
3758#Data security in a relational database environment
3759#Risk management—a key to security in the electronic funds transfer system
3760#A pauper's callback scheme
3761#On the key storage requirements for secure terminals
3762#Electromagnetic radiation revisited
3763#Computer security—prevention: lessons from the operation of a nuclear power pl
3764#Three general principles are presented that can be applied in early software life cycle stages for the definition of software requirements and designs with acceptable performance. They are genuine high-level considerations for meeting responsiveness goals without sacrificing understandability and maintainability, and without increasing development time and cost. The principles are derived from the interrelationships of two performance models: a queueing network based on computer system model and an execution graph software model. The performance effect of each of the principles is quantified using the models. Examples are given that illustrate how they can be applied to software systems.
3765#Replication can enhance the availability of data in distributed systems. This paper introduces a new method for managing replicated data. Unlike many methods that support replication only for uninterpreted files, this method systematically exploits type-specific properties of objects such as sets, queues, or directories to provide more effective replication. Each operation requires the cooperation of a certain number of sites for its successful completion. A quorum for an operation is any such set of sites. Necessary and sufficient constraints on quorum intersections are derived from an analysis of the data type's algebraic structure. A reconfiguration method is proposed that permits quorums to be changed dynamically. By taking advantage of type-specific properties in a general and systematic way, this method can realize a wider range of availability properties and more flexible reconfiguration than comparable replication methods.
3766#Many distributed systems replicate data for fault tolerance or availability. In such systems, a logical update on a data item results in a physical update on a number of copies. The synchronization and communication required to keep the copies of replicated data consistent introduce a delay when operations are performed. In this paper, we describe a technique that relaxes the usual degree of synchronization, permitting replicated data items to be updated concurrently with other operations, while at the same time ensuring that correctness is not violated. The additional concurrency thus obtained results in better response time when performing operations on replicated data. We also discuss how this technique performs in conjunction with a roll-back and a roll-forward failure recovery mechanism.
3767#The scheduling of jobs for multiprogramming systems includes the selection of jobs to be loaded into memory (job loading policy or memory schedule) and the scheduling for CPU processing (CPU schedule). There has been a successful empirical claim for the optimal CPU schedule; its optimality has been proved in a Markovian model of job-stream processing that uses the first-come-first-loaded (FCFL) job loading policy. We extend this model to gain insight into the effects of job loading policies.The model studied consists of an input stream of jobs of two classes and a multiple-resource system (the model of a multiprogramming system) with a stack for waiting jobs. The system consists of a finite amount of memory and a cyclic queue of a single (CPU) server station and a multiple (I/O) server station. The values of parameters describing each class of jobs are distinct except the mean I/O service time and the amount of memory required. The estimate of the maximum processing capacity (throughput bound) of the system is obtained and is shown to be achieved by the combination of the empirically claimed optimal CPU schedule and a job loading policy whereby the set of jobs in memory is kept to be (nearly) balanced with respect to the job stream. Furthermore, we show that the job loading policies independent of the system status have no improvement over the FCFL policy.Our investigation, supported by numerical calculations, suggests that much more care may be needed in implementing the job loading policy that aims at the optimal processing capacity than in implementing the optimal CPU schedule. This agrees with what has been conjectured on the basis of empirical studies.
3768#Authoring: a guide to the design of instructional software
3769#The misconstrued semicolon: reconciling imperative languages and dataflow machines
3770#An operating systems vade mecum
3771#We study algorithms for computing the equijoin of two relations in a system with a standard architecture hut with large amounts of main memory. Our algorithms are especially efficient when the main memory available is a significant fraction of the size of one of the relations to he joined; but they can be applied whenever there is memory equal to approximately the square root of the size of one relation. We present a new algorithm which is a hybrid of two hash-based algorithms and which dominates the other algorithms we present, including sort-merge. Even in a virtual memory environment, the hybrid algorithm dominates all the others we study.Finally, we describe how three popular tools to increase the efficiency of joins, namely filters, Babb arrays, and semijoins, can he grafted onto any of our algorithms.
3772#An intelligent system for document retrieval in distributed office environments
3773#Task-oriented approach to interactive control of heavy-duty manipulators based on coarse scene description
3774#First Page of the Article
3775#First Page of the Article
3776#First Page of the Article
3777#Syntax-directed compression of program files
3778#Coroutines for C reconsidered
3779#Elliott I. Organick (1925-1985)
3780#In the following interview, which took place at ACM 85 in Denver, Karp discusses the relation of his work to leading-edge computing topics like parallel processing and artificial intelligence. Tracing his experience as a pioneer in highly theoretical computer science, Karp describes how the decision to go against established wisdom led to the work for which he is best known and how a colleague's findings led him to see links between two previously unrelated areas. Throughout, he stresses the exchange of ideas with colleagues that helped yield fundamental insights.
3781#What kinds of lessons does a classical engineering discipline like bridge design have for an emerging engineering discipline like computer systems design? Case-study editors Alfred Spector and David Gifford consider the insight and experience of bridge designer Gerard Fox to find out how strong the parallels are.
3782#Computer simulation studies of the phase transition in compressible deuteroammonium chloride
3783#Numerical simulations of large-scale solar magnetic fields
3784#This article provides a survey of aspects and methods of the automation of processes involved in performing inferences. It addresses classical deductive reasoning as well as non-monotonic and inductive reasoning. Several important reasoning methods are informally described and illustrated. The emphasis is on a clarification of some or the main principles rather than on an exhaustive listing of particular techniques.
3785#A complete structure theorem is given for standard (= Grobner) bases for bivariate polynomials over a field and lexicographical orderings or for univariate polynomials over a Euclidian ring. An easy computation of primary decomposition in such rings is deduced. Another consequence is a natural factorisation of the resultant of two univariate polynomials over the integers which is a generalisation of the ''reduced discriminant'' of a polynomial of degree 2.
3786#A symbolic iterative algorithm, based on Hensel's lemma and the Newton-Schultz method, is described for the generalised inversion of rational polynomial matrices over a field. The approach presented here unifies the computational framework for the inversion of both the numerical and polynomial matrices and provides the possibility for parallel implementation using array processors. This algorithm requires O(m^34^l^o^g^R) polynomial multiplications over a field, where m is the order of the matrix and the R the maximal degree of the rational polynomial element in the generalised inverse.
3787#A decision procedure for integrating a class of transcendental elementary functions in terms of elementary functions and error functions is described. The procedure consists of three mutually exclusive cases. In the first two cases a generalised procedure for completing squares is used to limit the error functions which can appear in the integral to a finite number. This reduces the problem to the solution of a differential equation and we use a result of Risch (1969) to solve it. The third case can be reduced to the determination of what we have termed E-decompositions. The result presented here is the key procedure to a more general algorithm which is described fully in Cherry (1983).
3788#This paper discusses some of the mathematical aspects of an algorithm for finding formulas for finite sums. The results presented here concern a property of difference fields which show that the algorithm does not divide by zero, and an analogue to Liouville's theorem on elementary integrals.
3789#Using Symbolic Computation in Buckling Analysis
3790#A Selected Bibliography on Constructive Mathematics, Intuitionistic Type Theory and Higher Order Deduction
3791#Performance evaluation of a simulated data-flow computer with low-resolution act
3792#A VLSI structure for the deadlock avoidance problem
3793#Software implementation of floating-point arithmetic on a reduced-instruction-set
3794#A fast inner product processor based on equal alignments
3795#A class of SIMD machines simulated by systolic arrays
3796#The prism machine: an alternative to the pyramid
3797#Ten methodologies for automatic program construction are presented, discussed and compared. Some of the techniques generate code from formal input-output specifications while others work from examples of the target behaviour or from natural language input.
3798#Algorithms for effectively computing with group homomorphisms are presented . Particular emphasis is given to those homomorphisms induced by invariant subsets and systems of imprimitivity of a permutation group, and by the right cosets of a subgroup in an arbitrarily represented group. The algorithms allow the computation of images and preimages of elements and subgroups, as well as the computation of the image and kernel of the homomorphism. A discussion of coset enumeration in permutation groups is included.
3799#We consider the following problem : given a polynomial f(x) @? k[x], k a field, find a complete decomposition of f in the form f= g"1^^og"2^^o^.^.^.^^og"nwhere ^o denotes functional composition . After reviewing some known results about existence and uniqueness of such decompositions two algorithms are presented that solve the decomposition problem.
3800#We develop the theory for decreasing the depth of nesting in expressions that contain square roots. We show exactly when fourth roots enable denesting of expressions not denestable with square roots only, When we restrict our attention to denesting over the real numbers, we show in fact that no roots other than square roots or fourth roots are ever useful for denesting expressions containing square roots only, thus characterising the denestable expressions in this case . We then proceed to describe new algorithms that accomplish such denesting.
3801#Algebraically dependent expressions arise in a large variety of symbolic computations. People seem to have the best intuition about expressions involving radicals. Symbolic computations with simple, non-nested, radicals is relatively straightforward; however, when the radicals are nested the problem becomes more difficult, This paper presents an algorithm for determining a linearly independent basis for a set of radicals (nested or not). This allows elementary techniques to be used for arithmetic operations on expressions involving elements of this set. In addition we provide a structure theorem that provides a sufficient condition for a nested radical to be expressed in terms of radicals of lower nesting level. These two techniques are powerful tools for computations involving radicals.
3802#An algorithm for determining polynomial first integrals of autonomous systems of ordinary differential equations
3803#The algebra system REDUCE is introduced by the exposition of a number of sample problems. While these problems will inevitably be small in scale, and biased towards the interests of the author, the aim is to show how many of the algebraic problems that are faced by scientists and engineers can be readily solved with the powerful tool of computer algebra, No attempt is made to explain the inner workings and design of REDUCE, although there is some reference to the international REDUCE user and implementor community.
3804#We describe the results and objectives of a research line to develop Lie-algebraic and group-theoretic methods for the study of optics with aberration. We have applied REDUCE programming to obtain the phase-space transformation due to the refracting interface between two media, using a recent result on factorisation into a simpler ''root'' transformation. The latter is given by a pair of implicit equations.
3805#We explain how factoring polynomials over finite fields can be used in computing logarithms in fields of characteristic two, and how this has applications in cryptography. This letter describes work which is described in more detail in Coppersmith (1984)-here we concentrate on the use of computer algebra, in particular the new SCRATCHPAD system (Jenks, 1984).
3806#The equivalence and inclusion problems for NTS languages
3807#NTS languages are deterministic and congruential
3808#Interactions between dependencies and nested relational structures
3809#Serializability theory for replicated databases
3810#Axiomatizing schemes and their behaviors
3811#Structural properties of the string statistics problem
3812#Automated deduction by theory resolution
3813#Robot selection expert `Rose'
3814#Circumscription and implicit definability
3815#Towards mechanical metamathematics
3816#Predicate logic hacker tricks
3817#First Page of the Article
3818#First Page of the Article
3819#First Page of the Article
3820#First Page of the Article
3821#First Page of the Article
3822#Expert systems in the SDI environment
3823#A broad cross section of computer security experts, hackers, educators, journalists, and corporate executives examine hacking issues, problems, and possible solutions.
3824#Systematic codes capable of detecting burst unidrectional errors of length up to 2r-1using r check bits where r = 3 are presented. Moreover, b-adjacent unidirectional error-detecting codes using [log2(b + 1)] check bits are also described. These codes are shown to be optimal or near optimal. The encoding/decoding and the totally self- checking checker design methods for these
3825#An O(n3) algorithm is given for determining the most likely set of faulty processors in a class of systems introduced by Maheshwari and Hakimi[6], known as probabilistically diagnosable systems. The technique uses the a priori probability of failure of each unit combined with the results of tests which the processors administer to one another to perform diagnosis. The algorithm uses wel
3826#A new modular, fault-tolerant scheme is proposed for the binary tree architecture. The approach uses redundant modular fault- tolerant building blocks to construct the complete binary tree. The restructuring operation is local to each faulty module. The proposed scheme is shown to be more reliable and easier to implement than the existing fault-tolerant schemes.
3827#In this correspondence, the concept of a test schema which describes how a test methodology is to execute is introduced. We also introduce the powerful concept of an I path which is used to transfer data unchanged from one place in a circuit to another. The process of embedding a test schema into an actual circuit is described. This produces a test plan for the circuit which specifies the sequence of actions that need to be carried out to execute the test. A theory of test plan execution overlap is presented, and is used as the basis for constructing test schedules with optimal execution times.
3828#This paper presents a design technique for linear feedback shift registers that generate test patterns for pseudoexhaustive testing. This technique is applicable to any combinational network in which none of the outputs depends on all inputs. It does not rewire the original network inputs during in-circuit test pattern generation. Thus, the possibility of undetected faults on some inputs is eliminated.
3829#The time interval between the occurrence of a fault and the detection of the error caused by the fault is divided by the generation of that error into two parts: fault latency and error latency. Since the moment of error generation is not directly observable, all related works in the literature have dealt with only the sum of fault and error latencies, thereby making the analysis of their separate effects impossible. To remedy this deficiency, we 1) present a new methodology for indirectly measuring fault latency, 2) derive the distribution of fault latency from the methodology, and 3) apply the knowledge of fault latency to the analysis of two important examples.
3830#This correspondence presents a test generation methodology for VLSI circuits described at the functional level. A VLSI circuit is modeled as a network of functional modules such as registers, adders, RAM's, and MUX's. The functions of the individual modules are described using binary decision diagrams. A functional fault model is developed independent of the implementation details of the circuit. A generalized D algorithm is proposed for generating tests to detect functional as well as gate-level faults. Algorithms which perform fault excitation, implication, D propagation, and line justification on the functional modules are also described.
3831#A new technique for designing easily testable PLA's is presented. The salient features of this technique are: 1) low overhead, 2) high fault coverage, 3) simple design, and 4) little or no impact on normal operation of PLA's. This technique consists of the addition of input lines in such a way that, in test mode, any single product line can be activated and its associated circuitry and device can be tested. Using this technique, all multiple stuck-at faults, as well as all multiple extra and multiple missing device faults, are detected.
3832#The problem of testing sequential machines using a checking experiment is investigated. An algorithm is given to augment sequential machines by adding extra input(s) to make them testable. We also present a circuit modification method, similar to scan methods, such that the augmented machine can be tested by the checking experiment. A justification of our method for a VLSI environment is given by determining the overheads.
3833#Social security administration's progress in modernizing its computer operations
3834#Inverse moments of negative-binomial distributions
3835#Very small tails of the t distribution, and significance tests for clustering
3836#A power series for the tail-area probability of student's t distribution
3837#An improved parallel algorithm for maximal matching
3838#Proving properties of Pascal programs in MIZAR 2: figures and appendices
3839#Decision support in a guaranteed student loan program: design and implementationof a midel-based system
3840#On computing solutions of consistent linear algebraic systems with a singular matrix
3841#A Lipschitz operator for function strips
3842#On the R-order of some recurrences with applications to inclusion-methods
3843#Helmut Werner
3844#How we know
3845#n-Level rewriting systems
3846#On the verifiability of two-party algebraic protocols
3847#On total regulators generated by derivation relations
3848#Cts systems and Petri nets
3849#Deque automata and a subfamily of context-sensitive languages which contains all semilinear bounded languages
3850#On the structure of one-tape nondeterministic Turing machine time hierarchy
3851#Implications of forbidden structures for extremal algorithmic problems
3852#While-programs with nondeterministic assignments and the logic ALNA
3853#On bounded query machines
3854#Homogeneous decomposition of stochastic systems
3855#Transitive closure and related semiring properties via eliminants
3856#Parallel and sequential computation on Boolean networks
3857#Reducibility of synchronization structures
3858#On Greibach normal form construction
3859#A lower bound for polynomial multiplication
3860#On recursive path ordering
3861#Algebraic calculi of processes and net expressions
3862#Recently developed inferential database systems face some common problems: a very fast growth of search space and difficulties in recognizing inference termination (especially for recursive axioms). These shortcomings stem mainly from the fact that the inference process is usually separated from database operations. A problem-oriented inferential system i8 described which refers to the database prior to query (or subquery) processing, so that the inference from the very beginning is directed by data relevant to the query. A multiprocessor implementation of the system is presented based on a computer network conforming to database relations and axioms. The system provides an efficient indication of query termination, and is complete in the sense that it produces all correct answers to a query in a finite time.
3863#In a faulty distributed system, voting is commonly used to achieve mutual exclusion among groups of nodes. Each node is assigned a number of votes, and any group with a majority of votes can perform the critical operations. Vote assignments can have a significant impact on system reliability, and in this paper we study the vote assignment problem. To compare vote assignments we define two deterministic measures, node and edge vulnerability. We present various properties of these measures and discuss how they can be computed. For these measures we discuss the selection of the best assignment and propose heuristics to identify good candidate assignments.
3864#This paper demonstrates a practical approach to the study of the failure behavior of computer systems. Particular attention is devoted to the analysis of permanent failures. A number of important techniques, which may have general applicability in both failure and workload analysis, are brought together in this presentation. These include: smeared averaging of the workload data, clustering of like failures, and joint analysis of workload and failures. Approximately 17 percent of all failures affecting the CPU were estimated to be permanent. The manifestation of a permanent failure was found to be strongly correlated with the level and type of workload prior to the failure. Although, in strict terms, the results only relate to the manifestation of permanent failures and not to their occurrence, there are strong indications that permanent failures are both caused and discovered by increased activity. More measurements and experiments are necessary to determine their respective contributions to the measured workload/failure relationship.
3865#This paper studies the performance of single-user workstations that access files remotely over a local area network. From the environmental, economic, and administrative points of view, workstations that are diskless or that have limited secondary storage are desirable at the present time. Even with changing technology, access to shared data will continue to be important. It is likely that some performance penalty must be paid for remote rather than local file access. Our objectives are to assess this penalty and to explore a number of design alternatives that can serve to minimize it. Our approach is to use the results of measurement experiments to parameterize queuing network performance models. These models then are used to assess performance under load and to evahrate design alternatives. The major conclusions of our study are: (1) A system of diskless workstations with a shared file server can have satisfactory performance. By this, we mean performance comparable to that of a local disk in the lightly loaded case, and the ability to support substantial numbers of client workstations without significant degradation. As with any shared facility, good design is necessary to minimize queuing delays under high load. (2) The key to efficiency is protocols that allow volume transfers at every interface (e.g., between client and server, and between disk and memory at the server) and at every level (e.g., between client and server at the level of logical request/response and at the level of local area network packet size). However, the benefits of volume transfers are limited to moderate sizes (8-16 kbytes) by several factors. (3) From a performance point of view, augmenting the capabilities of the shared file server may be more cost effective than augmenting the capabilities of the client workstations. (4) Network contention should not be a performance problem for a lo-Mbit network and 100 active workstations in a software development environment.
3866#Ada's importance goes far beyond its initial limited goals. The worldwide interest in the usage of Ada is one of many reasons for its uniqueness.
3867#The Initiative is a comprehensive effort to address major software engineering issues in both the military and private industry.
3868#Two radically different parallel computers prompt a debate about the best parallel architectures and may mark the commercial viability of parallelism on the supercomputer scale.
3869#Benchmarks are developed to measure the Ada notion of time, the Ada features believed important to real-time performance, and other time-related features that are not part of the language, but are part of the run-time system; these benchmarks are then applied to the language and run-time system, and the results evaluated.
3870#The authors describe a system that makes it easy and convenient to describe graphs and to include them as an integral part of the document formatting process.
3871#An exploratory study of computerized performance monitoring and control systems reveals both positive and negative effects. Responses of 50 clerical workers from 2 organizations with computerized monitoring were compared to 94 individuals from 3 organizations in similar jobs without computerized monitoring. The results indicate that computerized monitoring is associated with perceived increases in office productivity, more accurate and complete assessment of workers' performance, and higher levels of organizational control. Respondents indicate that managers overemphasize the importance of quantity and underemphasize the importance of quality in evaluating employee performance. Workers perceive increased stress, lower levels of satisfaction, and a decrease in the quality of their relationships with peers and management as a consequence of computerized monitoring. The relevance of existing models of performance monitoring is examined in light of these findings.
3872#The orders of equidistribution of subsequences of every nth term of the asymptotically random sequence given by Tootill, Robinson, and Eagle [5], and of six other asymptotically random sequences, were determined for various values of n and of the number of bits to which each term in the sequence is read. Deficiencies in equidistribution were found to be small enough to qualify the sequences for use in applications with fixed, as well as variable, dimensionality requirements. An improved initialization algorithm is also given.
3873#In this paper we present a new data structure for representing Boolean functions and an associated set of manipulation algorithms. Functions are represented by directed, acyclic graphs in a manner similar to the representations introduced by Lee [1] and Akers [2], but with further restrictions on the ordering of decision variables in the graph. Although a function requires, in the worst case, a graph of size exponential in the number of arguments, many of the functions encountered in typical applications have a more reasonable representation. Our algorithms have time complexity proportional to the sizes of the graphs being operated on, and hence are quite efficient as long as the graphs do not grow too large. We present experimental results from applying these algorithms to problems in logic design verification that demonstrate the practicality of our approach.
3874#Decoupled architectures achieve high scalar performance by cleanly splitting instruction processing into memory access and execution tasks. Several decoupled architectures have been proposed, and they all have two characteristics in common: 1) they have two separate sets of instructions, one for accessing memory and one for performing function execution. 2) The memory accessing task and the execution task communicate via architectural queues.
3875#Recovery procedures involving time redundancy in the form of instruction retries and program rollbacks have proved to be very effective against transient failures in computer systems. A class of such recovery procedures is presented and analyzed here, and the parameters of each procedure are determined so that the system's operation is optimized. These procedures are then compared in order to select the most appropriate one for given system parameters.
3876#Algorithms for the parallel multiplication of two n- bit binary numbers by an iterative array of logic cells are discussed. The regular interconnection structures of the multiplier array cell elements, which are ideal for VLSI implementation, are described. The speed and hardware complexity of two new iterative array algorithms, both of which require n-cell delays for one n-bit 脳 n-bit multiplication, are compared to a straightforward iterative array algorithm having a 2n-cell delay and its higher radix version having an n-cell delay.
3877#The "hit ratio" of a high-speed buffer (cache) depends on the "locality" of memory references. However, locality of reference is disturbed and the hit ratio decreases whenever a task switch occurs. This performance degradation can be minimized if "locality of task switching," the tendency for a small set of favored tasks to be frequently executed, exists and the cache is organized in such a way that it can hold blocks (lines) of multiple tasks. Locality of task switching and locality of memory references in individual tasks exhibit overall locality of memory references at a system level. This paper addresses the following questions. Does locality of task switching really exist? How can it be modeled? Task switching in IBM operating system/virtual storage with multiple virtual storage (OS/VS2 MVS) was measured using event traces for three different workloads to show that locality of task switching actually exists in MVS. Two different models of task switching are proposed. These models can be incorporated into cache multitasking models to predict more accurately the misses in real computer systems. A key parameter of these models is the task execution interval; measurements of execution intervals for the workloads used in the paper are presented and discussed.
3878#In this paper drawbacks of the three-state data compressor in the form of the unit decoder 3/2 JK flip-flop are described. The main results of the paper are the algebraic operation model and the description of detection capability of a new three-state data stream compressor consisting of decoder 3/2 and a two-input shift register TISR. In particular, the properties of the unit decoder 3/2 TISR in detecting faults of the s-a-0, s- a-1, and s-a-HZ type are discussed. In this paper important aspects of the application of the new compressor are given. An example of the new compressor's performance scheme is also described. An additional result of this paper is the description of the operation model and the detection capability of the multiinput shift register MISR in which the most significant bit and other selected flip-flop output signals are fed back to the least significant bit positions via Exclusive-OR gates outside the flip-flops.
3879#In this paper, potential invalidation of stuck-open fault-detecting tests, derived by neglecting circuit delays and charge distribution in CMOS logic circuits, is studied. Several classes of circuits derived from sum of products and product of sums expressions for a given combinational logic function are investigated to determine the testability of FET stuck-open faults by tests which will remain valid in the presence of arbitrary circuit delays. Necessary and sufficient conditions for the existence of tests that will remain valid in the presence of arbitrary circuit delays are derived. Using these conditions, it is shown that all single FET stuck-open faults, in a specific design using a single CMOs complex gate, are detectable by tests that remain valid in the presence of arbitrary circuit delays. For several other realizations, methods to augment them, to insure detectability of all single FET stuck-open faults by tests that will remain valid in the presence of arbitrary circuit delays are proposed. It is observed that in many of the logic circuits investigated it is also possible to avoid test invalidation due to charge distribution.
3880#A self-assessment procedure dealing with file processing
3881#Taking Ein-Dor's recent reevaluation of Grosch's law one step further, the authors find evidence of different slopes for different classes of computers and the utility of an additional variable: the IBM or IBM-compatible factor. The analysis indicates that Grosch's law no longer applies to minicomputers.
3882#A set of characterizing parameters, called ratio parameters, has been used to formulate an efficient algorithm for realizing any given Boolean funetion with a single multiplexer of minimum size. The algorithm is applicable to fuctions of a large number of variables because the conventional logic design tools, e.g., Karnaugh map, decomposition chart, etc., which are unsuitable for higher variables, have not been used. The algorithm is also simple in computation, iterative in nature, and very suitable for machine implementation.
3883#We discuss three methods of reducing the diameters of computer networks by adding additional processor to processor links under the constraint that no more than one I/O port be added to each processor. This is equivalent to adding edges to a given graph under the constraint that the degree of any node be increased, at most, by one.
3884#We show that any Boolean function f which can be expressed in a sum-of-products form using m product terms can contain as many as 2m- 1 implicants but no more.
3885#A method of residue number system (RNS) conversion to mixed-radix (MR) representation is presented. This method is found to be cost-effective and efficient, particularly for moduli size 4/5 bits. A comparison of conversion times and hardware necessary for RNS conversion to MR digits based on different methods is also presented.
3886#Two parallel algorithms for finding the lowest common ancestors of a set of vertex pairs Q (the query set) in a directed tree are presented. With all the overheads taken into account, these algorithms take O((n + QI) P log2 n) and O(n2/p + log2n) time, respectively, with p( 0) processors (n is the size of the tree). These results are better than the best known result in that the first achieves th
3887#Stuck-at faults on primary inputs and fan-out branches are commonly used as target faults in test generation algorithms for combinational circuits. This correspondence shows that these faults may not constitute an adequate set of target faults. A procedure is presented for selecting a set of target faults with the property that the detection of all detectable faults from this set guarantees the detection of all detectable faults in the circuit.
3888#Compilers: principles, techniques, and tools
3889#Data administration: selected topics of data control
3890#Engineer's notebook
3891#Cleaning up a computer mess: a guide to diagnosing and correcting computer problems
3892#Software portability
3893#Machine learning of inductive bias
3894#Computational complexity of sequential and parallel algorithms
3895#The control revolution: technological and economic origins of the information society
3896#Digital CMOS circuit design
3897#Future computer & information systems: the uses of the next generation computer and information systems
3898#Relational database technology
3899#Access to academic networks
3900#A state transition model for the optimization of query processing in a distributed database system is presented. The problem is parameterized by means of a state describing the amount of processing that has been performed at each site where the database is located. A state transition occurs each time a new join or semijoin is executed. Dynamic programming is used to compute recursively the costs of the states and the globally optimal solution, taking into account communication and local processing costs. The state transition model is general enough to account for the possibility of parallel processing among the various sites, as well as for redundancy in the database. The model also permits significant reductions of the necessary computations by taking advantage of simple additivity and site-uniformity properties of a cost model, and of clever strategies that improve on the basic dynamic programming algorithm.
3901#An extension to the relational model is described in which domains can he arbitrarily defined as abstract data types. Operations on these data types include primitive operations, aggregates, and transformations. It is shown that these operations make the query language complete in the sense of Chandra and Harel. The system has been designed in such a way that new data types and their operations can be defined with a minimal amount of interaction with the database management system.
3902#The high-level languages proposed for supercomputers, such as vector and array processors, have been designed using one of the following two approaches: (1) an existing sequential language is adapted, (2) a new language based on the hardware is developed. Recently, there has emerged a third approach, which does not require the programmer to be aware of the sequential nature of the language or the hardware characteristics.Examples of these language groups are examined to illustrate their main features and what is required of a programmer when using such languages. The study therefore enables a comparison of the different language approaches to be made.
3903#This paper presents a comparative study and survey of model-based object-recognition algorithms for robot vision. The goal of these algorithms is to recognize the identity, position, and orientation of randomly oriented industrial parts. In one form this is commonly referred to as the "bin-picking" problem, in which the parts to be recognized are presented in a jumbled bin. The paper is organized according to 2-D, 2½-D, and 3-D object representations, which are used as the basis for the recognition algorithms. Three central issues common to each category, namely, feature extraction, modeling, and matching, are examined in detail. An evaluation and comparison of existing industrial part-recognition systems and algorithms is given, providing insights for progress toward future robot vision systems.
3904#This paper presents an overview of the Cedar programming environment, focusing on its overall structure—that is, the major components of Cedar and the way they are organized. Cedar supports the development of programs written in a single programming language, also called Cedar. Its primary purpose is to increase the productivity of programmers whose activities include experimental programming and the development of prototype software systems for a high-performance personal computer. The paper emphasizes the extent to which the Cedar language, with run-time support, has influenced the organization, flexibility, usefulness, and stability of the Cedar environment. It highlights the novel system features of Cedar, including automatic storage management of dynamically allocated typed values, a run-time type system that provides run-time access to Cedar data type definitions and allows interpretive manipulation of typed values, and a powerful device-independent imaging modelthat supports the user interface facilities. Using these discussions to set the context, the paper addresses the language and system features and the methodologies used to facilitate the integration of Cedar applications. A comparison of Cedar with other programming environments further identifies areas where Cedar excels and areas where work remains to be done.
3905#Software Engineering Journal - Controlling software projects
3906#The problems of managing software projects
3907#Controlling software projects
3908#Quantitative models for managing software development processes
3909#Controlling software quality
3910#Quality management—procedures and practices
3911#The Eclipse object management system
3912#Field monitoring of software maintenance
3913#SPMMS—information structures in software mangement
3914#Software metrics and integrated project support environments
3915#Dossier society: value choices in the design of national information systems
3916#PegsSys is an experimental system in which a user formally describes how a program is put together by means of a hierarchically structured collection of pictures, called formal dependency diagrams (FDDs). Icons in an FDD denote a wide range of data and control dependencies among the relatively coarse-grained entities contained in large programs. Dependencies considered atomic with respect to one level in a hierarchy can be decomposed into a number of dependencies at a lower level. Each dependency can be a predefined primitive of the FDD language or it can be defined by a PegaSys user in terms of the primitives.A PegsSys user is given the illusion that logical formulas do not exist, even though PegaSys reasons about them internally. This involves (1) checking whether an FDD is meaningful syntactically, (2) determining whether hierarchical refinements of an FDD are methodologically sound, and (3) deciding whether an FDD hierarchy is logically consistent with the program that it is intended to describe. The techniques used to provide these capabilities are discussed along with the logical properties that enable PegaSys to maintain the user illusion.
3917#Computers and the Humanities - A special double issue on activities in Canada: part I
3918#Most by numbers judge a poet's song: measuring sound effects in poetry
3919#Structural analysis of drama: practical and theoretical implications
3920#The computer music facility at Simon Fraser University
3921#Integrating artificial intelligence into literary research: an invitation to discuss design specifications
3922#The dictionary of Old English and the final design of its computer system
3923#Traditional discrete-event simulations employ an inherently sequential algorithm. In practice, simulations of large systems are limited by this sequentiality, because only a modest number of events can be simulated. Distributed discrete-event simulation (carried out on a network of processors with asynchronous message-communicating capabilities) is proposed as an alternative; it may provide better performance by partitioning the simulation among the component processors. The basic distributed simulation scheme, which uses time encoding, is described. Its major shortcoming is a possibility of deadlock. Several techniques for deadlock avoidance and deadlock detection are suggested. The focus of this work is on the theory of distributed discrete-event simulation.
3924#LISPcraft
3925#Digital systems and hardware/firmware algorithms
3926#This paper addresses the problem of optimizing queries that involve set operations (set queries) in a distributed relational database system. A particular emphasis is put on the optimization of such queries in horizontally partitioned database systems. A mathematical programming model of the set query problem is developed and its NP-completeness is proved. Solution procedures are proposed and computational results presented. One of the main results of the computational experiments is that, for many queries, the solution procedures are not sensitive to errors in estimating the size of results of set operations.
3927#In spite of substantial progress in the theory of interprocedural data flow analysis, few practical compiling systems can afford to apply it to produce more efficient object programs. To perform interprocedural analysis, a compiler needs not only the source code of the module being compiled, but also information about the side effects of every procedure in the program containing that module, even separately compiled procedures. In a conventional batch compiler system, the increase in compilation time required to gather this information would make the whole process impractical. In an integrated programming environment, however, other tools can cooperate with the compiler to compute the necessary interprocedural information incrementally. as the program is being developed, decreasing both the overall cost of the analysis and the cost of individual compilations.A central goal of the Rn project at Rice University is to construct a prototype software development environment that is designed to build whole programs, rather than just individual modules. It employs interprocedural analysis and optimization to produce high-quality machine code for whole programs. This paper presents an overview of the methods used by the environment to accomplish this task and discusses the impact of these methods on the various environment components. The responsibilities of each component of the environment for the preparation and use of interprocedural information are presented in detail.
3928#Properties are proved about INSTANCE, a theorem prover module that recognizes that a formula is a special case and/or an alphabetic variant of another formula, and about INSURER, another theorem prover module that decomposes a problem, represented by a formula, into independent subproblems, using a conjunction. The main result of INSTANCE is soundness; the main result of INSURER is a maximum decomposition into subproblems (with some provisos). Experimental results show that a connection graph theorem prover extended with these modules is more effective than the resolution-based connection graph theorem prover alone.
3929#The problem of recognizing what objects are where in the workspace of a robot can be cast as one of searching for a consistent matching between sensory data elements and equivalent model elements. In principle, this search space is enormous, and to control the potential combinatorial explosion, constraints between the data and model elements are needed. A set of constraints for sparse sensory data that are applicable to a wide variety of sensors are derived, and their characteristics are examined. Known bounds on the complexity of constraint satisfaction problems are used, together with explicit estimates of the effectiveness of the constraints derived for the case of sparse, noisy, three-dimensional sensory data, to obtain general theoretical bounds on the number of interpretations expected to be consistent with the data. It is shown that these bounds are consistent with empirical results reported previously. The results are used to demonstrate the graceful degradation of the recognition technique with the presence of noise in the data, and to predict the number of data points needed, in general, to uniquely determine the object being sensed.
3930#The generalized feedback shift register pseudorandom number generators proposed by Lewis and Payne provide a very attractive method of random number generation. Unfortunately, the published initialization procedure can be extremely time consuming. This paper considers an alternative method of initialization based on a natural polynomial representation for the terms of a feedback shift register sequence that results in substantial improvements in the initialization process.
3931#Four semantics for a small programming language involving unbounded (but countable) nondeterminism are provided. These comprise an operational semantics, two state transformation semantics based on the Egli-Milner and Smyth orders, respectively, and a weakest precondition semantics. Their equivalence is proved. A Hoare-like proof system for total correctness is also introduced and its soundness and completeness in an appropriate sense are shown. Finally, the recursion theoretic complexity of the notions introduced is studied. Admission of countable nondeterminism results in a lack of continuity of various semantic functions, and this is shown to be necessary for any semantics satisfying appropriate conditions. In proofs of total correctness, one resorts to the use of (countable) ordinals, and it is shown that all recursive ordinals are needed.
3932#RECAL, a Recursion by Chain Algorithm for computing the mean performance measures of product-form multiple-chain closed queuing networks, is presented. It is based on a new recursive expression that relates the normalization constant of a network with r closed routing chains to those of a set of networks having (r - 1) chains. It relies on the artifice of breaking down each chain into constituent subchains that each have a population of one. The time and space requirements of the algorithm are shown to be polynomial in the number of chains. When the network contains many routing chains, the proposed algorithm is substantially more efficient than the convolution or mean value analysis algorithms. The algorithm, therefore, extends the range of queuing networks that can be analyzed efficiently by exact means.
3933#The accessibility problem for linear sequential machines [12] is the problem of deciding whether there is an input x such that on x the machine starting in a given state q1 goes to a given state q2. Harrison shows that this problem is reducible to the following simply stated linear algebra problem, which we call the "orbit problem":Given (n, A, x, y), where n is a natural number and A, x, and y are nxn, nx1, and nx1 matrices of rationals, respectively, decide whether there is a natural number I such that Aix=y.He conjectured that the orbit problem is decidable. No progress was made on the conjecture for ten years until Shank [22] showed that if n is fixed at 2, then the problem is decidable. This paper shows that the orbit problem for general n is decidable and indeed decidable in polynomial time. The orbit problem arises in several contexts; two of these, linear recurrences and the discrete logarithm problem for polynomials, are discussed, and we apply our algorithm for the orbit problem in these contexts.
3934#The exponential function presented here returns a result which differs from ex by less than one unit in the last place, for any representable value of x which is not too close to values for which ex would overflow or underflow. (For values of x which are not within this range, an error condition is raised.) It is a 聯variable precision聰 function in that it returns a p-digit approximation for a p-digit argument, for any p = 0 (p-digit means p-decimal-digit). The program and analysis are valid for all p = 0, but current implementations place a restriction on p. The program is presented in a Pascal-like programming language called Numerical Turing which has special facilities for scientific computing, including precision control, directed roundings, and built-in functions for getting and setting exponents.
3935#For a given sparse symmetric positive definite matrix, a compact row-oriented storage scheme for its Cholesky factor is introduced. The scheme is based on the structure of an elimination tree defined for the given matrix. This new storage scheme has the distinct advantage of having the amount of overhead storage required for indexing always bounded by the number of nonzeros in the original matrix. The structural representation may be viewed as storing the minimal structure of the given matrix that will preserve the symbolic Cholesky factor. Experimental results on practical problems indicate that the amount of savings in overhead storage can be substantial when compared with Sherman's compressed column storage scheme.
3936#An implementation using systolic array logic of Aitken's method of iterated interpolation is described. The proposed design has a simple, linear topology, requires no clock, and makes only modest demands on the host computer. By overlapping the computation of successive function values, a processing element utilization of approximately 1/2 is achieved. The paper illustrates how “mathematical hardware” packages, as well as software library routines, may be part of the mathematical problem solver's tool kit in the future.
3937#This paper examines mathematical programming software in the context of model management and decision support. The concept of a model management system (MMS) is introduced and compared to traditional modeling systems. An MMS is seen as a much more generalized software system that requires the confluence of existing operations research, database management, and artificial intelligence techniques. By incorporating powerful, abstraction-based representation structures, an MMS can support multiple levels of model abstraction, only one of which corresponds to traditional, solution-oriented modeling software. The database structures required to implement a knowledge-based MMS are discussed and a prototype system for mathematical programming, the Generalized eXperimental Math Programming system (GXMP), is described. An algebraic language developed for use in GXMP is described in detail.
3938#This paper surveys the techniques used for designing the most efficient algorithms for finding a maximum cardinality or weighted matching in (general or bipartite) graphs. It also lists some open problems concerning possible improvements in existing algorithms and the existence of fast parallel algorithms for these problems.
3939#A constructive theory of randomness for functions, based on computational complexity, is developed, and a pseudorandom function generator is presented. This generator is a deterministic polynomial-time algorithm that transforms pairs (g, r), where g is any one-way function and r is a random k-bit string, to polynomial-time computable functions ƒr: {1, … , 2k} → {1, … , 2k}. These ƒr's cannot be distinguished from random functions by any probabilistic polynomial-time algorithm that asks and receives the value of a function at arguments of its choice. The result has applications in cryptography, random constructions, and complexity theory.
3940#Telecommunication networks: protocols, modeling and analysis
3941#Dynamics of digital interpolation & extrapolation
3942#Performance analysis of multiple access protocols
3943#Learning with personal computers
3944#Dictionary of robotics
3945#A practical introduction to standard Pascal
3946#Business data communications
3947#The ability to generate language-based editors depends on the existence of a powerful, language-independent model of editing. A model is proposed in which programs are represented as attributed abstract-syntax trees with an associated relational database. Relations can depend on the state of the attributed tree, and attributes can depend on the values in relations, provided there are no circular dependencies.The power and the limitations of relational operations are demonstrated with respect to the support of static-semantic checking, anomaly detection, an interrogation facility, and the ability to define alternative program displays. The advantages of the hybrid system over both the purely relational and purely attribute-based systems are presented, and new algorithms are given for query evaluation and incremental view updating motivated by the efficiency requirements of interactive editing under the defined model. A prototype implementation of an editor generator is described, and suggestions for future research are made.
3948#Using simulation, we examine the efficiency of several distributed, hardware-based solutions to the cache coherence problem in shared-bus multiprocessors. For each of the approaches, the associated protocol is outlined. The simulation model is described, and results from that model are presented. The magnitude of the potential performance difference between the various approaches indicates that the choice of coherence solution is very important in the design of an efficient shared-bus multiprocessor, since it may limit the number of processors in the system.
3949#A new message communication paradigm based on conversations that provides an alternative to memo- and conference-based mail is described. A conversation-based message system groups messages into conversations, and orders messages within a conversation according to the context in which they were written. The message context relation leads to an efficient implementation of conversations in a distributed environment and supports a natural ordering of messages when viewed by the user. Experience with a prototype demonstrates the workability of conversation-based mail and suggests that conversations provide a powerful tool for message communication.
3950#We propose a distributed deadlock detection algorithm for distributed computer systems. We consider two types of resources, depending on whether the remote resource lock granularity and mode can or cannot be determined without access to the remote resource site. We present the algorithm, its performance analysis, and an informal argument about its correctness. The proposed algorithm has a hierarchical design intended to detect the most frequent deadlocks with maximum efficiency.
3951#A number of multiversion concurrency control algorithms have been proposed in the past few years. These algorithms use previous versions of data items in order to improve the level of achievable concurrency. This paper describes a simulation study of the performance of several multiversion concurrency control algorithms, investigating the extent to which they provide increases in the level of concurrency and also the CPU, I/O, and storage costs resulting from the use of multiple versions. The multiversion algorithms are compared with regard to performance with their single-version counterparts and also with each other. It is shown that each multiversion algorithm offers significant performance improvements despite the additional disk accesses involved in accessing old versions of data; the nature of the improvement depends on the algorithm in question. It is also shown that the storage overhead for maintaining old versions that may be required by ongoing transactions is not all that large under most circumstances. Finally, it is demonstrated that it is important for version maintenance to be implemented efficiently, as otherwise the cost of maintaining old versions could outweigh their concurrency benefits.
3952#Quantitative systems for business: QSB
3953#The connection machine
3954#Dynamics of WordPerfect: including version 4.0
3955#Phonology and syntax: the relationship between sound and structure
3956#Large deviations of uniformly recurrent Markov additive processes
3957#It was shown in [2] that Burgers' equation can be obtained as a contraction of a certain N-body problem when N - ~. Using this result we derive a variant of the Hopf-Cole transformation.
3958#Decompositions of the plane into disjoint components separated by curves occur frequently. We describe a package of subroutines which provides facilities for defining, building, and modifying such decompositions and for efficiently solving various point and area location problems. Beyond the point that the specification of this package may be useful to others, we reach the broader conclusion that well-designed data structures and support routines allow the use of more conceptual or non-numerical portions of mathematics in the computational process, thereby extending greatly the potential scope of the use of computers in scientific problem solving. Ideas from conceptual mathematics, symbolic computation, and computer science can be utilized within the framework of scientific computing and have an important role to play in that area.
3959#The distribution of the eigenvalues of the Schrodinger Operator is studied. It is found that when the underlying manifold is non-compact these eigenvalues can be generated asymptotically at the same rate as the primes.
3960#Homotopy properties of greedoids
3961#Computer output devices: a tutorial review
3962#Use of information technology in UK agricultural information study
3963#Generic elements in an undergraduate course in information study
3964#The scientific paper as an archaeological artifact
3965#Nearest neighbour searching in serial files using text signature
3966#A note concerning two ISBN-checking algorithms
3967#Marketing books and journals to western Europe
3968#Group decision-making with a fuzzy majority via linguistic quantifiers. part 1:
3969#Group decision-making with a fuzzy majority via linguistic quantifiers. part II:
3970#Systems approach for constructing dynamic motivation models
3971#Some cybernetic principles for the design, control, and development of social systems
3972#Fuzzy models for energy demand management
3973#Positional transduction: an alternative to code
3974#A case study demonstration use of Beer's cybernetic model of viable systems
3975#Toward an algebraic gnoseology
3976#Management accounting information systems
3977#An application of cybernetic algorithm design
3978#Cahiers du Centre d'Etudes de Recherche Operationelle
3979#Reduced form of a general model of rational expectations. (French)
3980#A dynamic programming approach to generalized linear fractional programs
3981#Connectedness of the efficient set in three criteria
3982#Inventory returns and special sales in the order-level lot-size system
3983#A general class of unequal probability sampling schemes for samples of two units
3984#Partitions of chains with minimum imbalance
3985#The stochastic max-min problem
3986#On the localization of recession points
3987#Algorithms to construct Minkowski reduced and Hermite reduced lattice bases
3988#Bandwidth constrained NP-complete problems
3989#Concerning two-adjacent context-free languages
3990#Petri nets with individual tokens
3991#A property of three-element codes
3992#A weaker sufficient condition for the equivalence of a pair of DPDA's to be decidable
3993#Fast parallel language recognition by cellular automata
3994#On the complexity of theories of permutations
3995#Inferences for numerical dependencies
3996#Complexity of the combinator reduction machine
3997#Alternating tree automata
3998#The complexity of evaluating interpolation polynomials
3999#Simulating probabilistic by deterministic algebraic computation trees
4000#Alternating on-line Turing machines with only universal states and small space b
4001#A variant of random context grammars: semi-conditional grammars
4002#Dynamics of positive automata networks
4003#On context-free trees
4004#On the combinatorial problem of codes composed of two words
4005#Computing in general Abelian groups is hard
4006#Adjunction of semifunctors: categorical structures in nonextensional lambda calculus
4007#On the equivalence problem of compositions of morphisms and inverse morphisms on
4008#Integrity of formal power series on a partially commutative alphabet
4009#Possible forms of evaluation or reduction in Martin-Lo¨f type theory
4010#A proof of Ehrenfeucht's conjecture
4011#The methodologies of artificial intelligence and the knowledge of cognitive psychology can be used to automatically generate fine-grain tutorial interactions, rather than having to program them manually.
4012#Teaching effective problem-solving skills in the context of teaching programming necessitates a revised curriculum for introductory computer programming courses.
4013#Programming is most often viewed as a way for experts to get computers to perform complex tasks efficiently and reliably. Boxer presents an alternative image—programming as a way for nonexperts to control a reconstructible medium, much like written language, but with dramatically extended interactive capabilities.
4014#This report is endorsed by the Computer Science Board and prepared by the board's Committee on Research Funding in Computer Science.
4015#Based on a review of some actual expert-system projects, guidelines are proposed for choosing appropriate applications and managing the development process.
4016#Existing Unix data protection and synchronization mechanisms present difficulties when adapting Unix to a multiprocessor environment, but solutions do exist.
4017#A simple algorithm is given which takes an arbitrary binary search tree and rebalances it to form another of optimal shape, using time linear in the number of nodes and only a constant amount of space (beyond that used to store the initial tree). This algorithm is therefore optimal in its use of both time and space. Previous algorithms were optimal in at most one of these two measures, or were not applicable to all binary search trees. When the nodes of the tree are stored in an array, a simple addition to this algorithm results in the nodes being stored in sorted order in the initial portion of the array, again using linear time and constant space.
4018#Fault-tolerant computing: theory and techniques; vol. 1
4019#Test generation for digital systems
4020#Design for testability
4021#Fault simulation
4022#Coding theory for fault-tolerant systems
4023#Coding techniques in fault-tolerant, self-checking, and fail-safe circuits
4024#Physics for computer science students: with emphasis on atomic and semiconductorphysics
4025#Machine translation: past, present, future
4026#Misunderstanding media
4027#Principles of digital communications: signal representation, detection, estimation and information coding
4028#Program construction and verification
4029#Applying expert systems in business
4030#Relational databases
4031#Microprocessor sourcebook for engineers
4032#Computer networks are becoming more numerous and more diverse. Collectively, they constitute a worldwide metanetwork.
4033#By carefully tuning computer and compiler, it is possible to avoid the otherwise inevitable compromises between complex compiling algorithms and less-than-optimal compiled code, where the key to performance appears to lie neither in sophisticated nor drastically reduced architectures, but in the key concepts of regularity and completeness.
4034#By incorporating bit-manipulation routines into Fortran-77, it is now possible to manipulate bits or partial word operands without having to write assembly-coded subroutines. Because the routines are now acceptable to Fortran-77 compilers, the accessing code is now portable to other Fortran Machines.
4035#A simple implementation of double-ended priority queues is presented. The proposed structure, called a min-max heap, can be built in linear time; in contrast to conventional heaps, it allows both FindMin and FindMax to be performed in constant time; Insert, DeleteMin, and DeleteMax operations can be performed in logarithmic time. Min-max heaps can be generalized to support other similar order-statistics operations efficiently (e.g., constant time FindMedian and logarithmic time DeleteMedian); furthermore, the notion of min-max ordering can be extended to other heap-ordered structures, such as leftist trees.
4036#A finite element computer system and analysis of a bridge structure
4037#Program DSSRSSR for the solution of nonlinear optimisation models
4038#Database administrator facilities for engineering data management
4039#MIDAS: management of information for design and analysis of systems
4040#A spread sheet-like input routine for optimisation problems
4041#Shape calculation for a class of axisymmetric minimum-energy surfaces. (Technical note)
4042#Integrated thermal-structure finite strip analysis
4043#Treatment of the singular initial conditions of the drop-shaped tank
4044#Presented here is the Computer Science Board's survey on the production and employment of Ph.D.'s and faculty in computer science and engineering.
4045#Microprocessor-based system for measurement of conductivity in amorphous semiconductors
4046#A new approach for the measurement of A.C. arc parameters using microprocessors
4047#A communication protocol for single chip processors
4048#Analysis of the transcutaneous oxygen trace by a microcomputer
4049#BBC microcomputers in population screening
4050#Computer aided learning and the nurse
4051#A portable microprocessor-based temperature recorder
4052#Computerized psychiatric diagnosis in the elderly: AGECAT
4053#Analysis of ambulatory colonic mobility records using a BBC (B) microcomputer
4054#System specification and design in clinical microcomputer systems: a tutorial in Jackson system development
4055#A microprocessor-controlled poster
4056#User guide to FOCUS
4057#The C++ programming language
4058#Recommended diagramming standards for analysts & programmers: a basis for automation
4059#A geometric investigation of reach
4060#Personal computer quality: a guide for victims and vendors
4061#Algorithms for mutual exclusion
4062#LUCAS associative array processor: design, programming and application studies
4063#Introduction to the Graphical Kernel System (GKS) (2nd ed. revised for international standard)
4064#Information and the crisis economy
4065#The micro-mainframe link: the corporate guide to productive use of the microcomputer
4066#File techniques for data base organization in COBOL (2nd ed.)
4067#Applied mathematical programming for production and engineering management
4068#Power system control technology
4069#Data entry for microcomputers and terminals
4070#Corporate information management
4071#Understanding language: man or machine
4072#IEEE standard FASTBUS modular high-speed data acquisition and control system: an American National Standard
4073#Structuring FP-style functional programs
4074#A constraint language and its interpreter
4075#Interpreters from functions and grammars
4076#Language and machine-independent global optimization on intermediate code
4077#A belated proof of self-stabilization
4078#A model and temporal proof system for networks of processes
4079#Easy impossibility proofs for distributed consensus problems
4080#How processes learn
4081#Verification of multiprocess probabilistic protocols
4082#Rough classification of patients after highly selective vagotomy for duodenal ulcer
4083#On the purpose and analysis of EDP user systems
4084#Discrimination of words in a large vocabulary using phonetic descriptions
4085#A comparative analysis of methods for expert systems
4086#Induction: processes of inference, learning, and discovery
4087#Concurrency and programming languages
4088#Optical fiber communications: principles and practice
4089#The dynamics of data base
4090#Software engineering and Modula-2
4091#Designing the user interface: strategies for effective human-computer interaction
4092#Computer Graphics
4093#Fundamentals of interactive computer graphics
4094#Data structures of Pascal, Algol 68, PL/1 and Ada
4095#The art of Prolog: advanced programming techniques
4096#Parallel array processing
4097#Personal computers & data communications
4098#Knowledge acquisition for expert systems
4099#Information systems management in practice
4100#Understanding information technology: text, readings, and cases
4101#Analog electronic circuits
4102#PL/1: structured programming and problem solving
4103#Spread spectrum communications; vols. 1-3
4104#Hit methodology for complicated data structure design
4105#Incorporating theory into database system development
4106#The possible effect of abstracting guidelines on retrieval performance of free-text searching
4107#End-user information-seeking in the energy field: implications for end-user access to DOE/RECON databases
4108#Data structures using Pascal (2nd ed.)
4109#The devil's DP dictionary
4110#Running Press glossary of computer terms
4111#The hacker's dictionary: a guide to the world of computer wizards
4112#A novice user's interface to information retrieval systems
4113#A note on the nature of creativity in engineering: implications for supporting system design
4114#The effects of communication monitors on user satisfaction
4115#Access to UK academic networks
4116#A structural representation of shape and its features
4117#Normal form of extended table matrix L systems
4118#The relative dimension of a probabilistic experiment
4119#A scheme for constructing ordered minimal perfect hashing functions
4120#Programming in C
4121#Fairness
4122#Data base organization for data management (2nd ed.)
4123#How to write computer documentation for users (2nd ed.)
4124#The bounding approach to VLSI circuit simulation
4125#FORTH
4126#FORTH: tools and applications
4127#Starting FORTH; 2nd ed.
4128#Modelling storage systems
4129#FORTRAN 77 syntax
4130#Data communications networking devices: characteristics, operation, application
4131#Quality innovation: an economic analysis of rapid improvements in microelectronics
4132#The Computer Bulletin - Computers in finance
4133#Skills shortage and the new partnership
4134#Credit card data capture
4135#City dealing rooms: developments in technology
4136#What's new in insurance?
4137#Homelink: a unique service
4138#The TSB common system
4139#Accounting systems updated
4140#Grosch's law updated
4141#Gearing up for the fast lane: new tools for management in a high-tech world
4142#Fuzzy mathematical approach to pattern recognition
4143#Machine learning: applications in expert systems and information retrieval
4144#Modern graphic communications: a CAD approach
4145#In search of the person: philosophical explorations in cognitive science
4146#Efficient use of systems with many processors
4147#Eric Howe: Data Ombudsman
4148#Not only computing-also art
4149#Eye movements in reading: perceptual and language processes
4150#CSP review manual: tools of the systems professional
4151#Writing better computer user documentation: from paper to online
4152#Developing data structured databases
4153#Expert systems 1986
4154#Computer science logo style; vol. 2: projects, styles, and techniques
4155#Selecting an Ada environment
4156#Analysis and design of stream ciphers
4157#Talking with computers in natural language
4158#Library networks, 1986-87: libraries in partnership
4159#Patterns and operators: the foundations of data representation
4160#Measured doses of data communications
4161#Advanced database techniques
4162#Networking with microcomputers
4163#Professional video graphic design: the art and technology
4164#Projective geometry and its applications to computer graphics
4165#Designing knowledge-based systems
4166#Natural language processing: a knowledge-engineering approach
4167#Fifth generation computers: concepts, implementations and uses
4168#Practitioner's guide to Ada
4169#Programming principles in computer graphics
4170#A comprehensive guide to AI and expert systems
4171#An introduction to computer-aided design and manufacture
4172#Fuzzy mathematical techniques with applications
4173#Dynamics of hierarchical systems: an evolutionary approach
4174#Varieties of realism: geometries of representational art
4175#Numerical control programming in APT
4176#Artifical intelligence and expert systems sourcebook
4177#C by dissection: the essentials of C programming
4178#Numerical recipes: the art of scientific computing
4179#Numerical recipes: example book (Pascal)
4180#Numerical recipes: example book (FORTRAN)
4181#Concepts in user interfaces: a reference model for command and response languages
4182#4GL: fourth generation languages; vol. III. 4GLs from IBM
4183#The IBM PC (and compatibles) free software catalog and directory: the what, where, why, and how of selecting, locating, acquiring, and using free software
4184#Decision support systems: tools and techniques
4185#Fundamentals of queueing theory (2nd ed.).
4186#Logic design principles with emphasis on testable semicustom circuits
4187#Scientific and engineering applications with personal computers
4188#Computer-aided design and VLSI device development
4189#Introduction to VLSI silicon devices: physics, technology and characterization
4190#IBM PC applications for the industrial engineer and manager
4191#It is assumed that long wires represent large capacitive loads, and the effect on the area of a VLSI layout when drivers are introduced along many long wires in the layout is investigated. A layout is presented for which the introduction of standard drivers along long wires squares the area of the layout; it is shown, however, that the increase in area is never greater than the layout's area squared if the driver can be laid out in a square region. This paper also shows an area-time trade-off for the driver of a single long wire of length / by which the area of the driver from &THgr;(l), to &THgr;(lq), q ll-q) rather than &THgr;(log l) can be tolerated. Tight bounds are also obtained on the worst-case area increase in general layouts having these drivers.
4192#Systems that learn: an introduction to learning theory for cognitive and computer scientists
4193#On machine intelligence (2nd revised ed.)
4194#Programming languages: a grand tour (3rd ed.)
4195#From models to modules: studies in cognitive science from the McGill workshops
4196#Robot plans and human plans: implications for models of communications
4197#The mapping between grammar and processor
4198#Modularity and lexical access
4199#The organization of medical disorders in the memories of medical students and general practitioners
4200#Cognitive factors in programming: the good, the bad, and the ugly
4201#The optimal level of abstraction for models of cerebral representation of language processes: the state of the question
4202#A plea for neutral monism from aphasiology
4203#From schema theory to computational (neuro-)linguistics
4204#The acquisition of grammar
4205#Theoretical issues in the investigation of words of internal report
4206#Some relations between children's knowledge of metalinguistic and metacognitive verbs and their linguistic competencies
4207#An interaction between morphology and discourse
4208#Language, the mind, and psychophysical parallelism
4209#A philosopher looks at the current debate on language acquisition
4210#Approaches to the semantics of questions in natural language: part 1
4211#The extraction of curved surface features with generic range sensors
4212#Using backprojections for fine motion planning with uncertainty
4213#Determining grasp configurations using photometric stereo and the PRISM binocular
4214#Implementation of force feedback in manipulation robots
4215#Optimization of mechanisms for force generation by using pulleys and spring
4216#Real-time obstacle avoidance for manipulators and mobile robots
4217#Kinematic analysis of manipulators using the zero reference position description
4218#Kinematics simulation of serial manipulators
4219#Computationally efficient kinematics for manipulators with spherical wrists base
4220#Dual orthogonal matrices in manipulator kinematics
4221#Singularities, configurations, and displacement functions for manipulators
4222#A new method for the singularity analysis of simple six-link manipulators
4223#Robotic bevel-gear differential train
4224#The canonical inverse velocity and acceleration solutions of a planar two-link o
4225#Geometric optimization of serial chain manipulator structures for working volume
4226#Optimization of the workspace of a three-link turning-pair connected robot arm
4227#On the nature of robot workspace
4228#Mapping the manipulator workspace using interactive computer graphics
4229#Workspace and mobility of a closed-loop manipulator
4230#Synthesis of 7-R spatial motion generators with prescribed crank rotations and e
4231#A Stewart-Platform based manipulator: general theory and practical construction
4232#Type selection of robot and gripper kinematic topology using expert systems
4233#An algorithm to decide whether a rational subset of Nk is recognizable
4234#Discrete logarithms in GF(p)
4235#Area-time lower-bound techniques with applications to sorting
4236#In this paper we present an algorithm for finding a ''closed-form'' solution of the differential equation y'' + ay' + by, where a and b are rational functions of a complex variable x, provided a ''closed-form'' solution exists. The algorithm is so arranged that if no solution is found, then no solution can exist.
4237#Computational methods for finding the character table of a finite group require a stock of reducible characters and techniques for decomposing these characters into irreducible characters. A method for generating reducible characters from a representation of a group is proposed. Several new techniques for computing the irreducible decompositions of a set of characters are given; these techniques extend earlier results of Conway and M. Guy.
4238#The present author as well as Andreka's group has experienced, while writing program- verifying programs, the following dilemma. We have to decide which program verification method (i.e. logic of programs) to choose as a framework for our software system. It is not obvious that the strongest method is also the best because it might overload the theorem prover subprogram. So we have to optimise. But for this we need as much information and insight as possible into the natures of available methods. Non-standard algorithmic logic of dynamic logic (NDL from now on) is a complete first order logic with a decidable proof concept for reasoning about programs, developed in 1978 by H. Andreka et al. NDL unifies existing approaches to program verification and turns incompleteness results into completeness results. Still, it is far from being popular and this is because non-standard models of computation are unpopular. It is the aim of the present paper to show that these models play for dynamic logic the same role which, say, complex numbers, play for physics. They are merely a tool for proving very realistic, standard properties of programs (e.g. non-provability by a given standard method) or for reasoning about (existing) program verification methods. The paper also provides two essential proofs, which are missing in their complete or proper form from the publications.
4239#Some notes on the computation of Groebner Bases using Buchberger's algorithm over different coefficient domains and the solution of systems of algebraic equations using Groebner bases are given. Examples demonstrate applicability and its current timits, and show the wide range of problems tractable by this method. The choices of an appropriate variable ordering and a suitable term ordering are of crucial importance for the computing time and space allocation. The ''optimal'' variable ordering is considered, and an improvement for the selection of wdid solutions of the system of algebraic equations is described.
4240#UNIX refguide
4241#Circuit analysis by computer: from algorithms to package
4242#Learn C in two weeks with RUN/C and CBREEZE
4243#Database design: a classified and annotated bibliography
4244#DOS UNIX systems: becoming a super user
4245#The 68000 microprocessor: architecture, software, and interfacing techniques
4246#The 8085A microprocessor: software, programming, and architecture
4247#Computers and the Social Sciences - Special double issue on statistical packages
4248#This paper presents a reeursive procedure for computing the degrees of the irreducible complex characters of a finite p-group by working up a central series in the group. A program written in the computer group theory language CAVLE7 is presented which implements this algorithm assuming that the p-group is given in terms of a power-commutator presentation. Some times for sample runs are presented which indicate that the CAYLEY implementation is effective for groups of order up to p^1^5 for small primes. In particular, this approach seems to produce the character degrees much faster than using CAYLEY,''S built-in character table function and reading off the degrees.
4249#We explain how factoring polynomials modulo primes can be used in proving that for certain geometric optimisation problems there exists no exact algorithm under models of computation where the root of an algebraic equation is obtained using arithmetic operations and the extraction of kth roots. This leaves only numerical or symbolic approximations to the solution of these problems under these models. This letter describes work which is described in more detail in Bajaj (1984)-here we concentrate on the use of computer algebra, in particular factoring polynomials over the rationals using the MACSVMA system.
4250#We determine piston trajectories yielding maximum work output from two variations of a light-driven engine: one is a free-piston engine; the other is an optimally controlled engine. The equations describing the optimal piston path of the controlled engine are generated by the symbolic processing program MACSYMA. A second set of computer algebra routines are used to perform a stability analysis of the coupled, non-linear differential equations describing the piston trajectories. From this analysis we generate parameter sets that allow a numerical program, which solves systems of differential equations with mixed boundary conditions, to determine etiieientty the explicit time-path of the optimally controlled engine.
4251#Future Computing Systems
4252#The correctness of two translation methods from definite clause grammars into Prolog programs
4253#A learning model for forecasting the future of information technology
4254#New infrastructures for research and technology transfer
4255#In search of a paradigm for the discipline of information systems
4256#Given the set @? of terms, a congruence ~ on @? and a set N of representatives for ~, we say a term rewriting system (TRS) R defines (~, N) if ~ is the congruence defined by R and N is the set of R-normal forms. We give necessary and sufficient syntactical conditions on (~, N) to be definable by a TRS. It turns out that (~, N) may be definable by a TRS but not by a uniquely terminating one. In order to find a minimal TRS defining (~, N) we construct the reduced TRS for (~, N). The reduced TRS R may fail to define (~, N), but if every term has an R-normal form, then it is a minimal TRS defining (~, N).
4257#The combination of functional and pure Horn clause logic languages is formally introduced. To give a framework for the investigation of implementations we define a complete and consistent model, which retains full invertibility and allows separation of logic and control. Some existing implementations are discussed from this viewpoint. An extended unification algorithm is suggested, which incorporates the features demanded by our model.
4258#It is well known that various notions of distinguished bases of ideals, such as standard and Grobner bases, and algorithms for constructing them, play a central role in solving algorithmic problems in polynomial ideal theory and related algebraic theories. In this paper a new structural algebraic framework is given for the concept and the construction of the so-called generalised standard bases. Although the spirit of this paper is more structural than algorithmic, the general results achieved should also help to shape and direct future research in the algorithmic aspects of commutative algebra.
4259#Let B be a set of n"b black points and W a set of n"w, white points in the Euclidean plane. A line h is said to bisect B (or W) if, at most, half of the points of B (or W) lie on any one side of h. A line that bisects both B and W is called a ham-sandwich cut of B and W. We give an algorithm that computes a ham-sandwich cut of B and W in 0((n"h+n"w) log (min {n"b, n"w}+ 1)) time. The algorithm is considerably simpler than the previous most efficient one which takes 0((n"b + n"w) log (n"b + n"w)) time.
4260#The Maple computer algebra system is described. Brief sample sessions show the user syntax and the mathematical power of the system for performing arithmetic, factoring, simplification, differentiation, integration, summation, solving algebraic equations, solving differential equations, series expansions, and matrix manipulations. Time and space statistics for each sample session show that the Maple system is very efficient in memory space utilisation, as well as in time. The Maple programming language is presented by describing the most commonly used features, using some non-trivial computations to illustrate the language features.
4261#We present some techniques we have used to apply REDUCE to problems which have mathematical structures unknown to REDUCE. Our examples, the spectrum of the @a model and the Gross-Neveu model, come from particle physics. We had to handle three-vectors, summation with indefinite upper limit, formatting requirements for producing efficient FORTRAN code, and anti-commuting operators.
4262#The symbol-manipulation system MuMATH has been applied to the algebraic problem of generating characters and irreducible representations of certain permutation groups which occur in the treatment of the quantum states of easily rearranged molecules. Character calculations are based on the methods of Dixon, in which calculations are done in modulo arithmetic; representations are recovered by induction as described by Altmann. These methods reduce the scale of the computation so that it may be accomplished within the limits of widely available microcomputers.
4263#Using MACSYMA to write FORTRAN subroutines
4264#Computers & Education - The MIT Press scientific computation series
4265#The role of computer simulations in engineering education
4266#Portability of computer-based teaching software: ESPE experience
4267#An illustrative computer program for instruction in the finite element method
4268#A methodology for developing computer-based teaching programs
4269#The microcomputer as a classroom audio visual device: the concept, and prospects
4270#An experimental evaluation of alternate pedagogical approaches for an introductory business data processing course
4271#Computer-based microworlds—a definition to aid design
4272#A heuristic approach to scheduling university timetables
4273#Abstraction and specification in program development
4274#Design of VLSI gate array ICs
4275#Universal subgoaling and chunking: the automatic generation and learning of goal hierarchies
4276#Denotational semantics: a methodology for language development
4277#Broadband network technology: an overview for the data and telecommunications industries
4278#Database processing for microcomputers
4279#Relational database: selected writings
4280#Wang systems word processing: a learning guide
4281#Introduction to system science
4282#System reliability: evaluation & prediction in engineering
4283#Introduction to data management & file design
4284#Data types and data structures
4285#Selected developments in Soviet mathematical cybernetics
4286#Digital logic design: tutorials and laboratory exercises
4287#Numerical weather forecasting research in the Canadian weather service
4288#Artificial intelligence applications on supercomputers
4289#Computer power for film and flight
4290#Cray/Blitz—1984 chess champion
4291#Simulation of complex molecules—computational requirements for the 1980's
4292#Large scale computer modeling of molecular systems at du Pont
4293#Synthetic aperture radar processing on a CRAY-1 S supercomputer
4294#Pre-stack seismic migration in three dimensions
4295#Telecommunications legislation: the 98th U.S. Congress, 2nd session in review
4296#Compare: a collusion detector for Pascal
4297#An APL compiler
4298#Practical use of Petri nets for production systems design
4299#Prao: a geographical information system
4300#Construction of distributed types by control migration
4301#Systems Research
4302#Organizational influence on future information systems architecture
4303#Giving back some freedom to the system designer
4304#Distributed computation by graph reduction
4305#Applicative programming
4306#A hierarchical information processing model for adaptation to technology change
4307#A Borel parametrization of Polish groups
4308#Actions of discrete amenable groups and groupoids on von Neumann algebras
4309#A mathematical one-dimensional model of supercooling solidification
4310#Linear Radon-Nikodym theorems for states on JBW and W* algebras
4311#The Weyl transformation and quantisation for locally compact Abelian groups
4312#Dressing transformations and Poisson group actions
4313#Cyclic cohomology of certain affine schemes
4314#Lower bounds of decay order of eigenfunctions of second-order elliptic operators
4315#Squaring operations in the 4-connective fibre spaces over the classifying spaces
4316#Remarks on the Feynman representation
4317#Zero's exponential sums and best diophantine approximations
4318#Some aspects of normal quantisation
4319#On the Ray-Walker extension of the Caristi-Kirk fixed point theorem
4320#Time-dependent solutions of a nonlinear system arising in semiconductor theory
4321#Phase plane analysis using the Poincare´ map
4322#A constructive approach to the Bellman semigroup
4323#Aronszajn's theorem for a parabolic partial differential equation
4324#On second derivatives for nonsmooth functions
4325#Existence of solutions to nonselfadjoint boundary value problems for ordinary differential equations
4326#Existence theorems for nonselfadjoint semilinear elliptic boundary value problems
4327#Einstein-like approximation for homogenization with small concentration. I—Elliptic problems
4328#Einstein-like approximation for homogenization with small concentration. II—Navier-Stokes equation
4329#Qualitative properties of a nonlinear system for laminar flames without ignition temperature
4330#Bounds for moving boundary problems with two chemical reactions
4331#Subharmonic oscillations of convex Hamiltonian systems
4332#Formal theories of knowledge in AI and robotics
4333#Meta-level programming and knowledge representation
4334#The design and implementation of DLOG, a Prolog-based knowledge representation system
4335#Multi-layer logic—A predicate logic including data structure as knowledge representation language
4336#Complex indeterminates in Prolog and its application to discourse models
4337#Ten requirements for a theory of change
4338#Prolog-ELF incorporating fuzzy logic
4339#In this paper we describe a new class of orderings-associative path orderings-for proving termination of associative-commutative term rewriting systems .These orderings are based on the concept of simplification orderings and extend the well-known recursive path orderings to E - congruence classes, where E is an equational theory consisting of associativity and commutativity axioms. Associative path orderings are applicable to term rewriting systems for which a precedence ordering on the set of operator symbols can be defined that satisfies a certain condition,the associative path condition. The precedence ordering can often be derived from the structure of the reduction rules. We include termination proofs for various term rewriting systems (for rings,boolean algebra,etc.) and, in addition, point out ways to handle situations where the associative path condition is too restrictive.
4340#We describe the theory and implementation of computer algorithms designed to compute the dimensions of the first and second cohomology groups of a finite group G, acting on a finite module M defined over a field K of prime order. Presentations of extensions of M by G can also be computed. The method is to find a Sylow p-subgroup P of G, where p =@?K@?, to compute H^x (P, M) first, using variants of the Nilpotent Quotient Algorithm, and then to compute H^x (G, M) as the subgroup of stable elements of H^x (P, M).
4341#Our aim is to present a practical algorithm for the isomorphism problem that can be easily adapted to any class of combinatorial objects. We investigate the underlying principles of backtrack algorithms that determine a canonical representative of a combinatorial object. We identify the parts of the algorithm that are dependent on the class of combinatorial objects and those parts that are independent of the class. An interface between the two parts is developed to provide a general backtrack algorithm for the isomorphism problem of combinatorial objects that incorporates the technique of branch-and-bound, and that also uses the automorphisms of the combinatorial object to prune the search tree. Our general algorithm incorporates from computational group theory an algorithm known as the base change algorithm. The base change algorithm allows one to recover as much information as possible about the automorphism group when a new branch of the search tree is processed. Thus, it can lead to greater pruning of the search tree. This work is intended to lead to a better understanding of the practical isomorphism algorithms. It is not intended as a contribution to the theoretical study of the complexity of the isomorphism problem.
4342#For a string rewriting system T on a finite alphabet @?, the word problem is the following decision problem: INSTANCE: Two words u, @u@?@?*. QUESTION:Are the words u, and @u congruent modulo T, i.e . can the word @u be derived from u in T? An algorithm @f for solving this problem is called a pseudo-natural algorithm, if on input u, @u@?@?*, / actually computes a derivation of v from a in T in case a and v are congruent modulo T. For many classes of monoids and groups, that are given through presentations involving finite string rewriting systems, the word problems are solved by pseudo-natural algorithms . Here, the following results concerning this class of algorithms are obtained: 1 . The degree of complexity of a pseudo-natural algorithm for solving the word problem for a finitely presented monoid is independent of the actually chosen finite presentation. 2. There exists a finitely presented monoid (in fact, even a group) such that every pseudonatural algorithm for solving the word problem for this monoid is of a high degree of complexity, although this problem is easily decidable. 3. Each finitely generated group G, the word problem for which is decidable, can be embedded in a finitely presented group H such that the word problem for H can be solved by a pseudo-natural algorithm that is of the same degree of complexity as the word problem for G.
4343#Five procedures have been written in MACSYMA dealing with the problem of finding a Hamiltonian and the corresponding dynamical equations for physical theories described by a singular Lagrangian. We describe the main structure of the Dirac-Bergmann algorithm as well as the corresponding procedures.
4344#The spirit of Expolanguages
4345#French-German office for youth
4346#“Triangle” seminar: an example of multilateral cooperation
4347#Eurocentres: a twenty-five year pedagogic experience
4348#LACITO/CNRS research
4349#Terminology/translation
4350#The French Society of Expolanguage translators
4351#The translation of Latin-American works in France
4352#Why DIWAN?
4353#A unique French linguistic network
4354#Good morning Mr. Microprofessor
4355#Potential fields of LSP research: A proposal for corpus selection and methods
4356#Combined wave refraction and diffraction near a breakwater
4357#Inelastic post buckling behavior of very short column
4358#Natural convection effects on laminar heat transfer in the thermal entrance region of horizontal isothermal tubes
4359#The stress relaxation of the 1,2-syndiotactic polybutadiene thermoplastic elastomer
4360#Effects of substrate protection and intraparticle diffusion on the stability of immobilized glucose isomerase
4361#The relationship between the eigenstructures and trajectory sensitivity of autonomous linear time-invariant systems
4362#Low-sensitivity controllers for discrete-time systems
4363#Transformation of continuous-time state equations to discrete-time state equations
4364#Direct sequence voice scrambling scheme—A new technique for secure communications
4365#Design of reinforced concrete panels subjected to combined tension and shear
4366#Effects of size distribution on the combustion efficiency of a liquid propellant
4367#An experimental technique for the measurement of flame propagation in heterogeneous fuel sprays
4368#Microcomputer loop communication network design
4369#New algorithms of interpolations for a computer numerical control system
4370#Prolog programming for artificial intelligence
4371#Information systems definition: the Multiview approach
4372#The micro to mainframe connection
4373#Process instruments and controls handbook (3rd ed.)
4374#IMS (DL/1) data base organization and performance
4375#Artificial behavior: computer simulation of psychological processes
4376#Distributed termination on a ring
4377#Disk allocation methods for binary Cartesian product files
4378#The amortized complexity of Henriksen's algorithm
4379#On systolic arrays for updating the Cholesky factorization
4380#On the design of a key-lock-pair mechanism in information protection systems
4381#Ordered priority queues
4382#A dynamic programming approach to the complete set partitioning problem
4383#Litigation considerations in restrictive covenant cases
4384#Q-Co Industries v. Hoffman
4385#Defense Department's proposed rule on data rights and computer software
4386#Numerical analysis of parametrized nonlinear equations
4387#Algorithms: the construction, proof, and analysis of programs
4388#Concurrent programming in Ada
4389#Fiber optics: devices and systems
4390#Fourth and fifth generation programming languages. Vol. 1: integrated software, database languages, and expert systems
4391#C for professional programmers
4392#Microcomputer applications in banking
4393#X.25 explained: protocols for packet switching networks (2nd ed.)
4394#Modula-2 wizard: a programmer's reference
4395#The oil industry—a complex cybernetic system
4396#Fundamental correlations in the macroeconomic system efficiency—profitableness
4397#Maximizing the development fund efficiency—a criterion for accumulation rate optimization
4398#Reduction of the large size graphs with a view of their scheduling
4399#A method of generating autocorrelated uniformly distributed random numbers
4400#A complex analysis of estimating the technical and qualitative standards of industrial products
4401#Automatic evaluation of emergency minimal modes in the fault tree
4402#Criteria for estimating the regression model parameters
4403#Fuzzy diameters method for multicriterial analysis
4404#An application of fuzzy decisions in operating a power unit
4405#Trends and perspectives in the field of data banks
4406#CP/M—An operating system for microcomputers (III)
4407#The SA-V organized data base—a relational approach
4408#Trees and hills: methodology for maximizing functions of systems of linear relations
4409#Algorithms and complexity
4410#Dr. Dobb's toolbook of C
4411#During recent years there has been strong interest in a certain source coding problem, which some authors call the "problem of multiple descriptions." Old and new wringing techniques enable us to establish a single-letter characterization of the rate-distortion region in the case of no excess rate for the joint description.
4412#The problem is considered of encoding a discrete memoryless source when correlated side information may or may not be available to the decoder. It is assumed that the side information is not available to the encoder. The rate-distortion functionR (D_{l}, D_{2})is determined whereD_{1}is the distortion achieved with side information andD_{2}is the distortion achieved without it. A generalization is made to the case ofmdecoders, each of which is privy to its own side information. An appropriately definedD-admissible rate for this general case is shown to equalR(D)when the side information sources satisfy a specified degradedness condition. Explicit results are obtained in the quadratic Gaussian case and in the binary Hamming case.
4413#Let(X_{i}, Y_{i}), i= 1,2 cdots, be a sequence of independent, identically distributed bivariate random variables and consider the following communication situation. TheXcomponent of the process is observed at some location, sayA, while theYcomponent is observed at a different location, sayB. TheX(Y)component of the process has to be reproduced at locationB(A). It is desired to find the amount of information that should be exchanged between the two locations, so that the distortions incurred will not exceed some predetermined tolerance. A "single-letter characterization" of a certain region{cal****}^{K} subset {cal R}^{4}of rates and distortions is given. This region contains (all, and only) the achievable rates and distortions for the special case where block coding is used and the information is conveyed through a one-way link that can switch direction onlyKtimes per block.
4414#A random coding bound for the multiple-access channel (MAC) is given, and it is shown to be obtainable universally for all MAC's with common input and output alphabets. For channels for which the random coding bound may be achieved by codes consisting of codewords of a single type for each sender, this bound is also achievable by codes produced by permutations.
4415#A strengthened version of Shannon's entropy power inequality for the case where one of the random vectors involved is Gaussian is proved. In particular it is shown that if independent Gaussian noise is added to an arbitrary, multivariate random variable, the entropy power of the resulting random variable is a concave function of the variance (power) of the added noise. The strengthened inequality is shown to hold for the class of stable distributions.
4416#A new tree code is introduced for discrete-time stationary Gaussian sources with hounded, integrable power spectra and the squared-error distortion measure. The codewords in the tree are reconstructions of Karhunen-Loève transforms of the source words. The branching factor and the number of code letters per branch may vary with level in the tree. A theorem that guarantees the existence of an optimal code for any code rate using such a tree is proved. The proof uses the random coding argument in conjunction with a theorem on survival of a branching process with random environment. A suboptimal but computationally affordable realization of the theorem's coding technique was used for encoding simulations for six autoregressive sources at rates of1.0, 0.50, 0.25, and0.10bits per source symbol. The average distortion results were generally within1dB of the distortion-rate bound but varied widely depending on the source and rate. The results were compared with those for transform quantization simulations for the same sources and rates. The tree code always performed better but only by an average of0.44dB all sources and rates. Longer source blocks and more intensive search would certainly improve the performance of the tree codes, but at the expense of extra computation and storage.
4417#Binary primitive BCH codes form a large class of powerful error-correcting codes. The weight distributions of primitive BCH codes are unknown except for some special classes, such as the single, double, triple error-correcting codes and some very low-rate primitive BCH codes. However, asymptotic results for the weight distribution of a large subclass of primitive BCH codes have been derived by Sidel'nikov. These results provide some insight into the weight structure of primitive BCH codes. Sidel'nikov's approach is improved and applied to the weight distribution of any binary linear block code. Then Sidel'nikov's results on the weight distributions of binary primitive BCH codes are improved and it is shown that the weights of a binary primitive code have approximate binomial distribution.
4418#There are a number of communications problems involving two-dimensional arrays with constrained correlation functions. Golomb's two classes of radar arrays and sonar arrays are examined. Improved bounds, optimal cases, and computational procedures are reported.
4419#It is shown that a linear two-dimensional cyclic code of lengthnNcan be factorized into a direct sum of concatenated codes, with cyclic inner and outer codes and, conversely, thai a two-dimensional cyclic code can be constructed in this way. This result is extended, and it appears that the Abelian codes are obtainable by taking a direct sum of several concatenations of cyclic codes. Codes are constructed that are better than any previously known. In particular, low-rate cyclic codes superior to the duals of high-rate BCH codes are constructed.
4420#When an error occurs in the encoded bit stream produced by a variable length code, the decoder may lose synchronization. A state model for synchronization recovery is developed, and a method for determining the expected span of source symbols lost is presented. The performance of various codes with respect to error recovery is discussed. Two examples are given where equivalent optimal codes have a marked difference in their error recovery characteristics. Some open problems are indicated.
4421#The problem of minimax robust coding for classes of channels with uncertainty in their statistical description is addressed. Specific consideration is given to: 1) discrete memoryless channels with uncertainty in the probability transition matrices; 2) discrete-time stationary Gaussian channels with spectral uncertainty; and to uncertainty with classes determined by 2-alternating Choquet capacities. Both block codes and convolutional codes are considered. A robust maximum-likelihood decoding rule is derived; the rule guarantees that, for all channels in the uncertainty class and all rates smaller than a critical rate, the average probability of decoding error for the ensemble of random block codes and the ensemble of random time-varying convolutional codes converges to zero exponentially with increasing block length or constraint length, respectively. The channel capacity and cut-off rate of the class are then evaluated.
4422#Robust matched filtering is considered for multiple-input systems, with problems formulated in both frequency and time domains being given specific treatment. Robust solutions are found for bounded classes containing well-defined but not exactly specified input characteristics. Several properties for some special cases of interest are examined, and an example is given to illustrate the usefulness of the results. Finally, the results are applied to a narrowband spatial array system, for which the robust scheme has an interesting and useful characteristic.
4423#Robust detection of a signal is considered for the case of independent and identically distributed observations. Following an asymptotic but nonlocal approach, the exponential rates of decrease of the error probabilities are considered as measure of performance. Under this measure a robust detection structure for the symmetric density case is derived. This detection structure is a generalization of an existing result for the local case and is reduced to it when the signal magnitude tends to zero.
4424#It is shown that the family ofq-ary generalized Reed-Solomon codes is identical to the family ofq-ary linear codes generated by matrices of the form[I|A], whereIis the identity matrix, andAis a generalized Cauchy matrix. Using Cauchy matrices, a construction is shown of maximal triangular arrays over GF(q), which are constant along diagonals in a Hankel matrix fashion, and with the property that every square subarray is a nonsingular matrix. By taking rectangular subarrays of the described triangles, it is possible to construct generator matrices[I|A]of maximum distance separable codes, whereAis a Hankel matrix. The parameters of the codes are(n,k,d), for1 leq n leq q+ 1, 1 leq k leq n, andd=n-k+1.
4425#An error is corrected in an expression, for misclassification probability with dichotomous (binary) random variables, and the perils of dichotomous feature extraction are exhibited.
4426#The estimation of the parameters of a sinusoid from observations of signal samples corrupted by additive noise is investigated. At high signal-to-noise ratios the additive noise is viewed as an equivalent phase noise, suggesting frequency and phase estimation by linear regression on the signal phase. The variances of the regression estimates are shown to achieve the Cramer-Rao bounds. A formula for the variance of the regression frequency estimator is derived in terms of the noise power spectrum. A simple formula for the variance with1/f^{2}phase noise is presented.
4427#The problem of finding a detector nonlinearity that maximizes the efficacy (or asymptotic processing gain) over a class of suboptimal nonlinearities is considered. It is shown that this efficacy maximization problem is essentially the same as the problem of finding the minimum-mean-square-error approximation to the locally optimal detector nonlinearity. This result is compared with some intuitive ideas about suboptimal detection.
4428#A discrete-time system described by a truncated Volterra series whose input is a Markov chain is considered. A general explicit formula is derived for the mean value of the output process in terms of the transition-probability matrix of the input and of the Volterra kernels.
4429#First Page of the Article
4430#Monte Carlo methods. Vol. 1: basics
4431#Data communications fundamentals
4432#Elementary numerical analysis
4433#Algorithms for drawing anti-aliased circles and ellipses
4434#Applying temporal constraints to the dynamic stereo problem
4435#Invariant surface characteristics for 3D object recognition in range images
4436#Geometrical transformations on pictures represented by leafcodes
4437#Visual hyperacuity: representation and computation of high precision position information
4438#A note on the gradient of a multi-image
4439#Introduction to finite fields and their applications
4440#Note on weighings carried out on the NBS-2 balance
4441#Thermodynamics of solution of SO2(g) in water and of aqueous sulfur dioxide
4442#SRM 1970: Succinonitrile triple-point standard—A temperature reference standard
4443#Performance assessment of automatic speech recognizers
4444#Jack Youden
4445#Adaptive Kalman filtering
4446#The limitations of models and measurements as revealed through chemometric intercomparison
4447#Statistical properties of a procedure for analyzing pulse voltametric data
4448#Fitting first order kinetic models quickly and easily
4449#The use of Kalman filtering and correlation techniques in analytical calibration
4450#Intelligent instrumentation
4451#The regression analysis of collinear data
4452#Optimization
4453#Strategies for the reduction and interpretation of multicomponent spectral data
4454#Some new ideas in the analysis of screening designs
4455#Polymers and random walks—Renormalization group description and comparison wit
4456#Fourier representations of pdf's arising in crystallography
4457#Aggregated Markov processes and channel gating kinetics
4458#Automated pattern recognition—Self-generating expert systems for the future
4459#Regression analysis of compartmental models
4460#Measurement and control of information content in electrochemical experiments
4461#Pattern recognition studies of complex chromatographic data sets
4462#On discontinuous finite element approximation for the solution of Tricomi's problem
4463#Numerical solution of the reaction-diffusion equation
4464#The iterative accelerative method of finite element approximation for the system
4465#A class of nonlinear methods for ordinary differential equations
4466#A-stable and L-stable block implicit one-step methods
4467#The high order exponentially fitted nonequidistant extrapolation methods for sti
4468#Eigenvalues and eigenvectors of a matrix dependent on several parameters
4469#A new uniformly convergent iterative method by interpolation, where error decrea
4470#Multigrid and MGRUνe methods for diffusion equations
4471#Selecting authoring systems
4472#Computer analysis of students' procedural “bugs” in an arithmetic domain
4473#Student evaluation of motivational and learning attributes of microcomputer soft
4474#Computer-presented organizational/memory aids as instruction for solving Pico-fo
4475#Instruction intrusiveness in dynamic simulation training
4476#Where is the authoring in authoring systems?
4477#Placement of questions and highlights as a variable influencing the effectiveness
4478#A computer simulation to evaluate construction quality of ready-to-wear garments
4479#Recognition of computer-generated pictures on monochrome monitors
4480#Competency-based vs. linear computer instruction of music fundamentals
4481#Effects of attitude and task complexity on microcomputer text-editing
4482#Information transfer as technical assistance for development
4483#International cooperation in information systems and services
4484#National and international information policy
4485#An overview of social measures of information
4486#Information technology and the third world
4487#Access to primary and secondary literature from peripheral or less developed cou
4488#Issues in information science education in developing countries
4489#Advanced feedback methods in information retrieval
4490#Ethics of knowing
4491#Socioeconomic conditions related to information activity in less developed count
4492#Private acts and public objects: An investigation of citer motives
4493#Electronic publishing: The predicament of occasional users in the editorial proc
4494#An investigation of online searcher traits and their relationship to search outcomes
4495#The Dillon Hypothesis of Titular Colonicity: An empirical test from the ecologic
4496#Informatics and small computers in Latin America
4497#A note about information science research
4498#Prolegomenon to `intelligent' thesaurus software
4499#Digital communication of voice: development of Integrated Systems Digital Network
4500#Emerging communications technology paradigms
4501#Uncertainty models in information and database systems
4502#The Library of Congress non-print optical disk pilot program
4503#Microcomputer-based faculty profile
4504#The online catalogue at the University of Illinois at Urbana-Champaign: A history
4505#Linking LCS and FBR: The library's perspective
4506#Linking LCS and FBR: Technical perspective
4507#Authority records and authority work in the online catalogue
4508#Maintenance of an online catalogue
4509#The effect of the online catalogue on reference: Uses, services, and personnel
4510#Microcomputer-based user interface
4511#Automated periodical reference service
4512#Using a text-processing language for serial record conversion
4513#Networking priorities for standards development
4514#Fifth generation and VLSI architectures
4515#Trends of VLSI in Japan
4516#Military applications of expert systems
4517#Educom Review
4518#Looking into education's high-tech future
4519#Education for citizenship in the information society
4520#Evolution of the concept of computer literacy
4521#New perspectives in decision support for port planning
4522#A decision support system for the planning of the workload on the grain terminal
4523#A new class of intelligent knowledge-based systems with an optimisation-based in
4524#Inference of the structure of economic reasoning from natural language analysis
4525#High parallelism and a proof procedure. I: Theoretical considerations
4526#A general purpose computer aid to judgemental forecasting: Rationale and procedure
4527#Semantic interpretation of a database query language
4528#A relational language with deductions, functions, and recursions
4529#The design of entity-relationship models for general ledger systems
4530#How well does a vanilla loop fit into a frame?
4531#Locating an n-server facility in a stochastic environment
4532#On revenue equalization of deduction versus flat income tax systems
4533#An assessment of some criticisms of goal programming
4534#Interfacing or models and information systems: A systematic approach
4535#Stochastic network evacuation models
4536#MRP lot sizing with multiple purchase discounts
4537#A simplified interactive multiple objective linear programming procedure
4538#Layout of facilities with some fixed points
4539#Micro-based CAD: A production tool for manufacturing engineering
4540#A survey of electronic R and D in the USA
4541#An edge-face relational scheme for boundary representations
4542#Better understanding through formal specification
4543#GKS programming in a PHIGS environment
4544#An interpolant with tension defined over triangles
4545#Arbitrary area filling in a fast procedure
4546#Moving picture synthesis at Linkoping Univ.
4547#Manufacturing models of biomedical objects via CAD/CAM and GKS
4548#Report of the Timberline meeting of ISO TC97/SC21/WG2 `Computer Graphics”
4549#Graphics language bindings
4550#EUROGRAPHICS '85—A personal view
4551#Polygonal clipping of polylines
4552#Fractional matchings and covers in infinite hypergraphs
4553#On submodular function minimization
4554#How many atoms can be defined by boxes?
4555#Counting points in hypercubes and convolution measure algebras
4556#Inclusion-exclusion inequalities
4557#Note to a problem of T. Gallai and G.A. Dirac
4558#Maximum set of edges no two covered by a clique
4559#A Desarguesian theorem for algebraic combinatorial geometries
4560#On a problem of Spencer
4561#A strongly polynomial minimum cost circulation algorithm
4562#A shellable poset that is not lexicographically shellable
4563#Independent sets in k-chromatic graphs
4564#Information science and the PSI phenomenon
4565#The macro-literalization of the artificial intelligence metaphor
4566#Teaching microcomputer applications in the library
4567#The evolving information center
4568#How information centers fail
4569#Human factors for design and evaluation of software
4570#Perception and acceptance of a local area network and electronic mail
4571#Language representation and misrepresentation
4572#Artificial intelligence reaches out
4573#Artificial intelligence—balancing euphoria with reality
4574#Negation and control in Prolog
4575#Microcomputers in management and economics education
4576#Co-ordinate transformation and robot control with Denavit-Hartenberg matrices
4577#Multitask coronary care unit—a distributed processing approach
4578#Microtechnology and user friendly systems—the CONNECT dialogue executor
4579#The CONNECT dialogue executor and its use of interprocess communication in concurrent CP/M 86
4580#A serial interface for process control
4581#Informatics and community services: Reports presented at Inforav's annual meeting (Rome, May 31, 1985)
4582#Informatics technology and quality of the services made available to the community
4583#Municipal services for its community members
4584#Municipal companies and public services
4585#Combinatorics: set systems, hypergraphs, families of vectors, and combinatorial probability
4586#The AutoCAD productivity book: tapping the hidden power of AutoCAD
4587#New telecommunications and telematics services in Italy: state of the art
4588#A new telephone usership
4589#Information and documentation for research and study
4590#Computational numerical methods
4591#Meeting the drivers' new needs
4592#Banking services and the community
4593#New transport services
4594#Statistical information for the individual
4595#The profile-query relationship
4596#This survey reviews some of the important accomplishments in computer algebra since 1966 and indicates some directions for future research and development.
4597#FINGER is a LISP-based system to derive formulas needed in finite element analysis, and to generate FORTRAN code from these formulas. The generated programs can be used with existing, FORTRAN-based finite element analysis packages. This approach aims to replace tedious hand computations that are time consuming and error prone. The design and implementation of FINGER are presented. Techniques for generating efficient code are discussed. These include automatic intermediate expression labelling, interleaving formula derivation with code generation, exploiting symmetry through generated functions and subroutines. Current capabilities include generation of material matrices, strain-displacement matrices and stiffness matrices. FINGER contains a package, called GENTRAN, that translates symbolic formulas into FORTRAN. GENTRAN can generate functions, subroutines and entire programs. Thus, it is also of interest as a general-purpose FORTRAN code generator, Aside from the finite element application, the techniques developed and employed are useful for automatic code generation in general.
4598#Two results about the Euclidean algorithm (EA) for Gaussian integers are proven in this paper: first, a general kind of division with remainder for Gaussian integers @x, @h is considered: @x = @c@h + @r, where we only require that @c is a Gaussian integer; N(@r), the norm of @r, need not be minimal or smaller than N(@h). This leads to a general version of the (EA), where an arbitrary remainder in this sense may be chosen at every division. We show that for every input the number of divisions is minimal, if a remainder of minimal norm is chosen at every step. We call such a version a minimal remainder-version of (EA). We also show that even the slightest deviation from a minimal remainder-version (in a sense to be defined) can lead to an increase in the number of divisions. Second, we establish a tight upper bound for the number of divisions of (EA) for an input of given size, and, equivalently, we determine the input values u, v with norm of u minimal, such that (EA) requires a given number of divisions. This is analogous to Lame's result for rational integers.
4599#Most resolution theorem provers convert a theorem into clause form before attempting to find a proof. The conventional translation of a first-order formula into clause form often obscures the structure of the formula, and may increase the length of the formula by an exponential amount in the worst case. We present a non-standard clause form translation that preserves more of the structure of the formula than the conventional translation. This new translation also avoids the exponential increase in size which may occur with the standard translation. We show how this idea may be combined with the idea of replacing predicates by their definitions before converting to clause form. We give a method of lock resolution which is appropriate for the non-standard clause form translation, and which has yielded a spectacular reduction in search space and time for one example. These techniques should increase the attractiveness of resolution theorem provers for program verification applications, since the theorems that arise in program verification are often simple but tedious for humans to prove.
4600#Let L(y) = b be a linear differential equation with coefficients in a differential field k, of characteristic 0, We show that if L(y) = b has a non-zero solution Liouvillian over k, then either L(y) = 0 has a non-zero solution u such that u'/u is algebraic over k, or L(y) = b has a solution in k. If L(y) = b has a non-zero solution elementary over k, then either L(y) = 0 has a non-zero solution algebraic over k, or L(y) = b has a solution in k. This latter fact is a consequence of the fact that if L(y) = b has a solution elementary over k, then it has a solution of the form P(log u"1,..., log u"m), where P is a polynomial with coefficients algebraic over k whose degree is at most equal to the order of L(y), and the u; are algebraic over k. Algorithmic considerations are also discussed.
4601#Visual terminals and user interfaces
4602#Data reduction of picture signals—review on the studies in Japan
4603#An overview of NTTs digital transmission networks—existing and planned
4604#Robot vision
4605#Medical image processing—an overview of and case study in the diagnosis of cardiac diseases
4606#AFCET—Informatique '85
4607#Predicative methodology
4608#A logic for the specification and proof of regular controllable processes of CCS
4609#Generating binary trees of bounded height
4610#Maximum entropy and the G/G/1/N queue
4611#Deterministic grammars and grammar morphisms
4612#On the equivalence of some transductions involving letter to letter morphisms on regular languages
4613#Synchronizable deterministic pushdown automata and the decidability of their equivalence
4614#Program evolution: processes of software change
4615#Robot hands and the mechanics of manipulation
4616#The corporate software guide; 5th ed.
4617#INTERLISP: the language and its usage
4618#A method is presented for permitting record updates by long-lived transactions without forbidding simultaneous access by other users to records modified. Earlier methods presented separately by Gawlick and Reuter are comparable but concentrate on “hot-spot” situations, where even short transactions cannot lock frequently accessed fields without causing bottlenecks. The Escrow Method offered here is designed to support nonblocking record updates by transactions that are “long lived” and thus require long periods to complete. Recoverability of intermediate results prior to commit thus becomes a design goal, so that updates as of a given time can be guaranteed against memory or media failure while still retaining the prerogative to abort. This guarantee basically completes phase one of a two-phase commit, and several advantages result: (1) As with Gawlick's and Reuter's methods, high-concurrency items in the database will not act as a bottleneck; (2) transaction commit of different updates can be performed asynchronously, allowing natural distributed transactions; indeed, distributed transactions in the presence of delayed messages or occasional line disconnection become feasible in a way that we argue will tie up minimal resources for the purpose intended; and (3) it becomes natural to allow for human interaction in the middle of a transaction without loss of concurrent access or any special difficulty for the application programmer. The Escrow Method, like Gawlick's Fast Path and Reuter's Method, requires the database system to be an “expert” about the type of transactional updates performed, most commonly updates involving incremental changes to aggregate quantities. However, the Escrow Method is extendable to other types of updates.
4619#This paper deals with the transaction management aspects of the R* distributed database system. It concentrates primarily on the description of the R* commit protocols, Presumed Abort (PA) and Presumed Commit (PC). PA and PC are extensions of the well-known, two-phase (2P) commit protocol. PA is optimized for read-only transactions and a class of multisite update transactions, and PC is optimized for other classes of multisite update transactions. The optimizations result in reduced intersite message traffic and log writes, and, consequently, a better response time. The paper also discusses R*'s approach toward distributed deadlock detection and resolution.
4620#Plastic design of steel portal frames using a microcomputer
4621#On a unified computer program for influence function methods in elasticity
4622#Computer aided analysis and optimisation of steam power cycles
4623#Data analysis via generalised continuous parabolic interpolation
4624#An automatic system for data logging and verification of multi-channel, multi-size geophysical data
4625#VAX FORTRAN to FORTRAN 77 translator
4626#A survey of database management in engineering
4627#Thinking and Turing's test
4628#The Manchester dataflow machine
4629#Second generation expert systems
4630#Knowledge bases
4631#Knowledge engineering and CAD
4632#Artificial intelligence in simulation—conference report
4633#Throughput of a satellite channel communication
4634#Analysis of tree algorithms for the simulation event list
4635#Thrifty execution of task pipelines
4636#Strongest invariant functions: their use in the systematic analysis of while statements
4637#General correctness: a unification of partial and total correctness
4638#Purely top-down updating algorithms for stratified search trees
4639#Performance bounds for binary testing with arbitrary weights
4640#Ramsey numbers and an approximation algorithm for the vertex cover problem
4641#BCS computer challenge
4642#The changing face of vocational education in computing
4643#Qualifying for the future
4644#Where should the BCS stand?
4645#Standards and a network service for data exchange
4646#The Starts initiative
4647#NMW computers
4648#The complexity of hashing with lazy deletion
4649#Shortest paths in Euclidean graphs
4650#Visibility of disjoint polygons
4651#Edge-skeletons in arrangements with applications
4652#The pairing heap: a new form of self-adjusting heap
4653#A technical overview of the Information Resource Directory System
4654#ANSI conference on high technology
4655#ANSI's accomplishments and goals
4656#Electromagnetic radiation from video display units: an eavesdropping risk?
4657#Computer crime—risk management and computer security
4658#Design of public key cryptosystems using idempotent elements
4659#Signature verification using holistic measures
4660#Data sharing and access protection in Business System 12
4661#Security mechanisms in a transport layer protocol
4662#Systems security
4663#In this paper, we look at the issue of accurate estimation of the three-dimensional motion parameters of a rigid body from a sequence of synthetic images, and relate the effect of some parameters to the shape of an error function. We first consider the case where only a small set of corresponding points is identified and suggest that a technique called regularization improves the quality and stability of a solution. We then observe that, if more pairs of corresponding points are available, the error function becomes smooth and the solution stable. Finally, we try to improve the quality of estimation by considering more than two consecutive frames for a moving camera looking at a stationary scene, and summing the error functions obtained for any two consecutive frames. Surprisingly enough, this technique does not improve stability unless we use regularization again.
4664#This paper presents a new model-based approach for texture classification which is rotation invariant, i.e., the recognition accuracy is not affected if the orientation of the test texture is different from the orientation of the training samples. The method uses three statistical features, two of which are obtained from a new parametric model of the image called a ``circular symmetric autoregressive model.'' Two of the proposed features have physical interpretation in terms of the roughness and directionality of the texture. The results of several classification experiments on differently oriented samples of natural textures including both microtextures and macrotextures are presented.
4665#A maximum likelihood approach is developed for a pattern recognition problem where the patterns are described by configurations of simple easily recognized parts called primitives. The approach is capable of dealing with three types of noise: measurement noise in the location and shape of observed primitives, undetected or missing primitives (leakage), and the unexpected appearance of extra primitives (false alarms). The approach is called combinatorial because the likelihood function dictates that observed primitives must be assigned to known primitives in all possible combinations. Due to the complexity of the likelihood function, practical classifiers must be based on likelihood function approximations. Several are proposed, and most of these are simple enough to be used in a gradient search strategy for recognizing distorted patterns with random orientations. Examples are included to show the characteristics of combinatorial classifier performance.
4666#Inference of Markov networks from finite sets of sample strings is formulated using dynamic programming. Strings are installed in a network sequentially via optimal string-to-network alignments computed with a dynamic programming matrix, the cost function of which uses relative frequency estimates of transition probabilities to emphasize landmark substrings common to the sample set. Properties of an inferred network are described and the method is illustrated with artificial data and with data representing banded human chromosomes.
4667#This paper considers the problem of stopping rules, in the context of sequential Bayesian classification. In particular a new criterion, based on the probability of reversal of the obtained classification, is introduced and compared to more commonly used strategies. The results show good behavior of the proposed technique, with both simulated and real data drawn from biomedical application. In fact it appears that this stopping rule reduces the misallocation error rate with the same mean number of used features, or conversely, with an equal level of misallocation error rate, it reduces the mean number of features necessary to attain it.
4668#A shape smoothing algorithm is presented which uses properties of the medial axis to define segments of the shape border and their prominence relative to the local radius of the shape. Prominence values are used to classify axes as either major or minor, and minor axes are then deleted. An augmented medial axis transform is also defined using an approximate Euclidean distance transform, and medial axis interpolation and linking.
4669#In [1], the converging squares algorithm was introduced as a method designed to effectively and efficiently locate peaks in data of two dimensions or higher. In this correspondence, the performance of the algorithm on a signal in noise is examined, and some extensions of the algorithm-beyond peak-picking-are introduced. The minimum-area enclosing square is one extension, which locates an image region in a uniform background, and finds the smallest square which entirely encloses it. The maximum-difference enclosing square is another extension by which a global feature of the image is found which separates it into a foreground square region and background region, based on the maximum statistical difference between the two. Some applications of these extensions are shown, including object location, tracking of a moving object, and adaptive binarization.
4670#This correspondence describes a new stereo analysis method using three views, in which correspondence is established among three images taken from triangularly configured viewpoints. Each match-point candidate obtained by the initial matching between the first and second images is easily examined independently of the other candidates using the third image. The correspondence determination is simple, fast, and reliable. Additionally, this analysis method allows occlusion to be dealt with explicitly. The effectiveness of the three-view stereo-analysis method is demonstrated by simulation and real object experiments. Ambiguous matches are sufficiently avoided for polyhedra. Position errors are less than 2.5 mm (about 0.4 percent) with camera-object spacing of 630 mm.
4671#Geometric objects such as polygons, line segments, and points may have manifold relations among each other, i.e., order, adjacency, connectivity, etc., and may be stored in a database. For the design of the spatial data structure and in order to preserve consistency when manipulating the data, we propose a graph grammar approach. All consistent states are described by a structure graph, and the manipulation rules are given by productions where intersection problems as well as topologic properties have to be solved. By appropriately modeling the behavior of geographic data, consistency is preserved at all times. This eliminates the tedious case of recovering a geographic database after an inconsistency has been detected.
4672#Intellectual assembly lines: the rationalization of managerial, professional, and technical work
4673#The electronic bulletin board: a computer-driven mass medium
4674#The computer-assisted literature review
4675#An introduction to data types
4676#Online information retrieval: concepts, principles, and techniques
4677#Dictionary of artificial intelligence & robotics
4678#Artificial intelligence: an applications-oriented approach
4679#Computer-aided drafting and design for IBM personal computers
4680#Computer security handbook: strategies and techniques for preventing data loss or theft
4681#Micromanual for casual users of National Library of Medicine databases
4682#Computability theory, semantics, and logic programming
4683#The hot-set model, characterizing the buffer requirements of relational queries, is presented. This model allows the system to determine the optimal buffer space to be allocated to a query; it can also be used by the query optimizer to derive efficient execution plans accounting for the available buffer space, and by a query scheduler to prevent thrashing. The hot-set model is compared with the working-set model. A simulation study is presented.
4684#Automotive computer control: emission and tune-up
4685#Computer software: contracting for development and distribution
4686#Computer analysis of structures: matrix structural analysis structured programming
4687#Fourth and fifth generation programming languages; Vol. 2: which UNIX? AT&T, IBM and other standard bearers
4688#Digital electronics: theory and experimentation
4689#Computing parent nodes in threaded binary trees
4690#A new approach to the restoration of an image blurred by a linear uniform motion
4691#Two dimensional object recognition using multiresolution models
4692#Hierarchical matching using relaxation
4693#Low cost local area networks
4694#Programming with sets; an introduction to SETL
4695#The research into time and data models has so far focused on the identification of extensions to the classical relational model that would provide it with “adequate” semantic capacity to deal with time. The temporally oriented data model (TODM) presented in this paper is a result of a different approach, namely, it directly operationalizes the pervasive three-dimensional metaphor for time. One of the main results is thus the development of the notion of the data cube: a three-dimensional and inherently temporal data construct where time, objects, and attributes are the primary dimensions of stored data. TODM's cube adds historical depth to the tabular notions of data and provides a framework for storing and retrieving data within their temporal context. The basic operations in the model allow the formation of new cubic views from existing ones, or viewing data as one moves up and down in time within cubes.This paper introduces TODM, a consistent set of temporally oriented data constructs, operations, and constraints, and then presents TOSQL, a corresponding end-user's SQL-like query syntax. The model is a restricted but consistent superset of the relational model, and the query syntax incorporates temporal notions in a manner that likewise avoids penalizing users who are interested solely in the current view of data (rather than in a temporal perspective). The naturalness of the spatial reference to time and the added semantic capacity of TODM come with a price—the definitions of the cubic constructs and basic operations are relatively cumbersome. As rudimentary as it is, TODM nonetheless provides a comprehensive basis for formulating an external data model for a temporally oriented database.
4696#A new solution to the mutual exclusion problem is presented that, in the absence of contention, requires only seven memory accesses. It assumes atomic reads and atomic writes to shared registers.
4697#A uniform I/O interface allows programs to be written relatively independently of specific I/O services and yet work with a wide variety of the I/O services available in a distributed environment. Ideally, the interface provides this uniform access without excessive complexity in the interface or loss of performance. However, a uniform interface does not arise from careful design of individual system interfaces alone; it requires explicit definition.In this paper, the UIO (uniform I/O) system interface that has been used for the past five years in the V distributed operating system is described, with the focus on the key design issues. This interface provides several extensions beyond the I/O interface of UNIX™, including support for record I/O, locking, atomic transactions, and replication, as well as attributes that indicate whether optional semantics and operations are available. Experience in using and implementing this interface with a variety of different I/O services is described, along with the performance of both local and network I/O. It is concluded that the UIO interface provides a uniform I/O system interface with significant functionality, wide applicability, and no significant performance penalty.
4698#Programming languages for industrial robots
4699#A new General Electric Automation Centre in Frankfurt will serve the European market for industrial automation
4700#Project management software
4701#Ships by computer
4702#Energy regulatory board purchases million dollar mapping system
4703#Apollo network for computer integrated manufacturing—:9P200,000 order from NEIParsons
4704#Intelligence: the eye, the brain, and the computer
4705#Data structures and program design (2nd ed.)
4706#Turnkey design capability announced by AMI and Mentor Graphics Corporation
4707#Auto-trol Technology announces new HVAC software package for industrial and commercial building design
4708#The economics of UNIX workstations
4709#A new renaissance
4710#Silicon Graphics introduced IRIS Series 2000 workstations to U.K. market
4711#Computing the visibility polygon from an edge
4712#Space-economical plane-sweep algorithms
4713#Computation of geometric properties from the medial axis transform in O (n log n) time
4714#Computerized manufacturing resource planning
4715#Stochastic modelling and analysis: a computational approach
4716#ALLC Journal
4717#A computer-aided system for printing variable text-blocks on crowded maps
4718#Methodological aspects in automatically discovering genealogical dependencies am
4719#Some graph theoretic models in literary and linguistic research
4720#The development and progress of machine translation systems
4721#The analysis of verbally elicited material
4722#ALLC Bulletin
4723#Scenic dominance, motif and conflict in the topological structures of the new co
4724#A new approach to stylometry
4725#An automation of Jackson's structured programming
4726#UCL: a user-friendly conceptual language
4727#Use of superimposed code words for partial match data retrieval
4728#Natural neighbour sorting
4729#Charles Hamblin (1922-1985)
4730#Numerical databases: their vital role in information science
4731#Accreditation for information science: has the time finally come?
4732#Rural information services in North America-and the world
4733#Language Processing
4734#Information science and transparent systems
4735#Numerical databases: their vital role in information science
4736#Accreditation and information science
4737#Natural language processors
4738#Protocols in perspective
4739#The moving target: future trends in networking
4740#Reflections on telecommunications issues
4741#Will there be a European videotex standard?
4742#A new computer-based self-correcting calibration system for computer storage media
4743#Anticipating the ISO file transfer standards in an open systems implementation
4744#Workshop on European information technology standardization and certification po
4745#Procedures, structures and means for IT-standardization
4746#The role of CEN/CENELEC in the verification and the certification of conformity
4747#10 theses for user's requests, actions and questions
4748#Soviet sting sours
4749#Befriending the befuddled
4750#PC software integration
4751#Caught in the act
4752#Showtime in Chicago
4753#Computer law
4754#Managing data-driven development
4755#Let George do it
4756#Support your local software
4757#Crazy about CAD/CAM
4758#Negotiation software contracts
4759#Managing a multivendor shop
4760#Europe's users talk back
4761#In praise of 4GLS
4762#The downside of 4GLS
4763#INMAGIC: the flexible information management package
4764#Selection of The CLANN circulation/OPAC system
4765#Implementation of the Geac circulation system within the CLANN network
4766#OSI-the open system interface or "The building block of the 80's"
4767#Acquisitions systems and the book trade
4768#DP goes suburban
4769#Exploring the OLTP realm
4770#Tools for developing OLTP applications
4771#Information politics
4772#Power and credibility in office automation
4773#Getting straight again
4774#Empowering programmers
4775#Lesson one: durable, doable databases
4776#The system understands
4777#A PC policy primer
4778#The DP psyche
4779#IBM's PC paces the pack
4780#On thin ice:micros and data integrity
4781#PC security: so what's new?
4782#A banking software story
4783#The technology of data intergration
4784#Project evaluation made simple
4785#Headless and optional arrows
4786#Shucking Dp
4787#The state of CIM
4788#The importance of good relations
4789#Enterprise analysis
4790#Blue skies ahead
4791#Software quality measurement
4792#Applied Ada
4793#Microprocessor interfacing and communication using the Intel SDK-85
4794#Is man a robot?
4795#Digital system design
4796#Reconstructing visible regions from visible segments
4797#A database design methodology is defined for the design of large relational databases. First, the data requirements are conceptualized using an extended entity-relationship model, with the extensions being additional semantics such as ternary relationships, optional relationships, and the generalization abstraction. The extended entity-relationship model is then decomposed according to a set of basic entity-relationship constructs, and these are transformed into candidate relations. A set of basic transformations has been developed for the three types of relations: entity relations, extended entity relations, and relationship relations. Candidate relations are further analyzed and modified to attain the highest degree of normalization desired.The methodology produces database designs that are not only accurate representations of reality, but flexible enough to accommodate future processing requirements. It also reduces the number of data dependencies that must be analyzed, using the extended ER model conceptualization, and maintains data integrity through normalization. This approach can be implemented manually or in a simple software package as long as a "good" solution is acceptable and absolute optimality is not required.
4798#Office automation impact has received considerable attention in the literature recently. Unfortunately, that which has appeared is diverse and contradictory. The relevant literature is reviewed, summarized, and placed in a framework containing three positions on office automation impact: optimism, pessimism, and relativism. The basic assumptions and empirical support for each position are noted and analyzed. It is proposed that these positions are based on a number of a priori views which guide the reporting and beliefs about technological impact.
4799#In a large integrated database, there often exists an “information hierarchy,” where both raw data and derived data are stored and used together. Therefore, among update transactions, there will often be some that perform only read accesses from a certain (i.e., the “raw” data) portion of the database and write into another (i.e., the “derived” data) portion. A conventional concurrency control algorithm would have treated such transactions as regular update transactions and subjected them to the usual protocols for synchronizing update transactions. In this paper such transactions are examined more closely. The purpose is to devise concurrency control methods that allow the computation of derived information to proceed without interfering with the updating of raw data.The first part of the paper presents a proof method for correctness of concurrency control algorithms in a hierarchically decomposed database. The proof method provides a framework for understanding the intricacies in dealing with hierarchically decomposed databases. The second part of the paper is an application of the proof method to show the correctness of a two-phase-locking- based algorithm, called partitioned two-phase locking, for hierarchically decomposed databases. This algorithm is a natural extension to the Version Pool method proposed previously in the literature.
4800#The design and correctness of a communication facility for a distributed computer system are reported on. The facility provides support for fault-tolerant process groups in the form of a family of reliable multicast protocols that can be used in both local- and wide-area networks. These protocols attain high levels of concurrency, while respecting application-specific delivery ordering constraints, and have varying cost and performance that depend on the degree of ordering desired. In particular, a protocol that enforces causal delivery orderings is introduced and shown to be a valuable alternative to conventional asynchronous communication protocols. The facility also ensures that the processes belonging to a fault-tolerant process group will observe consistent orderings of events affecting the group as a whole, including process failures, recoveries, migration, and dynamic changes to group properties like member rankings. A review of several uses for the protocols in the ISIS system, which supports fault-tolerant resilient objects and bulletin boards, illustrates the significant simplification of higher level algorithms made possible by our approach.
4801#Quantitative results in the theory of overconvergence of complex interpolating polynomials
4802#Strongly unique best approximation in Banach spaces
4803#Quadrature and widths
4804#Banach spaces antiproximinial in their biduals
4805#A note on real vs complex best Chebyshev approximation on an interval
4806#Monotone approximation in several variables
4807#Extensions of subgradient projection algorithms
4808#A lower bound on the norm of interpolation with an extended Tchebycheff system
4809#Note on operators of Sza´sz-Mirakyan type
4810#On an open problem of P. Tura´n concerning Birkhoff interpolation based on th
4811#Some results in the theory of interpolation using the Legendre polynomial and its derivative
4812#Average case optimal algorithms in Hilbert spaces
4813#Restricted range approximate solutions of nonlinear differential systems with boundary conditions
4814#Interpolation between sum and intersection of Banach spaces
4815#Best monotone approximations in L1[0,1]
4816#Proceedings of Centre for Software Reliability Workshop on Software: requirements, specification and testing
4817#Specification, verification and testing in software development
4818#An industrial viewpoint
4819#Support for the management process
4820#Adding formality to pragmatism
4821#Software requirements definitions
4822#Tools for “Design by Objectives"
4823#Pragmatic aspects of formal specification
4824#Specifications and programs
4825#Program validation
4826#Testing techniques based on symbolic evaluation
4827#Functional testing
4828#Software verification through statistical testing
4829#Taming the tiger: software engineering and software economics
4830#The world of programming languages
4831#Manager's guide to expert systems using GURU
4832#Introduction to higher order categorical logic
4833#Structured analysis & design of information systems
4834#The C programming language
4835#Files & databases: an introduction
4836#C: An advanced introduction
4837#C programming guide
4838#Design of distributed operating systems: concepts and technology
4839#The C primer (2nd ed.)
4840#Software testing and evaluation
4841#Programming 16-bit machines: the PDP-11, 8086, and M68000
4842#Introduction to data base management in business; 2nd ed.
4843#Software safety issues become important when computers are used to control real-time, safety-critical processes. This survey attempts to explain why there is a problem, what the problem is, and what is known about how to solve it. Since this is a relatively new software research area, emphasis is placed on delineating the outstanding issues and research topics.
4844#A topologically complete set operations algorithm for planar polyhedral Z-manifold objects is described; that is, under the assumption that all numerical tests required can be correctly evaluated, the algorithm is capable of solving all “special cases."The central component of the algorithm is a module here called the vertex neighborhood classifier. By virtue of the classifier, the various special cases can be reduced into a collection of classification problems involving a pair of coincident vertices. The classifier works by means of decision rules that guarantee the topological consistency and regularity of the resulting polyhedron. If the result is not a 2-manifold, a relaxed polyhedron will be produced.
4845#A randomized algorithm that sorts on an N node network with constant valence in O(log N) time is given. More particularly, the algorithm sorts N items on an N-node cube-connected cycles graph, and, for some constant k, for all large enough &agr;, it terminates within k&agr; log N time with probability at least 1 - N-&agr;.
4846#Reaching agreement is a primitive of distributed computing. Whereas this poses no problem in an ideal, failure-free environment, it imposes certain constraints on the capabilities of an actual system: A system is viable only if it permits the existence of consensus protocols tolerant to some number of failures. Fischer et al. have shown that in a completely asynchronous model, even one failure cannot be tolerated. In this paper their work is extended: Several critical system parameters, including various synchrony conditions, are identified and how varying these affects the number of faults that can be tolerated is examined. The proofs expose general heuristic principles that explain why consensus is possible in certain models but not possible in others.
4847#The direct sum of two term rewriting systems is the union of systems having disjoint sets of function symbols. It is shown that if two term rewriting systems both have the Chruch-Rosser property, then the direct sum of these systems also has this property.
4848#The problem of scheduling a set of n jobs on m identical machines so as to minimize the makespan time is perhaps the most well-studied problem in the theory of approximation algorithms for NP-hard optimization problems. In this paper the strongest possible type of result for this problem, a polynomial approximation scheme, is presented. More precisely, for each &egr;, an algorithm that runs in time O((n/&egr;)1/&egr;2) and has relative error at most &egr; is given. In addition, more practical algorithms for &egr; = 1/5 + 2-k and &egr; = 1/6 + 2-k, which have running times O(n(k + log n)) and O(n(km4 + log n)) are presented. The techniques of analysis used in proving these results are extremely simple, especially in comparison with the baroque weighting techniques used previously.The scheme is based on a new approach to constructing approximation algorithms, which is called dual approximation algorithms, where the aim is to find superoptimal, but infeasible, solutions, and the performance is measured by the degree of infeasibility allowed. This notion should find wide applicability in its own right and should be considered for any optimization problem where traditional approximation algorithms have been particularly elusive.
4849#Today's concomitant needs for higher computing power and reliability has increased the relevance of multiple-processor fault-tolerant systems. Multiple functional units improve the raw performance (throughput, response time, etc.) of the system, and, as units fail, the system may continue to function albeit with degraded performance. Such systems and other fault-tolerant systems are not adequately characterized by separate performance and reliability measures. A composite measure for the performance and reliability of a fault-tolerant system observed over a finite mission time is analyzed. A Markov chain model is used for system state-space representation, and transient analysis is performed to obtain closed-form solutions for the density and moments of the composite measure. Only failures that cannot be repaired until the end of the mission are modeled. The time spent in a specific system configuration is assumed to be large enough to permit the use of a hierarchical model and static measures to quantify the performance of the system in individual configurations. For a multiple-processor system, where performance measures are usually associated with and aggregated over many jobs, this is tantamount to assuming that the time to process a job is much smaller than the time between failures. An extension of the results to general acyclic Markov chain models is included.
4850#Megiddo introduced a technique for using a parallel algorithm for one problem to construct an efficient serial algorithm for a second problem. This paper provides a general method that trims a factor of O(log n) time (or more) for many applications of this technique.
4851#The USSR has carried out a large-scale program to bring computer-based information systems, called Automated Enterprise Management Systems (ASUPs), to industrial enterprises. This program illustrates the extent to which computer-based information systems are inextricably embedded in the surrounding social, economic, and political systems.
4852#Inappropriate use of software complexity measures can have large, damaging effects by rewarding poor programming practices and demoralizing good programmers. Software complexity measures must be critically evaluated to determine the ways in which they can best be used.
4853#To achieve program control flow representation that is relatively independent of any given programming language, schematic pseudocode (SPC) uses a perceptual notation system composed of schemata whose syntax rules are described by a grammar. Source code documentation is supported by operational comments, and translation into a target procedural language is fully automatic.
4854#By computing probabilities from the normalization of the F distribution (instead of by numerical integration methods), statistical capabilities in spreadsheet operations can be greatly expanded and enhanced.
4855#A self-assessment procedure dealing with computer organization and logic design
4856#The Committee evaluates ACM as it exists today, and makes recommendations for the future.
4857#A series of three laboratory experiments were conducted to assess the influence of graphical and color-enhanced information presentation modes on decision quality, decision making time, use of information, and user perceptions. The experimental design allowed for the unconfounded study of line graphs and color using a variety of information presentation designs for the same decision making task. Based on the findings of these studies, propositions about the impact of graphics and color on individual decision makers are presented. The influence of presentation mode on human performance and the perceived value of information is related to how well it supports the solution approach to a particular task. The benefits of graphics are limited to reducing decision making time but only when the graphical report has been designed to directly assist in solving the task. Multicolor reports aid in decision making, but only in specific circumstances, that is, their benefits are not pervasive. It appears that color is more advantageous when associated with graphical reports, for certain decision maker types, during learning periods, and in time constrained environments.
4858#Competent expert systems: a case study in fault diagnosis
4859#System simulation programming styles and languages
4860#Robotics: a manager's guide
4861#Once. A test of authorship based on words which are not repeated in the sample
4862#Modal verbs and moral principles: an aspect of Jane Austen's style
4863#Test-score semantics as a basis for a computational approach to the representation of meaning
4864#Text processing in the Leningrad Research Group: `Speech Statistics'—theory, results, outlook
4865#A computational study of Sardinian based upon the proverbs published by Canon Giovanni Spano (1871)
4866#Programs on syntactic lexicometry (an annotated bibliography)
4867#Professional Pascal: essays on the practice of programming
4868#Classification algorithms
4869#Doing the news with Cpus
4870#Whither VM?
4871#Database: what's in store?
4872#Parallel processing: fact or fancy?
4873#Past and future events
4874#The equivalence of the moduli of continuity of the best approximation operator and of strong unicity in L1
4875#Local and global Lipschitz constants
4876#The strong uniqueness theorem for monosplines
4877#Degree raising for splines
4878#Positive convergent approximation operators associated with orthogonal polynomials for weights on the whole real line
4879#Norm oscillatory weight measures
4880#Limits of some q-Laguerre polynomials
4881#Estimates of Christoffel functions of generalized Freud-type weights
4882#Polynomials orthogonal on the semicircle
4883#Orthogonal polynomials with asymptotically periodic recurrence coefficients
4884#On sieved orthogonal polynomials. IV. Generating functions
4885#Gaussian quadrature, weights on the whole real line and even entire functions with nonnegative even order derivatives
4886#Necessary conditions for weighted mean convergence of Fourier series in orthogonal polynomials
4887#Behavior of zeros of polynomials of near best approximation
4888#An extension of strong uniqueness to rational approximation
4889#Convergence of a class of interpolatory splines for holomorphic functions
4890#Reconstructing a function from its values on a subset of its domain—a Hilbert space approach
4891#Discrete semi-classical orthogonal polynomials: generalized Meixner
4892#Estimates of the orthogonal polynomials with weight exp(-xm), m an even positive integer
4893#Two-dimensional fully adaptive solutions of solid-solid alloying reactions
4894#On the stability of mesh equidistribution strategies for time-dependent partial differential equations
4895#Solution of the implicitly discretised fluid flow equations by operator-splitting
4896#The computation of compressible and incompressible recirculating flows by a non-iterative implicit scheme
4897#Front tracking for gas dynamics
4898#A method of local corrections for computing the velocity field due to a distribution of vortex blobs
4899#The vector potential in the numerical solution of three-dimensional fluid dynamics problems in multiply connected regions
4900#An iterative method for simultaneous determination of bulk and shear moduli and density variations
4901#Action-variable theory and classical frequencies
4902#A general collapsing technique for three-dimensional algebraic grid generation
4903#An algorithm for the simulation of transient viscoelastic flows with free surfaces
4904#Conformal-mapping-based coordinate generation method for flows in periodic configurations
4905#Continuous orthonormalization for boundary value problems
4906#Variational methods for generating meshes on surfaces in three dimensions
4907#A finite difference 3-D Poisson-Vlasov algorithm for ions extracted from a plasma
4908#An adaptive method of lines with error control for parabolic equations of the reaction-diffusion type
4909#CONKUB: A conversational path-follower for systems of nonlinear equations
4910#The random choice method applied to two-dimensional shock focusing and diffraction
4911#Numerical calculations using the full MHD equations in toroidal geometry
4912#Quadratic accuracy diffusion Monte Carlo
4913#An introduction to programming multiple-processor computers
4914#An approximate LU factorization method for the compressible Navier-Stokes equations
4915#An implementation of a moving finite element method
4916#An embedding method for the steady Euler equations
4917#A method for reduction of numerical diffusion in the donor cell treatment of convection
4918#An efficient numerical evaluation of the Green's function for the Helmholtz operator on periodic structures
4919#A stable highly accurate ADI method for hyperbolic heat conduction equation
4920#Numerical solution of the shallow water equations
4921#High-order spline interpolations in the particle simulation
4922#Invariance theorems concerning reflection at numerical boundaries
4923#An implicit-explicit hybrid method for Lagrangian hydrodynamics
4924#An inverse method for subcritical flows
4925#ORMEC: A three-dimensional MHD spectral inverse equilibrium code
4926#Simultaneous solution of temperatures in plasmas with rapid equipartition rates
4927#Absorbing boundaries for wave propagation problems
4928#A numerical method for incompressible and compressible flow problems with smooth solutions
4929#SIMMI: A linearized particle code
4930#Transonic flow simulations using an upstream centered scheme of Godunov in finite elements
4931#An implicit moment electromagnetic plasma simulation in cylindrical coordinates
4932#Discrete models for the numerical analysis of time-dependent multidimensional gas dynamics
4933#Numerical method for tokamak equilibrium with outside limiter
4934#The computation of radiation transport using Feautrier variables. II. Spectrum line formation in moving media
4935#Sensitivity analysis of boundary value problems: Application to nonlinear reacti
4936#Finite element methods applied to nearly one-way wave propagation
4937#Numerical grid generation in arbitrary surfaces through a second-order differential-geometric model
4938#A Petrov-Galerkin finite element method for solving the neutron transport equation
4939#Boundary integral techniques for multi-connected domains
4940#Program for efficient Monte Carlo computations of quenched SU(3) lattice gauge theory using the quasi-heatbath method on a CDC CYBER 205 computer
4941#Direct determination of axisymmetric magnetohydrodynamic equilibria in Hamada coordinates
4942#Free-flight time generation in the Monte Carlo simulation of carrier transport in semiconductors
4943#Simulation of binary-single star and binary-binary scattering
4944#A generalized version of the recursive residue generation method for vector computers
4945#Iterative inverse scattering method employing Gram-Schmidt orthogonalization
4946#A regularity theorem for a nonconvex scalar conservation law
4947#Approximation for the turning points of Bessel functions
4948#The calculation of eigenvalues for the stationary perturbation of symmetrical pipe Poiseuille flow
4949#Polynomial series versus sinc expansions for functions with corner or endpoint singularities
4950#A method for vectorized random number generators
4951#Propagation of singularities for semilinear hyperbolic initial-boundary value problems in one space dimension
4952#Constant unfoldings of saddle connections in planar flows
4953#Exponential dichotomy, rotation number, and linear differential operators with bounded coefficients
4954#A system of simultaneous non-linear equations in three-thousand variables
4955#On the behavior of the solutions of the Navier-Stokes equations lying on invariant manifolds
4956#A simple approach to cardinal Lagrange and periodic Lagrange splines
4957#A bang-bang theorem for optimization over spaces of analytic functions
4958#On exponential splines
4959#On proximinality and sets of operators. I. Best approximation by finite rank operators
4960#On proximinality and sets of operators. II. Nonexistence of best approximation from the sets of finite rank operators
4961#On proximinality and sets of operators. III. Approximation by finite rank operators on spaces of continuous functions
4962#Rational approximation on the nonnegative integers
4963#Derived and integrated sets of simple sets of polynomials in two complex variables
4964#The approximate identity kernels of product type for the Walsh system
4965#Uniform rotundity of Musielak-Orlicz sequence spaces
4966#A relation between best approximations in the Chebyshev and the gauges senses
4967#On best partial bases
4968#A note on a result of Bernstein
4969#Ge´za Freud, orthogonal polynomials and Christoffel functions. A case study
4970#Microelectronic Engineering - Microcircuit engineering 85: Proc. of the international conference on microlitho
4971#Nanostructures: fabrication and applications
4972#Nanometer structure fabrication attained by a nanometer E-beam lithography system (NSF-1)
4973#Nanometer scale metal wire fabrication
4974#Electron beam lithography and information transfer
4975#The shower-beam concept
4976#Short beam-path electron optical system for high-throughput submicron lithography
4977#Limitations on the performance of charged particle beams in microlithography
4978#An electron beam image projection system with automatic wafer handling
4979#Proximity corrections for electron image projection
4980#Fabrication of high aspect ratio submicron structures by variable-shape electron lithography
4981#A new approach to proximity effect correction
4982#A novel Monte Carlo simulation in electron beam exposure
4983#Advances in proximity effect measurement and correction in electron beam lithography
4984#A test stand for the development of imaging triode guns
4985#NM scale device fabrication in a 100 keV E-beam system
4986#Precise mask-to-wafer gap sensing established in the EPB-lithography tool
4987#Ion-beam lithography
4988#Gas ion source for focused beams
4989#Focusing column for helium field source
4990#Design of a 100 kV, high resolution focused ion beam column with a liquid metal ion source
4991#Submicron lithography and DUV-master masks made by ion projection lithography
4992#Study of the effects of ion beam lithography on the electrical properties of substrates
4993#Background and applications of electron beam test techniques
4994#Accurate electron beam waveform measurement on high density integrated circuits
4995#Logic-state tracing: electron beam testing by correlation
4996#Test specimens for SEM voltage contrast
4997#Evaluation of a Fourier transform method for accurate critical dimension measurements
4998#Micromechanics: a silicon microfabrication technology
4999#Electron collimating structures, evaporation masks and vacuum checks made by anisotropic wet etching of silicon
5000#High resolution optical lithography by formation of a Built On Mask (BOM)
5001#Focused ion beam repair techniques for clear and opaque defects in masks
5002#Advances in digital alignment strategies for step-and-repeat optical imaging
5003#Effective procedures to achieve a 1 micron CMOS process using a step and repeat aligner with autocalibration system
5004#Resist materials
5005#A comparison of the electron beam sensitivities and relative oxygen plasma etch rates of various organosilicon polymers
5006#Polysiloxanes for deep UV lithography
5007#Formation of thick and narrow-spacing metal patterns by lift-off technique using negative photoresists, LMR and LMR-UV
5008#The selection of processing conditions for e-beam resists in mask making
5009#To dye or not to dye—some aspects of today's resist technology
5010#Thermal stability and etching resistance of formaldehyde- and deep UV-hardened photoresists
5011#Experiments and computer simulation of submicron image formation by direct VUV photoetching
5012#Lithographic image simulations
5013#A comparison of techniques for improving linewidth control over steps
5014#Proximity effects in submicronic lithography
5015#Optical lithography simulation: introduction to SPESA
5016#Application of the simulator XMAS on specific problems in sub-half micron lithography
5017#Methods of creation and effect of microwave plasmas upon the etching of polymers and silicon
5018#Microwave multipolar plasma etching at low pressure: a novel reactor concept
5019#Mass spectrometry for controlling etch processes of silicon containing layers
5020#Self-aligning resist techniques for shadow evaporation of a superconducting three-terminal device
5021#Anisotropic dry etching of GaAs and silicon using CCl4
5022#A direct-write electron beam lithographic process using multi-layer resists and its application on silicon-on-sapphire technology
5023#The mechanism of ion implantation passivation of PMMA for lithography with dry etch development
5024#Fabrication of X-ray zone plates with a minimum zone width smaller than 100 nm by electron beam lithography
5025#Submicron patterns formed by reactive ion etching
5026#SIMS and AES investigations of contamination effects by RIE of PIQ layers
5027#Etch behavior and lateral etch rates of trilevel resist systems in an RIE-system using SOG and Ti intermediate layers
5028#Reactive ion etching of polyimide for multi-level resist and contact hole applications
5029#Polyimide lift off for submicrometer metallisation patterns
5030#Two layer planarization process
5031#E-beam lithography for sub-micron MOS-devices
5032#Submicron gate level process step using E-beam lithography
5033#Characterization of a two-layer resist
5034#X-ray lithography
5035#Laser-plasma sources for X-ray lithography
5036#Conversion efficiency of laser radiation into soft X-ray radiation of laser produced plasmas for X-ray lithography
5037#Characterization of stress in the absorber of X-ray masks using a holographic technique
5038#High contrast synchrotron X-ray lithography by means of silicon based masks and magnesium beam windows
5039#Prospects of high resolution X-ray lithography
5040#Photoelectron exposure of X-ray resists
5041#Thorough investigations on the resolution of replicated resist patterns in conventional X-ray lithography
5042#Plasma focus as a radiation source for X-ray lithography
5043#Distortion of masks for X-ray lithography
5044#Negative resist dose characteristics measurements by laser plasma soft X-ray source
5045#Computer simulation of pattern profiles through physical etching with shadow, trenching and redeposition
5046#Ion-beam etching, and chemically assisted ion-beam etching to produce X-ray masks for synchrotron-radiation-lithography
5047#On the existence of generally convergent algorithms
5048#Approximation of linear functionals on a Banach space with a Gaussian measure
5049#Complexity of computing topological degree of Lipschitz functions in n dimensions
5050#Structuring causal trees
5051#Strongly optimal algorithms and optimal information in estimation problems
5052#On the computational complexity of best Chebyshev approximations
5053#On the Kolmogorov complexity of functions of finite smoothness
5054#On the optimal solution of large eigenpair problems
5055#For which error criteria can we solve nonlinear equations?
5056#Polynomial division and its computational complexity
5057#Information of varying cardinality
5058#On average case errors in numerical analysis
5059#Optimal complexity recovery of band- and energy-limited signals
5060#Probabilistic setting of information-based complexity
5061#Correctness criteria of some algorithms for uncertain reasoning using incidence calculus
5062#Automated analysis of operators on state tables: A technique for intelligent search
5063#Negation as failure. Completeness of the query evaluation process for Horn clause programs with recursive definitions
5064#A decision procedure for combinations of propositional temporal logic and other specialized theories
5065#Seventy-five problems for testing automatic theorem provers
5066#A dual form of Erdo¨s-Rado's canonization theorem
5067#Product constructions for cyclic block designs. II. Steiner 2-designs
5068#Minimum dimension embedding of finite metric spaces
5069#All rationals occur as exponents
5070#The nonexistence of code words of weight 16 in a projective plane of order 10
5071#On the poset of partitions of an integer
5072#Remarks on symbols, hooks, and degrees of unipotent characters
5073#An incidence algebra for t-designs with automorphisms
5074#Finiteness questions in quasi-symmetric designs
5075#Extraneous multipliers of cyclic difference sets
5076#Large minimal sets which force long arithmetic progressions
5077#Self-complementary totally symmetric plane partitions
5078#Preassigning the shape of projections of convex polytopes
5079#Reconstructing the ternary Golay code
5080#A note on the cake-division problem
5081#Lower bounds for small diagonal Ramsey numbers
5082#A new biplane of order 9 with a small automorphism group
5083#Two selection problems revisited
5084#Addendum to the paper “On the dependence of functions on their variables”
5085#A new proof of the Erdos-Szekeres convex k-gon result
5086#Notes on the derived Walker planes
5087#On localized potential spaces
5088#Piecewise smooth solutions of some difference-differential equations
5089#Spectral approximation
5090#A criterion for isolated solution structure and global computability for operator equations
5091#The differentiability of Fourier gap series and “Riemann's example” of a continuous, nondifferentiable function
5092#On the K functional between L1 and L2 and some other K functionals
5093#A note on Littlewood-Paley decompositions with arbitrary intervals
5094#Catalog of professional development seminars
5095#Cybernetic simulation of control processes through economic increase equalization
5096#A cybernetic model of the circulation means rotation in an industrial enterprise
5097#The relation between heuristics and the fuzzy sets theory
5098#Dynamic model for determining the optimal intervals between two successive repairs
5099#Numerical results concerning the optimum distribution of electric and thermal ch
5100#The concept of a data bank for economic scientific research in education
5101#Elaboration of cooperation programmes at a group and branch level
5102#Analysis of dynamic systems in the state-control extended space
5103#Methods and techniques of objective assessment of the student's personality
5104#Aspects on the implementation of a statistical data bank
5105#Causality in cybernetic-economic systems: a statistical approach
5106#A model of multiobjective technical and material supply
5107#Models of economical increase and preparation of labour manpower
5108#Optimizing the location of corp fields
5109#CP/M—an operating system for microcomputers (IV)
5110#Interpretation and representation of decision problems under uncertainty as fuzz
5111#AAAI membership directory, January, 1986
5112#Simulation of steel plant gas recovery system during switch-over flaring to reco
5113#Experimental order approximation for a batch process
5114#Critical review of visual inspection
5115#A new algorithm for control systems with delay - the algorithm of model-reference
5116#Development of batch control software—a structured methodology
5117#The impatient Italian
5118#High tech in the heartland
5119#Digital network strategies
5120#French micro lessons
5121#Backcast
5122#Computer advertising, 1985: the $2.1 billion prize
5123#The psychological costs of master computer
5124#So where are the products
5125#Of commerce and academe
5126#Who's teaching telecom?
5127#Toward a viable OS for the PC
5128#Surveying the software generation market
5129#Data flow dynamics
5130#The AT&T make-over
5131#The designing mind
5132#How to pick eagles
5133#Building a fourth generation environment
5134#From analysis to design
5135#Learning to live in a distributed world
5136#Objects and events
5137#South Africa: pulling the plug.
5138#A system to grow with
5139#Are smart buildings a dumb idea
5140#Avoiding conversion confusion
5141#Keyfield design
5142#The art of space software
5143#The shifting shape of SNA
5144#Coming: a new SNA
5145#Pitfalls in data design
5146#Sending software overseas
5147#Electronic mail
5148#The art of modeling
5149#Data integrity and the identifier
5150#Dp and the disabled
5151#Fast break in Armonk
5152#Shopping for market share
5153#The users' story
5154#IBM: mainframes in 1990
5155#A generous portion
5156#Banking on IBM
5157#The use of screening in policy analysis
5158#Safety stocks in MRP—systems with emergency setups for components
5159#A comparison of strategies to dampen nervousness in MRP systems
5160#A comparative evaluation of heuristic line balancing techniques
5161#A cost-based methodology for stochastic line balancing with intermittent line
5162#Scheduling with multiple performance measures: the one-machine case
5163#The ability of Nash's theory of cooperative games to predict the outcomes of
5164#Forecasting data published at irregular time intervals using an extension of
5165#Computers: how to break into the field (2nd ed.)
5166#Expertise transfer for expert system design
5167#Computer simulation methods: in theoretical physics
5168#Advice giving could become the first successful domain for intelligent interfaces.
5169#Although individual use of computers is fairly widespread, in meetings we tend to leave them behind. At Xerox PARC, an experimental meeting room called the Colab has been created to study computer support of collaborative problem solving in face-to-face meetings. The long-term goal is to understand how to build computer tools to make meetings more effective.
5170#A relational implementation of IRDS using SQL demonstrates how the flexibility of the relational environment enhances the extensibility of the IRDS while at the same time providing more powerful dictionary capabilities than are typically found in relational systems.
5171#Pattern matching is a common and fundamental operation of many applications, such as expert systems (ES). With continued growth the knowledge bases of such systems will need database management systems (DBMS) support. Providing this support will require extending DBMS to meet the needs of these systems. We have developed an operator that extends the relational data model to do pattern matching with very complex stored patterns.
5172#Update to "data parallel algorithms"
5173#What is computer science?
5174#Computer networks
5175#Supernetworks
5176#Parallel computation
5177#The evolution of parallel processing
5178#The next knowledge medium
5179#Parallel computers with tens of thousands of processors are typically programmed in a data parallel style, as opposed to the control parallel style used in multiprocessing. The success of data parallel algorithms—even on problems that at first glance seem inherently serial—suggests that this style of programming has much wider applicability than was previously thought.
5180#Compilers for vector or multiprocessor computers must have certain optimization features to successfully generate parallel code.
5181#Contention in large-scale shared-memory systems is less of a concern than generally believed. Through careful engineering of a parallel system, the effects of contention can be controlled.
5182#The intensive use of memory to recall specific episodes from the past—rather than rules—should be the foundation of machine reasoning.
5183#A new implementation of free-text search using a new parallel computer—the Connection Machine®—makes possible the application of exhaustive methods not previously feasible for large databases.
5184#An introduction to data base design
5185#Mental models: towards a cognitive science of language, inference, and consciousness
5186#Three faces of IBM
5187#Computing shakeout
5188#The hidden manager: communication technology and information networks in business organisations
5189#Mind over machine: the power of human intuition and expertise in the era of the computer
5190#Introduction to information theory
5191#A simple extension of the relational model is introduced to study the effects of dynamic constraints on database evolution. Both static and dynamic constraints are used in conjunction with the model. The static constraints considered here are functional dependencies (FDs). The dynamic constraints involve global updates and are restricted to certain analogs of FDs, called “dynamic” FDs. The results concern the effect of the dynamic constraints on the static constraints satisfied by the database in the course of time. The effect of the past history of the database on the static constraints is investigated using the notions of age and age closure. The connection between the static constraints and the potential future evolution of the database is briefly discussed using the notions of survivability and survivability closure.
5192#The problem of electing a leader in a synchronous ring of n processors is considered. Both positive and negative results are obtained. On the one hand, if processor IDS are chosen from some countable set, then there is an algorithm that uses only O(n) messages in the worst case. On the other hand, any algorithm that is restricted to use only comparisons of IDs requires &OHgr;(n log n) messages in the worst case. Alternatively, if the number of rounds is required to be bounded by some t in the worst case, and IDs are chosen from any set having at least ƒ(n, t) elements, for a certain very fast-growing function ƒ, then any algorithm requires &OHgr;(n log n) messages in the worst case.
5193#Accurate simulation of light propagation within an environment and perceptually based imaging techniques are necessary for the creation of realistic images. A physical experiment that verifies the simulation of reflected light intensities for diffuse environments was conducted. Measurements of radiant energy flux densities are compared with predictions using the radiosity method for those physical environments. By using color science procedures the results of the light model simulation are then transformed to produce a color television image. The final image compares favorably with the original physical model. The experiment indicates that, when the physical model and the simulation were viewed through a view camera, subjects could not distinguish between them. The results and comparison of both test procedures are presented within this paper.
5194#A theory is given that accounts for the observed behavior of Runge-Kutta codes when the stepsize is restricted by stability. The theory deals with the general case when the dominant eigenvalues of the Jacobian may be a complex conjugate pair. This extends and generalizes the results of Part I of this paper, which deal with the real case. Familiarity with Part I is assumed, but not essential.
5195#A general procedure for the construction of interpolants for Runge-Kutta (RK) formulas is presented. As illustrations, this approach is used to develop interpolants for three explicit RK formulas, including those employed in the well-known subroutines RKF45 and DVERK. A typical result is that no extra function evaluations are required to obtain an interpolant with O(h5) local truncation error for the fifth-order RK formula used in RKF45; two extra function evaluations per step are required to obtain an interpolant with O(h6) local truncation error for this RK formula.
5196#The problem of finding the plane curve of minimal elastic energy with prescribed endpoints and end-directions was solved in 1983 by B. K. P. Horn. Here the solution is discussed, given a very short proof, and extended to include a constant on length.
5197#The blended linear multistep methods of Skeel and Kong (1977) are fairly simply expressed in Nordsieck form, but the underlying multistep method turns out to be much more complicated.
5198#The power of shared-memory in models of parallel computation is studied, and a novel distributed data structure that eliminates the need for shared memory without significantly increasing the run time of the parallel computation is described. More specifically, it is shown how a complete network of processors can deterministically simulate one PRAM step in O(log n/(log log n)2) time when both models use n processors and the size of the PRAM's shared memory is polynomial in n. (The best previously known upper bound was the trivial O(n)). It is established that this upper bound is nearly optimal, and it is proved that an on-line simulation of T PRAM steps by a complete network of processors requires &OHgr;(T(log n/ log log n)) time.A simple consequence of the upper bound is that an Ultracomputer (the currently feasible general-purpose parallel machine) can simulate one step of a PRAM (the most convenient parallel model to program) in O((log n)2log log n) steps.
5199#Universal assembly language
5200#Latchup in CMOS technology: the problem and its cure
5201#Actors: a model of concurrent computation in distributed systems
5202#Software quality assurance & management
5203#Optimization using personal computers: with applications to electrical networks
5204#Mathematical structures for computer science (2nd ed.)
5205#Portraits of success: impressions of Silicon Valley pioneers
5206#Path generating functions and continued fractions
5207#A method for constructing generalised residual designs
5208#Distributions, continued fractions, and the Ehrenfest urn model
5209#On the minimum rank of regular classes of matrices of zeros and ones
5210#A generalisation of Canfield's formula
5211#The number of repeated blocks in twofold triple systems
5212#An improved lower bound on the greatest element of a sum-distinct set of fixed order
5213#A canonical version for partition regular systems of linear equations
5214#“Poly-unsaturated" posets: the Greene-Kleitman theorem is best possible
5215#Covering triples by quadruples: an asymptotic solution
5216#Decomposition of the complete hypergraph into Delta-Systems II
5217#Non-trivial intersecting families
5218#The number of small semispaces of a finite set of points in the plane
5219#Orthogonal F-rectangles, orthogonal arrays, and codes
5220#The generalized Sprague-Grundy function and its invariance under certain mappings
5221#Partition relations for countable topological spaces
5222#Minimal non-two-colorable hypergraphs and minimal unsatisfiable formulas
5223#On a natural extension of Jacob's ranks
5224#A characterization of designs related to dodecads in the Witt System S(5,8,24)
5225#The Erdo¨s-Ko-Rado theorem for vector spaces
5226#The existence of simple 6-(14,7,4) designs
5227#The asymptotic number of rooted maps on a surface
5228#Q-Codes
5229#New results for quasi-symmetric designs an application of MACSYMA
5230#Combinatorial properties of planar spaces and embeddability
5231#Asymptotic analogs of the Rogers-Ramanujan identities
5232#A Schensted-type correspondence for the symplectic group
5233#An infinite version of Ryser's inequality
5234#Cyclic projective planes and binary, extended cyclic self-dual codes
5235#On resolvable designs S3(3;4,v)
5236#A density statement generalizing Schur's theorem
5237#The number of extreme pairs of finite point-sets in Euclidean spaces
5238#(81, 16, 3) Abelian difference sets do not exist
5239#Doubly transitive (n+2)-arcs in projective planes of even order n
5240#A sublattice of the Leech lattice
5241#Bijections for Cayley trees, spanning trees, and their q-analogues
5242#k-Color Sperner theorems
5243#On an infinite class of Steiner systems with t=3 and k=6
5244#A new approach to the covering radius of codes
5245#Nonexistence of weakly neighborly polyhedral maps on the orientable 2-manifold of Genus-2
5246#Quasi-symmetric 2-(31, 7, 7) designs and a revision of Hamada's conjecture
5247#Geometric lattices with topology
5248#Embedding geometric lattices with topology
5249#On the diagonal queens domination problem
5250#Inherited arcs in finite affine planes
5251#An elementary proof of the canonizing version of Gallai-Witt's theorem
5252#Disjoint covering systems of rational Beatty sequences
5253#The classification of all (x, y)-transitive generalized quadrangles
5254#Research opportunities in the decision and management sciences
5255#Optimal strategic petroleum reserve policies: a steady state analysis
5256#A comparative application of data envelopment analysis and translog methods: an illustrative study of hospital production
5257#Subjective probability and the prisoner's dilemma
5258#"Lottery equivalents": reduction of the certainty effect problem in utility assessment
5259#An interactive branch-and-bound algorithm for multiple criteria optimization
5260#The dynamics of plant layout
5261#A study of organizational effectiveness and its predictors
5262#Optimal and heuristic procedures for component log-splitting in multi-stage manufacturing systems
5263#Piecewise loglinear estimation of efficient production surfaces
5264#What is an attractive industry?
5265#Strategic factor markets: expectations, luck, and business strategy
5266#Emergency government interventions: case study of natural gas shortages
5267#An analysis of risk and return in the defense market: its impact on weapon system competition
5268#A tight linearization and an algorithm for zero-one quadratic programming problems
5269#A comparison of heuristics for scheduling projects with cash flows and resource restrictions
5270#Quality improvement and learning in productive systems
5271#A branch and bound approach for machine load balancing in flexible manufacturing systems
5272#A single product cycling problem under Brownian motion demand
5273#Binding versus final-offer arbitration: a combination is best
5274#A note on economic models for R&D project selection in the presence of project interactions
5275#An improved conditional Monte Carlo technique for the stochastic path problem
5276#On transformations of algorithms to multiply 2 x 2 matrices
5277#Every iterated morphism yields a co-CFL
5278#The trade-off between the additive complexity and the asynchronicity of linear and bilinear algorithms
5279#On termination and phase changes in the presence of unreliable communication
5280#Linear programming in O(n × 3d2) time
5281#The Greedy and Delaunay triangulations are not bad in the average case
5282#A note on Presburger arithmetic with array segments, permutation and equality
5283#Hexagonal unit network a tool for proving the NP-completeness results of geometric problems
5284#Two results on tables
5285#Tree-like parse and polynomial subclasses of search problems
5286#Bibliometric application of Markov chains
5287#An investigation of document partitions
5288#Statistics in information retrieval experiments
5289#Library—An electronic ordering system
5290#Processes and problems in information consolidation
5291#Minstrel-ODM: A basic office data model
5292#A recursive approach to office object modelling
5293#Interactive querying techniques for an office filing facility
5294#Information retrieval in an office filing facility and future work in Project Minstrel
5295#Novel filing systems applicable to an automated office: a state-of-the-art study
5296#Analyzing the information economy: tools and techniques
5297#A longitudinal profile of a national database search service
5298#On the value of information in system design: A framework for understanding and aiding designers
5299#Indeterminacy in the subject access to documents
5300#Organization of the inverted files in a distributed information retrieval system based on thesauri
5301#A statistical assessment of two measures of citation: the impact factor and the immediacy index
5302#The application of computers in the humanities: A view from Britain
5303#On the greatest zero of an orthogonal polynomial
5304#Lipschitz continuity and strong unicity in G. Freud's work
5305#Freud's work in constructive function theory
5306#K functionals and best polynomial approximation in weighted Lp(R)
5307#Ge&caron;za Freud's work on Tauberian remainder theorems
5308#Ge&caron;za Freud and lacunary Fourier series
5309#Strong approximation by Fourier series
5310#On Freud's equations for exponential weights
5311#Weighted polynomial approximation
5312#Contributions of Ge&caron;za Freud to the theory of rational approximation of functions
5313#On the work of G. Freud in the theory of interpolation of functions
5314#LU-factorization of order bounded operators on Banach sequence spaces
5315#An estimate for the coefficients of polynomials of given length
5316#Approximation by semi-non-linear functions
5317#The Fourier projection is minimal for regular polyhedral spaces
5318#Spectral bounds for ||A-1||∞
5319#The embedding of proximinal sets
5320#Unicity subspaces in L1-approximation
5321#Generalized Gaussian quadrature formulas
5322#On generalized Hausdorff matrices
5323#Sections of the Taylor expansions of Lindelo¨f functions
5324#Jackson-type theorems on approximation by trigonometric and algebraic pseudopolynomials
5325#A piecewise polynomial lacunary interpolation method
5326#The optimal representation of disjoint iso-oriented rectangles in two-dimensional trees
5327#Evaluation of a MULTIFIT-based scheduling algorithm
5328#A compact representation for permutation groups
5329#A better than “best possible” algorithm to edge color multigraphs
5330#An efficient parallel algorithm for shifting the root of a depth first spanning tree
5331#An algorithmic characterization of total digraphs
5332#On the complexity of circulations
5333#An algorithm for early unlocking of entities in database transactions
5334#A new upper bound for Shellsort
5335#Planar 3DM is NP-complete
5336#Depth-size trade-offs for parallel prefix computation
5337#Searching and sorting similar lists
5338#Polygon triangulation: efficiency and minimality
5339#Single bend wiring
5340#An optimal algorithm for finding minimal enclosing triangles
5341#Conway's parallel sorting algorithm
5342#Bipartite graph matching for points on a line or a circle
5343#Computing the convex hull of line intersections
5344#The NP-completeness column: An ongoing guide
5345#On the number of queries necessary to identify a permutation
5346#The complexity of generating an exponentially distributed variate
5347#A stochastic analysis of the NFD bin-packing algorithm
5348#Routing through a generalized switchbox
5349#Polygon containment under translation
5350#Generalized Steiner problem in series-parallel networks
5351#A fast and simple randomized parallel algorithm for the maximal independent set problem
5352#The NP-completeness column: An ongoing guide
5353#What is automated reasoning?
5354#Logic programming
5355#Research in intelligent robots
5356#Program verification
5357#What is automated theorem proving?
5358#Expert systems
5359#Nonclassical logic theorem proving
5360#What is program synthesis?
5361#ROGET: A knowledge-based system for acquiring the conceptual structure of a diagnostic expert system
5362#On the role of automated theorem proving in the compile-time derivation of concurrency
5363#Non-Horn problems
5364#Experiments with semantic paramodulation
5365#Incidence calculus: A mechanism for probabilistic reasoning
5366#Writing programs that construct proofs
5367#The lion and the unicorn
5368#Automated reasoning in geometry theorem proving with Prolog
5369#A class of confluent term rewriting systems and unification
5370#A foray into combinatory logic
5371#The power of the private workspace model
5372#A requirements modeling language and its logic
5373#Taxonomy and formal properties of distributed joins
5374#Losslessness and semantic correctness of database schema transformation: another look at schema equivalence
5375#The INFOLOG linear tense propositional logic of events and transactions
5376#Modeling the CODASYL DML context dependency for database program conversion
5377#Classification and transformations of binary relationship schemata
5378#Functional data model design
5379#The relational model with relation-valued attributes
5380#A semantic data model as the basis for an automated database design tool
5381#Batch insertion for tree structured file organizations—improving differential database representation
5382#Double encoding—A technique for reducing storage requirement of text
5383#Dimensions of information systems design: A framework for a long-range research program
5384#Choice of the optimal number of blocks for data access by an index
5385#Statistical treatment of the information content of a database
5386#Redundancy in functional databases
5387#Grid file concurrency
5388#A combined methodology for information systems analysis and design based on ISAC and NIAM
5389#Schema translation: A three-level semantic abstraction approach
5390#Japan's dynamic PCM DUO
5391#Picking up the pieces
5392#Users: a time for caution
5393#Learning from lemons
5394#Raising orphans
5395#Alas poor Visicorp
5396#The computer expert's guide to life
5397#Blood from turnips?
5398#The importance of power
5399#A Swedish experiment
5400#Sensible network security
5401#IBM's OA puzzle
5402#The real cost of OA
5403#The networking standards collision
5404#Japanese DP
5405#The evolution of software architecture
5406#Risc-y business?
5407#Closing the software gap
5408#Iterative development
5409#Measuring applications development performance
5410#Developing PC applications
5411#Message from Managua
5412#A new voyage for Columbus
5413#Computer marts multiply
5414#Insight into on-site telecom
5415#Handicapping LANs
5416#Quality assurance
5417#The quest for quality
5418#IRM revisited
5419#A PC support center
5420#The state of state telecom
5421#Telecommunications standards arrive
5422#Can we talk?
5423#DES revisited
5424#Telecom and MIS: managing the merger
5425#Do you telecommute?
5426#The two-headed arrow
5427#Reality hits the valley
5428#Stress
5429#High tech, high stress?
5430#Users are people too
5431#Oil and water?
5432#The planning ritual
5433#Managing software development
5434#Wish book wonders
5435#Advent of the clustered system
5436#Departmental computing: a choice of strategies
5437#IMNET takes the field
5438#Break with tradition
5439#The applications software survey
5440#Up, up, and away
5441#Sierra: where will it lead?
5442#Up the software curve
5443#You know my name, look up the number
5444#Is your computer insecure?
5445#Painting a new picture
5446#Beyond today's blue
5447#A global industry... The Datamation 100
5448#Alliances, networks, and international competition
5449#Mini-micro survey
5450#Branch office microcomputing
5451#Managing the PC revolution
5452#Business graphics trends
5453#The king of Malaputa
5454#Is progress what it seems to be?
5455#Leadership is crucial
5456#Getting away with merger
5457#The integrated services digital network
5458#Systems software survey: users' favorite disks
5459#Decentralizing data security
5460#Graphics imager allows check of designs-in progress
5461#Determining CTR resolution
5462#Continuous ink-jet produces true color halftone images
5463#Pre-shaped polymer forms ink-jet nozzles in ceramic
5464#Optical fiber choice, a function of specific application
5465#Shadow enhancement provides 2-D maps with 3-D imagery
5466#Recording thin-film spectra has its parameters, pitfalls
5467#Hi-res color hardcopy meeting user needs and image quality
5468#Flat tension-mark yields brighter image with higher contrast
5469#Touch technology: variety of systems spur maturity
5470#Are video displays a health hazard?
5471#Processing system extends life of flat-panel displays
5472#Knife-edge technique improves measurement of CRT beam profiles
5473#High-res color monitors drive development of signal generators
5474#Information system ties computers, WPs, printers to telecommunications
5475#Documentation system automatically plans, supervises work flow
5476#Private copying, reproduction costs, and the supply of intellectual property
5477#Learning, quality and prices
5478#Medical diagnosis as a problem in the economics of information
5479#The impact of economic cycles on the demand for international telecommunications in Australia
5480#A model of intra-brand competition and related pricing policies for manufacturers
5481#Search and market for lemons
5482#A reexamination of the `lemons' market when warranties are not prepurchase quality signals
5483#The dual approach to the value of information: an appraisal of use and exchange values
5484#Enhancement of text representations using related document titles
5485#Decision support systems in academic planning: important considerations and issues
5486#A discipline-specific journal selection algorithm
5487#Empirical validation of Lotka's law
5488#Virtual files in a distributed environment
5489#On the quasi-optimality principle for ill-posed problems in Hilbert space
5490#Two-step iterative regularization methods for solving ill-posed problems with a selfconjugate non-negative operator
5491#On the problems of linear programming with integral coefficients
5492#The method of successive approximations in a problem of the optimal control of one non-linear parabolic system
5493#Approximate solution of a non-linear boundary value problem with a small parameter for the highest-order differential
5494#Investigation of the method of nets for two-dimensional equations of the Navier-Stokes and Euler type with non-negative viscosity—I
5495#Anomalous thermal waves in a plasma
5496#Determination of the parameters of a model for the motion of salts
5497#Estimates of the rate of convergence of projection-difference schemes for parabolic equations in a domain with a small opening
5498#Distance-transitive graphs of valency 5, 6 and 7
5499#Capacity of algebraic extensions of a model of estimate-computing algorithms
5500#On multiplication of a perforated matrix by a vector
5501#Some sufficient conditions for the non-degeneracy of matrices
5502#Optimal regularization of ill-posed normally solvable operator equations
5503#Galerkin-Tikhonov regularization in the numerical differentiation problem
5504#On numerical modelling of one-dimensional stochastic wave problems
5505#Existence and representation of natural arithmetic graphs
5506#On a problem of non-linear programming for unsmooth target functions
5507#An estimate of the stability and the condition number of a set of solutions for a system of linear inequalities
5508#A general approach to reducing a regular linear pencil to a pencil of quasitriangular form
5509#Minimization of a multi-extremum function with a discontinuity
5510#Investigation of a class of production functions arising in the macro descriptin of economic systems
5511#On the numerical solution of a singularly-perturbed equation with a turning point
5512#The solution of non-linear stationary problems of thermal conduction with boundary conditions of the I-IV kind
5513#Investigation of the method of nets for two-dimensional equations of the Navier-Stokes type with non-negative viscosity—II
5514#a method of solving implicit difference equations approximating systems of radiation transport and diffusion equations
5515#On some equations arising in the dynamics of a rotating stratified and compressible fluid
5516#The existence of a solution of the direct Lavalle nozzle problem in variations
5517#Estimate-computing algorithms for the object recognition problem with continous initial information
5518#Lower bounds of the capacity of L-dimensional algebras of estimate-computing algorithms
5519#On the solution of linear ill-posed problems by the method of local discrepancies
5520#Automatic construction of systems of recurrence relations
5521#On closed sets of a directed graph
5522#Approximation of non-eigen problems of linear programming using the Euclidean norm criterion
5523#What it's like to be a POPL referee
5524#Improved string matching with k mismatches
5525#On the inference of canonical context-free grammars
5526#What does O(n) mean
5527#Testing for semilattices
5528#The cycle burning problem
5529#The halting problem for Turning machines
5530#On the integer complexity of Boolean matrix multiplication
5531#It is reasonable to expect parallel machines to be faster than sequential ones. But exactly how much faster do we expect them to be? Various authors have observed that an exponential speedup is possible if sufficiently many processors are available. One such author has claimed (erroneously) that this is a counterexample to the parallel computation thesis. We show that even more startling speedups are possible. In fact, if enough processors are used, any recursive function can be computed in constant time. Although such machines clearly do not obey the parallel computation thesis, we argue that they still provide evidence in favour of it. In contrast, we show that an arbitrary polynomial speedup of sequential machines is possible on a model which satisfies the parallel computation thesis. If, as widely conjectured, P⊈POLYLOGSPACE, then there can be no exponential speedup on such a model.
5532#Logic and databases: a critique
5533#Experiments with a generic reduction computer
5534#Time complexity of the Towers of Hanoi problem
5535#Replacement-nodal-subtractive nomenclature and codes of chemical compounds
5536#A simple method for the representation, quantification, and comparison of the volumes and shapes of chemical compounds
5537#Electronic publishing and document delivery of German patent information
5538#The chemical reactions documentation service: ten years on
5539#A method for early identification of loss from a nuclear material inventory
5540#Cambridge crystallographic data centre. 7. Estimating average molecular dimensions from the Cambridge structural database
5541#TERRE-TOX: a data base for effects of anthropogenic substances on terrestrial animals
5542#Implementation of nearest-neighbor searching in an online chemical structure search system
5543#Primary journals today and tomorrow
5544#Scientometrics with some emphasis on communication at scientific meetings and through the Invisible College"
5545#A least-square digital filter for repetitive data acquisition
5546#Comparison of manual and online searches of chemical abstracts
5547#IDC inorganic chemicals data base. 2. Utilization of chemical abstracts service data bases for the IDC inorganic chemistry documentation systems
5548#Chemical graphs. 43. FORTRAN IV program for computing the number of general cubic graphs onp vertices
5549#Stereo numbers, cosets and the configuration symmetry group
5550#Microcomputer software. 2. Scientific and technical word processing on a personal computer: has the time come?
5551#Development of a novel weighting scheme for the k-nearest-neighbor algorithm
5552#Development and use of numerical databases for properties of metastable chemical species in solution
5553#A microcomputer-based system for chemical information and molecular structure search
5554#Implementation of nonhierarchic cluster analysis methods in chemical information structure search
5555#Computer storage and retrieval of generic chemical structures in patents. 7. Parallel simulation of a relaxation algorithm for chemical substructure search
5556#Heuristic approaches to the design of a cybernetic electroanalytical instrument
5557#Compact molecular codes
5558#From timesharing to the sixth generation: the development of human-computer interaction. Part I
5559#An experimental comparison of a mouse and arrow-jump keys for an interactive encyclopedia
5560#The user's mental model of an information retrieval system: an experiment on a prototype online catalog
5561#Fuzzy cognitive maps
5562#Using planning techniques in intelligent tutoring systems
5563#Foundations of dialog engineering: the development of human-computer interaction. Part II
5564#Comparison of decision support strategies in expert consultation systems
5565#On the suitability of fuzzy models: an evaluation through fuzzy integrals
5566#ADDS-a dialogue development system for the Ada programming language
5567#Training by exploration: facilitating the transfer of procedural knowledge through analogical reasoning
5568#A taxonomy of user-oriented functions
5569#Star, maximal rectangles, lattices: a new perspective on Q-analysis
5570#A virtual protocol model for computer-human interaction
5571#Mode errors: a user-centered analysis and some preventative measures using keying-contingent sound
5572#A review and synthesis of recent research in intelligent computer-assisted instruction
5573#An empirical comparison of model-based and explicit communication for dynamic human-computer task allocation
5574#An experimental evaluation of prefix and postfix notation in command language sytax
5575#On-line recognition of Pitman's hand-written shorthand—an evaluation of potential
5576#The use of q-analysis and q-factor weightings to derive clinical psychiatric syndromes
5577#A three-level human-computer interface model
5578#Icon-based human-computer interaction
5579#On methods for interface specification and design
5580#Fuzzy Prolog
5581#Negative knowledge towards a strategy for asking in logic programming
5582#Support for tentative design: incorporating the screen image, as a graphical object, into PROLOG
5583#Automatic speech recognition based on spectrogram reading
5584#Testing functional grammar placement rules using PROLOG
5585#Constructing 3-D object models using multiple simulated 2.5-D sketches
5586#Studying depth cues in a three-dimensional computer graphics workstation
5587#A multi-purpose system for alpha-numeric input to computers via a reduced keyboard
5588#Dealing with a database query language in a new situation
5589#A descriptive/prescriptive model for menu-based interaction
5590#Adaptive command prompting in an on-line documentation
5591#Comparison of rough-set and statistical methods in inductive learning
5592#A comparison of menu selection techniques: touch panel, mouse and keyboard
5593#Infinite-valued logic based on two-valued logic and probability. Part 1.1. Difficulties with present-day fuzzy set theory and their resolution in the TEE model
5594#Principles of information structure common to six levels of the human cognitive system
5595#The analysis of simple list structures
5596#A VLSI implementation of a fuzzy-inference engine: toward a expert system on a chip
5597#A partitioning algorithm for distributed software systems design
5598#Computing human oriented descriptions
5599#A note on rule representation in expert systems
5600#Weights of evidence and internal conflict for support functions
5601#Correctness proof for the majority consensus algorithm
5602#The complementary process of fuzzy medical diagnosis and its properties
5603#Letter-oriented reciprocal hashing scheme
5604#Complete test-set generation for bridging faults in combinational-logic circuits
5605#Three-way two dimensional finite automata with rotated inputs
5606#On selecting rollback points for error recovery
5607#Fuzzy subgroup: some characterizations II
5608#A comment on "NP = P?" and restricted partitions
5609#An LP planning model for a mental health community support system
5610#The intellectual development of management information systems, 1972-1982: a co-citation analysis
5611#Patents and innovation: an empirical study
5612#When does lag structure really matter in optimizing advertising expenditures?
5613#A market entry timing model for new techniques
5614#A variable buffer-size model and its use in analyzing closed queueing networks with blocking
5615#A homogeneous industry model of resource allocation to basic research and its policy implications
5616#Notions of efficiency and their reference sets
5617#Naive diversification and portfolio risk—a note
5618#Comment on "A perturbation scheme to improve Hillier's solution to the facilities layout problem"
5619#"A perturbation scheme to improve Hillier's solution to the facilities layout problem": a clarification
5620#Implications of salesforce productivity heterogeneity and demotivation: a Navy case study
5621#Chief executive personality and corporate strategy and structure in small firms
5622#The effects of the sample size, the investment horizon and market conditions on the validity of composite performance measures: a generalization
5623#The adoption of radical and incremental innovations: an empirical analysis
5624#Concepts and applications of backup coverage
5625#Expected utility, penalty functions, and duality in stochastic nonlinear programming
5626#Sequencing capacity expansion projects in continuous time
5627#Decision rules and transactions, organizations and markets
5628#Reducing social context cues: electronic mail in organizational communication
5629#On "A quantity discount pricing model to increase vendor profits"
5630#Determining organizational effectiveness: another look, and an agenda for research
5631#Effectiveness as paradox: consensus and conflict in conceptions of organizational effectiveness
5632#Organizational information requirements, media richness and structural design
5633#The decision-making paradigm of organizational design
5634#Central problems in the management of innovation
5635#Inertia, environments and strategic choice: a quasi-experimental design for comparative-longitudinal research
5636#Virtual positions and power
5637#Inventory optimization in the U.S. petroleum industry: empirical analysis and implications for energy emergency policy
5638#Lead users: a source of novel product concepts
5639#New product strategy in small technology-based firms: a pilot study
5640#The relation between research and development project performance and technical communication in a developing country—Afghanistan
5641#Axiomatic foundation of the analytic hierarchy process
5642#Improved penalties for fixed cost linear programs using Lagrangean relaxation
5643#True interest cost in municipal bond bidding: an integer programming approach
5644#An adaptive filter for estimating spatially-varying parameters: application to modeling police hours spent in response to calls for service
5645#Flexible manufacturing systems: a review of analytical models
5646#Tournament methods in choice theory
5647#Hierarchical voting
5648#Control of social choice systems
5649#Asymptotic properties of the paths in a specific voting model
5650#On a class of best-choice problems
5651#Effect of data organization in a system of interleaved memories on the performance of parallel search
5652#Fuzzy Groups: some group-theoretic analogs
5653#On fuzzy convergence
5654#Design of optimal filters for error-feedback quantization of monochrome pictures
5655#An improved protocol validation technique for a class of communication models
5656#Direction-independent grammars with contexts
5657#On the average case analysis of some satisfiability model problems
5658#On the derivation of memberships for fuzzy sets in expert systems
5659#On two-dimensional pattern-matching languages and their decision problems
5660#Finding fundamental cycles and bridges on a tree-structured parallel computer
5661#Signal space geometry
5662#Lower bounds over codes correcting bursts with a given Lee weight or intensity
5663#On probability of forest of quadtrees reducing to quadtrees
5664#Inhomogeneities in the polynomial-time degrees: the degrees of super sparse sets
5665#The one-dimensional weighted Voronoi diagram
5666#Square-free words on partially commutative free monoids
5667#Nonisomorphic graphs with the same T-polynomial
5668#Two decidability problems for infinite words
5669#A novel representation of lists and its application to the function "reverse"
5670#On the rationality of Petri net languages
5671#O(1) space complexity deletion for AVL trees
5672#Exact computation of Steiner Minimal Trees in the plane
5673#Computing the minimum cover of functional dependencies
5674#Convex hull made easy
5675#An efficient algorithm for the transitive closure and a linear worst-case complexity result for a class of sparse graphs
5676#Total domination in interval graphs
5677#A note on the higher moments of the expected behavior of straight insertion sort
5678#Two tagless variations on the Deutsch-Schorr-Waite algorithm
5679#Election in a complete network with a sense of direction
5680#Splitmerge—a fast stable merging algorithm
5681#A note on the VLSI counter
5682#Deques with heap order
5683#Data compression and Gray-code sorting
5684#A controlled quantification in parsing of Montague grammar
5685#Optimal algorithms for finding the symmetries of a planar point set
5686#An O(log n)algorithm for parallel update of minimum spanning trees
5687#Market share rewards to pioneering brands: an empirical analysis and strategic implications
5688#On a minimum violations ranking of a tournament
5689#Uncertainty, experience, and the "Winner's Curse" in OCS lease bidding
5690#Unstable weights in the combination of forecasts
5691#The bias of schedules and playoff systems in professional sports
5692#A stochastic inventory model incorporating intra-year purchases and accounting tax incentives
5693#A sequencing problem with release dates and clustered jobs
5694#Multiattribute Bayesian acceptance sampling plans under nondestructive inspection
5695#A two-moment approximation for the mean waiting time in the GI/G/s queue
5696#Patience is a virtue in a simple model of repetitively joining a queue
5697#A remark on optimality of control limit rules
5698#In memoriam of Professor Hua Loo-Keng
5699#Highly accurate numerical solutions of elliptic boundary value problems on general regions
5700#Error estimates of two nonconforming finite elements for the obstacle problem
5701#Numerical analysis of bifurcation problems of nonlinear equations
5702#Finite element approximation to axial symmetric Stokes flow
5703#Particle approximation of first order systems
5704#Canonical integral equations of Stokes problem
5705#A recursive algorithm for computing the weighted Moore-Penrose inverse A+-MN-
5706#A finite element method of semi-discretization with moving grid
5707#On collocation methods for solving the neutron transport equation in two-dimensional problems
5708#Infinite element approximation to axial symmetric Stokes flow
5709#The convergence of numerical method for nonlinear Schro¨dinger equation
5710#On the convergence of quasi-conforming elements for linear elasticity problems
5711#Linear interpolation and parallel iteration for splitting factors of polynomials
5712#Multigrid method for elasticity problems
5713#An analysis of penalty-nonconforming finite element method for Stokes equations
5714#Numerical tests on convergence of the random choice method
5715#Two-dimensional reproducing kernel and surface interpolation
5716#The exact estimation of the Hermite-Feje´r interpolation
5717#A numerical method for a system of generalized nonlinear Schro¨dinger equations
5718#A system of plane elasticity canonical integral equations and its application
5719#The unsolvability of inverse algebraic eigenvalue problems almost everywhere
5720#The unsolvability of multiplicative inverse eigenvalue problems almost everywhere
5721#The perturbation analysis of the product of singular vector matrices UVT
5722#Numerical solution of Radon's problem in a two dimensional space
5723#Variable-elliptic-vortex method for incompressible flow simulation
5724#Local asymptotic expansion and extrapolation for finite elements
5725#The use of maximal monotone operators in the numerical analysis of variational inequalities and free boundary problems
5726#Difference schemes for Hamiltonian formalism and symplectic geometry
5727#Practical considerations for adaptive implicit methods in reservoir simulation
5728#The influence of differencing and CFL number on implicit time-dependent non-linear calculations
5729#A mixed pseudospectral finite difference method for the axisymmetric flow in a heated, rotating spherical shell
5730#A comparison of finite-element methods for solving flow past a sphere
5731#Relativistic inelastic scattering using a logarithmic grid
5732#Integral conditions for the pressure in the computation of incompressible viscous flows
5733#The method of inner boundary condition: A new approach for solving singular perturbation problems
5734#An isoparametric spectral element method for solution of the Navier-Stokes equations in complex geometry
5735#Spline-Galerkin solution of integral equations for three-body scattering above break-up
5736#Exact and approximate gas dynamics using the tangent gas
5737#Adiabatic particle hydrodynamics in three dimensions
5738#An Eulerian method for transient nonlinear free surface wave problems
5739#The convergence properties and stochastic characteristics inherent in force-biased and in Metropolis Monte Carlo simulations on liquids
5740#Some practical considerations in the use of Metropolis and force-biased Monte Carlo simulations on liquids
5741#A conservative treatment of zonal boundaries for Euler equation calculations
5742#Vortex dynamics of cavity flows
5743#On the solution of Poisson's equation on a regular hexagonal grid using FFT methods
5744#An accuracy analysis of boundary conditions for the forced shallow water equations
5745#On vector potential-vorticity methods for incompressible flow problems
5746#A special purpose computer for the electrical conductivity of disordered media
5747#A space-marching method for viscous incompressible internal flows
5748#Toroidally symmetric polynomial multipole solutions of the vector Laplace equation
5749#Computation of quasi-periodic solutions of forced dissipative systems II
5750#Collocation for an integral equation arising in duct acoustics
5751#On the numerical treatment of boundary singularities in elliptic problems
5752#High order finite-difference methods for two-point boundary value problems with singular sources
5753#Coulomb and Bessel functions of complex arguments and order
5754#Use of Monte Carlo techniques for complex angular momentum algebra calculations
5755#Contemporary electronics circuits deskbook
5756#The design of the UNIX operating system
5757#Shuffle of parenthesis systems and Baxter permutations
5758#Some intersection theorems for ordered sets and graphs
5759#Note on decomposition of spheres in Hilbert spaces
5760#Every finite group is the automorphism group of some perfect code
5761#Generalized Euler and Chu-Vandermonde identities
5762#Shanks' convergence acceleration transform, Pade´ approximants and partitions
5763#A new generalization of the Erdo¨s-Ko-Rado theorem
5764#All maximum 2-part Sperner families
5765#Regular hypergraphs, Gordon's lemma, Steinitz' lemma and invariant theory
5766#Hadamard matrices of order 28 with automorphism groups of order two
5767#Symmetries of plane partitions
5768#k-Rootsystems
5769#The number of subsets without a fixed circular distance
5770#Non-embeddable quasi-residual designs with kv
5771#Doubly homogeneous 2-(v, k, 1) designs
5772#On orthogonal Latin squares
5773#On the maximal number of edges of many faces in an arrangement
5774#Characterization of f-vectors of families of convex sets in Rd. Part II: Sufficiency of Eckhoff's conditions
5775#Characterization of projective planes of small prime orders
5776#On the cuts and cut number of the 4-cube
5777#The extension to root systems of a theorem on tournaments
5778#Q-Counting rook configurations and a formula of Frobenius
5779#Answers to two questions about semi-symmetric designs
5780#On growing a random young tableau
5781#Symmetry groups related to the construction of perfect one factorizations of K2n
5782#Minimally 3-connected graphs
5783#Switching classes of directed graphs
5784#Maximum matchings in a class of random graphs
5785#An exact threshold theorem for random graphs and the node-packing problem
5786#A class of distance-regular graphs that are Q-polynomial
5787#Perfect codes over graphs
5788#Proof of the strong 2-cover conjecture for planar graphs
5789#Sphericity exceeds cubicity for almost all complete bipartite graphs
5790#Directed switching games on graphs and matroids
5791#Extremal problems concerning Kneser graphs
5792#An extension of matching theory
5793#A survey of the asymptotic behaviour of maps
5794#Relaxations of vertex packing
5795#Signatures and signed switching classes
5796#A note on Cayley graphs
5797#On k-leaf-connected graphs
5798#Longest cycles in 3-connected cubic graphs
5799#Factors of regular graphs
5800#On a pursuit game played on graphs for which a minor is excluded
5801#Proportional transitivity in linear extensions of ordered sets
5802#Maximum induced trees in graphs
5803#The number of matchings in random regular graphs and bipartite graphs
5804#Graph minors. V. Excluding a planar graph
5805#Graph minors. VI. Disjoint paths across a disc
5806#Distance-hereditary graphs
5807#Geodetic graphs of diameter two and some related structures
5808#Graphs determined by their finite induced subgraphs
5809#Order properties of lines in the plane and a conjecture of G. Ringel
5810#On the matroids representable over GF(4)
5811#Hypertrees and Bonferroni inequalities
5812#Intersection graphs of paths in a tree
5813#Similarity reconstruction of trees
5814#Introduction to expert systems
5815#Expert system case study: the chocolate biscuit factory
5816#The practical significance of reliability calculations
5817#Energy production cost minimization by a process control system
5818#A capacitive sensor responding to mass rather than level of a liquid in a tank
5819#FORTH programming in control engineering
5820#Applying adaptive control - problems and solutions : a survey
5821#Evaluation of commercial available adaptive controllers
5822#Practical experiences with adaptive control of distillation columns
5823#Intelligent knowledge-based system for adaptive pid controller tuning
5824#Adaptive control of glass furnaces,gasification wells and fermentation processes : methods and experimental results
5825#A robotic manipulator controlled by means of a self-tuning controller
5826#Personal computer training software for adaptive control
5827#Adaptive adjustment of the weighting factors in a criterion
5828#Self-tuning of pid controllers based on process parameter estimation
5829#An industrial approach towards the development of a multivariable self-tuner
5830#Stability and regular points of inequality systems
5831#Norm duality for convex processes and applications
5832#Necessary conditions for upper semicontinuity in parametric semi-infinite programming
5833#On perturbations of certain nonconvex optimization problems
5834#Convexity and concavity properties of the optimal value function in parametric nonlinear programming
5835#Approximate first-order and second-order directional derivatives f a marginal function in convex optimization
5836#One-parameter families of optimization problems: Equality constraints
5837#Limiting lagrangians: A primal approach
5838#Rates of convergence for adaptive Newton methods
5839#Sensitivity analysis for variational inequalities
5840#Numerical examples of the behavior of REQP on nonlinear programming problems involving linear dependence among the constraint normals
5841#Dual-lattice theorems in the geometric approach
5842#Self-bounded controlled invariants versus stabilizability
5843#A Carathe´odory-Hamilton-Jacobi theory for infinite-horizon optimal control problems
5844#An optimal control problem in the study of liver kinetics
5845#Construction of large-scale global minimum concave quadratic test problems
5846#Characterization of constant policies in optimal control
5847#An approach to singular perturbation problems insoluble by asymptotic methods
5848#Existence theorems for games of survival
5849#An efficient line search for nonlinear least squares
5850#On the generation of updates for Quasi-Newton methods
5851#A characterization of positive semidefinite operators on a Hilbert space
5852#Algorithms for generalized inverses
5853#A method for minimizing the sum of a convex function and a continuously differentiable function
5854#Duality and existence theory for nondifferentiable programming
5855#A new constraint qualification condition
5856#Minimum-Fuel control of high-order systems
5857#An algorithm for composite nonsmooth optimization problems
5858#A generalization of a minimax theorem of Fan via a theorem of the alternative
5859#Essentials of structured BASIC
5860#Forecasting when pattern changes occur beyond the historical data
5861#Optimal timing of account audits in internal control
5862#A parametric approach to stochastic dominance: the lognormal case
5863#Using order statistics to estimate real estate bid distributions
5864#Expert resolution
5865#Another look at an axiomatic approach to expert resolution
5866#Comments on some axioms for combining expert judgments
5867#Calibration and the aggregation of probabilities
5868#Calibration and the expert problem
5869#Observations on expert aggregation
5870#Delays for customers from different arrival streams to a queue
5871#Preemptive scheduling of uniform machines by ordinary network flow techniques
5872#The multi-item capacitated lot size problem: error bounds of Manne's formulations
5873#Extending planning languages to include optimization capabilities
5874#Analysis and generalisation of a multivariate exponential smoothing model
5875#The variational gradient method
5876#Computer realization of the method of Newton diagrams
5877#Two schemes for a non-linear method of optimization in external problems
5878#On the approximation of a Pareto set
5879#Numerical solution of the third boundary value problem for an equation with a small parameter
5880#Asymptotic estimates of Green's function and the "difference step" in the case of Lipschitz-continuous coefficients
5881#Mathematical models of the quasistationary mode of magnetic self-insulation in vacuum transport lines
5882#Sturm solutions of the two-center problem of quantum mechanics
5883#Scattering of two-dimensional elastic waves by a cavity with a free boundary
5884#On numerical modelling of long surface and internal waves in a closed and slowly revolving tank
5885#One class of methods of unconditional minimization of a convex function, having a high rate of convergence
5886#A method of modelling exponential distributions transport theory
5887#A numerical method of calculating the neutron field in a three-dimensional rectangular cell of a reactor
5888#Diffraction of the field of an electric dipole on a spirally conducting finite one
5889#The setting in motion of a viscous liquid inside a two-dimensional cavity
5890#The consequences (unconnected with a change of state) of executing programs
5891#Regularization of the calculation of the lower bounds of functionals
5892#Energy functional for the abstract Cauchy problem
5893#The Runge-Kutta method for evaluating the Wiener integrals of exponential type functionals
5894#On some estimates of the penalty coefficient in methods of exact penalty functions
5895#Regularization of discontinuous numerical solutions of equations of hyperbolic type
5896#On computations of modes with peaking in problems of heat conduction
5897#Numerical solution of boundary value problems for fourth-order elliptic equations
5898#Numerical modelling of the non-stationary periodic flow of a viscous fluid in the wake behind a cylinder
5899#On the non-local nature of the behaviour of dissipative structures
5900#On the cycles generated by an arbitrary set of matrix elements
5901#Retrieval of maximum upper zero for minimizing the number of attributes in regression analysis
5902#On one criterion of the optimality of an algorithm for evaluating monotonic Boolean functions
5903#Remarks on choosing a regularization parameter using the quasioptimality and ratio criterion
5904#Evaluation of multidimensional integrals using Peono-curve type involutions
5905#A method for successive approximations of Bellman's function
5906#Two versions of the gradient method
5907#Asymptotic expansions of the eigenfunctions of a discrete spectrum of the problem of two Coulomb centres
5908#The behaviour of a medium with weak diffusion for large values of time
5909#A double-sided estimate of the solution of a non-linear integral equation
5910#Regularized methods of restoring quadratures optimum in classes of grids
5911#An efficient method for synthesizing correct recognition algorithms
5912#A generalized discrepancy principle for solving incompatible equations
5913#Calculation of the complex zeros of the modified Bessel function of the second kind and its derivatives
5914#On optimal choice of nodes when approximating functions by interpolation splines
5915#Minimax theory of weighted Monte Carlo methods
5916#The problem of linear programming with approximate data
5917#Numerical solution of variational elliptic inequalities of fourth order
5918#Singularly disturbed elliptic boundary value problem in a rectangle in the critical case
5919#The uniqueness of the solution of the first boundary value problem in an unbounded domain for a second-order parabolic equation
5920#The construction of difference schemes with positive approximation for equation of parabolic type
5921#On the asymptotic error expansions to finite difference methods
5922#Approximate and numerical methods for calculating the composition of an equilibrium plasma
5923#The applicability of the reduction method when solving algebraic systems in certain diffraction problems
5924#Synthesis of recognition and classification algorithms by the covering method
5925#On computational schemes of the regularization method
5926#On a multiplicative generator of pseudorandom numbers
5927#A stochastic method for solving a boundary value problem
5928#A quasimonotonic scheme for a quasilinear equation
5929#Mathematical models of the pronounced skin effect
5930#Calculation of chemically non-equilibrium jets of gas flowing into a vacuum
5931#Methods of local optimization for the problem of permutation bipartite graphs
5932#Methods of finding simultaneously all the roots of algebraic, trigonometric, and exponential equations
5933#Two-step iterative regularization methods
5934#Regularization of ill-posed problems of solving one-dimensional intergral equations in convolutions
5935#On a method of solving problems of best discrete approximation
5936#Evaluation of complex zeros of Bessel functionsJv(z) and Iv(z) and their derivatives
5937#The modelling of very long stationary Gaussian sequences with an arbitary correlation function
5938#On the efficiency of a modified local algorithm for solving discrete optimization problems
5939#Algorithms for the statistical modelling of the solution of elliptic-type boundary value problems
5940#The numerical solution of elliptic differential equations
5941#Diffraction of plane waves at a horizontal half-plane in a compressible stratified fluid
5942#Calculation of the pressure in stationary problems of ideal fluid dynamics
5943#Some algorithms for solving the covering problem, and their experimental study on a computer
5944#The convergency of the Kaczmarz projection algorithm
5945#A method of calculating the correlation characteristics of the brightness field in a stochastic medium by the Monte Carlo method
5946#The accuracy of monotonic schemes for rigid systems of differential equations
5947#Approximation of atomic wave functions and potentials by functions of Gaussian type
5948#A bicriterion problem of the scheduling theory taking the variation of servicing time into account
5949#The solution of systems of Boolean equations arising when constructing tests andsystems of Nelson's type
5950#On knowledge base management systems: integrating artificial intelligence and d atabase technologies
5951#On knowledge base management systems
5952#The knowledge level of KBMS
5953#Knowledge level interfaces to information systems
5954#On knowledge-based systems architectures
5955#A view of knowledge representation
5956#AI knowledge bases and databases
5957#Knowledge versus data
5958#Knowledge bases versus databases
5959#Knowledge-based and database systems: enhancements, coupling or integration?
5960#Inference: a somewhat skewed survey
5961#Current trends in database query processing: a survey
5962#Logic and database systems
5963#Negation in knowledge base management systems
5964#An approach to processing queries in a logic-based query language
5965#Naive evaluation of recursively defined relations
5966#Knowledge base retrieval
5967#Database management: a survey
5968#Logic and database systems: a survey
5969#PROBE: a knowledge-oriented database management system
5970#Learning improved integrity constraints and schemas from exceptions in databases and knowledge bases
5971#Organizing a design database across time
5972#Triggers and inference in database systems
5973#Extensible database systems
5974#Knowledge-based systems: a survey
5975#Natural language processing: a survey
5976#Questions, answers, and responses: interacting with knowledge base systems
5977#Learning in knowledge base management systems
5978#The role of databases in knowledge-based systems
5979#An integration of knowledge and data representation
5980#Context structures/versioning: a survey
5981#Survey of conceptual modeling of information systems
5982#A requirements modeling language and its logic
5983#Languages for knowledge bases
5984#Control of search and knowledge acquisition in large-scale KBMS
5985#New computer architectures: a survey
5986#The role of massive memory in knowledge base management systems
5987#Parallel computers for AI databases
5988#Concluding remarks from the Artificial Intelligence perspective
5989#Concluding remarks from the database perspective
5990#Large-scale knowledge-based systems: concluding remarks and technological challenges
5991#What to look for in a tax preparation package
5992#Micros in accountancy
5993#Spreadsheet planning and design
5994#Popular bookkeeping software for small business clients
5995#Pros and cons of multiuser accounting systems
5996#Tax benefits for business usage of the home PC
5997#Using lotus 1-2-3 as a time and billing system
5998#Developments in microcomputer software and hardware
5999#Designing advanced spreadsheets for small business clients
6000#Doing multiple regression analysis on lotus 1-2-3
6001#Concepts of k-convex n-person games
6002#On milnor's classes “L” and “D”
6003#The minmax theorem for u.s.c.-l.s.c. payoff functions
6004#Parallel implementations of the statistical cooling algorithm
6005#Fast execution for circuit consistency verification
6006#Lower bounds for vlsi implementation of residue number system architectures
6007#Computer algebra and logic programming
6008#On the models for designing VLSI asynchronous digital systems
6009#An automatic cell pattern generation system for CMOS transistor-pair array LSI
6010#VLSI architecture for device simulation
6011#On minimizing memory in systolic arrays for the dynamic time warping algorithm
6012#Information flow in VLSI design
6013#MASHER: An automatic VLSI layout system
6014#Yield optimization in wafer scale circuits with hierarchical redundancies
6015#Automatic determination of signal flow through MOS transistor networks
6016#The instruction systolic array, a parallel architecture for VLSI
6017#Signal resynchronization in VLSI for systems
6018#The inaccessible set: A classification by query type of security risks in statistical database
6019#On the complexity of some extended word problems defined by cancellation rules
6020#Halfplanar range search in linear space and O(n0.695) query time
6021#A new generalization of Dekker's algorithm for mutual exclusion
6022#The correctness of nondeterministic programs revisited
6023#A bit-string longest-common-subsequence algorithm
6024#Efficient computation of the locally least-cost insertion string for the LR error repair
6025#A linear algorithm for the cutting center of a tree
6026#When chasing your tail saves time
6027#L-attributed LL(1)-grammars are LR-attributed
6028#Gaussian elimination is optimal for solving linear equations in dimension two
6029#A simple characterization of database dependency implication
6030#On recurrent and recursive interconnection patterns
6031#Equivalent approximation algorithms for node cover
6032#Direction-independent application of productions on two-dimensional arrays
6033#O(n1/2) algorithms for the maximal elements and ECDF searching problem on a mesh-connected parallel computer
6034#Limits for automatic verification of finite-state concurrent systems
6035#Distributed termination detection algorithm for distributed computations
6036#An algorithm to generate a random cyclic permutation
6037#Horizontally and vertically bounded propagation of privileges
6038#An on-line pattern matching algorithm
6039#The space complexity of the unique decipherability problem
6040#Long edges in the layouts of shuffle-exchange and cube-connected cycles graphs
6041#The bounded subset sum problem is almost everywhere randomly decidable in O(n)
6042#On the maximum edge length in VLSI layouts of complete binary trees
6043#On ΔP2-immunity
6044#A note on the equivalence problem of rational formal power series
6045#A parallel reference counting algorithm
6046#A note on the queens' problem
6047#Data algebra and its application in database design
6048#A fully distributed (minimal) spanning tree algorithm
6049#Improving the worst-case performance of the Hunt-Szymanski strategy for the longest common subsequence of two strings
6050#Shortest paths in the plane with convex polygonal obstacles
6051#An implementation of mutual inclusion
6052#An application of Mehlhorn's algorithm for bracket languages to log(n) space recognition of input-driven languages
6053#An algorithm for the derivation of codefinitions in computer programs
6054#Comments on Morris's starvation-free solution to the mutual exclusion problem
6055#On gallery watchmen in grids
6056#On the probabilistic performance of algorithms for the satisfiability problem
6057#Area-time tradeoffs for bilinear forms computations in VLSI
6058#Turing complexity of the ordinals
6059#Finitely generated &ohgr;-languages
6060#Safety without stuttering
6061#A generalized deadlock predicate
6062#Towards an asymptotic analysis of Karmarkar's algorithm
6063#Hamiltonian circuits in interval graph generalizations
6064#Resolution deduction to detect satisfiability for another class including non-Horn sentences in propositional logic
6065#Eliminating the flag in threaded binary search trees
6066#The efficiency of using k-d trees for finding nearest neighbors in discrete space
6067#Ray tracing, ray casting, and other forms of point sampling are important techniques in computer graphics, but their usefulness has been undermined by aliasing artifacts. In this paper it is shown that these artifacts are not an inherent part of point sampling, but a consequence of using regularly spaced samples. If the samples occur at appropriate nonuniformly spaced locations, frequencies above the Nyquist limit do not alias, but instead appear as noise of the correct average intensity. This noise is much less objectionable to our visual system than aliasing. In ray tracing, the rays can be stochastically distributed to perform a Monte Carlo evaluation of integrals in the rendering equation. This is called distributed ray tracing and can be used to simulate motion blur, depth of field, penumbrae, gloss, and translucency.
6068#Exponential lower bounds are proved for the length-of-resolution refutations of sets of disjunctions constructed from expander graphs, using the method of Tseitin. Since these sets of clauses encode biconditionals, they have short (polynomial-length) refutations in a standard axiomatic formulation of propositional calculus.
6069#A continuum of disk scheduling algorithms, V(R), having endpoints V(0) = SSTF and V(1) = SCAN, is defined. V(R) maintains a current SCAN direction (in or out) and services next the request with the smallest effective distance. The effective distance of a request that lies in the current direction is its physical distance (in cylinders) from the read/write head. The effective distance of a request in the opposite direction is its physical distance plus R x (total number of cylinders on the disk). By use of simulation methods, it is shown that this definitional continuum also provides a continuum in performance, both with respect to the mean and with respect to the standard deviation of request waiting time. For objective functions that are linear combinations of the two measures, &mgr;w + kow, intermediate points of the continuum are seen to provide performance uniformly superior to both SSTF and SCAN. A method of implementing V(R) and the results of its experimental use in a real system are presented.
6070#Remark on "Disk Cashe—miss ratio analysis and design consideration"
6071#A measure of efficiency of simultaneous methods for determination of polynomial zeros, defined by the coefficient of efficiency, is considered. This coefficient takes into consideration (1) the R-order of convergence in the sense of the definition introduced by Ortega and Rheinboldt (Iterative Solution of Nonlinear Equations in Several Variables. Academic Press, New York, 1970) and (2) the number of basic arithmetic operations per iteration, taken with certain weights depending on a processor time. The introduced definition of computational efficiency was used for comparison of the simultaneous methods with various structures.
6072#Arithmetic codes resembling neural encoding
6073#Weighted minimum and maximun operations in fuzzy sets theory
6074#A short note on the redundancy of degree&agr;
6075#Stability of adaptive systems: passivity and averaging analysis
6076#Systems in stochastic equilibrium
6077#The stability and control of discrete processes
6078#Control systems engineering: modelling and simulation, control theory and microprocessor implementation
6079#Micros in accounting: estate planning software packages
6080#Moment redistribution in reinforced concrete frames
6081#Applications of correlation and spectral analysis to earthquake data
6082#Dynamics of clearance- type mechanical seals
6083#Linear stability of a binary fluid layer with freezing
6084#An experimental study of on-line computer control techniques applied to a doublepipe heat exchanger
6085#A modified Y-parameter model for computer-aided analysis using SPICE2
6086#Relationship between mobile charges and interface trap states in silicon MOS capcitors
6087#Two new methods for the synthesis of low sensitivity state feedback regulator
6088#Fundamental solutions for torsional problems of nonhomogeneous transversely isotropic media
6089#Solutions of plate problems by finite strip method with orthogonal collocation
6090#Numerical analysis of magnetic field distribution in an air gap with the effects of slot depth and width
6091#A two-phase testing technique for analog fault diagnosis systems
6092#Rotary effect on the constitutive equation of a rotational deformable object
6093#Strength development of blended blast-furnace slag-cement mortars
6094#Dilatancy rate for evaluating liquefaction potential of sands
6095#A model for measuring productive efficiency
6096#Salt effect of lithium bromide on the solution polymerization of acrylonitrile
6097#Model simplification of stable discrete-time systems by the squared magnitude Pade´ approximation
6098#The behavior of reinforcing bars under compression
6099#Prediction of moment redistribution in continuous prestressed concrete beams
6100#Strategies of using fly ash and their effect on properties of cement mortar
6101#Analysis of first-order partial differential equation via shifted chebyshev polynomials
6102#Assessment and improvement of viscosity models for miscible binary and ternary liquid mixtures
6103#Determination of A1xGa1-x as bandgap by Schottky barrier spectral response measurement
6104#An approach to the implementation and verification of abstract data
6105#Alternation with restrictions on looping
6106#Fast recognition of pushdown automaton and context-free languages
6107#The power of the future perfect in program logics
6108#Uniform characterizations of non-uniform complexity measures
6109#A zero-one law for logic with a fixed-point operator
6110#Optimal parallel pattern matching in strings
6111#Characterizations of multihead finite automata
6112#On space and time efficient TM simulations of some restricted classes of PDA's
6113#Optimal parallel algorithms for string matching
6114#There is no polynomial deterministic space simulation of probabilistic space with a two-way random-tape generator
6115#Symmetrical one-dimensional cellular spaces
6116#AVL-trees for localized search
6117#Lower time bounds for solving linear diophantine equations on several parallel computational models
6118#The critical complexity of all (monotone) Boolean functions and monotone graph properties
6119#Dynamic C-oriented polygonal intersection searching
6120#An algorithm for covering polygons with rectangles
6121#An easy proof of Greibach normal form
6122#On the progress of communication between two finite state machines
6123#Hash functions for priority queues
6124#Sloan Management Review
6125#Expert systems: the next challenge for managers
6126#End-user computing: are you a leader or a laggard
6127#Getting more out of DOS
6128#Analyzing those :20other” investments
6129#Transferring spreadsheet data for impact
6130#Managing your employees to level 3
6131#The new data base functionality
6132#Which dbase is right for you?
6133#Bigger, faster spreadsheets
6134#Living with a two-printer setup
6135#Graphics boards: what can they do for you?
6136#Tracking your competition: the on-line edge
6137#The new bounds of compatibility
6138#Non-impact printers: thermals, ink jets and lasers
6139#A detecting method for the fetal QRS complex with a small amplitude
6140#Overview of an architectural approach to the development of the Johns Hopkins Hospital distributed clinical information system
6141#Local network and distributed processiing issues in the Johns Hopkins Hospital
6142#Impact of computerization on laboratory staffing
6143#Portable and desktop microcomputers for patient care charting
6144#A performance-based management system to reduce prematurity and low birth weight
6145#Problems in establishing the medical expert systems CADIAG-1 and CADIAG-2 in rheumatology
6146#Hospital characteristics and the use of computer processing and abstract services: a logistic analysis
6147#Standardizing the Raster display for medical images using a fixed set of frame buffer primitives
6148#An inexpensive and portable talking-tactile terminal for the visually handicapped
6149#Design of an integral computer-based wheelchair controller/linear synchronous motor system
6150#Human factors design of a video monitor emulator and display (VMED) for visuallyimpaired computer users
6151#Dissemination of COSTAR: promises and realities
6152#Interactive videodisc to teach combat trauma life support
6153#Keyboards for the handicapped: a new concept
6154#A method linking statistics and knowledge engineering for making medical consulting systems: a medical consulting system for electric response audiometry through auditory slow vertex response
6155#Superallowed Fermi &bgr; decays, CVC and universality
6156#Excitation of swift heavy ions in foil targets. II. X-radiation from Br
6157#The mobility of K+ ions in helium and argon
6158#The LT-4 tokamak. II. MHD activity
6159#Dielectric tensor of weakly relativistic electron distributions separable in momentum and pitch angle
6160#Experimental determination of the imaging properties of a 200kV electron microscope
6161#Fast timing of air shower fronts
6162#Finite element calculations for non-radial oscillations of stars
6163#Flux densities, spectra and variability of pulsars at metre wavelengths
6164#Experimental aspects of the electroweak gauge theory
6165#Dependence of the universal constants on the nature of the maximum of the mapping function
6166#An analytic distorted wave approximation for electropion and photopion production on 12C near threshold
6167#Enhancement of parity violation for overlapping nuclear resonances
6168#The dependence of measured drift velocity on shutter open time in the four gauze time-of-flight method
6169#The application of Blanc's law to the determination of the diffusion coefficients for thermal electrons in gases
6170#The determination of the diffusion coefficient for thermal electrons in water vapour by the use of a modified Blanc's law procedure
6171#EXAFS spectroscopy by continuum soft X-ray emission from a short pulse laser-produced plasma
6172#Ionization growth between hyperboloidal needle and plane electrode under r.f. electric fields in N2. I. Image intensifier observations and the influence of spaces charge accumulations
6173#Ionization growth between hyperboloidal needle and plane electrode under r.f. electric fields, in N2. II. Spectroscopic investigations.
6174#A calculation of the room temperature elastic constants of caesium thiocyanate
6175#Is there a connection between local and global (in-)stability?
6176#The large numbers hypothesis and a relativistic theory of gravitation
6177#Alternative scheme of spontaneous chiral symmetry breaking
6178#Excitation function for 16O+24Mg elastic scattering at θc.m. = 90:9D
6179#Experimental study of noise temperature and conversion loss of SIS junction mixers
6180#Interpretation of backscattered HF radio waves from the sea
6181#Low temperate zone sporadic-E: seasonal and diurnal variations at Rarotonga
6182#Finite Larmor radius modifications to the magnetoionic wave modes and their effects on electron cyclotron maser emission
6183#Relativistic electron injection into axisymmetric pulsar magnetospheres
6184#Scattering of pulsar radiation and electron density turbulence in the interstellar medium
6185#Parity violation from SUSY vertex corrections in deep inelastic scattering
6186#A phenomenological nucleon-nucleon interaction
6187#The discrepancy in the Fermi matrix elements of the isospin-forbidden 4+:2WZ4+ β- decay of 46Sc
6188#Excited-state quenching phenomena in weakly ionised nitrogen
6189#Numerical simulation of positron diffusion in the heavy noble gases Ar, Kr and Xe
6190#Intensity correlation functions for 'thermalised' TEMn0 laser beams
6191#The influence of the spatial harmonics on the rotating magnetic field current drive
6192#Conduction electron scattering in alloys
6193#Phonon spectrum of ternary alloys
6194#Electronic structure of the principal uranium centre in alkali fluorides
6195#Variable precision logic
6196#Shading into texture
6197#A computer model of child language learning
6198#Independence and Bayesian updating methods
6199#Fusion, propagation, and structuring in belief networks
6200#Qualitative simulation
6201#Heuristic search through islands
6202#Pre- and post-processing software in geomechanics application of finite and boundary element packages
6203#Interactive microcomputer programs for linear and non-linear static analysis of frameworks
6204#SMART: Scientific database management and engineering analysis routines and tools
6205#Ray-tossing: a quick and dirty method for the interactive design of implicitly-defined surface
6206#Automated kinematic analysis of rock slope stability
6207#Depiction of friction damping in numerical flow modelling
6208#An expert system for preliminary numerical design modelling
6209#Numerical treatment of models arising in nuclear magnetic resonance spectroscopy
6210#The cost of internally developed applications: Analysis of problems and cost control methods
6211#Financial impact of information processing
6212#Adaptive information systems control: A reliability-based approach
6213#The application of prototyping to systems development: A rationale and model
6214#Integration of computer graphics and statistical procedures for decision support systems
6215#Effects of decision support training and cognitive style on decision process attributes
6216#Developing model strings for model managers
6217#Controlling the use and evolution of database systems: A Prolog-based approach
6218#Generating an optimal information system: PMAX-SDLC and the redirection of MIS research (or how to help Joe eat salmon)
6219#Controlling bias in user assertions in expert decision support systems for problem formulation
6220#Organizational factors affecting the success of end-user computing
6221#Capability criteria for marketing decision support system
6222#Adaptation of information systems building blocks to design forces
6223#Minisum location of a traveling salesman
6224#Shortest paths in networks with exponentially distributed arc lengths
6225#On the number of active nodes in a multicomputer system
6226#On finding Steiner vertices
6227#Solving stochastic programs with network recourse
6228#First- and second-order bounds on terminal reliability
6229#The minimum dummy task problem
6230#Fully abstract submodels of typed lambda calculi
6231#Polymorphic arrays: A novel VLSI layout for systolic computers
6232#An implicit data structure supporting insertion, deletion, and search in O(log:OS2:OEn) time
6233#Generating quasi-random sequences from semi-random sources
6234#A lower bound for probabilistic algorithms for finite state machines
6235#Probabilistic communication complexity
6236#Finding small simple cycle separators for 2-connected planar graphs
6237#Efficient symbolic analysis of programs
6238#A simple undecidable problem: Existential agreement of inverses of two morphisms of a regular language
6239#Conditional rewrite rules: Confluence and termination
6240#Uniform normal form for general time-bounded complexity classes
6241#Effective choice functions and index sets
6242#Domino-tiling games
6243#First-order logic and star-free sets
6244#"Global" graph problems tend to be intractable
6245#Reporting and counting segment intersections
6246#Automata-Theoretic techniques for modal logics of programs
6247#Threshold functions and bounded depth monotone circuits
6248#On the possibility and impossibility of achieving clock synchronization
6249#The complexity of elementary algebra and geometry
6250#Binary trees and uniform distribution of traffic cutback
6251#Reliable computation with cellular automata
6252#About the Paterson-Wegman linear unification algorithm
6253#Time-Space trade-offs for branching programs
6254#"During" cannot be expressed by "After"
6255#A multiparameter analysis of the boundedness problem for vector addition systems
6256#New algorithms for multilink robot arms
6257#A complete rule for equifair termination
6258#Quasi-varieties in abstract algebraic institutions
6259#Non first normal form relations: An algebra allowing data restructuring
6260#A theory of orbital behavior in a class of nonlinear systems: Chaos and a signature-based approach
6261#The bounded degree problem for NLC grammars is decidable
6262#A representation theorem of infinite dimensional algebras and applications to language theory
6263#Membership for growing context-sensitive grammars is polynomial
6264#Analysis of bounded linear cellular automata based on a method of image charges
6265#On Cournot-Nash equilibria with exogenous uncertainty
6266#A graphical method for a class of Branin trajectories
6267#A generalization of Fenchel duality theory
6268#Perturbation theory for mathematical programming problems
6269#The lion and man problem revisited
6270#Nondifferentiable fractional programming with Hanson-Mond classes of functions
6271#Optimal operation of multireservoir power systems
6272#Convergence of a feasible directions algorithm for a distributed optimal control problem of a parabolic type with terminal inequality constraints
6273#Silent-noisy marksmanship contest with random termination
6274#Monotone optimal decision rules and their computation
6275#The conjugate of the difference of convex functions
6276#Long-term optimal operation of a parallel multireservoir power system
6277#Existence theorems in vector optimization
6278#Duality theorem of nondifferentiable convex multiobjective programming
6279#Maximum principle of optimal periodic control for functional differential systems
6280#N-person differential games governed by infinite-dimensional systems
6281#Optimal control of a Timoshenko beam by distributed forces
6282#Modelling and optimization of reservoirs for long-term regulation with variable head using functional analysis
6283#On differentiable exact penalty functions
6284#Stochastic pursuit-evasion differential games in the plane
6285#On optimal periodic control and nested optimization problems
6286#On the solution of εy″ = y3
6287#A utilization of properties of the discrete-time Riccati equation in Stochastic realization theory
6288#On the existence of catching-up optimal solutions for Lagrange problems defined on unbounded intervals
6289#On the existence of overtaking trajectories
6290#A primal-dual Newton-type algorithm for geometric programs with equality constraints
6291#Optimal residence time policy for product yield maximization chemical reactors
6292#A Stochastic optimal control approach to a class of production and inventory problems
6293#Epsilon efficiency
6294#Optimal take-off trajectories in the presence of windshear
6295#Application of the sequential gradient-restoration to thermal convective instability problems
6296#On generating state space equations of a linear constant coefficient system
6297#Tactical problems involving uncertain actions
6298#More results in the convergence of iterative methods for the symetric linear complementarity problem
6299#Convergent stepsizes for constrained optimization algorithms
6300#A new look at Bellman's principle of optimality
6301#Consistency of a linear system of inequalities
6302#Prolog
6303#Bifurcation of extremals in optimal control
6304#Introduction to combinators and &lgr;-calculus
6305#Relaxation techniques for the simulation of VLSI circuits
6306#Computer talk for the liberal arts
6307#Information and records management: a decision-maker's guide to systems planning and implementation
6308#Infinite-valued logic based on two-valued logic and probability. Part 1.2. Different sources of fuzziness
6309#Computer decision support for senior managers: encouraging exploration
6310#Instructionless learning about a complex device: the paradigm and observations
6311#On the applied use of human memory models: the memory extender personal filing system
6312#Cognitive layouts of windows and multiple screens for user interfaces
6313#First Page of the Article
6314#First Page of the Article
6315#First Page of the Article
6316#First Page of the Article
6317#First Page of the Article
6318#Continuous analog of Newton method in the multichannel scattering problem
6319#Multiple-water-bag simulation of inhomogeneous plasma motion near an electrode
6320#Steady laminar forced convection from a circular cylinder
6321#Semi-implicit method for long time scale magnetohydrodynamic computations in three dimensions
6322#A method for reducing numerical dispersion in two-phase black-oil reservoir simulation
6323#The local evaluation of the derivative of a determinant
6324#The Fourier pseudospectral method with a restrain operator for the Korteweg-de Vries equation
6325#Block-implicit multigrid solution of Navier-Stokes equations in primitive variables
6326#Efficient computation of the Pru¨fer phase function for determining eigenvalues of Sturm-Liouville systems
6327#Application of the “generalized Riemann problem” method to 1-D compressible flows with material interfaces
6328#Finite-difference simulation of breaking waves
6329#Guiding center magnetostatic particle simulation model in three dimensions
6330#Predictions of fluid flow and heat transfer problems by the vorticity-velocity formulation of the Navier-Stokes equations
6331#Finding singular points of two-point boundary value problems
6332#3D nonlinear MHD calculations using implicit and explicit time integration schemes
6333#Some tests of precision for a finite element model of ocean tides
6334#Desingularization of periodic vortex sheet roll-up
6335#FLIP: A method for adaptively zoned, particle-in-cell calculations of fluid flows in two dimensions
6336#A dual algorithm for the calculation of the H1-0--transform
6337#Blending method for grid generation
6338#About the coupling of turbulence closure models with averaged Navier-Stokes equations
6339#Scattering of a pulse by a cavity in an elastic half-space
6340#A numerical solution for the nonlinear diffusion equation of the electromagnetic field in ferromagnetic materials
6341#The numerical solution of elliptic free boundary problems using multigrid techniques
6342#A fast computing technique for diffusion-type equations
6343#Fast direct Poisson solvers for high-order finite element discretizations in rectangularly decomposable domains
6344#An interesting set of simultaneous, nonlinear equations
6345#Application of a semi-implicit finite difference scheme to heat generation in explosives
6346#A vectorized "near neighbors" algorithm of order N using a monotonic logical grid
6347#High-frequency numerical-analytic approximations for the separable acoustic wave equation
6348#Locating the zeros of an analytic function
6349#An improvement of the finite-element series-expansion technique for linear water waves
6350#A nearly-implicit hydrodynamic numerical scheme for two-phase flows
6351#An integral equation technique for the exterior and interior Neumann problem in toroidal regions
6352#A relaxation approach to patched-grid calculations with the Euler equations
6353#Elements of a computational theory for glaciers
6354#Quasi-analytical method for solving nonlinear differential equations for turbulent self-confined magneto-plasmas
6355#Computation of turbulent supersonic flows around pointed bodies having crossflow separation
6356#A relativistic multiregion bounce-averaged Fokker-Planck code for mirror plasmas
6357#Numerical method for unitary systems
6358#Studies in numerical nonlinear instability. II. A new look at ut + uux = 0
6359#A time-implicit Monte Carlo collision algorithm for particle-in-cell electron transport models
6360#In memoriam: Raymond C. Grimm
6361#A new method for computing normal modes in axisymmetric toroidal geometry using a scalar form of ideal MHD
6362#Computation of visco-resistive MHD instabilities
6363#Numerical studies of toroidal resistive magnetohydrodynamic instabilities
6364#Accessibility of second regions of stability in tokamaks
6365#Finite-element semi-discretization of linearized compressible and resistive MHD
6366#Galerkin method for differential equations with regular singular points
6367#β limits in H-mode-like discharges
6368#Stellarator expansion methods for MHD equilibrium and stability codes
6369#Comparison of two-dimensional and three-dimensional MHD equilibrium and stability codes
6370#Ideal MHD properties for proposed noncircular tokamaks
6371#An orbit-averaged Darwin quasi-neutral hybrid code
6372#Dynamic modeling of transport and positional control of tokamaks
6373#Improving the convergence rate to steady state of parabolic ADI methods
6374#Computer implementation of an algorithm for the quadratic analytical solution of Hamiltonian systems
6375#An improved heat bath method for vectorized processing
6376#A block preconditioned conjugate gradient-type iterative solver for linear systems in thermal reservoir simulation
6377#An implicit Monte Carlo scheme for calculating time-dependent line transport
6378#Numerical solution of two-dimensional Stokes equations for flow with particles in a channel of arbitrary shape using boundary-conforming coordinates
6379#Solution of elliptic PDEs by fast Poisson solvers using a local relaxation factor
6380#A two-dimensional mesh moving technique for time-dependent partial differential equations
6381#A pseudospectral Legendre method for hyperbolic equations with an improved stability condition
6382#An application of the random choice method to reactive gas with many chemical species
6383#An adaptive characteristic Petrov-Galerkin finite element method for convection-dominated linear and nonlinear parabolic problems in one space variable
6384#Simplified second-order rezoning algorithm for generalized two-dimensional meshes
6385#The algorithm for three-dimensional Voronoi polyhedra
6386#Accelerating the convergence of an iterative method for derivatives of eigensystems
6387#Extension of the renormalized Numerov method for second-order differential eigenvalue equations
6388#On the interpolation of eigenvalues and a resultant integration scheme
6389#Numerical solution of Poisson's equation with arbitrarily shaped boundaries using a domain decomposition and overlapping technique
6390#Monte Carlo technique for simulating the evolution of an assembly of particles increasing in number
6391#Nonrelativistic numerical MCSCF for atoms
6392#The use of symmetry in bifurcation calculations and its application to the Be´nard problem
6393#A numerical comparison of one-dimensional fluid jet models applied to drop-on-demand printing
6394#A simple adaptive technique for nonlinear wave problems
6395#A pseudospectral method for the solution of the two-dimensional Navier-Stokes equations in the primitive variable formulation
6396#On nonlinear instabilities in leap-frog finite difference schemes
6397#The multidimensional positive definite advection transport algorithm: further development and applications
6398#A numerical model of the balance equations in a periodic domain and an example of balanced turbulence
6399#On operator splitting for unsteady boundary value problems
6400#Closed form expressions for an integral involving the Coulomb potential
6401#The use of Cebysev mixing to generate pseudo-random numbers
6402#One can associate with an arbitrary algebroid formal group law F, defined over F"p, a sequence [n]"F(x@?) (= [n - 1]"F(x@?) @?"Fx@?). These sequences for various F (multiplicative group, reduced elliptic curves and Abelian varieties) provide a variety of new primality tests like Lucas' test for Mersenne primes. Implementations and relations with factorization algorithms are presented.
6403#Global bifurcation and attractivity of stationary solutions of a degenerate diffusion equation
6404#Prediction of RNA secondary structure from the linear RNA sequence is an important mathematical problem in molecular biology. Dynamic programming methods are currently the most useful computer technique but are frequently very expensive in running time. In this paper new dynamic programming algorithms are presented which reduce the required computation. The first polynomial time algorithm is given for predicting general secondary structure.
6405#The main structure underlying the nonlinearity of conservation laws of gasdynamical type in two independent variables will be discussed at the hand of a canonical example describing also properties of water waves near shore. The ultimately singular nature of such laws is here the central issue and calls for an unusual formulation (Sect. 2). Attention is directed to the globally strong solutions, and an unusual regularization (Sect. 2) is employed to make them accessible, after illposedness is overcome (Sect. 3). The usual regularity theory is not normally sufficient for singular partial differential equations, and the necessary additional chapter on extensions to the singular locus is developed (Sect. 4) in detail for the canonical example. Criteria for the relation between regularized and strong solutions are discussed in Section 5 and used in Section 6 to characterize the class of solutions that are globally strong in the strictest sense.
6406#A portable Ada implementation of index sequential input-output, part 2
6407#Ada information hiding - a design goal missing?
6408#Dereference the reference manual
6409#The ATMAda environment: an enhanced APSE
6410#Ackermann's function in Ada
6411#This paper describes a method for drawing Ada structure charts and "with"ing trees. This method was used at GTE in developing the Ada version of a project management tool, TRACKER, for NOSC. The paper defines a set of symbols for various Ada entities. It further describes how these symbols can be combined to show nesting, packaging, "with"ing, generic instantiation, exported procedures and data, or any combination thereof. It also shows how visibility can be easily traced from the structure chart. Several examples are shown, including portions of the actual chart for Tracker. The paper concludes with a brief discussion of the benefits and limitations of this method, and compares it to those of Booch and Buhr.
6412#Generic implementation via analogies in the Ada programming languages
6413#Task coupling and cohesion in Ada
6414#Classifying Ada packages
6415#Transformation of structured data schemata into Ada language statements
6416#Several attempts have been made to define notations for diagrams that can represent the structure of an Ada program in terms of the interaction between its packages and tasks1, 2, 3. While handling the issue of visibility fairly well, none of these gives any guidance for the more difficult areas of Ada, such as generics, task creation and exceptions. The notation described here is complete. It employs a few carefully chosen features in a consistent way to construct an easily understandable chart of an Ada system. The notation is adaptable for use by hand or by computers with graphic capabilities.
6417#A specification for Ada machine code insertions
6418#An example of the developer's documentation for an embedded computer system written in Ada
6419#This paper describes an algorithm for forward chaining in rule-based production expert systems which makes extensive use of array structures and Boolean operations, to which APL lends itself. Additionally, a short introduction is provided for the reader unfamiliar with expert systems.
6420#Emulating Prolog in an IBM PC APL environment
6421#Trees and networks using APL2
6422#Minnowbrook APL workshop
6423#168 Global character string search and replace
6424#Zeros, identities and critical path
6425#We propose a natural extension of the "enclose" general array function, and describe its use in representing complicated data structures such as trees with (possibly) shared branches. We give two examples of the use of the extension, one each in symbolic algebra and in graphics.
6426#The fast Fourier transformation implemented in APL
6427#An adaptive quadrature routine
6428#An automatic adaptive integration routine in APL
6429#Economic lot scheduling
6430#Dp, the terror target
6431#The CIM connection
6432#In pursuit of CIM
6433#Information asset management
6434#Avoiding a crisis
6435#To stop another Bhopal
6436#Nowhere but up
6437#The DASD time bomb
6438#An eye on optical disks
6439#Dancing with the elephant
6440#Another tangled network
6441#Grafting a wonder office system
6442#Half empty or half full?
6443#OA banks on connectivity
6444#Planning and building a DSS
6445#The sharing of ATMs
6446#But what about quality?
6447#Micros in accounting: a comparison of integrated accounting programs
6448#3DPO: A three-dimensional part orientation system
6449#The representation, recognition, and locating of 3-d objects
6450#Mechanics and planning of manipulator pushing operations
6451#Toward efficient trajectory planning: the path-velocity decomposition
6452#Planning of minimum-time trajectories for robot arms
6453#Estimation of inertial parameters of manipulator loads and links
6454#Simplification and linearization of manipulator dynamics by the design of inertia distribution
6455#Computer-assisted generation of dynamical equations
6456#An unconditionally implicit direct integration method for linear structural dynamics
6457#A limit equilibrium method for analyzing progressive failure in slopes
6458#Growth kinetics and cultivation of spirulina platensis
6459#Removal of lindane from water by activated carbon in the bisolute adsorption system
6460#Optimum design of a cogeneration system in processes
6461#A key-lock-pair mechanism based on generalized chinese remainder theorem
6462#Transient ignition on a flat plate
6463#Effect of probe orientation on hot-film/CTA velocity measurements in stirred tanks and a simplified measuring method
6464#Polling of two correlated queues under three service disciplines in discrete- time environment
6465#A graphic approach to draw the S-curves for the symbol synchronizers
6466#Asymptotic stability of quasi-stationary tracking systems with parameter variations
6467#A computer aided design system for artistic chinese fonts
6468#Enhancing your data base reports
6469#Reorganizing your hard disk
6470#Powerful ways to link the small department
6471#Driving your point home
6472#On computing in multiuser environments
6473#Saving money with speedier communications
6474#Write faster
6475#Making your sales force more productive
6476#Breaking away
6477#EGA boards and monitors
6478#Cost-benefit of laboratory computer systems
6479#Hospital information systems—friend or foe? a management perspective
6480#Prescription: office automation
6481#The request for proposal (RFP): the key document in successful systems acquisition
6482#Evaluating the contribution to a hospital of specific physicians through the use of a financial and social weighting criterion developed on a microcomputer
6483#Maximizing the benefits of health care information systems
6484#An incentive management plan for hospital-based physicians
6485#Market model addresses hospitals' need for decision support
6486#The computerized severity index: a new tool for case-mix management
6487#Design of a management support system for hospital strategic planning
6488#Does your hospital need a robot or a management trainer? On advising the health care executive who is interested in innovation, but uncommitted to it
6489#Introduction to the papers on computer-assisted instruction in nursing
6490#Preparing faculty to use and develop computer-based instructional materials in nursing
6491#A regression model to identify successful learner traits with CAI
6492#Developing computer simulations for staff nurse education
6493#The impact of microcomputers on program excellence
6494#Computer-assisted instruction: an overview
6495#The POSCH data processing experience: the problem of metadata
6496#Medical diagnostic support for spacecraft: the NASA project
6497#An information theoretic method for classifying patients according to the risk of adverse hospital incidents
6498#Big blue tiptoes into India
6499#Beta site politics
6500#1986 Dp budget survey
6501#Relating to database machines
6502#The trouble with application generators
6503#Who's maintaining the micros?
6504#Stalking the wilds of the pc market
6505#Micro applications development
6506#Wall Street: Cautiously upbeat on micros
6507#The high-tech express
6508#GE's electronic corporate ladder
6509#Users and vendors: Bound to win?
6510#Does guide need guidance?
6511#Vendors hunt for the key to success
6512#Improving productivity at Northern Trust
6513#Gambling on RISC
6514#RISC: Back to the future?
6515#MIPS, Dhrystones, and other tales
6516#My data, right or wrong
6517#What ever happened to structured analysis?
6518#Getting from here to there: No way
6519#Into the night
6520#Quest for darkness
6521#No DBMS is an island
6522#The heat is on
6523#All sizzle and no steak
6524#Federal computing: The good & the bad
6525#Automation in the White House
6526#Truths, half-truths, and statistics
6527#Mergers: A raw deal for MIS?
6528#Salary survey: Small change for dp pros
6529#Computer maintenance goes on-line
6530#Sorting out the solutions
6531#SEI: The software battleground
6532#Third-party maintenance grows up
6533#Is home banking for real?
6534#Coming of age
6535#Battling for new roles
6536#Border patrol
6537#Is anyone really using computer consultants?
6538#Milestone management
6539#OTIS to the rescue
6540#Rapid prototyping revisited
6541#Tracking America's health
6542#Tall in the saddle
6543#New ports of call
6544#MIS rates the issues
6545#Master plan for LANs
6546#AMEX designs an OLTP system
6547#Software discounting continues
6548#Getting carried away
6549#The ABCs of printing
6550#Taming the DSAD monster
6551#A new climate for leasing
6552#Unix customers pressure AT&T
6553#Battle lines are being drawn
6554#Pyramid hits the skids
6555#Brokerages discover pcs
6556#IBM pricing irks users
6557#First Page of the Article
6558#First Page of the Article
6559#First Page of the Article
6560#First Page of the Article
6561#First Page of the Article
6562#First Page of the Article
6563#First Page of the Article
6564#First Page of the Article
6565#An exact penalty function method with global convergence properties for nonlinear programming problems
6566#A two-stage feasible directions algorithm for nonlinear constrained optimization
6567#Two algorithms for weighted matroid intersection
6568#Inexact Newton methods for the nonlinear complementarity problem
6569#A note on optimality conditions for the Euclidean multifacility location problem
6570#Error bounds for monotone linear complementarity problems
6571#Convex quadratic programming with one constraint and bounded variables
6572#Uniqueness and differentiability of solutions of parametric nonlinear complementarity problems
6573#Continuous maximin knapsack problems with GLB constraints
6574#A successive quadratic programming algorithm with global and superlinear convergence properties
6575#A recursive quadratic programming algorithm that uses differentiable exact penalty functions
6576#A class of convergent primal-dual subgradient algorithms for decomposable convex programs
6577#A capacity-rounding algorithm for the minimum-cost circulation problem: A dual framework of the Tardos algorithm
6578#A regularized decomposition method for minimizing a sum of polyhedral functions
6579#Solving multiple criteria problems by interactive decomposition
6580#On the average length of lexicographic paths
6581#A note on degeneracy in linear programming
6582#Characterizing an optimal input in perturbed convex programming: Corrigendum
6583#The expected number of extreme points of a random linear program
6584#Random inequality constraint systems with few variables
6585#Improved asymptotic analysis of the average number of steps performed by the self-dual simplex algorithm
6586#Polynomial expected behavior of a pivoting algorithm for linear complementarity and linear programming problems
6587#Low order polynomial bounds on the expected performance of local improvement algorithms
6588#On the expected number of linear complementarity cones intersected by random and semi-random rays
6589#On the average speed of Lemke's algorithm for quadratic programming
6590#On linear programs with random costs
6591#A finite characterization of K-matrices in dimensions less than four
6592#Continuity of the null space basis and constrained optimization
6593#Additively decomposed quasiconvex funtions
6594#A relaxed projection method for variational inequalities
6595#Broyden's method in Hilbert space
6596#A simple constraint qualification in infinite dimensional programming
6597#The method of successive affine reduction for nonlinear minimization
6598#Some comments of Wolfe's `away step'
6599#A competitive (dual) simplex method for the assignment problem
6600#Network design problem with congestion effects: A case of bilevel programming
6601#Global minimization of large-scale constrained concave quadratic problems by separable programming
6602#A method of linearizations for linearly constrained nonconvex nonsmooth minimization
6603#An algorithm for finding the global maximum of a multimodal, multivariate function
6604#On the stability of invariant capital stock in a two-dimensional planning model
6605#A generalized linear production model: A unifying model
6606#A linear expected-time algorithm for deriving all logical conclusions implied by a set of Boolean inequalities
6607#On Fan's minimax theorem
6608#A nonlinear equation for linear programming
6609#Even more with the Lemke complementarity algorithm
6610#Nonlinear programming and stationary strategies in stochastic games
6611#Sensitivity theorems in integer linear programming
6612#Linear complementarity problems with an invariant number of solutions
6613#Affirmative action algorithms
6614#The Manne-Chao-Wilson algorithm for computing competitive equilibria: A modified version and its implementation
6615#Critical sets in parametric optimization
6616#An implementation of a discretization method for semi-infinite programming
6617#On the continuity of a Lagrangian multiplier function in input optimization
6618#Binary group and Chinese postman polyhedra
6619#How bad are the BFGS and DFP methods when the objective function is quadratic?
6620#On box totally dual integral polyhedra
6621#Random linear programs with many variables and few constraints
6622#Facet inequalities from simple disjunctions in cutting plane theory
6623#Structure of the first-order solution set for a class of nonlinear programs wit h parameters
6624#Convergence of an annealing algorithm
6625#Hamilton cycles in Euler tour graph
6626#Interval representations of planar graphs
6627#Concerning the achromatic number of graphs
6628#On the cycle polytope of a binary matroid
6629#An integer analogue of Carathe´odory's theorem
6630#The chromatic index of nearly bipartite multigraphs
6631#Representing abstract groups by powers of a graph
6632#A common cover of graphs and 2-cell embeddings
6633#Spectral bounds for the clique and independence numbers of graphs
6634#Cayley digraphs of prime-power order are Hamiltonian
6635#Dynamic modelling and analysis of a wind turbine with variable speed
6636#Modelling and control of bioreactors: an illustrative case study
6637#Aspects of dynamic models of robots
6638#An invariable matrix product for iterative deconvolution
6639#The computer-aided design of a servo system as a multiple-criteria decision problem
6640#About the legal protection of control knowledge
6641#A survey of exact algorithms for the simple assembly line balancing problem
6642#Financial futures hedging via goal programming
6643#Search theory and the manufacturing progress function
6644#Arbitrating a dispute: a decision analytic approach
6645#Inventory service-level measures: convexity and approximation
6646#The effect of commonality on safety stock in a simple inventory model
6647#Heuristics for multilevel lot-sizing with a bottleneck
6648#A generalized network formulation of the pairwise comparison consensus ranking model
6649#Game theory and cost allocation problems
6650#A game theoretic approach to collections and disbursements
6651#Searching for positive returns at the track: a multinomial logic model for handicapping horse races
6652#Risk preferences for gains and losses in multiple objective decision making
6653#A model for the distribution of the number of bids on federal offshore oil leases
6654#A multiplier adjustment method for the generalized assignment problem
6655#Optimal residence times for a batch biomass-to-methane conversion system
6656#The channel intermediary selection decision: a model and an application
6657#Value functions for infinite-period planning
6658#The multiregional dynamic capacity expansion problem: an improved heuristic
6659#Optimal capacity expansion planning when there are learning effects
6660#Incorporating learning curve analysis into medium-term capacity planning procedures: a simulation experiment
6661#A generalized quantity discount pricing model to increase supplier's profits
6662#Forecasting error evaluation in material requirements planning (MRP) production-inventory systems
6663#Detection of nonstationarity in hydrologic time series
6664#Retrofit doesn't necessarily mean upgrade
6665#Will you be replaced by a knowledge base?
6666#Upgrading and retrofitting: where the action is
6667#Building performance indices: raw-data distillation for process optimization
6668#Applying PLCs and PCs in offshore platform safety shutdown systems
6669#Hierarchical diagramming communicates control-system design concepts
6670#Integrated automation for pulp and paper mills
6671#Adapting expert systems to simulation training of process operators
6672#The expanding use of personal computers in batch chemical process control
6673#Solar photovoltaic power supplies
6674#Why MAP makes sense for the process industries: an interview with Michael A Kaminski, ISA/86 MAP Symposium Keynote Speaker
6675#Networking and information management: Its use by the project planning function
6676#The feature chart: A tool for communicating the analysis for a decision support system
6677#Role of data dictionaries in information resource management
6678#A critical view of factors affecting successful application of normative and socio-technical systems development approaches
6679#Sixth International Conference on information systems
6680#The success of DP charge-back systems from a user's perception
6681#An assessment of alternative application development approaches
6682#Applying a pilot system and prototyping approach to systems development and implementation
6683#Tax administration - information on IRS' Philadelphia Service Center
6684#Fifth Annual Office Systems Research Conference
6685#Issues in information systems planning
6686#On program development effort and productivity
6687#A survey of information technology in the U.K. service sector
6688#Insights on the implementation of a computer-based message system
6689#CHI '86 - human factors in computing systems
6690#Electronic banking and telecommunications
6691#Integrating systems into the organization
6692#The use of financial modelling in strategic planning
6693#Do computer systems really pay-off?
6694#Decision support systems: A decade in perspective
6695#Information systems design methodology
6696#IFIP WG8.1 conference in the CRIS series: Computerized assistance during the systems life cycle
6697#On-stream analyzer: Using the signals once you have them
6698#Control system engineering: Have we gone wrong?
6699#On-stream analyzer: Handle with kid gloves
6700#Remote and in-situ composition analysis: Have your cake, eat it too
6701#Solving a tough valve problem: A power plant case history
6702#PC's: Moving toward integration
6703#Personal computer monitoring system improves operations economics
6704#Local work station concepts in a small distributed system
6705#Electronic data base searching
6706#Wave-based sensor technologies: user/vendor harmony improves
6707#Scanning electron microscopy: A tool for all technologies
6708#Liquid and gas process streams analyzed by a single FTIR system
6709#Online wear-particle monitoring based on ultrasonic detection
6710#Design by exmple: An application of Armstrong relations
6711#Querying logical databases
6712#Deadlock-Freedom (and safety) of transactions in a distributed database
6713#Chordality properties on graphs and minimal conceptual connections in semantic data models
6714#Partition semantics for relations
6715#Equivalence of views by query capacity
6716#Concurrent operations on B*-trees with overtaking
6717#Algorithmic aspects of multiversion concurrency control
6718#Witold Lipski, Jr. (1949-1985)
6719#Guidance strategies for near-optimum take-off performance in a windshear
6720#On the Kleinrock-Nilsson problem of optimal scheduling algorithms for time- shared systems
6721#An on-line procedure in discounted infinite-horizon Stochastic optimal control
6722#Complete controllability
6723#Stabilization of a class of hybrid systems arising in flexible spacecraft
6724#Modified quasilinearization algorithm for optimal control problems with non differential constraints and general boundary conditions
6725#Sufficient conditions for a strong relative minimum in an optimal control problem
6726#A model for real poker with an upper bound of assets
6727#Simplical zero-point algorithms: a unifying description
6728#A note on an algorithm for generalized fractional programs
6729#Sufficiency and game structure in Nash open-loop differential games
6730#A finite algorithm for finding the projection of a point onto the Canonical simplex of Rn
6731#Existence of optimal controls for a class of systems governed by differential inclusions on a Banach space
6732#Tracking control of high-performance robots via stabilizing controllers for uncertain systems
6733#Global maxima of raal-valued functions
6734#On the intersection of controllable and reachable sets
6735#Duality in inexact programming with set-inclusive constraints
6736#Convex semi-infinite games
6737#On the null controllability of linear discrete-time systems with restrained controls
6738#Numerical solution of minimax optimal control problems by multiple shooting technique
6739#On the Isaacs equation of differential games of fixed duration
6740#On convergence properties of a least-distance programming procedure for minimization problems under linear constraints
6741#On detection of the number of signals in presence of white noise
6742#On detection of the number of signals when the noise covariance matrix is arbitrary
6743#Limiting spectral distribution for a class of random matrices
6744#Multivariate splines: a probabilistic perspective
6745#Random approximations to some measures of accuracy in nonparametric curve estimation
6746#Strong approximations of the Q-Q process
6747#Limits of translation invariant experiments
6748#Hitting a boundary point by diffusions in the closed half space
6749#Characterization of Hilbert spaces by the strong law of large numbers
6750#Estimation of parameters for Hilbert space-valued partially observable Stochastic processes
6751#On powerful distributional tests based on sample spacings
6752#Two-sided bounds and leading term for rates of convergence in the multivariate central limit theorem
6753#On the errors-in-variables problem for time series
6754#Bandwidth choice for differentiation
6755#On certain random simplices in Rn:OE
6756#Central limit theorem for perturbed empirical distribution functions evaluated at a random point
6757#Positive definite symmetric functions on finite dimensional spaces. I. Applications of the Radon transform
6758#Invariance principles under weak dependence
6759#Tightness problem and Stochastic evolution equation arising from fluctuation phenomena for interacting diffusions
6760#Supplements to operator-stable and operator-semistable laws on Euclidean spaces
6761#Domains of attraction of nonnormal operator-stable laws
6762#Local times of continuous N-parameter strong Martingales
6763#Convergence properties of an empirical error criterion for multivariate density estimation
6764#Selecting a minimax estimator doing well at a point
6765#Spectral factorization of wide sence stationary processes on Z2
6766#Approximating hierarchical normal priors using a vague component
6767#Bimeasures and measures induced by Planar Stochastic integrators
6768#Stop rule and supremum expectations of i.i.d. random variables: a complete comparison by conjugate duality
6769#Two Lil-type results for the Brownian bridge
6770#Recent contributions to the embedding problem for probability measures on a locally compact group
6771#Generalized least squares estimation of the functional multivariate linear errors-in-variables model
6772#Optimal stratification and clustering on the line using the L1-norm
6773#The greatest invariance-group of multivariate models
6774#Gaussian measures on Orlicz spaces and abstract Wiener spaces
6775#A remark on semiparametric models
6776#On limiting spectral distribution of product of two random matrices when the underlying distribution is isotropic
6777#Asymptotic distribution of the increase of the largest canonical correlation when one of the vectors is augmented
6778#The problem of identification of parameters by the distribution of the maximum random variable
6779#Second order asymptotics in nonlinear regression
6780#Computation of the maximum likelihood estimate of a noncentrality parameter
6781#Parametric estimation for simple branching diffusion processes,II
6782#Prophet regions and sharp inequalities for pth absolute moments of Martingales
6783#Random creation and dispersion of mass
6784#Applications of integration by parts formula for infinite-dimensional semimartingales
6785#On specifications,theories, and models with higher types
6786#Probabilistic analysis of a network resource allocation algorithm
6787#Relational queries computable in polynomial time
6788#New upper bounds for neighbor searching
6789#A modal characterization of observational congruence on finite terms of CCS
6790#A polynomial jump operator
6791#Sorting Jordan sequences in linear time using level-linked search trees
6792#The position of index sets of identifiable sets in the arithmetical hierarchy
6793#A superexponential lower bound for Gro¨bner bases and church-Rosser Commutative Thue systems
6794#An optimally data efficient isomorphism inference algoithm
6795#Syntax directed analysis of liveness properties of while programs
6796#A logic for the description of nondeterministic programs and their properties
6797#First Page of the Article
6798#First Page of the Article
6799#First Page of the Article
6800#First Page of the Article
6801#First Page of the Article
6802#Synchronization errors in concurrent programs are notoriously difficult to find and correct. Deadlock, partial deadlock, and unsafeness are conditions that constitute such errors.A model of concurrent semaphore programs based on multidimensional, solid geometry is presented. While previously reported geometric models are restricted to two-process mutual exclusion problems, the model described here applies to a broader class of synchronization problems. The model is shown to be exact for systems composed of an arbitrary, yet fixed number of concurrent processes, each consisting of a straight line sequence of arbitrarily ordered semaphore operations.
6803#Naming and addressing are areas in which there is still a need for clarification. Many definitions for names, addresses, and routes have been proposed, but the exact relations among these concepts are obscure. A taxonomy of names, addresses, and routes is presented. First, we identify names and routes as the essential concepts of communication. Then, addresses are introduced as an intermediate form that eases the process of mapping between names and routes; an original definition of an address is thus proposed. Relations among names, addresses, and routes are explained with the concept of mapping. On this basis, a general model relating names, addresses, and routes is built and then applied recursively throughout a layered architecture, leading to a layered naming and addressing model which may play the same role for naming and addressing features that the OS1 reference model plays for the definition of services and protocols. Finally, the model is particularized to a typical network architecture. The model may also be applied to non-OSI layered systems; naming, addressing, and routing issues in any network architecture could be a particular instance of this layered model.
6804#Every information system incorporates a database component, and a frequent activity of users of information systems is to present it with queries. These queries reflect the presuppositions of their authors about the system and the information it contains. With most query processors, queries that are based on erroneous presuppositions often result in null answers. These fake nulls are misleading, since they do not point out the user's erroneous presuppositions (and can even be interpreted as their affirmation). This article describes the SEAVE mechanism for extracting presuppositions from queries and verifying their correctness. The verification is done against three repositories of information: the actual data, their integrity constraints, and their completeness assertions. Consequently, queries that reflect erroneous presuppositions are answered with informative messages instead of null answers, and user-system communication is thus improved (an aspect that is particularly important in systems that often are accessed by naive users). First, the principles of SEAVE are described abstractly. Then, specific algorithms for implementing it with relational databases are presented, including a new method for storing knowledge and an efficient algorithm for processing queries against the knowledge.
6805#In order to apply office automation in a meaningful fashion, it is apparent that some understanding of the office is necessary. Most descriptive studies of the office have placed great emphasis on manifest office actions, suggesting that offices are the embodiment of these actions. The meanings of these actions or tasks, however, have been given scant attention. There exist a number of office activity or task taxonomies, but they do little more than provide a simple and limited structure through which to conceive of an office. From a social-analytic perspective this appears to be overly simplistic and misses the richness of social action in an office. Focusing on the overt and manifest aspects of the office may very well lead to its misrepresentation. This paper takes a critical look at the way offices are conceived in the office automation literature and suggests alternatives that may provide a better understanding of the real functions of an office.
6806#MINOS is an object-oriented multimedia information system that provides integrated facilities for creating and managing complex multimedia objects. In this paper the model for multimedia documents supported by MINOS and its implementation is described. Described in particular are functions provided in MINOS that exploit the capabilities of a modern workstation equipped with image and voice input-output devices to accomplish an active multimedia document presentation and browsing within documents. These functions are powerful enough to support a variety of office applications. Also described are functions provided for the extraction of information from multimedia documents that exist in a large repository of information (multimedia document archiver) and functions that select and transform this information. Facilities for information sharing among objects of the archiver are described; an interactive multimedia editor that is used for the extraction and interactive creation of new information is outlined; finally, a multimedia document formatter that is used to synthesize a new multimedia document from extracted and interactively generated information is presented.This prototype system runs on a SUN-3 workstation running UNIX'". An Instavox, directly addressable, analog device is used to store voice segments.
6807#Recursive source coding: a theory for the practice of waveform coding
6808#Managing computer projects
6809#Computer simulation and modelling
6810#The compound Poisson distribution
6811#A functional approach to program testing and analysis
6812#On multisystem coupling through function request shipping
6813#Allocating programs containing branches and loops within a multiple processor system
6814#Decomposition and aggregation by class in closed queueing networks
6815#Controllability of computer performance tradeoffs obtained using controlled-share queue schedulers
6816#Whether software engineering needs to be artificially intelligent
6817#Experimentation in software engineering
6818#Advances in software inspections
6819#Knowledge-based programming: a survey of program design and construction techniques
6820#Programming in the large
6821#Specification of modular systems
6822#Two-dimensional program design
6823#Flexible software development for multiple computer systems
6824#Reuse of software through generation of partial systems
6825#A structure editor for abstract document objects
6826#Dynamic storage fragmentation and file deterioration
6827#Derivation of a parallel algorithm for balancing binary trees
6828#Approximate analysis of open networks of queues with blocking: Tandem configurations
6829#Commutable transactions and the time pad synchronization mechanism for distributed systems
6830#Distributed agreement in the presence of processor and communication faults
6831#Optimal partitioning of randomly generated distributed programs
6832#The impact on software development costs of using HOL's
6833#Data structured programming: Programm design without Arrays and Pointers
6834#The transformation schema: An extension of the data flow diagram to represent control and timing
6835#Object-oriented development
6836#An overview of JSD
6837#Functional programming, formal specification, and rapid prototyping
6838#A rational design process: How and why to fake it
6839#A recommended practice for describing software designs: IEEE standards project 1016
6840#An empirical study of software design practices
6841#A Metaprogramming method and its economic justification
6842#Constrained expressions: Adding analysis capabilities to design methods for concurrent software systems
6843#SARA (system architects apprentice): modeling, analysis, and simulation support for design of concurrent systems
6844#Salient features of and executable specification language and its environment
6845#Developing interactive information systems with the user software engineering methodology
6846#Process-translatable Petri Nets for the rapid prototyping of process control systems
6847#Real-time software life cycle with the model system
6848#A fast algorithm for finding an edge-maximal subgraph with TR-formative coloring
6849#Greedy concepts for network flow problems
6850#New classes of perfect graphs
6851#On chains of 3-connected matroids
6852#Optimal schedules of periodically recurring events
6853#Most and least uniform spanning trees
6854#On KΔ
6855#Generalized neighbourhoods and a class of perfectly orderable graphs
6856#Strong unimodularity for matrices and hypergraphs
6857#Monge sequences and a simple assignment algorithm
6858#Exchange properties of combinatorial closure spaces
6859#On the computational complexity of the order polynomial
6860#Testing the theory of evolution: a novel application of combinatorial optimization
6861#Homomorphisms and Ramsey properties of antimatroids
6862#Polymatroidal flows with lower bounds
6863#On BF-orderable graphs
6864#A decomposition of the matroids with the max-flow min-cut property
6865#Duality for balanced submodular flows
6866#Representative graphs of r-regular partial planes and representation of orthomodular posets
6867#The matching polynomial of a polygraph
6868#On the ordering of graphs with respect to their matching numbers
6869#A fast approximation algorithm for the multicovering problem
6870#Maximal dynamic polymatroid flows and applications
6871#On morphic generation of regular languages
6872#A polynomial algorithm for constructing the clique graph of a line graph
6873#On the number of edges in the transitive closure of a graph
6874#On the order of the largest induced tree in a random graph
6875#Linear and combinatorial sharing problems
6876#Directed cartesian-product graphs have unique factorizations that can be computed in polynomial time
6877#Iterative characterizations of Boolean algebras
6878#A property of real-time trellis automata
6879#Search problems on graphs
6880#Recognition of Gilmore-Gomory traveling salesman problem
6881#Some NP-complete problems for hypergraph degree sequences
6882#Largest polygons with vertices in a given finite set
6883#On equivalent knapsack problems
6884#Unimodular functions
6885#An asymptotically exact polynomial algorithm for equipartition problems
6886#Computation on binary tree-networks
6887#Special market equilibrium problems as network models
6888#A variable dimension homotopy on networks for computing linear spatial equilibri
6889#Multi-terminal maximum flows in node-capacitated networks
6890#Microcomputer based algorithms for large scale shortest path problems
6891#A new variant of the partitioning shortest path algorithm
6892#Allowable processing orders in the accelerated cascade algorithm
6893#Degeneracy in transportation problems
6894#Computational experience with a polynomial-time dual simplex algorithm for the transportation problem
6895#The family constrained network problem
6896#The asymmetric m-traveling salesman problem: A duality based branch-and-bound algorithm
6897#The 2-quasi-greedy algorithm for cardinality constrained matroid bases
6898#A linear algorithm for finding a minimum dominating set in a cactus algorithm for finding a minimum dominating set in a cactus
6899#Stability analysis of product &thgr;-methods for Abel integral equations of the second kind
6900#Finite dimensional approximation of bifurcation problems in presence of symmetries
6901#Some generalizations of the Euler-Knopp transformation
6902#Stability and accuracy for implicit semidiscretizations of hyperbolic problems
6903#Parallel QR Decomposition of a rectangular matrix
6904#Incomplete data problems in X-ray computerized tomography. I. Singular value decomposition of the limited angle transform
6905#Improving the accuracy of collocation solutions of volterra integral equations of the first kind by local interpolation
6906#Numerical approximation of transverse shearing stress in bent plates
6907#Absolute monotonicity of polynomials occurring in the numerical solution of initial value problems
6908#Solution of differential equations by splines. A perturbation theory. Part 1: Statements about divergence
6909#On the condition number of some gram matrices arising from least squares approximation in the complex plane
6910#Eigenvalues of a symmetric tridiagonal matrix: A divide-and-conquer approach
6911#On the sensitivity of orthogonal polynomials to perturbations in the moments
6912#A- and B-stability for Runge-Kutta methods - characterizations and equivalence
6913#Componentwise inclusion and exclusion sets for solutions of quadratic equations in finite dimensional spaces
6914#How to get around a simple quadratic fold
6915#Multivariate Pade´ approximation
6916#Orthogonal least squares fitting with linear manifolds
6917#On the construction of optimal mixed finite element methods for the linear elasticity problem
6918#An algorithm for segment approximation
6919#On the eigenvalue distribution of a class of preconditioning methods
6920#On the rate of convergence of the preconditioned conjugate gradient method
6921#On the class of Chebyshev approximation problems which arise in connection with a conjugate gradient type method
6922#The rate of convergence of conjugate gradients
6923#Stream vectors in three dimensional aerodynamics
6924#The approximation of generalized turn)ng points by projections methods with superconvergence to the critical parameter
6925#Numerical computation of least constants for the Sobolev inequality
6926#Global superconvergence for the solution of linear boundary value problems
6927#calculation of cubic smoothing splines for equally spaced data
6928#Stability and convergence properties of Bergman kernel methods for numerical conformal mapping
6929#Improved estimates of statistical regularization parameters in fourier differentiation and smoothing
6930#K-step iterative methods for solving nonlinear systems of equations
6931#Multicluster integrated communication network with dedicated channels: description and overall design
6932#On new types of homomorphisms and congruences for partial algebraic structures and n-ary relations
6933#A general systems logical theory
6934#Send it by satellite
6935#1986 Mainframe survey
6936#The Sierra, one year later
6937#Rule-based data resource management
6938#Multics users face their maker
6939#The Datamation 100
6940#Ranking of the top 100
6941#Company profiles
6942#Mixed forecasts for dp
6943#NCC at the crossroads
6944#Going for Japan
6945#Pirate's paradise
6946#What's ahead for CICS?
6947#Training: The art of the sport
6948#MVS/XA converts face snags
6949#NCR consent decree to end
6950#Infomart still not selling
6951#IBM enters desktop publishing
6952#Microtasking on IBM multiprocessors
6953#Compiling APL: the Yorktown APL translator
6954#Program analysis and code generation in an APL/370 compiler
6955#An automatic overlay generator
6956#An execution architecture for FP
6957#Early error detection in syntax-driven parsers
6958#A computerized autoradiographic technique for the simultaneous high-resolution mapping of myocardial blood flow and metabolism
6959#Mechanical design of the cartridge and transport for the IBM 3480 magnetic tape subsystem
6960#Wide-range, low-operating-voltage, bimorph STM: application as potentiometer
6961#Traversal time for tunneling
6962#Properties of vacuum tunneling currents: anomalous barrier heights
6963#Mono-atomic tips for scanning tunneling microscopy
6964#Scanning tunneling microscopy of cleaved semiconductor surfaces
6965#Scanning tunneling microscopy of surface microstructure on rough surfaces
6966#Near-field optical scanning microscopy with tunnel-distance regulation
6967#Chemical applications of scanning tunneling microscopy
6968#Surface modification with the scanning tunneling microscope
6969#STM activity at the University of Basel
6970#Applications of a high-stability scanning tunneling microscope
6971#Construction of a UHV scanning tunneling microscope
6972#A scanning tunneling microscope for the investigation of the growth of metal fils on semiconductor surfaces
6973#Scanning tunneling microscope automation
6974#Theory of scanning tunneling microscopy and spectroscopy: resolution, image and field states, and thin oxide layers
6975#Computer automation for scanning tunneling microscopy
6976#The behavior and calibration of some piezoelectric ceramics used in the STM
6977#Effect of the CYBER 205 on the choice of method for solving the eigenvalue problem (A-λm)x=0
6978#An algorithm for fitting data over a circle using tensor product splines
6979#A second order approximation to nonlinear circuit equations as applied to high energy electrical discharge processes
6980#On the convergence factor of Uzawa's algorithm
6981#A reconsideration of some embedded Runge-Kutta formulae
6982#Families of two-step fourth order P-stable methods for second oder differential equations
6983#Even and odd parts of limit periodic continued fractions
6984#Solutions from a direct point of view: padeons
6985#A finite difference method for a class of two-point boundary value problems over a semi-infinite range
6986#A proof of the order barrier for upwind schemes by Dahlquist's second barrier
6987#Phase-lag analysis for a family of two-step methods for second order periodic initial value problems
6988#A method for the improvement of the convergence rates of stationary iterative schemes for the solution of complex linear systems
6989#On some improvements of square root iteration for polynomial complex zeros
6990#Truncation and manipulation of multivariate power series
6991#Automation of the manipulation of multivariate power series
6992#Edge waves by boundary collocation
6993#Inequalities for Bessel functions
6994#On the computation of a certain class of Hill determinants
6995#An error analysis for a difference scheme of exponential type applied to a nonlinear singular perturbation problem without turning points
6996#A mathematical curiosity in estimating the radius of the first ring electrons ofan arbitrary atom
6997#A numerical method for the solution of two-parameter eigenvalue problems
6998#A note on bivariate box splines on a k-direction mesh
6999#The tau method with perturbation term depending on the differential operator
7000#A new interpretation of Cauchy type singular integrals with an application to singular integral equations
7001#Numerical solution of a free boundary problem by continuation
7002#Singular rules for the calculations of non-normal multivariate Pade´ approximants
7003#Efficient evaluation of oversampled functions
7004#Singular integral equations with a Cauchy kernel
7005#On the integral ∫∞ 0 Xv-1(1+βX)-λ ln m X dX
7006#Orthonormal polynomials in one and two dimensions: application to calibrations problems in high energy physics
7007#On power-boundedness of interval matrices
7008#New Runge-Jutta-Nyström formula-pairs of order 8(7), 9(8), 10(9) and 11(10) for differential equations of the form y″ = f(x,y)
7009#Iterative methods for solving right focal point boundary value problems
7010#An aggregate subgradient method for nonsmooth and nonconvex minimization
7011#Pade´ techniques for model reduction in linear system theory: a survey
7012#Pringsheim's theory for generalized continued fractions
7013#A simple method for computing he values of the derivatives of a rational
7014#Convergence of linear multistep methods with multiple roots
7015#A class of two-step P-stable methods for the accurate integration of second order periodic initial value problems
7016#An exponential version of Filon's rule
7017#A new class of explicit two-step fourth order methods for y″ = f(t,y) with extended intervals of periodicity
7018#Data processing fraud: six opportunities
7019#Taking the disaster out of recovery
7020#Seven terms, one answer?
7021#The protection racket
7022#User-developers: the new software resource
7023#It's time for IS to 'think marketing'
7024#Knotting the line: the courtship of IS and the phone companies
7025#An algorithm for the location of transition states
7026#Energy-optimized GTO basis sets for LCAO calculations. A gradient approach
7027#Theoretical investigations on fluorine-substituted ethylene dications C2HnF4-n2+(n = 0 - 4)
7028#MINDO/3 study of the rearrangement of 1-methylcyclohexyl cation to 1,2-dimethylcyclopentyl cation
7029#Substituent effects on the low-lying singlet and triplet states of methylene
7030#Transfer-matrix method for subgraph enumeration: Applications to polypyrene fusenes
7031#Transport properties of macromolecules by Brownian dynamics simulation: vectorization of Brownian dynamics on the Cyber-205
7032#An SCF and CI study of the 1,3 shift in the HX—CH=Y=X=CH—YH isoelectric series: X,Y = CH2, NH, and O
7033#On the use of constraints in molecular mechanics. Rigid group refinement
7034#Conformational dynamics of 9,9-dimethyl-1,5-dihetero-spiro U5,5e undecanes by molecular mechanics calculations: a three-dimensional topological approach
7035#An efficient method for using molecular symmetry. In advance of zero integrals
7036#Optimization of the generalized valence bond for vector processors
7037#Confirmational properties of 3-phenylpiperidine and 3-phenylpyrrolidine opioid analgesics
7038#Atomic charges in the quadruple solvation energy calculations
7039#A comparison of the rotational potential functions in butane, propylsilane, ethylmethylsilane, and 1,2-disilylethane: Ab initio and MM2 results
7040#A strategy for the regional characterization of potential energy surfaces
7041#On the enumeration of 2-factors of polyhexes
7042#Atomic physicochemical parameters for three-dimensional structure-directed quantitative structure-activity relationships. I. Partition coefficients as a measure
7043#A new method for molecular mechanics
7044#A data-driven machine for OR-parallel evaluation of logic programs
7045#MOLOG: A system that extends PROLOG with modal logic
7046#Sequential Prolog machine PEK
7047#A logic-based calculus of events
7048#Translating production rules into a forward reasoning Prolog program
7049#Report on IJCAI-85
7050#Report on the 11th International Conference on Very Large Data Bases
7051#A deductive solution for plan generation
7052#Maximal unifiable subsets and minimal non-unifiable subsets
7053#Computation of full logic programs using one-variable environments
7054#Specification and initialization of a logic computer system
7055#Multiway merge with constant delay in concurrent Prolog
7056#On the structure of fuzzy social welfare functions
7057#Orlovsky's concept of decision-making with fuzzy preference relation—Further results
7058#Semifuzzy games
7059#Extension principle in fuzzy optimization
7060#Lower solutions of systems of fuzzy equations
7061#A property of matrices over ordered sets
7062#On local and global measures of separation in fuzzy topological spaces
7063#A comparison of lattice-theoretic approaches to fuzzy topology
7064#Fuzzy fields and fuzzy linear spaces
7065#Fuzzy controllers design via fixed point theorem
7066#On some logical points of fuzzy conditional decision making
7067#Preference relations on a set of fuzzy utilities as a basis for decision making
7068#Fuzzy expected utility
7069#On the use of Zadeh's probabilistic definition for testing statistical hypotheses from fuzzy information
7070#Interval valued fuzzy sets based on normal forms
7071#Adjointness of fuzzy systems
7072#Connectedness on fuzzy topological spaces
7073#On the transitivity property
7074#Fuzzy measure analysis of public attitude towards the use of nuclear energy
7075#Fuzzy resource management analysis
7076#A modification of the certainty measure to handle subnormal distributions
7077#Fuzzy modeling with tolerances
7078#On fuzzy multi-valued functions, Part 4: Fuzzy economic models
7079#Linear fuzzy regression
7080#Distributions in fuzzy logic
7081#A FORTRAN input program generator
7082#Construction of quadtrees and octtrees from raster data: A new algorithm based on run-encoding
7083#Integrating the structured analysis and design models: an initial algebra approach
7084#Simple compiler correctness—a tutorial on the algebraic approach
7085#A survey of control facilities in logic programming
7086#Distance-transitive representations of the symmetric groups
7087#A decomposition theory for matroids. III. Decomposition conditions
7088#On the chromatic index of multigraphs and a conjecture of seymour (I)
7089#Semi-duality and the cycle double cover conjecture
7090#Infinite paths that contain only shortest paths
7091#Partition properties of q-Hypergraphs
7092#Research libraries and the dissemination of information in genetic engineering and biotechnology
7093#A managerially based framework for the role and contribution of an information service in a production organisation
7094#The future of a small technical data base
7095#The weight functions, generating functions and miscellaneous properties of the sequences of orthogonal polynomials of the second kind associated with the Jacobi and the Gegenbauer polynomials
7096#On equidistributing principles in moving finite element methods
7097#Stiffly stable Adams-type methods
7098#Accelerated monotone scheme for finite difference equations concerning steady-state prey-predator interactions
7099#A new predictor-corrector method for solving unconstrained minimization problems
7100#Finite amplitude axisymmetric convection between rigid rotating planes
7101#On the non-normal two-point Pade´ table
7102#On the fast solution of a linear system arising in numerical conformal mapping
7103#Numerical methods for unilateral problems
7104#Forbidden submatrices
7105#Pseudo-modular graphs
7106#(m)-covering of a triangulation
7107#The maximal number of induced complete bipartite graphs
7108#Maximal partial spreads and two-weight codes
7109#The number of tiered posets modulo six
7110#Enumeration of projective-planar embeddings of graphs
7111#Regular orbits of permutation groups on the power set
7112#What must be contained in every oriented k-uniform hypergraph
7113#Central and parallel projections of polytopes
7114#A pipeline-interval-optimum systolic queue
7115#On d-arrangements associated with a simplex
7116#Bipartite regulation numbers
7117#Thresholding of monomorphisms n-ary tournaments
7118#Wv paths in the projective plane
7119#About recognizing (&agr; &bgr;) classes of polar graphs
7120#On the existence of certain generalized Moore geometries (part IV)
7121#Connected cutsets of a graph and triangle bases of the cycle space
7122#On latin squares and the facial structure of related polytopes
7123#Partial triple systems and edge colourings
7124#Existence results for KS3(v;2,4)s
7125#Permanents of doubly stochastic matrices
7126#Ordered trees an noncrossing partitions
7127#Generating stable permutations
7128#Every simple 3-polytope with 34 vertices is Hamiltonian
7129#Lins-Mandel manifolds as branched coverings of S3
7130#Path and cycle sub-Ramsey numbers and an edge-colouring conjecture
7131#The toroidal splitting number of the complete graph Kn
7132#Hexagonal coordinate systems and Steiner minimal trees
7133#On construction of partially balanced n-ary designs
7134#Uniquely colourable m-dichromatic oriented graphs
7135#On ternary transversal matroids
7136#On the number of cycles of short length in the de Bruijn-Good graph Gn
7137#Extending subpermutation matrices in regular classes of matrices
7138#Separation by a right-side in rank 3 oriented matroids
7139#Clique graphs of backed graphs
7140#Finite point-sets on S2 with minimum distance as large as possible
7141#A simplical 3-arrangement of 21 planes
7142#On the intersection of edges of a geometric graph by straight lines
7143#A 'large deviation' phenomenon in discrete geometry,I
7144#Maximal volume enclosed by plates and proof of the chessboard conjecture
7145#The 37 combinatorial types of minimal, non-transitive, equivariant tilings of the Euclidean plane
7146#The complexity of cells in three-dimensional arrangements
7147#On some metric and combinatorial geometric problems
7148#An extension to the catalogue of isonemal fabrics
7149#Point sets with many unit circles
7150#Few slopes without colinearity
7151#On a problem of Yuzvinsky on separating the n-cube
7152#Two results about points, lines and planes
7153#Lattice point simplices
7154#On the number of triangles in simple arrangements of pseudolines in the real proective plane
7155#On Coxete's regular skew polyhedra
7156#Packing of ellipses with continuously distributed area
7157#Finite linear spaces in which any n-gon is Euclidean
7158#On Ramsay-Tura´n type problems in tournaments
7159#More balanced incomplete block designs from Frobenius groups
7160#Clique numbers of graphs
7161#On large matchings and cycles in sparse random graphs
7162#On kernel-perfect critical digraphs
7163#Clique partitions of the cocktail party graphs
7164#On small packing and covering designs with block size 4
7165#On automorphism groups of certain 2-(v,3,2) designs induced by group actions
7166#Non-interval greedoids and the transposition property
7167#An inequality in binary vector spaces
7168#A non-linear algebraic matroid with infinite characteristic set
7169#Parity results on connected f-factors
7170#Bipartite Steinhaus graphs
7171#Coloring graphs with locally few colors
7172#A theorem about a conjecture of H. Meyniel on kernel-perfect graphs
7173#The non-classical 10-arc of PG(4,9)
7174#Path-connectivity in graphs
7175#Complete subgraphs of infinite multipartite graphs and antichains in partially ordered sets
7176#Existence of orthogonal latin squares with aligned subsquares
7177#Some uses of struction
7178#Regular parallelism from translation planes
7179#Bijections between formulae and trees which are compatible with equivalences of the type ((f:2W0g):2W0h)((f:2W0h):2W0g)
7180#Simple 3-polytopal graphs with edges of only two types and shortness coefficients
7181#Solutions of a quadratic equation in the free group
7182#On universality of graphs with uniformly distributed edges
7183#Some sequences associated with combinatoral structures
7184#Some theorems of uniquely pancyclic graphs
7185#Exact coverings of the integers by arithmetic progressions
7186#Enumeration with the lattice of periods
7187#Extension of a clique cover result to uniform hypergraphs
7188#The QR algorithm for unitary Hessenberg matrices
7189#Exponentially fitted one-step methods for the numerical solution of the scalar Ricatti equation
7190#Generalized reducible quadrature methods for Volterra integral and integro-differential equations
7191#A tensor product generalized ADI method for elliptic problems on cylindrical domains with holes
7192#Convergence of Chebyshev semi-iterative methods
7193#The modified equation as a model of local errors in convective schemes
7194#Multivariate interpolation of arbitrarily spaced data by moving least squares methods
7195#Relaxed Newton-like methods for stiff differential systems
7196#Linearized solution of a flow over a nonuniform bottom
7197#The choice between techniques for choosing between methods of estimation
7198#Generalized k-s confidence regions: Some exact results
7199#Sensitivity of a Bayesian inference to prior assumptions
7200#Tests for normality with stable alternatives
7201#A review of maximum likelihood estimation methods for the three-parameter weibull distribution
7202#Alternative estimators in logistic regression when the data are collinear
7203#Exact tests for equality of two proportions: Fisher × Bayes
7204#The extreme residuals in logistic regression models
7205#Efficient calculation of Hodges-Lehmann estimators of location
7206#Estimation of error probabilities in stochastic dominance
7207#A simulation study of deterministic ridge estimators
7208#Confidence interval estimation and hypothesis testing for a common correlation coefficient
7209#A simulation study of some suboptimal Bayesian sequential sampling schemes for choosing the better of two binomial populations
7210#Estimation of variance components: What is missing in the EM algorithm?
7211#Autoregressive model identification for multivariate time series
7212#The use of surrogate variables in binary regression models
7213#Large sample prediction intervals for a future sample mean: A comparative study
7214#The comparison of two spectral density functions using the bootstrap
7215#On estimating a dynamic model with partially aggregated data: Finite sample performance of least squares and maximum likelihood estimators
7216#Calculation of the asymptotic mean square forecast error for an autoregressive process with estimated parameters
7217#Numerical comparison of some test procedures for determining model adequacy when fitting polynomial equations to sequences of observations
7218#Generating subsets of order statistics with applications to trimmed means and means of trimmings
7219#A note on reparameterizing a vector autoregressive moving average model to enforce stationarity
7220#A Monte Carlo comparison of the small sample behaviour of the Pearson, the likelihood ratio and the Cressie-Read statistics
7221#A simple graphic for assessing influence in regression G
7222#Determining the optimal sample size for decision making
7223#Fitting a curve to data when both variables are subject to error
7224#A note on the derivation of theoretical autocovariances for ARMA models
7225#Composite forecasting of annual earnings: An application of biased regression techniques
7226#Bayesian insight into Tiku's robust procedures based on asymmetric censored samples
7227#A test for the difference of means
7228#The scale problem in robust regression M-estimates
7229#The effect of non-normality on the use of the range in estimating the population standard deviation
7230#Some robust procedures for comparing several straight lines under heteroscedasticity and non-normality
7231#Estimation by moments in a model of faulty inspection
7232#Planning accelerated life tests with type II censored data
7233#Statistical analysis of a compound exponential failure model
7234#Bootstrap confidence intervals for regression coefficients when the residuals are dependent
7235#An iterative method for conformal mapping
7236#The Newton method for solving the Theodorsen integral equation
7237#Numerical conformal mapping methods based on function conjugation
7238#An iterative method for the conformal mapping of doubly connected regions
7239#A Fredholm integral equation of the second kind for conformal mapping
7240#Numerical conformal mapping via the Szego¨ Kernel
7241#A fast method for solving certain integral equations of the first kind with application to conforma mapping
7242#Rapid methods for the conformal mapping of multiply connected regions
7243#A reparameterisation method to determine conformal maps
7244#The treatment of corner and pole-type singularities in numerical conformal mapping techniques
7245#Uniform approximation as a numerical tool for constructing conformal maps
7246#A conformal map formula for difficult cases
7247#Rounding corners of gearlike domains and the omitted area problem
7248#Conformal mapping solution of Laplace's equation on a polygon with oblique derivative boundary conditions
7249#Classical free-streamline flow over a polygonal obstacle
7250#High-order three-point schemes for boundary value problems.II: Nonlinear problems
7251#Cubic spline solutions of boundary value problems over infinite intervals
7252#Solution of structured non-stiff ODES
7253#High-order methods for the numerical solution of Volterra integro-differential equations
7254#Parallel and sequential Kaczmarz methods for solving underdetermined nonlinear equations
7255#Determination of poles of sectionally meromorphic functions
7256#A Noumerov-type method with minimal phase-lag for the integration of second order periodic initial-value
7257#An iterative solution method for solving sparse nonsymmetiric linear systems
7258#Design of near-optimal linear digital tracking filters with colored input
7259#A comparison of basis functions for the pseudo-spectral method for a model reaction-diffusion problem
7260#The noisy convergence phenomena in decomposition method solutions
7261#Random walks on the triangular prism and other vertex-transitive graphs
7262#A new direct method for the numerical calculation of a swallowtail
7263#On the curvature of the trigamma function
7264#The Riemann problem for the planar motion of an elastic string
7265#Weighted means and oscillation conditions for second order matrix differential equations
7266#Boundedness of solutions of duffing's equations
7267#Point-condensation for a reaction-diffusion system
7268#Subelliptic estimates for certain complexes of pseudodifferential operators
7269#Long time behaviour of solutions of abstract inequalities: applications to thermo-hydraulic and magnetohydrodynamic equations
7270#Probabilistic propositional temporal logics
7271#Inductive inference of approximations
7272#A note on some simultaneous relations among time, space, and reversal for singlework tape nondeterministic turing machines
7273#Every sequence is reducible to a random one
7274#Pre-analysis locking
7275#Definability by constant-depth polynomial-size circuits
7276#Arithmetic theories for computational complexity problems
7277#On the complexity of inductive inference
7278#Machines for attribute grammars
7279#A decisive characterization of BPP
7280#Boundary NLC graph grammars--basic definitions, normal forms, and complexity
7281#Solving tree problems on a Mesh-connected processor Array
7282#Categorical combinators
7283#A simplified lower bound for context-free-language recognition
7284#Application of advanced control methods in the pulp and paper industry-a survey
7285#Design of an L.Q.G. controller for single point moored large tankers
7286#Optimal performance and robust stabilization
7287#Convergence rate determined for gradient-based adaptive estimators
7288#Deterministic convergence of a Clarke-Gawthrop self-tuning controller
7289#Rapprochement between continuous and discrete model reference adaptive control
7290#Adaptive attitude control for large-angle Slew manoeuvres
7291#An optimal secondary voltage-VAR control technique
7292#Plasma estimation: a noise cancelling application
7293#Modified maximum likelihood method for the robust estimation of system parameters from very noisy data
7294#Asymptotically optimum recursive prediction error methods in adaptive estimation and control
7295#Self-tuning servo for Stochastic references
7296#Decoupling in the design and synthesis of singular systems
7297#Ranking multiple aspect alternatives-fuzzy relational equations approach
7298#Comments on "the parameter identificato in of a population model of china"
7299#Nonsmooth analysis on partially ordered vector spaces: the subdifferential theo ry
7300#An example of a bifurcation from fixed points to period 3 points
7301#On the peroidic BVP for the forced duffing equation with jumping nonlinearity
7302#A mini max theorem and applications to nonresonance problems for semilinear equations
7303#A nonconvex vector minimization problem
7304#A global existence theorem for the bounmdary value problem of Y″-f(x,y,y′)
7305#An algebraic approach to nonlinear stability
7306#Examples of transverse homoclinic orbits in delay equations
7307#Multiple solutions for a Dirichlet problem with jumping monlinearities,II
7308#An elementary algebraic method for approximating average radii of first and second ring electrons
7309#Strategic value analysis: a modern approach to systems and data planning
7310#The database book
7311#Automated office systems
7312#Data structured software maintenance: the Warnier/Orr approach
7313#Data abstraction in programming languages
7314#Digital communications systems
7315#Data center operations: a guide to effective planning, processing and performance (2nd ed.)
7316#Computer chess
7317#RS-232 simplified: everything you need to know about connecting, interfacing, and troubleshooting peripheral devices
7318#Architectural design and CAD
7319#The architecture of microprocessors
7320#Programming language translation: a practical approach
7321#Ranking of the top 100
7322#Company profiles
7323#The Rise of the Vars
7324#1985 DP salary survey
7325#Pushing the state of the art
7326#Imaging technology shows preview: systems, devices
7327#Fiber optic LAN supports many networks
7328#Today's technology: tomorrow's products
7329#On selecting the best contender
7330#Subdivision algorithms converge quadratically
7331#Unsteady interface between two fluids in a porous medium
7332#Solving systems of nonlinear equations by means of an accelerated successive orthogonal projections method
7333#The evaluation of the conjugate function of a periodic spline on a uniform mesh
7334#Reduction of dispersion in hyperbolic difference schemes by adapting the space discretization
7335#Generalized nonlinear minimal residual (GNLMR) method for iterative algorithms
7336#Two-step fourth-order P-stable methods with phase-lag of order six for y″=(t,y)
7337#Comparison of spline of Lagrangian interpolation
7338#Bounds for positive roots of polynomials
7339#A minimum configuration fourth-order nonautonomous explicit Rosenbrock method for nonstiff differential equations
7340#A de Montessus-type theorem for CF approximation
7341#The numerical evaluation of certain multivariate normal integrals
7342#Some comments on a paper by Macleod on Lagrangian interpolation
7343#An automata-theoretical characterization of the OI-hierarchy
7344#Retraction map categories and their applications to the construction of Lambda calculus models
7345#An exponential lower bound for real-time branching programs
7346#An ideal model for recursive polymorphic types
7347#On the power of two-way random generators and the impossibility of deterministic poly-space simulations
7348#Functional dependencies and constraints on Null values in database relations
7349#Deterministic coin tossing with applications to optimal parallel list ranking
7350#The density and complexity of polynomial cores for intractable sets
7351#Aggregating inductive expertise
7352#On some nonlinear boundary value problem on the Poincare´ disc with discontinuous data-I
7353#On some nonlinear boundary value problem on the Poincare´ disc with discontinuous data-II
7354#On the existence of Li-Yorke joints in the theory of chaos
7355#Topological dynamics of control systems: stability and attraction
7356#Existence of solutions for the abstract nonlinear equation BTu = f(u)
7357#Periodic solution and decay for some nonlinear wave equations with sublinear dissipative terms
7358#Dirichlet problem for demi-coercive functionals
7359#The drop theorem,the petal theorem and Ekeland's variational principle
7360#A characterization of m-accretivity and an application to nonlinear Schrödinger type equations
7361#Remark on the decay for damped string and beam equations
7362#Multiple critical points of invariant functionals and applications
7363#Unbounded positive entire solutions of semilinear elliptic equations
7364#Existence and approximation of solutions of inverse-positive problems
7365#The method of mIxed monotony and first order differential systems
7366#The free boundary of a flow in a porous body heated from its boundary
7367#A semigroup associated with a quasilinear system in which the coupling terms are linear-I
7368#Great delay in a predator-prey model
7369#Interval bounds and equivalent problems in saddle point problems
7370#Uniform decay rated for parabolic conservations laws
7371#Nonlinear multipoint boundary value problems
7372#Propagation and reflection of regularity for semilinear hyperbolic (2x2) systems in one space dimension
7373#Semiflows with global extensions
7374#On the rate of decay of solutions of functional differential equations with infinite delay
7375#Existence and uniqueness of solutions to nonlinear dissipative wave equations
7376#Emden-Fowler equations involving critical exponents
7377#Some backward uniqueness results
7378#Quasilinear elliptic equations with quadratic growth in unbounded domains
7379#On the multiplicity of the solution set of some nonlinear boundary value problems-II
7380#Upper and lower solutions for second-order boundary value problems with nonlinear boundary conditions
7381#The rank r-theorem in infinite dimension
7382#Stabilization of Hamiltonian systems
7383#Cooperative systems of differential equations with concave nonlinearities
7384#Almost periodic solutions for a semilinear quasi-autonomous hyperbolic problem
7385#Multiple steady states for rotating rods
7386#Global existence for a particular convection diffusion system
7387#Generalization of Fredholm alternative for nonlinear differential operators
7388#Optimal trajectories of generalized control systems with state constraints
7389#One-sided existence and uniqueness for periodic solutions of second-order ordinary differential equations
7390#An existence theorem for quasiconcave functions with applications
7391#An approach for generating different types of gray codes
7392#A decidable propositional dynamic logic with explicit probabilities
7393#Geometric retrieval problems
7394#The uniform conjugacy problem for finite Church-Rosser Thue systems in NP-complete
7395#Fast probabilistic RAM simulation of single tape turing machine computations
7396#Can message buffers be axiomatized in linear temporal logic?
7397#Direction independent context-sensitive grammars
7398#A programming language for the inductive sets, and applications
7399#Dynamics of a two-parameter family of maps of the interval
7400#Convergence of difference approximations of quasilinear evolution equations
7401#Time-dependent implicit evolution equations
7402#Fixed points of weakly inward multivalued maps
7403#Relation between ultimate boundedness and radially unbounded Liapunov function
7404#Perturbation of nonlinear operators and their parallel sum
7405#Time-dependent solutions of a nonlinear system arising in semiconductor theory-II. Boundedness and periodicity
7406#Spline approximation for autonomous nonlinear functional differential equations
7407#Expert systems as decision-making support tools
7408#Documentation and documental language for artistic activities
7409#Information system of price statistics in ISTAT
7410#Generation of homogeneous clusters in terms of perturbation of representative linear models of relational data systems
7411#Europe's elite
7412#View from the top
7413#Building AI behind closed doors
7414#The Lisp race heats up
7415#Starlan may be fading
7416#Offshore data entry picks up
7417#Information technology for command and control
7418#Capturing expertise: Some approaches to modeling command decisionmaking in combat analysis
7419#Representing operational planning knowledge
7420#A framework for task cooperation within systems containing intelligent components
7421#Distributed tactical decisionmaking: conceptual framework and empirical results
7422#Applications of a theory of automated adversarial planning to command and control
7423#Distributed decisionmaking with constrained decisionmakers: a case study
7424#On the role of artificial intelligence in command and control
7425#Delimiting expert systems
7426#Timeliness and measures of effectiveness in command and control
7427#Intelligent aids for tactical planning
7428#Data fusion and decision support for command and control
7429#A C2 process and an approach to design and evaluation
7430#Tools for C2 software reliability analysis
7431#A selective callup system for managing tactical information on graphic displays
7432#Adaptive user interfaces for planning and decision aids in C3I systems
7433#Graphic equivalence, graphic explanations, and embedded process modeling for enhanced user-system interaction
7434#Decision support for planning and resource allocation in hierarchical organizations
7435#Evolutionary development of command and control systems: the Fort Lewis experience
7436#Decision aiding dangers: The law of the hammer and other maxims
7437#Understanding and enhancing user acceptance of computer
7438#Army command and control information system requirements definition
7439#Utilization-oriented evaluation of decision support systems
7440#Expertise in debugging computer programs: an analysis of the content of verbal protocols
7441#Multivariable structure of fuzzy control systems
7442#Fuzzy grammars in syntactic recognition of skeletal maturity from X-rays
7443#A fuzzy approximation scheme or sequential learning in pattern recognition
7444#Neural network model with rhythm-assimilation capacity
7445#A decentralized water-quality control scheme
7446#On reliable control system designs
7447#The systems-engineering process: a technical bibliography
7448#On the relationship between Forrester's schematics and compartmental graphs
7449#Two simulation studies investigating means of human-computer communication for dynamic task allocation
7450#Adaptive navigation of automated vehicles by image analysis techniques
7451#A new algorithm for graph monomorphism based on the projections of the product graph
7452#A simple learning scheme for priority assignment at a single-server queue
7453#Fuzzy set theoretic measure for automatic feature evaluation
7454#Acquisition of process control skills
7455#Analysis of user procedural compliance in controlling a simulated process
7456#Aiding the human decisionmaker through the knowledge-based sciences
7457#Feedforward/feedback controls in a noisy environment
7458#Efficient parallel algorithm for robot inverse dynamics computation
7459#Distributed computer architecture and fast parallel algorithms in real-time robot control
7460#Coordinate transformation: A solution algorithm for one class of robots
7461#Peak-power-demand limitation through independent consumer coordination
7462#A posteriori representations based on linear inequality descriptions of a priori and conditional probabilities
7463#Variable structure control design for large-scale systems
7464#Controllability of fuzzy control systems
7465#A robot vision system based on two-dimensional object-oriented models
7466#Low-level segmentation of aerial images with fuzzy clustering
7467#A learning automation solution to the stochastic minimum-spanning circle problem
7468#On systemness and the problem solver: tutorial comments
7469#Implication theory and algorithm for reachability matrix model
7470#Current research in specifications is emphasizing the practical use of formal specifications in program design. One way to encourage their use in practice is to provide specification languages that are accessible to both designers and programmers. With this goal in mind, the Larch family of formal specification languages has evolved to support a two-tiered approach to writing specifications. This approach separates the specification of state transformations and programming language dependencies from the specification of underlying abstractions. Thus, each member of the Larch family has a subset derived from a programming language and another subset independent of any programming languages. We call the former interface languages, and the latter the Larch Shared Language.This paper focuses on Larch interface language specifications. Through examples, we illustrate some salient features of Larch/CLU, a Larch interface language for the programming language CLU. We give an example of writing an interface specification following the two-tiered approach and discuss in detail issues involved in writing interface specifications and their interaction with their Shared Language components.
7471#The algebraic specification of the semantics of programming languages is outlined. Particular emphasis is given to the problem of specifying least-fixed points by first-order conditional equations. To cover this issue, the theory of specifying partial heterogeneous algebras by abstract data types is slightly extended by a more general notion of homomorphism. In this framework the semantics of programming languages can be uniquely specified in a purely algebraic way, using particular models of a hierarchy of abstract types. This approach is demonstrated for a simple procedural programming language. Several increasingly complex versions of iterations are treated and analyzed with respect to their theoretical consequences. Finally, as a complementary algebraic technique, transformational semantics is explained and applied to our examples.
7472#The UNIX system encyclopedia
7473#The UNIX system encyclopedia; 2nd ed.
7474#Computer-aided drafting and design
7475#Elements of data processing mathematics (3rd ed.)
7476#Data communications & teleprocessing systems (2nd ed.)
7477#Fundamentals of systems analysis: using structured analysis and design techniques (3rd ed.)
7478#IBM assembler language programming: a systems approach (2nd ed.)
7479#Analysis of polling systems
7480#Implementing mathematics with the Nuprl proof development system
7481#LSI/VLSI testability design
7482#Operating systems: a systematic view (3rd ed.)
7483#Ada programming with applications
7484#Design and partitioning of VLSI-based interconnection networks
7485#Proceedings of the second annual symposium on Computational geometry
7486#We present linear time algorithms for solving the following problems involving a simple planar polygon P: (i) Computing the collection of all shortest paths inside P from a given source vertex s to all the other vertices of P; (ii) Computing the subpolygon of P consisting of points that are visible from a segment within P; (iii) Preprocessing P so that for any query ray r emerging from some fixed edge e of P, we can find in logarithmic time the first intersection of r with the boundary of P; (iv) Preprocessing P so that for any query point x in P, we can find in logarithmic time the portion of the edge e that is visible from x; (v) Preprocessing P so that for any query point x inside P and direction u, we can find in logarithmic time the first point on the boundary of P hit by the ray at direction u from x; (vi) Calculating a hierarchical decomposition of P into smaller polygons by recursive polygon cutting, as in [Ch]. (vii) Calculating the (clockwise and counterclockwise) “convex ropes” (in the terminology of [PS]) from a fixed vertex s of P lying on its convex hull, to all other vertices of P. All these algorithms are based on a recent linear time algorithm of Tarjan and Van Wyk for triangulating a simple polygon, but use additional techniques to make all subsequent phases of these algorithms also linear.
7487#Worst-case optimal algorithms for constructing visibility polygons with holes
7488#In this paper we consider the problem of finding shortest routes from which every point in a given space is visible (watchman routes). We show that the problem is NP-hard when the space is a polygon with holes even if the polygon and the holes are convex or rectilinear. The problem remains NP-hard for simple polyhedra. We present O(n) and O(nlogn) algorithms to find a shortest route in a simple rectilinear monotone polygon and a simple rectilinear polygon respectively, where n is the number of vertices in the polygon. Finding optimum watchman routes in simple polygons is closely related to the problem of finding shortest routes that visit a set of convex polygons in the plane in the presence of obstacles. We show that finding a shortest route that visits a set of convex polygons is NP-hard even when there are no obstacles. We present an O(logn) algorithm to find the shortest route that visits a point and two convex polygons, where n is the total number of vertices.
7489#In this paper, we present an &Ogr;(n log n) algorithm for finding the minimum Euclidean visible vertex distance between two nonintersecting simple polygons, where n is the number of vertices in a polygon. The algorithm is based on applying a divide and conquer method to two preprocessed facing boundaries of the polygons. We also derive an &Ogr;(n log n) algorithm for finding a minimum sequence of separating line segments between two nonintersecting polygons.
7490#In this paper we present &Ogr;(n2) time algorithms for the problems of covering a horizontally convex orthogonal polygon with the minimum number of orthogonal convex polygons and with the minimum number of orthogonal star-shaped polygons.
7491#On computing simple circuits on a set of line segments
7492#We present a new technique for half-space and simplex range query using &Ogr;(n) space and &Ogr;(na) query time, where a d(d-1)/d(d-1) + 1 + &ggr; for all dimensions d ≥ 2 and &ggr; 0. These bounds are better than those previously published for all d ≥ 2. The technique uses random sampling to build a partition-tree structure. We introduce the concept of an &egr;-net for an abstract set of ranges to describe the desired result of this random sampling and give necessary and sufficient conditions that a random sample is an &egr;-net with high probability. We illustrate the application of these ideas to other range query problems.
7493#Manacher and Zorbrist conjectured that the greedy triangulation heuristic for minimum weight triangulation of n-point planar point sets yields solutions within an &Ogr;(n&egr;), &egr; n) bound on the approximation factor of the Delauney triangulation heuristic which holds for convex, planar n-point sets. To support the conjecture of Manacher and Zorbrist, we also show that the greedy triangulation heuristic for minimum weight triangulation of a (non-necessarily convex) polygon yields solutions at most h times longer than the optimum where h is the diameter of the tree dual to the produced greedy triangulation of the polygon. On the other hand, we present an implementation of the greedy triangulation heuristic for an n-vertex convex point set or a convex polygon taking &Ogr;(n2) time and &Ogr;(n) space which improves Gilbert's &Ogr;(n2logn)-time and &Ogr;(n2)-space bound in this case. To derive the latter result, we show that given a convex polygon P, one can find for all vertices v of P a shortest diagonal of P incident to v in linear time.
7494#We propose a new search technique, called the Shear-Based Format, which shows that Yao's lower bound on the time-space tradeoff for orthogonal range queries is either optimal or nearly optimal [Ya82, Ya85]. Shearing is also a very pragmatic technique.
7495#In this paper we show how certain geometric convolution operations can be computed efficiently. Here “efficiently” means that our algorithms have running time proportional to the input size plus the output size. Our convolution algorithms rely on new optimal solutions for certain reciprocal search problems, such as finding intersections between “blue” and “green” intervals, and overlaying convex planar subdivisions.
7496#We consider the problem of partitioning isothetic polygons into rectangles by drawing edges of minimum total length. The problem has various applications [LPRS], eg. in VLSI design when dividing routing regions into channels ([Riv1], [Riv2]). If the polygons contain holes, the problem in NP-hard [LPRS]. In this paper it is shown how solutions within a constant factor of the optimum can be computed in time &Ogr;(n log n), thus improving the previous &Ogr;(n2) time bound. An unusual divide-and-conquer technique is employed, involving alternating search from two opposite directions, and further efficiency is gained by using a fast method to sort subsets of points. Generalized Voronoi diagrams are used in combination with plane-sweeping in order to detect all “well bounded” rectangles, which are essential for the heuristic.
7497#Given a point set in plane and a fixed planar region (window) a window query consists of enumerating the points in a translate of the region. A recently presented result shows that a static data structure of optimal size enables window queries for convex regions in optimal time. We show that if the windows are (maybe non-convex) polygons another data structure of optimal size supports not only window queries in optimal time but also allows updating of the point set in optimal time.
7498#Geometry of planar graphs with angles
7499#During the last 10-12 years there has been a dramatic revival of interest in applied geometric problems. Geometers have reconsidered a number of questions in infinitesimal mechanics, questions treated by J.C. Maxwell and L. Cremona [6, 12, 13] in 1864-70, further developed under the banner of graphical statics [7, 11], but left largely untouched since the end of the nineteenth century. At the same time, computer scientists have come to recognize that the tools of graphical statics and of applied projective geometry are fundamental to research in scene analysis.A good deal of the recent revival of interest is due to the efforts of the Structural Topology research group at the University of Montreal. The work of this group, reported in the pages of the journal Structural Topology [1, 2, 3, 4, 16, 17, 18] (and elsewhere), was a biproduct of research on infinitesimal mechanics, using methods derived from graphical statics, as well as from exterior algebra and its modern offspring, the Doubilet-Rota-Stein double algebra [8, 14]. Independently, Huffman [11], Duda and Hart [9], and others recognized that Maxwell's reciprocal figures could help in deciding whether a given plane image is the projection of a 3D polyhedral scene. More recently, Sugihara [15] and his colleagues in Nagoya created what may be considered a pilot project for automated descriptive geometry. They wrote a software package capable of modifying a rough plane sketch, so as to make it a true projection of a 3D scene.The starting point of the During the last 10-12 years there has been a dramatic revival of interest in applied geometric problems. Geometers have reconsidered a number of questions in infinitesimal mechanics, questions treated by J.C. Maxwell and L. Cremona [6, 12, 13] in 1864-70, further developed under the banner of graphical statics [7, 11], but left largely untouched since the end of the nineteenth century. At the same time, computer scientists have come to recognize that the tools of graphical statics and of applied projective geometry are fundamental to research in scene analysis.A good deal of the recent revival of interest is due to the efforts of the Structural Topology research group at the University of Montreal. The work of this group, reported in the pages of the journal Structural Topology [1, 2, 3, 4, 16, 17, 18] (and elsewhere), was a biproduct of research on infinitesimal mechanics, using methods derived from graphical statics, as well as from exterior a[8, 14]. Independently, Huffman [11], Duda and Hart [9], and others recognized that Maxwell's reciprocal figures could help in deciding whether a given plane image is the projection of a 3D polyhedral scene. More recently, Sugihara [15] and his colleagues in Nagoya created what may be considered a pilot project for automated descriptive geometry. They wrote a software package capable of modifying a rough plane sketch, so as to make it a true projection of a 3D scene. The starting point of the projective geometric analysis of scenes is the observation that the set of all three-dimensional realizations (scenes) having a given two-dimensional projection (a drawing, or image) form a linear space. Much information about an image, and about its possible spatial interpretations, can be obtained simply by calculating (either locally or globally) the linear dimension (or rank) of its linear space of scenes. In practice, the image is a pattern on a cathode-ray tube, an aerial photograph, an engineer's or architect's drawing, or an X-ray or NMR scan. The rank of its space of scenes will reveal whether there is ambiguity or uniqueness in the construction of its spatial interpretation, or whether such a construction is in fact impossible, as would be the case for a poorly conceived engineering drawing, or even in an otherwise correctly conceived drawing, if too many hypotheses are made concerning the 3D structure of the scene.Calculation of the rank of the space of scenes having a given image should, in principle, be accomplished using simple combinatorial algorithms based on easily-remembered rules-of-thumb. This is the goal, and it shows every sign of being achievable. The problem has, however, a certain degree of unavoidable difficulty. The requirement that a given image be an accurate projection of a non-trivial (non-planar) 3D scene imposes conditions on the image, conditions which are perhaps best described in terms of not-always-elementary constructions with straight-edge and pencil. In this paper, we begin to sort out the interplay of these projective conditions by creating a new homology theory for geometric configurations. The new homology theory applies to geometric objects which are more rigid, less pliable, than the “rubber sheets” studied by the topology of Henri Poincaré and his school. The passage to this higher degree of invariance is made possible by the creation of a homology theory with (restricted) vector, rather than (unrestricted) scalar, coefficients, or equivalently, by the use of a cohomology theory based on locally linear, rather than on locally constant, functions. We have verified that the new theory agrees with the cohomology theory for the sheaf of locally linear functions on a certain (combinatorially defined) topological space.The basic objects about which this new homology theory has something non-trivial to say are extremely general. From the geometric point of view, they are simply finite sets of points in a projective space or finite sets of vectors in a vector space. In order to emphasize the departure we take from linear algebra as it is usually practiced, we should say that we study vector spaces with a selected basis, that is, concrete vector spaces, in their usual representation as spaces FP of functions from a set P into a field F. Finally, we might say we are simply studying rectangular matrices. Since such objects are found throughout applied mathematics, the resulting homology theory has a very broad range of potential application. Indeed, potential applications of this new homology theory are to any domain where one is interested in the global behavior of systems determined locally by linear constraints.
7500#A set P of points in Rd is called simplicial if it has dimension d and contains exactly d + 1 extreme points. We show that when P contains n interior points, there is always one point, called a splitter, that partitions P into d + 1 simplices, none of which contain more than dn /(d + 1) points. A splitter can be found in &Ogr; (d4n) time. Using this result, we give a &Ogr; (d4n log1+1/d n) algorithm for triangulating simplicial point sets that are in general position. In R3 we give an &Ogr; (n logn + k) algorithm for triangulating arbitrary point sets, where k is the number of simplices produced. We exhibit sets of 2n + 1 points in R3 for which the number of simplices produced may vary between (n -1)2 + 1 and 2n -2. We also exhibit point sets for which every triangulation contains a quadratic number of simplices.
7501#We present two algorithms for pictures of polyhedral scenes. These algorithms have been conjectured (and used for some time), but only now been verified. The combinatorial algorithm, proposed by Sugihara, uses counts on the incidence structure to characterize pictures which are generically the projection of sharp polyhedral scenes of planes and points. The geometric algorithm, described by Clerk Maxwell and rediscovered in the last decade, uses a reciprocal diagram in the plane to characterize pictures of strict oriented polyhedra in space.
7502#A common structure arising in computational geometry is the subdivision of a plane defined by the faces of a straight line planar graph. We consider a natural generalization of this structure on a polyhedral surface. The regions of the subdivision are bounded by geodesics on the surface of the polyhedron. A method is given for representing such a subdivision that is efficient both with respect to space and the time required to answer a number of different queries involving the subdivision. For example, given a point @@@@ on the surface of the polyhedron, the region of the subdivision containing x can be determined in logarithmic time. If n denotes the number of edges in the polyhedron, and m denotes the number of geodesics in the subdivision, then the space required by the data structure is &Ogr;((n + m) log (n + m)). Combined with existing algorithms for computing Voronoi diagrams on the surface of polyhedra, this structure provides an efficient solution to the nearest neighbor query problem on polyhedral surfaces.
7503#A defect-correction algorithm for minimizing the volume of a simple polyhedron which circumscribes a sphere
7504#Given a set S of points in the plane, there is a triangulation of S such that a path found within this triangulation has length bounded by a constant times the straight-line distance between the endpoints of the path. Specifically, for any two points a and b of S there is a path along edges of the triangulation with length less than √10 times |ab|, where |ab| is the straight-line Euclidean distance between a and b. Thus, a shortest path in this planar graph is less than about 3 times longer than the corresponding straight-line distance. The triangulation that has this property is the L1 metric Delaunay triangulation for the set 5. This result can be applied to motion planning in the plane. Given a source, a destination, and a set of polygonal obstacles of size n, an &Ogr;(n) size data structure can be used to find a reasonable approximation to the shortest path between the source and the destination in &Ogr;(n log n) time.
7505#We present here a new and efficient algorithm for planning collision-free motion of a rod in the plane amidst polygonal obstacles. The algorithm calculates the boundary of the space of free positions of the rod, and then uses this boundary for determining the existence of required motions. The algorithm runs in time &Ogr;(K log n) where n is the number of obstacle corners and where K is the total number of pairs of obstacle walls or corners lying from one another at distance less than or equal to the length of the rod. Since K = &Ogr;(n2), the algorithm has the same worst-case complexity as the best previously developed algorithm of Leven and Sharir [LS1], but if the obstacles are not too cluttered together it will run much more efficiently.
7506#We consider the problem of moving an n vertex simple polygon around a corner in a right-angular corridor. We give an &Ogr;(n log n) algorithm for a convex polygon which constructs a motion of the polygon when one exists; otherwise it reports that none exists. In the case of non-convex polygons, we have an &Ogr;(n2) time algorithm.
7507#We consider the problem of computing the Euclidean shortest path between two points in three-dimensional space which must avoid the interiors of k given disjoint convex polyhedral obstacles, having altogether n faces. Although this problem is hard to solve when k is arbitrarily large, it had been efficiently solved by Mount [Mo84] (cf. also Sharir and Schorr [SS84]) for k = 1, i.e. in the presence of a single convex polyhedral obstacle, in time &Ogr;(n2log n). In this paper we consider the generalization of this technique to the cases k = 2 and k 2. In the first part of this presentation we describe an algorithm which calculates shortest paths amidst two convex polyhedral obstacles in time &Ogr;(n3&agr;(n)&Ogr;(&agr;(n)7)log n), where &agr;(n) is the functional inverse of Ackermann's function (and is thus extremely slowly growing). This result is achieved by constructing a new kind of Voronoi diagram, called peeper's Voronoi diagram, which is introduced and analyzed here. In the second part we show that shortest paths amidst k 2 disjoint convex polyhedral obstacles can be calculated in time polynomial in the total number n of faces of these obstacles (but exponential in the number of obstacles). This is a consequence of the following result: Let K be a 3-D convex polyhedron having n vertices. Then the number of shortest-path edge sequences on K is polynomial in n (specifically &Ogr;(n7)), where a shortest-path edge sequence &xgr; is a sequence of edges of K for which there exist two points X, Y on the surface S of K such that &xgr; is the sequence of edges crossed by the shortest path from X to Y along S.
7508#An efficient algorithm to determine the image of a parallelepiped under a linear transformation is presented. The work was motivated by certain problems in the testing of analog integrated circuits. The method is based on specifying the boundary hyperplanes that define the image polytope and is of polynomial complexity in n (the dimension of the parallelepiped), for a fixed value of the dimension of the range of the linear transformation. The algorithm has been implemented using library routines from LINPACK.
7509#We present techniques which result in improved parallel algorithms for a number of problems whose efficient sequential algorithms use the plane-sweeping paradigm. The problems for which we give improved algorithms include intersection detection, trapezoidal decomposition, triangulation, and planar point location. Our technique can be used to improve on the previous time bound while keeping the space and processor bounds the same, or improve on the previous space bound while keeping the time and processor bounds the same. We also give efficient parallel algorithms for visibility from a point, 3-dimensional maxima, multiple range-counting, and rectilinear segment intersection counting. We never use the AKS sorting network in any of our algorithms.
7510#This paper is divided in two parts of which the first describes a method to obtain solid models with free-form geometry from polyhedral models. This is achieved by replacing the edges of the original model with curved faces, i.e. sharp edges are replaced by rounds or fillets. The “radii” of these rounds and fillets are controlled by weight values assigned to the original edges. The value of each weight can vary in the interval from 0 to 1, which gives increased possibilities for the user to control the radius of a round or fillet without changing the topology or shape of the polyhedral model.Several of the curved faces will be non-rectangular and in the second part of the paper a method to determine surfaces to these faces is described. To do this we can either split these faces into rectangular subfaces and fit rectangular surfaces to the subfaces or use non-rectangular surfaces. I have tried the second alternative and used a scheme that is inspired by the methods presented by Gregory & Charrot, (1980), (1983) and (1984). However, my method differs from theirs in some respects:Their methods are based on a convex combination of Boolean sum surfaces which interpolate position and slope along to adjacent boundaries. The Boolean sum surfaces are based on linear Taylor interpolants. Instead of Boolean sum surfaces I use convex combinations of Taylor interpolants.I have also found that linear Taylor interpolants may not always give a satisfactory shape of the interior of the surface. A considerable improvement can be obtained by using higher degree interpolants.
7511#This paper presents a new solid modelling system capable of representing three dimensional objects consisting of both simple and complicated surfaces and, equally importantly, blend surfaces between them. Implicit polynomial inequalities and set theoretic techniques are used to specify the models. The modelling system can generate shaded pictures and NC machining instructions for cutting complicated objects automatically.The modelling system uses a technique for generating polynomials for blends and fillets that allows the user complete control over their extent without requiring him or her explicitly to devise the polynomial inequalities needed to represent them.
7512#Computer generated solid models must be decomposed into finite element meshes for analysis by the Finite Element Method. To enable decompositions of complex solid models, tetrahedra are employed and to avoid badly skewed tetrahedra for finite element analysis, a Delaunay triangulation is created by Watson's Algorithm [6]. Certain two-dimensional properties of Delaunay triangulations do not extend to the three-dimensional implementation of Watson's Algorithm. Furthermore, serious numerical difficulties can occur due to the nonrandomness of triangulation points, Nonrandomness imposed by the geometry can be ameliorated by using tetrahedral decompositions of icosahedra to fill space. A measure of the quality of tetrahedra is proposed and used to identify undesirable tetrahedra created due to point distributions and geometric constraints of solid models. Postprocessing Delaunay triangulations to rectify undesirable tetrahedra is briefly discussed.
7513#We present, in this paper, a new hierarchical data structure called the Delaunay tree. It is defined from the Delaunay triangulation and, roughly speaking, represents a triangulation as a hierarchy of balls. The Delaunay tree provides efficient solutions to several problems such as building the Delaunay triangulation of a finite set of n points in any dimension, locating a point in the triangulation, defining neighborhood relationships in the triangulation and computing intersections. The algorithms are extremely simple and are analyzed from a theoretical and practical points of view.
7514#Quadratic bounds for hidden line elimination
7515#We present a modification to the divide-and-conquer algorithm of Guibas & Stolfi [GS] for computing the Delaunay triangulation of n sites in the plane. The change reduces its &THgr;(n log n) expected running time to &Ogr;(n log n) for a large class of distributions which includes the uniform distribution in the unit square. The modified algorithm is significantly easier to implement than the optimal linear-expected-time algorithm of Bentley, Weide & Yao [BWY]. Unlike the incremental methods of Ohya, Iri & Murota [OIM] and Maus [M] it has optimal &Ogr;(n log log n) worst-case performance. The improvement extends to the composition of the Delaunay triangulation in the Lp metric for 1 p ≤ ∞. Experimental evidence presented demonstrates that in the Euclidean case the modified algorithm performs very well for n ≤ 216, the range of the experiments. We conjecture that its average running time is no more than twice optimal for n less than seven trillion.
7516#Geometric applications of a matrix searching algorithm
7517#We present two algorithms for pictures of polyhedral scenes. These algorithms have been conjectured (and used for some time), but only now been verified. The combinatorial algorithm, proposed by Sugihara, uses counts on the incidence structure to characterize pictures which are generically the projection of sharp polyhedral scenes of planes and points. The geometric algorithm, described by Clerk Maxwell and rediscovered in the last decade, uses a reciprocal diagram in the plane to characterize pictures of strict oriented polyhedra in space.
7518#We consider the problem of answering a series of on-line queries on a static database. The conventional approach to such problems involves a preprocessing phase which constructs a data structure with good search behavior. The data structure is then used to process a series of queries without any further reordering. Our approach involves dynamic or query-driven structuring of the database, i.e. we process the database only when it is required for answering a query. We present optimal algorithms for the following problems in the plane: testing convex hull membership, half-plane intersection queries and fixed-constraint multi-objective linear programming. This technique is also applied to multidimensional dominance query problems.
7519#We present a transformation that can be used to compute Voronoi diagrams with a sweepline technique. The transformation is used to obtain simple algorithms for computing the Voronoi diagram of point sites, of line segment sites, and of weighted point sites. All algorithms have &Ogr;(n log n) worst case running time and use &Ogr;(n) space.
7520#on Proceedings of the Fifth British National Conference on Databases (BNCOD 5)
7521#A statistical database system for survey analysis
7522#A relational data handling system for scientists
7523#An expert system to detect burglars using a logic language and a relational database
7524#The use of databases for software engineering
7525#Behaviour-specification in an information systems analysis context
7526#Knowledge base enhancements to relational databases
7527#Formalising the notion of semantic integrity in database and knowledge base systems work
7528#Meta-rules and semantic integrity constraints in databases
7529#An implementation of a constraint enforcement system
7530#Database maps
7531#SIS—A schema integration system
7532#Implementing joins by hashing on Codasyl DBMS
7533#Proceedings of the 4th annual international conference on Systems documentation
7534#Recent research has demonstrated the advantages of separating management of the user interface from the application program. A user interface system should integrate access to on-line help and documentation with other dialog for interacting with the program into a uniform environment. We describe such a user interface management system, called ICE, with emphasis on its facilities for authoring networks of frames containing help information and menus for interacting with the application program. Authors can write help and dialog using a language similar to the SCRIBE document processing system, widely used at CMU and elsewhere. But instead of generating hardcopy documents for different printing devices, ICE produces interactive “softcopy” documents, consisting of a network of frames combining documentation and interface.In ICE the screen layout of frames and the style of interaction is specified in a format file which is separate from the dialog file that contains the text to appear in the frames. This separation allows the dialog author to write the text without having to worry much about its precise appearance on the screen. The display designer can specify the actual format independently. The same text can be formatted in different ways to make use of different display devices and to allow experimentation with alternative formats and styles of interaction.
7535#What sort of a role will the printed page play in the computer user manuals of the future? I believe that print does have a future in this area, but not perhaps the future we might have foreseen five years ago. At that time nothing was less controversial than the viability of print as a medium of documentation. That viability is in question now, and to show how the questioning developed I propose to examine its beginnings in the recent past. I shall then go into some detail on how the controversy about print is being maintained at present. Finally, I shall explain how I feel the controversy is likely to be resolved, by making four predictions about the future of computer user manuals, and those whose job it is to produce them.
7536#ADL—A documentation language
7537#This work aims at presenting a model for assisting in the development of Information System for software maintenance documentation.It seeks to emphasize the optimization of the functions related to the documentation, by employing automatic processes.In this study the system of documentation is based on a Data Dictionary structure, adequately designed for the organized storage of the information needed for the execution of the maintenance activities.Forms of the information input, updating and retrieval have been analysed with the intention of utilizing the basic software of support, as well as to consider the possibilities of the Dictionary interface with the Operating System file, throughout the modification of the application software.
7538#Documentation generation from a PSA database
7539#This paper is a case study with some recommendations. Over the course of a four-year (twenty person-year) project, the method of documenting programs changed from using separate files containing input data for a documentation lister, to placing all of the program documentation in the source code and using an extraction program when separate documentation was needed. The history and reasons for this evolution are described. The project revealed the usefulness of documentation tools including program templates, a good cross-reference lister, in-line documentation, and the extraction program.
7540#BASIC and DOS jobstreams in IBM PC software documentation
7541#At the Los Alamos National Laboratory we have over 15 years of experience in designing computer documentation for computer users of the Los Alamos Integrated Computing Network (ICN), which includes five major operating systems. Currently there are over 6,000 users of the ICN: programmers, scientists, technicians, managers, technical editors, and secretaries. They can choose from more than 1,000 printed documents and a variety of online information sources.Because of this plethora of information, many users do not know where to find the information they need. And, after finding the right document, they may be dissatisfied by the way the information is presented.Over the last few years we studied our computer users and their needs for information. Our objective was to develop a model that could be used to organize the mountain of computer documentation that is needed for complex computer networks.In this paper we present the results of this study.We find that user attitudes toward information acquisition fall into three categories: (1) no time to learn, (2) want to learn, and (3) know what I want.No-time-to-learn users generally are using the computer as a tool and are trying to accomplish something in their own discipline. They need Quick Steps documentation that shows them what to do without explanation.Want-to-learn users have the time and inclination to learn a computing topic in a methodical way. They need Learning documentation that teaches the use of computers by developing an understanding of computing concepts and providing a foundation for generalization.Know-what-I-want users generally are knowledgeable in a specific computing area and simply want to look up particular information. They need Reference documentation.We find that these user attitudes significantly determine documentation needs, even more so than do experience or background. We reject the significance of alternative factors, including casual vs. expert; programmer vs. nonprogrammer; scientist vs. manager vs. secretary; and inexperienced vs. experienced. These factors tend to pigeonhole people and fail to recognize that a user can have different documentation needs at different times of each day.The types of documentation resulting from this understanding of our computer users are (1) Catalog, (2) Quick Steps, (3) Learning, and (4) Reference.Catalog documentation helps all users select the systems and documentation they need. It compares system capabilities in tabular and textual forms. It may describe computing concepts that users must understand in order to make their selections.Quick Steps documentation shows no-time-to-learn users what to do without explaining it. There is little reading and there are lots of examples. Development of Quick Steps documentation is appropriate for systems that are used by many people.Learning documentation teaches the use of computers by developing an understanding of computing concepts and providing a foundation for generalization. There is lots to read and try. Learning information can be provided in a variety of forms, including tutorial manuals, computer-assisted instruction, and live or videotaped courses. It is useful for want-to-learn users who have the time and inclination to learn a computing topic in a methodical way. Development of Learning documentation is appropriate for systems that are frequently used and where in-depth understanding by many people would be useful.Reference documentation can be provided in a variety of forms, including comprehensive reference manuals, quick-reference cards, online help, and glossaries. It is useful for know-what-I-want users who generally are knowledgeable in a specific computing area and simply want to look up particular information. All computing topics require Reference documentation.Additional documentation, such as news about changed computing capabilities and public information for laymen, is also required.We believe that it is necessary to consider computer user attitudes in order to design documentation that will be used.
7542#Readers of technical documentation generally agree that the information in those manuals is only as good as the ease with which they can find it. An informative and accurate index is one of the best tools for helping the reader find information quickly and easily. Yet indexes are one of the most neglected areas of technical documentation, in part because the tools used for creating indexes have not kept pace with other document creation tools.This paper discusses the qualities of a good index, and how different index creation tools can hinder or contribute to achieving those qualities. The method developed at Burroughs, which provides capabilities for generating high-quality indexes easily, is described.
7543#Documentation's recognition problem: What can we do about it?
7544#If writers can't program and programmers can't write, who's writing user documentation?
7545#Judith Turner's article on CUINFO (The Chronicle of Higher Education, July 10, 1985) resulted in a number of requests for more information. This note is intended to answer the most frequently asked questions. For more details, please get in touch with me at 401 Uris Hall, Cornell University, Ithaca, NY 14853; (607)256-4981; SLW@CORNELLA.BITNET.
7546#To compare different methods of accessing and presenting on-line help, controlled experiments were conducted. Several different help systems were compared, including a natural language help system and a human tutor. The results indicate that, while varying the help mechanism may have some effect on learning, its importance is greatly overshadowed by the simple quality of the help texts being presented. Even for on-line help, good writing seems to be the most important part of helping the user, far more important than elaborate or sophisticated mechanisms.
7547#For the last three years I have been using Writers Workbench, a UNIX text-editing tool, to edit computer documentation. In this article I outline my experiences using the system, noting both the advantages to explore and pitfalls to avoid in using this tool. Writers Workbench is especially useful for improving a writer's basic skills—punctuation, spelling, and grammar. When used effectively, Writers Workbench can cut down on wordiness and improve the consistency of a manual. It can help in the creation of a table of contents, index, glossary, and bibliography and in checking readability. Furthermore, by creating user-defined dictionaries, authors or editors can customize the tool to fit their purposes and styles. However, Writers Workbench is not good at catching problems relating to organization, focus, and clarity.
7548#Though frequently misunderstood and dismissed as irrelevant ornamentation, metaphors are useful tools for writers in the computer industry. Metaphors are especially useful for presenting information about new technologies because they help readers grasp whole concepts immediately and because they illuminate concepts that are difficult to communicate otherwise. It is important to distinguish this use of metaphors from their use in literature and advertisement.Participants in the workshop will follow procedures for investigating the suitability of several metaphors. They will analyze the power and appropriateness of metaphors currently used in the computer industry by applying seven criteria: Is the metaphor useful? understood? close? illuminating? acceptable? economical? memorable?
7549#Research into the effect of word processing on writing and a paperless environment for the submission and grading of student assignments has led to considerations for new technology to support the development of system documentation. We assert that a relatively paperless system which integrates the concepts of word processing, electronic mail, computer conferencing and the HANDIN paperless system for student assignments (Cross and Wolfe, 1985) has potential for facilitating the process of developing system documentation. A conceptual framework and specific system features are presented. Research goals and methodologies are briefly considered.
7550#Information Systems, MIT's campus-wide computing service organization, recently reorganized and strengthened its resources. Out of this recent effort came the decision to explore several ways of reporting on the expanded range of systems and services we offer.One service that central computing facilities must provide is timely notice of changes to the supported systems. This paper presents the design and implementation of Information Systems' “On-Line News System”, which keeps users updated about changes in the wide variety of services offered by Information Systems.
7551#No one has found a way to really help writers create readable prose. Robert Gunning developed a method for calculating the 'Fog Index' and Rudolph Flesch worked out more than one formula for measuring the simplicity of writing. By one of Flesch's formulas (the one without personal pronouns), Ronald S. Lemos in the February, 1985 issue of Communications of the ACM (CACM) was able to prove that CACM required two less years of school to read than Datamation. Statistics can prove anything. I have no idea what Sophomore in High School could read the CACM cover to cover and even understand most of it.Flesch's book 'The Art of Plain Talk' was given to me at a Yourdon Systems Analysis course. The Instructor handed it to each of us, saying something like “read this and you'll be a manager in no time” (supposedly, management is handed to the least efficient person who can also write well). The book is full of examples, mostly journalistic, showing how good writers evoke human interest. Of course, these writers had human events, thoughts and feelings as their focal points, not software, I doubt whether any of the graduates of that week ever used Flesch as a reference for grading their own documentation. How would Bernard Shaw have documented software? Or Mingus played it? This paper addresses these burning issues.
7552#The purpose of this paper is to show how documentation can be literate, in a stylistic sense, and still be effective. Literate prose is a powerful tool that, when properly used in computer documentation, can take advantage of the full power of the English language. This does not mean that all computer documentation must or can read like a Nobel Prize novel, but neither does it have to read like a military cryptogram. A happy medium — founded on healthy grammar and syntax, and following the logic of the software being documented — is a good AND obtainable goal.The roots of the problem of literate documentation lie in a common complaint from software users: “The program looked great in the store, but the documentation is so awful that I can't get it to work!” This is particularly acute in the field of educational software — but applies across the board — because the product cannot fulfill its purpose nor its potential unless it can be effectively employed. The problem is usually caused by an excessively technical focus, and/or poor composition (that obscures the information). A person should not have to be a computer scientist or a programmer to use software; that would defeat the purpose of the product. On the other hand, the user should not need to be a philologist to discover the author's intent. In short, documentation we compose needs to be truly “user-friendly.”The major obstacle to producing effective documentation is selecting the appropriate conceptual approach. The two main tendencies when tackling the problem are both extreme: often, there is either over emphasis on academic modes of expression, or on the technical aspects. These are often inappropriate as people want beginning words and concepts when they are “beginners.” They will enjoy high-tech once they grasp the basics; they want to how-to, not why.This “how-to” label is a critical issue in developing a good conceptual approach to documentation. In the field of software documentation, the “technical writing” mindset can often derail what would otherwise have been an effective product.Far too many people are seriously misled by the term “technical” writing and it is unfortunate that the word has been so broadly applied. The use of “technical” conjures a dominant notion that, in our case here, the writer must tell the reader all there is to know about hardware and programming. If the purpose of the document is to explain such things, then that is certainly fine and can legitimately be called “technical writing.”However, the technical details are often precisely what the non-technical user does NOT need to know; most really do not care about the electronic complexities, they just want their program to work. Hence, they need “practical” documentation: that is, documentation that tells them how to perform a function or set of functions so they can do whatever it is that they want to do (one might also wish to define it as being task-oriented or task-specific rather than technology-oriented). So, the rule of thumb should be to tell them NO MORE than what is necessary to use the program.There is also an economic bonus attached to practicality. Supporting documentation that is unnecessarily abstruse will deter program use, and it is altogether likely that further offerings would consequently not sell. Keeping it “sweet and simple,” as they say, also keeps it saleable.The term “practical writing” is preferrable to “technical writing” because the term conceptually moves away from a nuts-and-bolts orientation toward a “how-to” approach.Despite the fact that computers have been with us for some time and that personal computers are now the rage, the average user still feels somewhat intimidated by the machine and its accoutrements. Therefore, they certainly do not need to be further put off by the software they wish to use. Any computer magazine or journal you can select will show the current over-emphasis on hardware, diskettes, and their capabilities. However, a corresponding under-emphasis on the accompanying documentation exists. For example, in five recent issues of BYTE magazine, there were 134 feature articles of which only TWO would be of any use to documentation writers. That is rather sad.As the educational software market grows by leaps and bounds,1 and more and more companies become involved in similar enterprises for internal training purposes, it is imperative that not only the programs themselves be impressive and intellectually stimulating, but the accompanying documentation must really SUPPORT the program. Steve Halpern, vice-president of Classroom Consortia Media, Inc. (Staten Island, NY), addressed the problem — for both programs AND documentation — thus: “The computer should be a non-threatening tool to help the teacher. So software needs to be free of problems, of any kind of sophisticated codes that have to be put in to make it work. It should have all kinds of error-trapping that lets it do what it's supposed to do, which is reinforce learning and teach concepts.”2 The computer should not be designed as a teacher replacement but, rather, to be a challenging teaching aid and learning tool. Consequently, the accompanying documentation needs to be much more than merely a textbook supplement or user's manual. Rather, it needs to be a bit of both, which is a difficult marriage to be sure, but necessary. We who produce documentation of this sort (and others) MUST be sensitive to the genuine needs of those who will be using the programs and their supporting material. This is to say that we must seriously consider our potential audience and resist the temptation to just “crank out” a document. The maxim “haste makes waste” certainly applies here.Kathy Yakal, Editorial Assistant for COMPUTE'S! PC & PCjr magazine, has said, “Courseware should be enjoyable, open-ended, and exciting. And humorous. Intriguing. Authentically pleasing. It needs to be easy to use. It must present concrete demonstrations of abstract ideas whenever possible. Provide constructive feedback for errors. Be accompanied with clear and complete manuals.”3 Equally important, it must also teach by its own example: which means that it should not include the kind of grammatical errors that are displayed in the foregoing quotation. The writer must be dedicated to producing documentation that is just as grammatically sound as it is accurate because poorly expressed information is worth little or nothing.Consequently, to produce a document that will function as an effective information base, the writer must walk a tough but necessary tightrope between two extremes. Information must be clearly expressed, and there is just no excuse for ignoring the rules of good English composition.To produce good documentation, we need to be very sensitive to writing as a mechanical process and the strategies employed by writers to present the information necessary to fulfill the required task. One might have all the best intentions of blending the academic and technical approaches, but you know the destination of the road that is pved with good intentions and those intentions go nowhere unless the writer produces really balanced copy.Even talented writers need training to produce consistently effective documentation. The preferred method is formal classroom instruction where the individual can learn various strategies and tactics and gain some intensive practice in the writing and production craft. However, as anyone in business knows, the time necessary for this process is often a luxury. Short company-sponsored workshops can be of assistance, but time is money and money is a precious commodity.With what, then, are we left? With the right tools, a lot can be done on one's own to become a more effective communicator. There are several sources in the marketplace that can be valuable as self-study materials as well as important job aids.4 They will certainly not replace a formal course, but they can at least serve as useful on-the-job training materials.Let us consider a pedagogical tool I devised while teaching tech writing at the College of Staten Island-CUNY that graphically displays the relationships between the five principles of practical writing: organization, clarity, exposition, accuracy and validity. I rather egotistically call it “Burdett's Pentagon.”The arrows are all double-headed simply because the mutual interdependencies are critical to the strength of the whole structure.ORGANIZATION: Organization is the basis of a document. Without proper logical structure, a document will fall flat on its face. Consequently, when planning a document, organize it according to the canons of logic as displayed in a normal syllogism (a word equation).Premise / Purpose / ProblemConditions / Evidence / InformationConclusion / Result / SolutionThis is an oversimplification, but pursuing this tack will keep a writer properly focused on the necessary steps. It is amazing how much documentation falters because the information is not presented in a logical sequence, and there is nothing more frustrating to a reader than to have to keep questioning the author's meaning.EXPOSITION: Exposition is text production and all its appurtenant features: proper grammar and syntax, effective vocabulary, appropriate reading level, and so on. This is where the writer's style will have the most direct impact and a talented writer should have little trouble. For those with average skills, the task will be more onerous. But, if they follow the syllogistic format, they will at least be able to produce satisfactory copy that will be logically consistent and do the job.CLARITY: Clarity is the connection between organization, exposition and accuracy. If the organization is not clear, the exposition will be muddied. If the data are not clear, then the points one is trying to make will be correspondingly obtuse. For our purposes, clarity is more a psychic requirement: that is, always keep the principle in the front of one's mind as a constant check on the work being performed.ACCURACY: Accuracy applies to the data or other information used in one's document. Quite simply, if the information is not accurate, the whole thing falls apart regardless how well organized or well expressed it might be.VALIDITY: Statisticians will be familiar with the concept of validity5: that is, accuracy itself is not all that is required for good documentation. In addition, we must ensure that the information used pertains to the points we are trying to make. It may well be accurate, but if it is not germane to our subject, the exposition will then be meaningless.It is fairly clear that if any one element of the pentagon is weak, the whole document will then be unsound. Devices such as this simple tool are often helpful to talented writers who may produce poor documentation because they are harried and harassed.English is a very rich tongue that, when properly employed, has tremendous potential for accurately and effectively transmitting instructions and information. Documentation writers should be particularly sensitive to the necessity of employing proper grammar and should utilize appropriate vocabulary because these documents (especially educational software) also teach by example. For instance, I cannot count the number of arguments I have had about the spelling of “through.” I consistently heard lamentations like: “But the road signs say 'thru' traffic, so…it must be OK.” Another example is the roaring battle I once had with another writer who actually said, “What difference does it make if the grammar is bad? It's a science program!” Regardless the subject, there is absolutely no excuse, especially in education programs but also in general, for sloppy exposition.Therefore, when composing documentation, let's be tough on ourselves and do it right, or don't do it at all. One's exposition is often sloppy because one has developed sloppy habits. Therefore, develop good habits, do things the proper way, use the full power of the language, and one's documentation will be exemplary. If we recall the pentagon, poor exposition can adversely affect the clarity of the document and obscure the information that one is trying to convey. Let's not take shortcuts just because it is easy. Let's not invent words (as “prioritize”) when the language already has a perfectly good word that sounds much less jarring (as “rank” or “order”).6 However, at present, there is a lot of documentation on the market that has such faulty punctuation, infantile vocabulary, excessive jargon, poor expression, that it would seem that few writers care whether they set a good example or not.Therefore, to be literate in one's composition is ALSO to be effective: instructions and information will be easy to understand, the documentation will thus mesh well with the program and will succeed in molding a comfortable computer-software-human unit. That's being truly “user-friendly,” literate and effective.
7553#This paper is an exposition of an algorithm for text analysis that can be of value to writers and documentalists. The simplicity of this algorithm allows it to be easily programmed on most computer systems. The author has successfully implemented this test as a function within a text editing system written in RPG II. Included in this paper is a sample program written for the VAX 11/780 in PL/I.In 1949 Dr. Rudolph Flesch published a book titled “The Art of Readable Writing.” In this book, he described a manual method of reading ease analysis. This method was to analyze text samples of about 100 words. Each sample is assigned a readability index based upon the average number of syllables per word and the average number of words per sentence. This Flesch Index is designed so that most scores range from 0 to 100. Only college graduates are supposed to follow prose in the 0 - 30 range. Scores of 50 -60 are high-school level and 90 - 100 should be readable by fourth graders.Though crude, since it is designed simply to reward short words and sentences, the index is useful. It gives a basic, objective idea of how hard prose is to wade through. This test has been used by some state insurance commissions to enforce the readability of policies.Flesch's algorithm was automated in the early 1970s by the Service Research Group of the General Motors Corporation. The program, called GM-STAR (General Motors Simple Test Approach for Readability) was used so that shop manuals could be made more readable. GM-STAR was originally written in BASIC language. The key to this program is a very simple algorithm to count the number of syllables in a word. In general the text analysis portion of the program uses the following rules:Periods, explanation points, question marks, colons and semi-colons count as end-of-sentence marks.Each group of continuous non-blank characters counts as a word.Each vowel (a, e, i, o, u, y) in a word counts as one syllable subject to the following sub-rules:Ignore final -ES, -ED, -E (except for -LE)Words of three letters or less count as one syllableConsecutive vowels count as one syllable.Although there are many exceptions to these rules, it works in a remarkable number of cases.The Flesch Index (F) for a given text sample is calculated from three statistics;The total number of sentences (N),The total number of words (W),The total number of syllables (L),according to the following formula: F = 206.835 - 1.015 × (W/N) - 84.6 &times (L/W).The Grade Level Equivalent (G) of the Flesch Index is given by the following table:If -50 F 50, then G = (140 - F)/6.66If 50 F 60, then G = (93 - F)/3.33If 60 F 70, then G = (110 - F)/5.0If 70 F , then G = (150 - F)/10.0A PL/I program that implements this algorithm is listed below along with sample output. For simplicity, this program assumes all letters are in upper case. Processing text with lower case letters can be accomplished by either modifying the program to test for lower case as well as upper case, or by preprocessing the text sample to translate all letters to upper case. There are a multitude of other refinements and amenities that can be added to the basic analysis. Among these are:Nothing which characters are considered sentence terminators.Ignoring periods that are used for abbreviations rather than sentence terminators.Ignoring word connecting hyphens in compound words.Noting which character groups should probably be spelled out, such as numerals and dollar amounts.Sharpening the syllable counting routine to detect exceptional cases.
7554#The high cost of software is not due to the difficulty of coding, but in recoding and redocumenting software. This can be better understood when one considers how many expressions of the same ideas must be constructed and coordinated. Program code and comments, user interface and on-line help, and a variety of off-line documents, all must be consistent. A solution to the coordination problem is presented in this paper. Multilingual programming is a method of developing software that uses a database of information to generate multiple target languages like commented program code, user interface languages, and text formatting languages.The method begins with an analysis of a domain to determine key attributes. These are used to describe particular problems in the domain and the description is stored in a database. Attributes in the database are inserted in templates of idioms in a variety of target languages to generate solutions to the original problem. Because each of these solutions is based on the same source database of information, the solutions (documents, programs, etc.) are consistent. If the information changes, the change is made in the database and propagated to all solutions. Conversely, if the form of a solution must change, then only the templates change. In sum, the method saves much effort for updates of documents and programs that must be coordinated by designing for redesign.
7555#This paper presents various technological developments from the Rosetta Stone to the Apple MacIntosh Computer. With the advent of each change the quality of the product decays significantly, and is only restored to something near the glory of the past after a long period requiring much creative endeavor.This paper was presented as a slide presentation with extemporaneous comments.Let me remind you that you are a publisher. Whether you publish only within your corporation, or to a larger market, you are disseminating information relating to computer software. You may publish on paper, in the usual sort of user's guide or procedure manual, or you may publish online in the form of help screen data dictionaries, or video text. You may be publishing conference notices, newsletters, and memos. All of these are publishing activities, and as a publisher you should be aware of publishing technology and its impact on your readers.Let me also remind you that “technology” did not spring up 10 years ago, or with the advent of the Twentieth century, or even with the industrial revolution. Technology is, after all, a word derived from the ancient Greek techne, meaning art or skill, and logia, meaning study or science. Further, computer technology did not spring up fully grown, like Athena from the head of Zeus, despite the implications of computer salesmen. Computer technology is just one more step in the history of ideas. It is not necessarily the pinnacle of that history either.Look at the average piece of paper that crosses your desk. More than likely, it comes from a word processing system. You are probably happy with it because it was bold face as required. Fancy formats to accommodate illustrations were no trouble. Even graphic enhancement of the Pharaoh's face was part of the job, if requested.The advent of papyrus, a less durable, but lighter writing medium than stone, created the word processing pool. In the scriptorium, Egyptian artists would make copies of the original texts, probably personalized for the class of audience, so that, while the papyrus could not be posted for long in the market square for all to see, copies could be sent by runner to a wider range of villages for more people to read.The problem with the papyrus technology was the limited supply of papyrus. It did not grow in cooler climates where civilization seems to have crept. Thus developed the parchment technology. Parchment is made from split and pounded sheep skin. For large documents, such as maps, the whole sheep skin was stretched on a rack, rather like an embroidery frame, or drum surface, and the colours and inks were applied while the surface was taut. For the more ordinary reading material, the skins were sewn together, and cut into long narrow, continuous forms, and stored on sticks, forming scrolls, or volumes. The advantages and disadvantages of the scroll format are known to many computer users. Eventually the scroll format was replaced with a side-ways columnar format, rather more like the “screen-full” of text used by many computer systems.The next advance was to fold the scroll side-ways to create pages with a column on each surface. This developed into the book, or “codex”, that valuable random-access storage system for information which was such an improvement over the sequential system. With the advent of the page, came the possibility of the index. The codex was a Roman invention, but the index is still not used in a great number of books.The medieval codex contains a spectacular use of ink, and pigment technology, combined with the surfacing technology of the parchment. After more than a thousand years pages are still white, with easy to generate, and compared to a manual typewriter, the result probably looks pretty good. The proceeding paper that you are reading is not the better sort of computer output—quite deliverately so, but it is pretty usual, and considered acceptable.Look at the average computer screen that you use. It is usually over-crowded, backlit in green, white, or amber. The lettering is often terribly distorted monospaced type which is very hard to read for hours on end. In fact, we don't usually read screens, we recognize patterns on them. These pieces of paper, and these screens are the signs of our advanced technology.Now I am going to ask you to consider the technological changes that have preceded the usual paper manuals and screens that we use in our offices: before Macdraw before Macwrite in “Old English”; before all those computer graphics posters, and colour graphics terminals.The first publishing technology I want you to consider is the Rosetta Stone. Next time you are in the British Museum take another look at this monumental tribute to publishing. The Rosetta Stone is a multilingual document, in clear, proportionally-spaced type. There was only one, but it was a published document because it was placed in a public place as part of a large edifice, and therefore everyone of any importance would visit this place and have a chance to read it in the language of his choice.The next important technological change in publishing came with the development of papyrus as a writing surface. This was not an overnight success, I'm sure. It must have taken a long time to develop the right sort of combination of surface and inks to produce the types of papyrus documents we have preserved. They have drawings in colour which accompany the text, usually written in columnar form, in a good clear lettering, proportionally spaced, and still legible, and flexible after 5-10 millennia. Print-outs were available in full colour, with multi-colour texts, variable fonts, and brilliant, full colour illustrations. Texts are proportionally spaced, there are multi-lingual pages with varying column widths to suit the needs of the translator or commentator. Very often the texts are justified to both left and right margins, with column balancing as required, and specially tailored illustrations. Ornamental headings and first letters of text include references to the owner of the book, so that the illustration of a man's book would include his coat of arms, or his name, so that his copy was not like any other.There are texts of this technology created as special graphical jokes, or multi-media presentations, e.g., the parable of the loaves and fishes written in the shape of two very realistic fishes with the words forming the scales. There is a story of an ostrich with the text circling around until is runs into the bird's neck, and thus into the ground. Changing fonts seems to have been no trouble: Greek and Latin, French and German can appear on a single page, in large and small type, with bold face, italic, and illumination. Even the length of dashes can be altered especially to justify the lines. Mixing red and black inks on the same page did not even take a special press run. It was all part of the page if you desired it.The next technological advance of real note was Gutenberg's movable type which could be put into a press to allow many copies of a text to be produced with a total reduction in time. Gutenberg's first type was carved hardwood, which would deteriorate after a few books. So while the Bible he printed looked like the best handwriting of the day (German style handwriting, or “black letter” which the layman calls “Old English”). The advantage of Gutenberg's contribution was a lessening of costs of books, and the proliferation of important texts. The disadvantage was that the printing process was only an improvement in the printing of the text, or in specially carved wood block pictures. The paintings that could be done in many colours disappeared, because these paints did not work in a printing press which required ink. There were some attempts at hand-colouring pictures whose outlines had been done on the press, but these soon stopped. This phenomenon is symptomatic of technological advancement. Once we think that we have achieved a method that takes less time, we resent mixing the old technology with the new. I have seen it in the computer age quite strongly. Our printing process is now nearly universally offset printing rather than Gutenberg's letterpress. We can photographically reproduce any drawing, in colour or black and white. But the computerized publisher seems to resent mixing the computer-generated letters with hand drawings, because somehow, if you cannot do the whole business on computer, you are losing some of the advantage of the technological advance. The hell with the way it looks. The feeling among these people seems to be that it is better to have boxes made out of dashes and vertical bars than a hand drawing with some rounded corners to indicate a screen or keys on the keyboard. In just such a way the hand painting of printed black and white line drawing was left undone, and we lost colour in book illustration for about 500 years. Even when it was finally re-introduced, the pictures and text were never integrated as they has been in the manuscript days, and now pictures go in blocks, or pages especially set aside for doing screened black and white photos, line drawings, or full colour separations.It took about 300 hundred years for the quality of printing to come into its own, with the progressive simplification of type making it clear, clean, and legible, and sufficiently flexible to allow for the fish jokes of yesteryear. And at about the same time there was another technological change that put the quality of texts back into the stone age. That invention was the typewriter. There is no doubt that the typewriter was a wonderful tool, replacing wax tables, paper notes, and eventually, writings with small circulation (meaning the circulation of the number of carbons that could be forced into the typewriter). The quality of the result was abysmal compared to typeset texts, but the convenience of the transcription by skilled scribes, allowed people to overlook the poor quality. It was 50 to 75 years before typewriters became advanced enough to even-up the darkness of the letters, and eventually produce a sharp image. Another ten years passed before it became possible to get crisp letters with film ribbons, and then proportionally spaced type.There are a few other technological changes about this time which provided even worse images, such as court-stenographic machines and calculators, but we will skip rapidly over them once you have a picture of that style of output in your mind.Now we come to the advance that you have been waiting for: the computer revolution. The first computer printing is much older than the micro-computer, and was in all uppercase, with bad inking, and often type that varied in position in two directions: it was out of line both up and down, and side to side. But with the introduction of the microcomputer, and the recognition of word processing as a worthwhile activity for a computer, the quality of type has gone up. There are computerized typesetters, which create text about as nice as type done in the 18th century. It is not as nice as the monotype of the 20th century, but not as bad as the cheap type of the 19th century. There is typewriter quality output—known as “letter quality”—which looks like the best typewriters because it uses exactly the same mechanism. And at the lower end there are several varieties of type created with dots. The 300 dot per inch laser printer looks like Gutenberg operating on some old type, but because it is in a Times Roman face, it is considered much better than the unpretentious letter quality monospaced type. Then, horror of horrors, there is enlarged Mactype, which looks like it was cut out of felt with pinking shears in any cookie-cutter shape from black letter to Helvetica. It's so much worse than anything ever produced before in the history of publishing, that I cannot understand why anyone thinks that this was a technological advance. Then there is the dot-matrix printer, which is ineffable.I cannot give you the impression that I am a Luddite, because I have produced this paper using a word processing system on the ineffable printer. What I am trying to tell you is that there is still much work to be done to achieve the quality that computer publishing may achieve. But frankly this technological advance may be easy, but it's not good quality. Consider some of the achievements of the past, when people were trying to prove what they could do by hand, and work toward hose goals in beauty of design, legibility, and appropriateness. Do not let anyone tell you that civilization began in 1949 with the invention of the digital computer. Louis XIV was rather more civilized than you or I will ever be.
7556#The capability to merge graphics and text into a consolidated document can greatly enhance communication. Even simple graphics such as boxes and arrows can help organize ideas and make information easier to understand. It is still disturbing to see the number of manuals that describe computer graphics systems that do not include even one graphic image!In the phototypesetting world, the capability to merge graphics and text has been available for some time, but only recently have the components for less costly systems become available. This paper will discuss a segmented system in use in a scientific R&D environment for including graphics into documents.
7557#Dynamic screens and static paper
7558#I've been asked to tell you how Cornell attempted to explain to the rest of the world the establishment here of one of four national centers for advanced computing — the supercomputer facility formally known as the Center for Theory and Simulation in Science and Engineering and nicknamed the Theory Center. This is the center that was founded this spring with part of the 200 million dollars that the National Science Foundation is allocating in the federal government's supercomputer initiative. That's a polite way of saying, we want to “Pearl Harbor” the Japanese before they do it to us in yet another area of technology.In brief, the Cornell Theory Center will be receiving something in the neighborhood of 30 million dollars from the National Science Foundation and another 30 million from IBM, in equipment and support, over the next three years to build and operate a production supercomputer facility — a sort of jumbo jet of supercomputers — and to conduct research in experimental supercomputer configurations — a program that could be thought of as the X-15 of computing. The Theory Center is still seeking additional industrial support; another $100 million would be a nice round number. Even without the industrial support, this is the largest single research program at Cornell.I'd like to describe the preparation — the groundwork — that went into this public information effort, as much as two years in advance. We'll go into the gory detail of what went wrong in our announcement, and some of the things that went right, not so many thanks to us. We'll take a look at how the news media covered an event like this — in particular television news — and I'll tell you why the hardest part of our job, as public information practitioners, is still ahead us.Let's start with who am I and what am I doing at a conference of computer documentation people? In a way, we're in the same business. We're supposed to be explaining computers and computing to people. Your people — your public — can be assumed to be receptive to computing. Or at least they're using it. The general public includes lots of people like myself who are still on the fringes of the computer revolution. They've been involved in a few skirmishes, maybe not even wounded yet, but they're not sure whose side they're on. They know that “user friendly” isn't good enough. They're not ready to learn a new language to speak to a machine. “The damn things are in the U.S. of A. Let them learn to speak American”.Even the millions of folks who have bought personal computers share a healthy suspicion of computing. Big computers are the ones the IRS uses to lose your tax returns. Big computers are the ones in government weapons labs. Big computers still can't predict the weather. Big computers are the ones, when they make mistakes, you can't argue with.That has something to do with why the idea of super computing — large scale computing — is not so easy to sell. “Bigger is better” went out with tailfins on cars. Now, if you're going to be bigger, or bigger just to be faster, there had better be a good reason for it.We didn't realize all of this, however, when ken Wilson won the Nobel Prize for physics in 1982, and immediately began talking about building supercomputers. I guess we were just glad to hear a theoretical physicist talk about something besides “the deep and hitherto unperceived analogies between the phenomena revealed by phase transitions and certain aspects of elementary particle physics.”The public's first inkling that there would be something called a Theory Center began when Ken Wilson stood up at a press conference that October morning, about four hours after being notified he was a Nobel Prize winner, and said: “I'm working at the national policy level to get people to realize the importance of computers as they become very much more powerful than they are today.” He said that just one field alone—theoretical physics — needed computing support to the tune of $100 million a year. He said, “I hope the prestige of the prize will help me get people — not necessarily to give $100 million — but to look carefully at the problems I've been discussing and to see if we can't get them worked out.”And from that day on, Cornell began promoting Kenneth G. Wilson — and I'm not ashamed of that word, promotion — and capitalizing on his fame. After all, you're only the reigning Nobel Prize winner for 365 days, and then someone else's phone starts ringing off the hook.Now Wilson was already serving on government panels to advise on the future of large scale computing and he had been knocking on the doors of executive suites in big business and industry, trying to convince the movers and shakers that American industry needed supercomputers and that the computer industry wasn't going to make very many of them until there was a demonstrated market and the best showroom, if you will, for supercomputers would be the universities where potential customers could come and “kick the tires” of the latest models.Then suddenly, Nobel Prize winner Wilson was the most prominent member of those government panels. Receptionists would say, “Let me show you right in, Dr. Wilson.” We interviewed Wilson for a Cornell publication a month later and he said, “There is nothing that comes close to providing the kind of forum that the Nobel Prize provides. With the kinds of problems I'm dealing with, with the kinds of barriers I face, anything short of the Nobel Prize doesn't mean very much.”We took the text of that interview — which talked about new uses for computer modeling and simulation and some schemes for parallel processing — and we sent it to about a dozen key business writers and science writers and editors around the country with a note saying, “Keep your eye on this guy. He knows more about supercomputing than anyone else in the country.”Now we didn't know whether that was true at the time. We just sort of became convinced of it.In the meantime, Ken Wilson was stepping up his activities in behalf of supercomputers. He was visiting more industries and getting more involved in advising government policy. When a report or a recommendation came out, if his name wasn't on it, people would ask his opinion. When the Japanese moved a little closer to making some big advance, people would ask Ken Wilson what he thought the U.S. should do. And once you get cited in The New York Times as a “leading expert” then you are one, and everyone else wants to know what you think. He was invited to write lots of articles and give talks on supercomputers and “the Japanese challenge.” He became “Mr. Supercomputer.”We don't claim all the credit for his fame. A lot, maybe most, of the effort was on Wilson's part. We just did everything we could to keep him in the public eye. When he and IBM and some other industries and the National Bureau of Standards sponsored a conference on large scale computing in Washington, we promoted it, even though it had next to nothing to do with Cornell. He became one of about a dozen almost-celebrity professors at Cornell. The only person more quoted, day in and out, was Carl Sagan.After Wilson had convinced the Washington establishment and the people holding the purse strings to spend some big money on scientific supercomputing, he had to step back from the role of neutral adviser and apply for some of the money himself. And somewhere along the line, the Theory Center became the Theory and Simulation Center, and it was to be for engineering and not just science. Must be someone figured out that there's a reason why the Fortune 500 doesn't include companies called International Business Theories or General Theoretical Motors. The co-investigators in the proposal to the National Science Foundation were Wilson; Dr. Kenneth King, who is also a physicist by background and is the computer czar for Cornell; and Ravi Sudan, also a physicist and an engineer who runs a lab for plasma fusion studies.During the time the proposal to the federal government was being reviewed — for months — we couldn't say much about the Theory Center. It's considered bad form to discuss something you're certain you will get. And if you don't get it, you look really silly.So instead, we concentrated on one little phase of the Theory Center, one that was already going on. This was the so-called GIBBS Project, an attempt by Wilson and some of the computer scientists here to create an entirely new scientific programming language to replace FORTRAN. We asked the public relations firm that represents the College of Engineering, of which computer science is a part, to push the GIBBS Project and they tried. It got some attention in the trade press and in places Like Science magazine, not too bad for something that wasn't hatched yet. The Theory Center, itself, wasn't real for a long time either. The Cornell faculty had given its consent and so had the University Board of Trustees. But Cornell's President, Frank Rhodes, wouldn't allow it to be established until Wilson could show some evidence of funding. They had an office with a name on the door and some furniture and a couple of people, but they didn't exist as far as Cornell University was concerned. We took to calling them the Theoretical Theory Center.We also started planning how we would announce the center when it was funded, which everyone said it would be, except that was a secret. We started preparing with the National Science Foundation's public information people to make an announcement. They told us they were afraid of a leak, ahead of the official announcement, and it could come from Congress. We thought they meant congressmen from California or Illinois or someplace. Surely, no elected official from New York would engage in something as sleazy as pork barreling, then spill the beans. Remember, I told you something would go wrong…In our brainstorming sessions, Ken Wilson made a demand that caused some snickers and mumblings of “Boy, is he naive.” He wanted to create the impression in the public mind that all of upstate New York was the next up-and-coming high technology region in the country. That all the isolated high tech areas like Rochester and Schenectady and Syracuse could be working together, rather than in competition, and that they could be linked electronically, by the Digital Thruway. The next Silicon Valley! And he wanted that impression created and established before the Theory Center was established, so that it would seem to be another piece fitting into the high tech picture. So we tossed around some names. Everything new has to have a catchy name. If New York City was the Big Apple, upstate could be the Silicon Apple. Then someone pointed out that gallium arsenide was the next hot semiconductor material and maybe we should be the Gallium Arsenide Apple. But that sounded too much like something the wicked witch would give Snow White. We talked about how the state could become involved. We tried to point out that impressions of prosperity and high tech environments aren't created overnight. Nobody knew they loved New York until millions of dollars worth of jingles and bumper stickers and billboards told them so.I guess we sensed a few inferiority complexes showing in these men who were about to pull off an astounding achievement — to persuade the federal government and the biggest computer company in the world to risk tens of millions of dollars. I remember Ken King telling of a telephone call he had just received from an acquaintance at another university who said, “Congratulations, but you got the booby prize.” He meant that Cornell — although it hadn't been announced yet — would be the fourth last-minute center funded by the government, and that we had to team up with a company that didn't even make supercomputers to do it.We tried to point out that Cornell didn't need to apologize for being the odd man in or out or wherever, because we had the element of surprise on our side. Everyone would want to know why the government was designating a private university in the middle of nowhere as a national center. We said that a couple of times, then shut up, We thought we still had three months to prepare for the announcement.At one point, some thought was given to hiring the same public relations firm that represents the manufacturer of the array processors the Theory Center uses, Floating Point Systems, to represent Cornell as well. They talked a Lot about “building understanding” which is something that p.r. people are big on. “Building understanding” is p.r. shorthand for building understanding of my point of view and convincing you of it. The firm wanted $40,000 to make the announcement of the Theory Center, and that was just to the trade press. It occurred to us that for $40,000 we could parachute Ken Wilson to the roof of every one of the top 100 newspapers in the country to personally hand a news release to the editor. We told them we'd think about it. We thought we still had two months to prepare for an announcement, sometime in the middle of April.In the meantime, we began preparing background information on the supercomputer center. We did a story saying that supercomputing will benefit American business, that “the advanced power of supercomputing and the research discoveries it makes possible promise to improve the entire corporate production cycle, from conception of a product through manufacturing to distribution.”We did a story saying that the marriage of supercomputing and three-dimensional, real-time computer graphics would be the greatest advance in communication since cavemen started painting on walls.We prepared a background piece saying that “Cornell University is a promising Location for a national, advanced scientific computing center because of its experience in operating highly successful interdisciplinary centers for the benefit of the scientific research community.” And we took the opportunity to brag about the Cornell Manufacturing Engineering and Productivity Program (COMEPP) and the Cornell High Energy Synchrotron Source (CHESS) and the Materials Science Center and the National Research and Resource Facility for Submicron Structures (which spells NRRFSS) and the Cornell Biotechnology Institute and the Semiconductor Research Corporation Center of Excellence in Microscience and Technology (which doesn't spell anything).We did another story saying the research uses of the supercomputer will range from “the study of galaxies to subatomic particles, from the motion of drifting continents to the movement of toxic wastes.”We wrote a general news release on the announcement, Leaving blanks for the amount of money and the number of years and the actual date of the announcement. We thought we still had a month to get ready.We solicited statement of congratulations from New York Governor Mario Cuomo and from the congressional delegation from this part of the state and from IBM vice president Jack Keuhler.When we were writing our news releases, by the way, we had to be careful not to mention IBM in the same breath — or even the same paragraph — with the word supercomputers. That directive came down from on high at IBM. IBM was not in the supercomputer business. Never had been, never will be. We couldn't even say the 3084QX would be a building block of a supercomputer. IBM was just giving us $30 million because they like us.We prepared biographies of all key personnel involved — all the way from Cornell President Frink Rhodes, who doesn't know anything about computers but who is able, with a little prompting, to speak eloquently on any issue and thank people for giving us money — down through all the vice presidents of: the university and provosts to the principal investigators in the Theory Center grant to the people who will really run the facility.Then we sat back and waited. Until February 20th, a Wednesday, when the NSF told us the announcement would be made the following Monday morning, in Washington. That didn't bother us. We were ready. We decided to schedule not one, not two, but three simultaneous press conferences. We would send Ken Wilson to the NSF press conference in Washington, along with a couple people from our office to straighten his tie and tuck in his shirt tails. We sent President Rhodes and Vice Provost King and Professor Ravi Sudan to New York for a press conference at Cornell Medical College. And we kept one Cornell vice president and one provost and the executive director of Theory Center, Bill Schrader, and the head of Theorynet, Alison Brown, for a simultaneous press conference in Ithaca.When we announce a press conference, we are very cagey. We try not to give away very much of the story — just enough to entice people to turn out. There's a reason for this. If you give away the story and if it's worth anything, the news people — being in a very competitive business — will try to run with it, and spoil your announcement. It happens every time. So we said something Like: Cornell University, the National Science Foundation and a major manufacturer of computing equipment will announce the start of a $60 million cooperative research venture at 10:30 a.m. Monday, February 25, at the following locations: …. Then we swore everybody to secrecy, everybody who might get calls Late at night or even be likely to talk in their sleep. There was one exception to that: We lined up an interview with Ken Wilson and The New York Times for Monday morning, just preceding the scheduled announcement. Then we sat back and waited.Imagine our surprise, on Saturday morning, February 23, to start receiving calls from news media all over New York State: “Could someone comment on the D'Amato announcement?” The D'Amato announcement? They read from a press release: “Senator Alfonse M. D'Amato (R, NY) is pleased to announce that Cornell University will receive at least $30 million and possibly up to $60 million from the National Science Foundation and up to $35 million from International Business Machines Corp. to do fundamental research from America's next generation of supercomputers.” Senator D'Amato said the grants would make Cornell one of the leading institutions in the country.That surprised us a little. We thought we were already a Leading institution. We are among the top four or five or six research universities in the country, and our academic reputation isn't too shabby, either.It was obvious what Sen. D'Amato was up to. He serves on one or two committees that some time in the past had reviewed the NSF proposals, probably voted for an appropriation when it seemed that some of the money might go to his home state, and placed a note in his future file: Break this on a slow news day and take credit for it.We tried to persuade D'Amato and his staff to back off, to correct his misinformation, to join us in a joint announcement on Monday and to shut up in the meantime. No go. He said the NSF had given him the green light to make the announcement. The NSF was furious. They refused to confirm that Cornell would even get a nickel, they started an investigation to determine how the leak occurred, and they blamed Cornell for prompting Sen. D'Amato to jump the gun and spoil the announcement for the other three centers around the country. The congressmen in the House of Representatives who really had gone to bat for Cornell on this one weren't too happy either. But they knew that D'Amato had a reputation for this sort of thing.Of course the news was in the Sunday papers all around New York the next day. That kind of money, even if the figures are incorrect, gets people's attention. The stories said that Cornell officials refused to comment, except to say that Sen. D'Amato was mistaken, and that an announcement would be made on Monday. It looked like we had something to hide. Or at least that we were caught off guard.Which we weren't. We had even given Ken Wilson media training. We had put him in front of our own TV cameras. We had dry runs of press conferences. We asked him the toughest, the stupidest, the most repetitive questions we could think of. We tried to teach him to look at the camera, not to fidget or play with parts of his clothing, not to look to the heavens or into his pocket for answers. In short, to give the impression that every question he gets is the most perceptive and original he has ever heard, deserving of a sensitive, profound answer that he just thought of. We weren't trying to make a Carl Sagan of him, just to help him come across as the intelligent person that he really is.Then we packed everybody off to their respective press conferences. All in all, they went pretty well, considering that practically nobody came to the New York City press conference and that the University of Illinois beat the pants off us in the Washington conference. The problem at the NSF press conference wag Larry Smarr, the Illinois astrophysicist, who was savvy enough to jump up and answer questions that weren't directed to anybody in particular. (We made a note to train Wilson to do that the next time.) Larry Smarr told a little story that any of the supercomputer people could have told but he thought of it first, and it's been quoted everywhere since then. He said that supercomputers are so scarce in this country that in order to do his research he had to go to Germany to find time on a machine — a machine that was made in this country. No big deal, but it was the kind of anecdote that writers love and lots of them used it in their stories.We knew our homework was paying off, however, when we saw that Ken Wilson was quoted on the front page of The New York Times, even before they mentioned the other places that have supercomputer centers. Larry Smarr had a snappier quote, but it was in the second section of the paper, and besides, IBM was quoted as saying that Cornell's approach to building supercomputers was the only one IBM would consider exploring, not that IBM was particularly interested in making supercomputers, of course.You have before you copies of some of the newspaper and magazine clips that appeared over the next few days. There have been lots more since. I'd like to play for you some tapes from local television stations that covered the Ithaca press conference. They go from bad to worse. We in the public information business collect these things to try to figure out how the information that we thought was presented so clearly gets so screwed up on the six o'clock news. Later I'll play a segment from a public affairs show on a Local PBS station, and then a piece that one of the national networks did — a really first rate job. Those of you who live in major media centers will be educated on what small town television is like. Those of you from small towns can sympathize.
7559#A few spring seasons ago one of my professors in graduate school was deep in a depression. In response to a departmental decision to install word processors, his desire to put pencil to paper had died and his passion for instilling a healthy respect for the English language in his students had waned. The following fall, however, he was a changed man - the depression had vanished. When I asked what had brought about this change, he said he had spent the summer in the “eighteenth century,” alias the museum school at Cooperstown. There, he had spent long hours drafting with a quill pen, setting type blocks by hand, and cranking sheets of rag paper through a press - producing documents from start to finish by his own hand. He had recaptured his vitality and his perspective by returning to the basics, and now, he thought, he was ready to take on the spectre of the computer.Many professionals in our field are experiencing the same desperation that my professor faced. However, they do not have the option of returning to a school for antiquities — they are being pushed into the future. Today, writers are being told to put aside their pencils, and to work online. Writers are complaining that the new documentation processes are removing them too far from their words, and that the process is contributing to the defamation of the natural beauty of our language. They fear that the art of technical writing and the craft of producing a document are being undermined by the new technology. They wonder how to maintain the integrity of the language when the words of that language can't be touched anymore - when they are composed not by human hand but by a sequence of dots in a matrix, and when they are not laid to boards with wax but synthesized by a computer that integrates text and graphics and appear on a clean, odorless printout. They are both intimidated by the new systems and feel resentful of the machine that separates them from their words.This separation conflict can be addressed on three levels. First, evaluating the advantages and disadvantages of computer-aided publishing can help ease the crisis of craft, that is, the idea that the documentation process is out of human control. Second, recognizing the advantages of the new medium - in our case, computer code - can help ease the crisis of change, that is, the perception that the new technology is overwhelming, and that resistance is the best line of defense against it. Third, accepting the idea that online development is not merely word processing, and realizing that your strength, skill, and art cannot be compromised by a keyboard can solve the crisis of art - that is, the idea that computer technology can deface the beauty of your words.To address the first concern - that of a revolutionary approach to production, let us examine a case in point. At Bell Communications Research, Inc. (Bellcore), a plan for electronic publishing has just been instituted. Within two years, we expect to write online, create graphics online, compose pages that integrate those words and graphics online, impose our publications' standards on those pages online, and publish documents composed of those pages online. Instead of sending mechanicals to a human printer, we will send computer code to a laser printer. In short, our publication portfolios will be in binary instead of binders.There are few technological obstacles to overcome to implement this system. One great advantage is that our form of computer-aided publishing (CAP) frees us from the traditional serial method of production - writing, editing, illustration, typeset, paste-up, and printing. That process is lengthy and labor-intensive, and each step is dependent on the one that preceded it. If, for instance, the decision is made after paste-up to drop an illustration, the document must be reformatted from the point of the illustration. The writer must return to the text to make sure that references and the folio list are changed. The proofreader must ensure that the writer has caught all the changes. The compositor must reformat the document. And, if the change occurred after the blueline was produced, the negatives must be re-shot. Each person's efforts are cumulative and pyramidal. If one block is imperfect, the end product may be structurally deficient.This takes not only time but money. Given an average cost per page of 20 to 50 dollars a page for new mechanicals, this can easily add hundreds of dollars to the cost of composition. Although CAP has its own costs, they are considerably less than the price of manual composition. For example, a 20-page document with four schematics costs approximately 450 dollars on our CAP system. This cost includes text entry, creation of the graphics, proofreading, formatting, composing, and typesetting. The “boards” (repro copy) are ready in less than three days. And, cost savings continue through the “printing” process. If the document is electronically transmitted, a negligible cost is incurred for XOPR, or whatever means of data transfer is used. Finally, whatever costs are normally associated with the laser printer are levied. If the document is printed at a print shop, the costs are about two-thirds of normal because negatives are not needed. Negatives are not necessary because the copy is not mounted on boards, and boards are not necessary because all paste-up is done electronically. CAP merges text and graphics. In either case, substantial savings can be realized. Given the cumulative effect these sorts of changes have on document price, CAP is particularly appealing to those who have to pay for the material - in our case, the regional telephone operating companies.The companies - our owners - also want to be in control of the number of documents they receive. This is an added feature of our CAP process. With “on-demand” printing, once a document is ready for “distribution” to the field, the code is transmitted to VAX systems in 14 major metropolitan areas. Each VAX system is connected to a Xerox 9700 printer. With computer code and their own laser printers (which can be used for purposes other than printing the documents) they do not have to pay for print overruns. They know exactly how many copies they need and only that number is printed. Consequently, they have more control over the cost of “printing” and distribution. They simply do it themselves. What could be better?From the writer's perspective, some things could be better. And these concerns revolve around the notion of a crisis of change. Attuning oneself to the radical changes embedded in this process takes more than a little doing. Although it is not a difficult task to type on a computer keyboard (instead of a typewriter), or learn which buttons to press to format a document (instead of dictating specs to a compositor), it is stressful not to have the option to return to paper and pencil. It is challenging to face the consequence of technology: you must address the future to address your clients. And, although this message may seem far-fetched for the publication industry, it is not. The time has come when industry wants its money spent wisely and efficiently. Computer-aided publication must follow on the heels of computer-aided design and computer-aided engineering.The benefits of accepting and employing technological change have historical precedent. Think back to the middle of the fifteenth century. Johann Gutenberg's invention of printing with movable type was more a modification of existing technology than a totally new concept, but it had enormous impact. Writers and philosophers who took advantage of the ability to disseminate their ideas through print instead of manuscript were at a great advantage in terms of how great an audience could be addressed. In fact, the humanist movement might have been short-lived had it not been for the relatively widespread availability of classical writings. We might never have had the joy of Erasmus' In Praise of Folly or Sir Thomas More's Utopia had it not been for their realization that circulation of exact copies of their writings led to not only increased discourse but new attitudes. They contributed not only to the world of ideas, but the idea that the world could get information in a more timely, accurate, and consistent form.Advancing in time, the same statement can be linked to those who fought the ideological battles that laid the way for the American Revolution. Through their rhetoric they inflamed more hearts and brought them to the edge of revolution than was justified by the turn of events. The printing and pamphleteering business boomed. The “audience” responded. Suffice to say, they used the latest in technology to address critical issues. By controlling the presses, they had a clear advantage. The rest, as they say, is history.These historical examples should not be viewed in isolation, for today great opportunities exist to use the tools and technology to expand our audience base and to reach out to those that standard print technology might not affect. The possibilities of sending text over television (broadband), over FM radio (narrowband), through microwave frequencies, or through satellites or over cable television are endless. The dream of videotext is now a reality. One- and two-way transmissions can be sent over the telephone or through a cable. Technical capabilities are no longer a hindrance. Rather, they should be seen as a boon.Computer-aided publishing can also be a boon to the writer as concerns the third crisis I want to address - that of the artistry of writing. As technology has advanced, and as writers must deal with new vocabularies and constructions, many feel the result is a decline in the style and presentation of writing. One of my colleagues described it as “our loss of autonomy in a world of presentation - with no latitude for creativity and individuality,” and wondered how “yesterday's writer is accepted into today's non-verbal, passive, and highly graphic world of communications.” These are legitimate concerns. Good examples of bad English abound in all the communication media today.Using CAP to its fullest advantage is one way to combat the deterioration of the language. For example, the speed and ease of editing allows for more editing iterations. And although a document will not necessarily improve during each editing cycle, very often the quality does improve the more the document is worked on. And, quality is the heart of this concern. Computers can do nothing to intuitively aid or deter the writer in his or her work - they are merely tools, but tools with many attachments that can ease the process. Those basic attachments, such as programs that check spelling, that count how many times and in which contexts words have been used, that identify certain types of phrase structures, and that format documents automatically are aids that should not be neglected. Additionally, the ease with which drafts can be circulated, commented on, and returned to a writer with comments contribute to better writing. From my terminal, for example, I can transmit drafts to experts on telecommunications in Washington, San Francisco, St. Louis, and Seattle within minutes, and receive their comments within hours.Furthermore, CAP permits the use of more exotic technology. The links to graphics software, which afford the writer the luxury of a choice of formats and presentation, allow for experimentation in how to effectively present illustrative material. Along those same lines, the writer also can dally with fonts and type size (although this is sometimes limited by the constraints of the printer that will ultimately produce the physical document). In sum, electronic peripherals are a means through which the writer can attack the problem of producing good writing in a world in which bad writing abounds. They offer the opportunity to the writer to fine-tune a document in relatively short period of time (with the aid of software “helpers” if desired), and to support that writing through interactive design and execution of graphics and format.These three perspectives on CAP - how to deal with the concerns of how the process has changed our craft, how to use it most effectively, and how we may maintain our standards in light of the revolutionary change - are central to our work. We cannot dismiss them. Whereas computer-aided publishing is an awesome concept, and one that threatens certain types of crafts, the advantages in speed (reduction of composition time results in increase in creativity time), control (over all phases of the production as well as the quality of the writing), and audience (the opportunity to address a greater audience both more directly and through a medium that is more the norm than the exception) are overwhelming. CAP should not be viewed as an obstacle, but as a gateway that, once opened, reveals a wealth of opportunity. I believe that even my professor in graduate school, light-hearted as he was over preparing a document by his own hand, would agree with me. When I last saw him a few months ago, I had to wrench him away from his current passion - composing a book on eighteenth century printing. His medium? His new loves in life - a personal computer, word processing software, and a printer.
7560#Proceedings of the fifth annual ACM symposium on Principles of distributed computing
7561#Designing a global name service
7562#Correctness conditions for highly available replicated databases
7563#Highly available distributed services and fault-tolerant distributed garbage collection
7564#Transaction commit in a realistic fault model
7565#Distributing the power of a government to enhance the privacy of voters
7566#A communication-efficient canonical form for fault-tolerant distributed protocols
7567#Asymptotically optimal algorithms for approximate agreement
7568#Optimal message routing without complete routing tables
7569#On fault tolerant routings in general networks
7570#The complexity of using forwarding addresses for decentralized object finding
7571#Incremental attribute evaluation in distributed language-based environments
7572#Gap theorems for distributed computing
7573#On the bit complexity of distributed computations in a ring with a leader
7574#Probabilistic solitude verification on a ring
7575#The effects of link failures on computations in asynchronous rings
7576#Limitations on database availability when networks partition
7577#Protocols for dynamic vote reassignment
7578#Optimistic concurrency control for abstract data types
7579#Efficient synchronization of multiprocessors with shared memory
7580#Memory coherence in shared virtual memory systems
7581#Reasoning about networks with many identical finite-state processes
7582#What processes know: Definitions and proof methods
7583#The synthesis of communication protocols
7584#Continuous routing and batch routing on the hypercube
7585#Slowing sequential algorithms for obtaining fast distributed and parallel algorithms: maximum matchings
7586#On an extremal problem concerning the interval number of a graph
7587#Linear objective functions on certain classes of greedoids
7588#The Linzertorte problem, or a unified approach to painting, baking, and weaving
7589#A polymatroid associated with convex games
7590#A system of linear equations related to the transportation problem with application to probability theory
7591#A duality property for the set of all feasible solutions to an integer program
7592#Schedule-induced posets
7593#Algorithms and complexity for least median of squares regression
7594#An optimization problem on graphs
7595#A decision procedure on partially commutative free monoids
7596#Design Studies
7597#Design activity models: worldwide emergence and convergence
7598#DASD, “Too much ain't enough”
7599#The maturation of capacity planning
7600#How the software workbench saved Christmas
7601#The template
7602#Software World
7603#Compute engine accelerator from Mentor Graphics
7604#Software quality—getting the edge
7605#Langton CD-ROM services
7606#Parallel processing: a user perspective
7607#Applying computer technology to the process industry
7608#EDV in Medizinund Biologie
7609#Design and mechanisation of agriculture field trials (German)
7610#The effect of the skewness of residual-distribution on the first type-error of some frequently used F-test statistics in the analysis of covariance (German)
7611#The quality of the average-linkage-method for different error distributions (German)
7612#Distribution-free tolerance regions for circular data (German)
7613#Analysis of a series of diallels using a model with finite populations (German)
7614#Analysis of ordinal data: an empirical comparison of two methods (German)
7615#The new breed of executive information users
7616#DBMS basics
7617#Electronic data interchange
7618#Making conversions obsolete?
7619#E-mail and voice-mail systems: conspirators or competitors?
7620#Capacity plananing & capacity management
7621#Refuting CIM myths
7622#The Gains from Computer Communication
7623#Functional addressing in Gutenberg: interprocess communication without process ientifiers
7624#Internet Locus: extending transparency to an internet environment
7625#SODOS: a software documentation environment-its use
7626#On the projection method for protocol verification
7627#A fault-tolerant scheduling problem
7628#The call-return tree and its application to program performance analysis
7629#On the properties of extended inclusion dependences
7630#Some design aspects of databases through Petri net modeling
7631#Distributed database management model and validation
7632#A decomposition solution to a queueing network model of a distributed file system with dynamic locking
7633#A distributed scheme for detecting communication deadlocks
7634#A Layout algorithm for data flow diagrams
7635#Development of a debugger for a concurrent language
7636#Load-leveling in fault-tolerant distributed computing systems
7637#Combining queueing network and generalized stochastic petri net models for the analysis of some software blocking phenomena
7638#NON-VON's performance on certain database benchmarks
7639#Validating Halstead's theory with system 3 data
7640#Comments on :20Estimating the number of faults in code" and two corrections to published data
7641#The accepted approach to software development is to specify and design a product in response to a requirements analysis and then to test the software selectively with cases perceived to be typical to those requirements. Frequently the result is a product which works well against inputs similar to those tested but which is unreliable in unexpected circumstances. In contrast it is possible to embed the software development and testing process within a formal statistical design. In such a design, software testing can be used to make statistical inferences about the reliability of the future operation of the software. In turn, the process of systematically assessing reliability permits a certification of the product at delivery, that attests to a public record of defect detection and repair and to a measured level of operating reliability. This paper describes a procedure for certifying the reliability of software before its release to users. The ingredients of this procedure are a life cycle of executable product increments, representative statistical testing, and a standard estimate of the MTTF (mean time to failure) of the product at the time of its release. The paper discusses the development of certified software products and the derivation of a statistical model used for reliability projection. Available software test data are used to demonstrate the application of the model in the certification process.
7642#Failure times of a software reliability growth process are modeled as order statistics of independent nonidentically distributed exponential random variables. The Jelinsky-Moranda, Goel-Okumoto, Littlewood, Musa-Okumoto logarithmic, and power law models are all special cases of exponential order statistic models, but there are many additional examples as well. Various characterizations, properties, and examples of this class of models are developed and presented.
7643#A discrete and, as approximation to it, a continuous model for the software reliability growth process are examined. The discrete model is based on independent multinomial trials and concerns itself with the joint distribution of the first occurrence time of its underlying events (bugs). The continuous model is based on the order statistics of N independent nonidentically distributed exponential random variables. It is shown that the spacings between bugs are not necessarily independent or exponentially (geometrically) distributed. However, there is a statistical rationale for viewing them so conditionally. Some identifiability problems are pointed out and resolved. In particular, it appears that the number of bugs in a program is not identifiable. Estimated upper bounds and confidence bounds for the residual program error content are given based on the spacings of the first k bugs removed.
7644#A new hardware-software reliability model is developed where lifetimes and repair times of the software subsystem have general system state-dependent distributions. The hardware subsystem constitutes an independent alternating renewal process having exponential up-times and general down-times. Multiple errors may be introduced or removed through repairs. The model is formulated as a multivariate stochastic process. To study the performance of the software subsystem under the influence of hardware failures, expressions of various time dependent performance measures are derived. Using the matrix Laguerre transform of Sumita [11], corresponding computational procedures are also developed. A numerical example is given, demonstrating speed, accuracy, and stability of these procedures.
7645#The reliability of distributed processing systems can be expressed in terms of the reliability of the processing elements that run the programs, the reliability of the processing elements holding the required files, and the reliability of the communication links used in file transfers. We introduce two reliability measures, namely, distributed program reliability and distributed system reliability to accurately model the reliability of distributed systems. The first measure describes the probability of successful execution of a distributed program which runs on some processing elements and needs to communicate with other processing elements for remote files, while the second measure describes the probability that all the programs of a given set can run successfully. The notion of minimal file spanning trees is introduced to efficiently evaluate these reliability measures. Graph theory techniques are used to systematically generate file spanning trees that provide all the required connections. Our technique is general and can be used in a dynamic environment for efficient reliability evaluation.
7646#A systems approach to analysis and control of software reliability is described which is intended to supplement conventional software reliability models which focus on program attributes under the control of the software professionals. The external view of software reliability is particularly appropriate at the two extreme phases of the life cycle: • during the concept development and project planning phases because during these very little is usually known about the internal attributes of the software • during the operations and maintenance (O&M) phase because very little can be done about the internal attributes of the software. A review of software reliability experience during the O&M phase is presented first. This is followed by the description of a basic failure model that supports a unified approach to software and hardware reliability and of the implications of that model for conventional software reliability approaches. Next the effect of management activities on reliability is investigated, and finally an outline of a combined hardware/software reliability model suitable for the planning phase is presented.
7647#Two complementary techniques have evolved for providing fault-tolerance in software: forward error recovery and backward error recovery. Few implementations permit both approaches to be combined within a particular application. Fewer techniques are available for the construction of fault-tolerant software for systems involving concurrent processes and multiple processors. Many schemes for supporting forward or backward recovery are based on some concept of an atomic action. In this paper, we propose a mechanism for supporting an atomic action in a system of Communicating Sequential Processes (CSP). The atomic action is used as the basic unit for providing fault-tolerance. The atomic action is called an FT-Action, and both forward and backward error recovery are performed in the context of an FT-Action. An implementation for the FT-Action is proposed, which employs a distributed control, uses CSP primitives, and supports local compile and runtime checking of the forward and backward error recovery schemes.
7648#Some difficulties and complexities in atomic actions occur only when the concept of atomic actions is extended to allow concurrency within atomic actions and to allow a single atomic action to execute at a number of different sites. Also, providing facilities for both forward and backward recovery presents problems not found in the more usual case of allowing only backward recovery. This paper presents an analysis of these problems and proposes a general structure for a solution. A syntax which might be used to specify this structure is also given and illustrated with examples. The practicality of the scheme is justified by sketching one possible implementation.
7649#Modular redundancy in the form of replicated computations in a concurrent programming model consisting of communicating sequential processes is investigated. Some conditions are given which must always be verified to ensure correctness in the presence of nondeterminism. Then some implementations which satisfy the given conditions are proposed. This approach permits redundant systems to be robust with respect to failures in redundant processors, and also permits the use of software fault tolerance techniques such as N-version programming. The concurrent programming model which has been chosen is based on a set of active entities, i.e., processes, each running in a local protected environment; processes interact using message passing only.
7650#A common assumption in the existing rollback techniques is that transients, the cause of most failures, subside very quickly, implying that a single retry of the program from the previous rollback point is sufficient. We discuss a general rollback strategy with n(n ≥ 2) retries which takes into consideration multiple transient failures as well as transients of long duration. Ways of deriving practical values of n for a given program are also discussed. Furthermore, we propose the use of a watchdog processor as an error detection tool to initiate recovery action through rollback, since the watchdog processor offers low error latency. We also discuss the merging of the watchdog processor with rollback recovery technique for enhancing the overall system reliability.
7651#N-version programming has been proposed as a method of incorporating fault tolerance into software. Multiple versions of a program (i.e., “N”) are prepared and executed in parallel. Their outputs are collected and examined by a voter, and, if they are not identical, it is assumed that the majority is correct. This method depends for its reliability improvement on the assumption that programs that have been developed independently will fail independently. In this paper an experiment is described in which the fundamental axiom is tested. A total of 27 versions of a program were prepared independently from the same specification at two universities and then subjected to one million tests. The results of the tests revealed that the programs were individually extremely reliable but that the number of tests in which more than one program failed was substantially more than expected. The results of these tests are presented along with an analysis of some of the faults that were found in the programs. Background information on the programmers used is also summarized. The conclusion from this experiment is that N-version programming must be used with care and that analysis of its reliability must include the effect of dependent errors.
7652#Digital computers are being used more frequently for process control applications in which the cost of system failure is high. Consideration of the potentially life-threatening risk, resulting from the high degree of functionality being ascribed to the software components of these systems, has stimulated the recommendation of various designs for tolerating software faults. Such designs are not panaceas, for they still entail — as did the fault intolerant designs they are superceding-an unknown probability of failure. The paper discusses four reliability data gathering experiments which were conducted using a small sample of programs for two problems having ultrareliability requirements, w-version programming for fault detection, and repetitive run modeling for failure and fault rate estimation. The experimental results agree with those of Nagel and Skrivan in that the program error rates suggest an approximate log-linear pattern and the individual faults occured with significantly different error rates. Additional analysis of the experimental data raises new questions concerning the phenomenon of interacting faults. This phenomenon may provide one explanation for software reliability decay. The fourth experiment underscored the difficulty in distinguishing between observations of deficiencies in the design of the algorithm and observations of software faults for real-time process control software. These experiments are a part of a program of serial experiments being pursued by the System Validation Methods of NASA-Langley Research Center to find a means of credibly performing reliability evaluations of flight control software.
7653#If a program is developed from a specification in a mathematically rigorous manner, work done in the development can be utilized in the testing of the program. We can apply the better understanding afforded by these methods to provide a more thorough check on the correct operation of the program under test. This should lead to earlier detection of faults (making it easier to determine their causes), more useful debugging information, and a greater confidence in the correctness of the final product. Overall, a more systematic approach should expedite the task of the program tester, and improve software reliability. The testing techniques described in this paper apply to the testing of abstract data types (modules, packages). The techniques utilize information generated during refinement of a data type, such as the data type invariant and the relationship between the specification and implementation states; this information is used to specify parts of the code to be written for testing. The techniques are illustrated by application to the implementation of a symbol table as an ordered list and as a height balanced tree.
7654#In order to enhance the reliability of software, programmers have first to detect program errors and then to remove them. Although many errors can be detected during compilation when high level programming languages are used, still the degree of detection achievable by a compiler will be limited to the static aspect of program errors. Therefore, we need further investigation into a more sophisticated programming and debugging environment. This paper presents an environment which involves a debugging tool to help us detect logic errors and remove them efficiently. The debugging tool is supported by a special architecture named SPRING which was originally developed for reliable execution of Ada or Pascal programs. Following an overview of the system backed up by SPRING, the details of SPRING architecture are described, and the implementation of high level debugging on the SPRING architecture is discussed. In conclusion, our trial could be seen as a step toward providing an advanced programming environment for the development of reliable software.
7655#User Software Engineering is a methodology, with supporting tools, for the specification, design, and implementation of interactive information systems. With the USE approach, the user interface is formally specified with augmented state transition diagrams, and the operations may be formally specified with preconditions and postconditions. The USE state transition diagrams may be directly executed, with the application development tool RAPID/USE. RAPID/USE and its associated tool RAPSUM create and analyze logging information that is useful for system testing, and for evaluation and modification of the user interface. We briefly describe the USE transition diagrams and the formal specification approach, and show how these tools and techniques aid in the creation of reliable interactive information systems.
7656#We introduce a new programming language concept called typestate, which is a refinement of the concept of type. Whereas the type of a data object determines the set of operations ever permitted on the object, typestate determines the subset of these operations which is permitted in a particular context. Typestate tracking is a program analysis technique which enhances program reliability by detecting at compile-time syntactically legal but semantically undefined execution sequences. These include, for example, reading a variable before it has been initialized, dereferencing a pointer after the dynamic object has bee deallocated, etc. Typestate tracking detects errors that cannot be detected by type checking or by conventional static scope rules. Additionally, typestate tracking makes it possible for compilers to insert appropriate finalization of data at exception points and on program termination, eliminating the need to support finalization by means of either garbage collection or unsafe deallocation operations such as Pascal's dispose operation. By enforcing typestate invariants at compile-time, it becomes practical to implement a “secure language” — that is, one in which all successfully compiled program modules have fully defined execution-time effects, and the only effects of program errors are incorrect output values. This paper defines typestate, gives examples of its application, and shows how typestate checking may be embedded into a compiler. We discuss the consequences of typestate checking for software reliability and software structure, and conclude with a discussion of our experience using a high-level language incorporating typestate checking.
7657#Program structure is designed, redesigned, and develops and changes during the development phase. This paper describes a mini methodology for generation and representation of design and program structures, and structural consistency checking between two successive designs or between a design and a program. The mini methodology is based on the following. 1) The tool: a special Program Design Language (PDL) which is equipped to extract the actual and complete structure information from design documents and programs, or partial structure information — when required. 2) The representation: two matrices, a Call Relationship Matrix (CRM) and a Global References Matrix (GRM), which completely represent the program structure. 3) The consistency criteria: clear definitions when the structures of two successive designs, or a design and a program, are consistent. The PDL extracts structure information, in a controlled way, from the top level program design, through layers of detailed designs, down to the source code itself. It generates an actual, complete, concise, and easily comparable structure representation. Structural consistency between levels can be checked, both at the development phase and at the operation and maintenance phase, ensuring continued structural consistency between the design(s) and the program. The structure representation can also be used for configuration management of the structure of designs and programs.
7658#Polyhederal proof methods in combinatorial optimization
7659#An introduction to parallelism in combinatorial optimization
7660#Randomized algorithms in combinatorial optimization: a survey
7661#An introduction to the analysis of approximation algorithms
7662#The rate of convergence to optimality of the LPT rule
7663#Valid inequalities for mixed 0-1 programs
7664#Complete spline smoothing
7665#Asymptotic error expansion and richardson extrapolation for linear fine elements
7666#AC0-Collocation-like method for two-point boundary value problems
7667#An elementary algebraic representation of polynomial spline interpolants for equidistant lattices and its condition
7668#Convergence analysis of discretization methods for nonlinear first kind volterra integral equations
7669#QR factorization of toeplitz matrices
7670#Uniformly enclosing discretization methods for weakly nonlinear boundary value problems
7671#Interval models of comparative probability on finite sets
7672#Languages for the assessment of knowledge
7673#A theory of information structure. II. A theory of perceptual organization
7674#Bradley-Terry-Luce models with an ordered response
7675#Relationships between linear systems theory and covariance structure modeling
7676#The wandering ideal point model: A probabilistic multidimensional unfolding model for paired comparisons data
7677#Induction of categories: The problem of multiple equilibria
7678#The :20Brain-state-in-a-box" Neural model is a gradient descent algorithm
7679#Login: A logic programming language with built-in inheritance
7680#The relation between logic and functional languages: A survey
7681#Natural deduction as higher-order resolution
7682#A technique for doing lazy evaluations in logic
7683#The consistency of negation as failure
7684#Comments on :20General Failure of logic programs"
7685#Analysis of sequential prolog programs
7686#Canonical logic programs
7687#Implementing parallel algorithms in concurrent prolog: The maxiflow experience
7688#Negation as inconsistency .I
7689#Quantitative deduction and its fixpoint theory
7690#A basis for deductive database systems. II
7691#A constructive view of prolog
7692#Pressing for parallelism: A prolog problem made concurrent
7693#Ada, as seen from simula
7694#Using high level languages for local computer network communication: A case study in Ada
7695#Reorganization in a simple database system
7696#TBLP-A simple preprocessor for tables
7697#Icecream, transportable software for creating friendly human interfaces
7698#A code generator synthesizer for the non-specialist
7699#Suitable multiprocessor structures and virtual storage management when applying a feasible scheduling algorithm in hard real-time environments
7700#Management of replicated files in a UNIX enviornment
7701#Superlinear speed-up and the halting problem
7702#Formatted syntaxes and modula-2
7703#Automatic generation of useful syntax error messages
7704#Dbxtool: A window-based symbolic debugger for sun workstations
7705#A monitor tool for a network based on the cambridge ring
7706#Multiplication by Integer constants
7707#Iterative development of information systems: A case study
7708#Integrating distributed array processing into EMAS 2900
7709#Providing multi-user access to distributed array processors
7710#A string pattern matching extension to Pascal and some comparisons with SNOBOL4
7711#A management system for dirty data
7712#A fortran procedure for drawing some space-filling curves
7713#Algorithms for pattern matching
7714#Process administration in a high level language
7715#Copying of dynamic structures in a Pascal environment
7716#The construction of information management system prototypes in Ada
7717#A persistent graphics facility for the ICL PERQ
7718#AWK as glue for programs
7719#Yet another storage technique for LR parsing tables
7720#Reliability analysis of multipath interconnection networks
7721#Multiple-microprocessor/microcomputer performance: what to acquire and how to evaluate: a status report
7722#On methods for direct memory access without cycle stealing
7723#A daisy architecture for the multiprocessor real time data acquistion system of the Thor Tokamak Experiment
7724#Supermicros—objectives and approaches
7725#A Survey of microprogramming languages
7726#Analysis of a few list scheduling algorithms for compaction of horizontal microprograms
7727#Workshop on European information technology standardization and certification policy—introduction and discussion
7728#Exact likelihood for stationary vector autoregressive moving average process
7729#MOVAL: A framework for turning digital signal processing algorithms into custom hips
7730#Multi-component filtering of magnetic signals
7731#Real-time numerical peak detector
7732#Maximum energy window with constrained spectral values
7733#An efficient method for the estimation of the frequency of a single tone in noise from the phases of discrete Fourier transforms
7734#Single trial evoked potential analysis by means of crosscorrelation and dynamic time-warping
7735#On the positivity of the Wigner-Ville spectrum
7736#An iterative restoration technique
7737#The spectral correlation theory of cyclostationary time-series
7738#A new generalized inverse definition for linear discrete systems
7739#Adaptive region growing technique using polynomial functions for image approximation
7740#Local linear transforms for texture measurements
7741#Study and comparison of certain shape measures
7742#Simplified time delay estimation between two phase-shifted signals
7743#A unifed view of parametric processing algorithms for prewindowed signals
7744#Design of optimal minimum phase FIR filters by direct factorization
7745#Polynomial representation of pictures
7746#Nonlinear order statistic filters for image filtering and edge detection
7747#Some theoretical aspects of a backscattering based tomographic imaging technique
7748#A conferencing technique for adaptive delta modulation
7749#Waveform preserving encoders for the compression of EEG data
7750#Temporal tracking of spectral variations
7751#Filter banks allowing perfect reconstruction
7752#Phase-locked loop based frequency adder
7753#Walsh transform applied to digital filtering
7754#Component coding of the NTSC color TV signal
7755#A clustering experiment of the spectra and the spectral changes of speech to extract phonemic features
7756#Deconvolution of time-varying systems by Kalman filtering: its application to the computation of the active state in the muscle
7757#On frequency detection by zero-crossings
7758#Some comments about the iterative filtering algorithm for spectral estimation of sinusoids
7759#An improvement in the evaluation of convolutions of real symmetric signals using the fast Fourier transform
7760#DPCM picture coding using two-dimensional quantizer
7761#Estimation of first- and second-order moments of a quantized stationary signal
7762#Search for periodicities by axis-crossings of filtered time series
7763#On the synthesis of radar signals using the Woodward ambiguity function
7764#A distribution function approach to point target resolution
7765#Channel error propagation in adaptive TV coders
7766#On objective autoregressive model testing
7767#Input/output memory for digital convolution via the parallel pipeline fast Fourier transformer
7768#Levinson filter for non-stationary processes
7769#Spectral estimation with rational modeling of the log spectrum
7770#Maximum likelihood filters in spectral estimation problems
7771#Bispectrum estimation via AR modeling
7772#Multichannel ARMA spectral estimation by the modified Yule-Walker method
7773#An AR spectral analysis of non-stationary signals
7774#An efficient lattice predictor algorithm for instantaneous frequency estimation
7775#Predictive adaptive moving target indicator
7776#An environment for development of decision support systems
7777#Domain specific DSS tools for knowledge-based model building
7778#Flexible management of computational models
7779#Computer based support of reasoning in the presence of fuzziness
7780#Information management: a new tool for a new curriculum
7781#Computing and information: steering student learning
7782#The writer with a word processor: juggler, sculptor, director
7783#Electronic spreadsheets in the curriculum
7784#New curriculum soundings on a voyage of the Mimi
7785#Using Appleworks in the geography class: from transparent maps to sortable electronic data
7786#Using VisiCalc and DYNAmo to make models and solve problems in high school math classes
7787#A new twist on an old skill: retrieving information with computers to enhance decision-making processes
7788#Expert systems and the next generation of tools
7789#Repetitive trauma disorders: job evaluation and design
7790#Results of the simulation of a qualitative information display
7791#The validity of subjective reports of visual discomfort
7792#Fatigue and reading of text on videotext
7793#The representation of command language syntax
7794#The effects of syntactic complexity on the human-computer interaction
7795#Multimodal detection and recognition performance of sonar operators
7796#Optimal colors, phosphors, and illuminant characteristics of CRT displays: the algorithmic approach
7797#The effects of set size on color matching using CRT displays
7798#Reading from microfiche, a VDT, and the printed page: subjective fatigue and performance
7799#Intermittent illumination from visual display units and fluorescent lighting affects movements of the eyes across text
7800#An integrated display for vertical and translational flight: eight factors affecting pilot performance
7801#The optimal number of menu options per panel
7802#Optimizing the structure of database menu indexes: a decision model of menu search
7803#The effect of number ordering and orientation on marking speed and errors for mark-sensed labels
7804#On the selection and evaluation of visual display symbology: factors influencing search and identification times
7805#Statistical dependency in visual scanning
7806#The effect of perspective geometry on judged direction in spatial information instruments
7807#Visual fatigue and spatial frequency adaptation to video displays of text
7808#Scanning tunneling microscopy
7809#Squeezable tunneling junctions
7810#Electronic structure and tunneling current for chemisorbed atoms
7811#Application to biology and technology of the scanning tunneling microscope operated in air at ambient pressure
7812#Tunneling microscopy from 300 to 4.2 K
7813#A scanning tunneling microscope for surface science studies
7814#Defects on the Pt(100) surface and their influence on surface reactions—a scanning tunneling microscopy study
7815#Spectroscopy of electronic states of metals with a scanning tunneling microscope
7816#Some design criteria in scanning tunneling microscopy
7817#Possible mechanisms of atom transfer in scanning tunneling microscopy
7818#The human factor in computer crime
7819#Computer circuit concepts
7820#An introduction to microelectronic technology
7821#A distributed algorithm for the detection of deadlocks in store-and-forward communication networks is presented. At first, we focus on a static environment and develop an efficient knot detection algorithm for general graphs. The knot detection algorithm uses at most O(n2+ m) messages and O(log (n)) bits of memory to detect all deadlocked nodes in the static network. Using the knot detection algorithm as a building block, a deadlock detection algorithm in a dynamic environment is developed. This algorithm has the following properties: It detects all the nodes which cause the deadlock. The algorithm is triggered only when there is a potential for deadlock and only those nodes which are potentially deadlocked perform the algorithm. The algorithm does not affect other processes at the nodes.
7822#This paper examines the problem of comparing large replicated files in a context in which communication dominates the cost of comparison. A low-cost checking matrix is proposed for comparison of these replicated files. The checking matrix is composed of check symbols generated by a divide-and-conquer encoding algorithm. The matrix allows for detection and diagnosis of disagreeing pages with very little communication overhead. In contrast to a previous O(N) proposal, the storage requirement for the checking matrix is O(log N), where N is the number of pages in the file. The matrix can be stored in main memory without the need for extra accesses to disk during normal updates of pages.
7823#We consider the problem of bringing a distributed system to a consistent state after transient failures. We address the two components of this problem by describing a distributed algorithm to create consistent checkpoints, as well as a rollback-recovery algorithm to recover the system to a consistent state. In contrast to previous algorithms, they tolerate failures that occur during their executions. Furthermore, when a process takes a checkpoint, a minimal number of additional processes are forced to take checkpoints. Similarly, when a process rolls back and restarts after a failure, a minimal number of additional processes are forced to roll back with it. Our algorithms require each process to store at most two checkpoints in stable storage. This storage requirement is shown to be minimal under general assumptions.
7824#A dynamic load balancing method is proposed for a class of large-diameter multiprocessor systems. The method is based on the "gradient model," which entails transferring backlogged tasks to nearby idle processors according to a pressure gradient indirectly established by requests from idle processors. The algorithm is fully distributed and asynchronous. Global balance is achieved by successive refinements of many localized balances. The gradient model is formulated so as to be independent of system topology.
7825#A replicated database architecture is described in which updates processed at a site must be saved to allow reconcilliation of newly arriving updates in a way that preserves mutual consistency. The storage space occupied by the saved updates increases indefinitely, and periodic discarding of old updates is needed to avoid running out of storage. A protocol is described which allows sites in the system to agree that updates older than a given timestamp are no longer needed and can be discarded. This protocol uses a "distributed snapshot" algorithm of Chandy and Lamport and represents a practical application of that algorithm. A protocol for permanent removal of sites is also described, which will allow the discarding of updates to continue when one or more sites crash and are expected not to recover.
7826#Simulation of large networks on smaller networks
7827#A note on succinct representations of graphs
7828#Function definitions in term rewriting and applicative programming
7829#Systolic Trellis automata: stability, decidability and complexity
7830#On relativized exponential and probabilistic complexity classes
7831#The generic system design approach
7832#Software strategies and the future of document management
7833#Weld County prospects new technology to help modern day pioneers
7834#Who needs microfilm now that the optical disk has arrived?
7835#COM enters its fourth decade
7836#Applications of parallel processors to some hard discrete problems
7837#Introduction to computational continuum dynamics: a personal perspective
7838#Spectral methods for the solution of nonlinear boundary value problems,a case study
7839#Computational considerations in solving the many electron problem for molecular systems
7840#A note on the relationship between the expression and the automatic detection of parallelism in programs
7841#Parallel computer architectures
7842#Linear algebra on high-performance computers
7843#Purcell's method, projective n-space,and a parallelizable, sparse linear equation solver
7844#A compiler-driven supercomputer
7845#Computations in fusion physics
7846#Parallel algorithms for computational continuum dynamics
7847#A development environment for scientific parallel programs
7848#Parallelizing SPICE in a timesharing environment
7849#Convergence to steady state of solutions of Burger's equation
7850#Stability analysis of intermediate boundary conditions in approximate factorization schemes
7851#Multiple steady states for characteristic initial value problems
7852#A minimum entropy principle in the gas dynamics equations
7853#A spectral multidomain method for the solution of hyperbolic systems
7854#On substructuring algorithms and solution techniques for the numerical approximation of partial differential equations
7855#Multiple laminar flows through curved pipes
7856#Calculations of the stability of some axisymmetric flows proposed as a model of vortex breakdown
7857#Numerical study of vortex breakdown
7858#Multigrid method for a vortex breakdown simulation
7859#Construction of higher order accurate vortex and particle methods
7860#Pseudo-time algorithms for the Navier-Stokes equations
7861#Conditions for the construction of multi-point total variation diminishing difference schemes
7862#Some results on uniformly high-order accurate essentially nonoscillatory schemes
7863#On numerical dispersion by upwind differencing
7864#AZTEC: a front tracking code based on Godunov's method
7865#Least squares finite element simulation of transonic flows
7866#The weak element method applied to Helmholtz type equations
7867#The local redistribution of points along curves for numerical grid generation
7868#Integral equation solution for the flow due to the motion of a body of arbitrary shape near a plane interface at small Reynolds number
7869#Improvements in spectral collocation discretization through a multiple domain technique
7870#A C1 interpolant for codes based on backward differentiation formulae
7871#On computing smooth solutions of problems with large Lipschitz constants
7872#The summation of series
7873#An extended cross rule for vector Pade:9aw approximants
7874#Group decision making with a fuzzy linguistic majority
7875#A value of information in FLP problems via sensitivity analysis
7876#A note on the usefulness of linguistic variables for differentiating between some respiratory diseases
7877#Fuzzy cardinals based on the generalized equality of fuzzy subsets
7878#On the concept of fuzzy point
7879#Nonstandard fuzzy sets
7880#On the Bayes formula for fuzzy probability measures
7881#A multicriteria fuzzy linear programming method for water supply system development planning
7882#Fuzzy resource allocation
7883#Priority structure in fuzzy goal programming
7884#Fuzzy discriminant analysis in fuzzy groups
7885#Fuzzy probability space defined by means of the fuzzy relation 'less than'
7886#Multifactorial fuzzy sets and multifactorial degree of nearness
7887#Fuzzy topologies and topological space objects in a topos
7888#A note on the fixed points of fuzzy maps on partially ordered topological spaces
7889#A fuzzy expert system
7890#A parametric approach to fuzzy linear programming
7891#Interactive fuzzy decision making for multiobjective nonlinear programming usingaugmented minimax problems
7892#Some problems on the definition of fussy preference relations
7893#On the construction of fuzzy eigen solutions in given regions
7894#Fuzzy reasoning and fuzzy relational equations
7895#Comprehensive fuzziness
7896#Intuitionistic fuzzy sets
7897#Two integrals and some modified versions-critical remarks
7898#Constructing membership functions using statistical data
7899#On possibilistic linear programming
7900#Elementary fuzzy calculus
7901#Solvability of fuzzy relational equations and manipulation of fuzzy data
7902#Two families of fuzzy integrals
7903#A note on semi-open sets in fuzzy topological spaces
7904#Scelernomic analysis of structures considering connection slip
7905#The reliability of finite element tools
7906#Survey of computer programs for heat transfer analysis
7907#The finite element used for determining impedance of symmetrical shape conductors carrying alternating current
7908#Postindustrial manufacturing
7909#Real robots do need jigs
7910#E pluribus computum
7911#Extension equivalence of oriented matroids
7912#Primes of linear recurrent sequences
7913#Ramsey numbers for the path with three edges
7914#Functions that never agree
7915#Computationally efficient bounds for the Catalan numbers
7916#An Erdo¨s-Ko-Rado theorem for integer sequences of given rank
7917#Embedding the n-cube in lower dimensions
7918#Solution to Dempwolf's nonsolvable B-group problem
7919#Inequalities relating degrees of adjacent vertices to the average degree
7920#A classification of modularly complemented geometric lattices
7921#Designs with mutually orthogonal resolutions
7922#On harmonic conjugates in full algebraic combinatorial geometries
7923#Equilibrium graphs and rational trees
7924#Clusters and semimatroids
7925#Longest chains in the lattice of integer partitions ordered by majorization
7926#Partitions of finite abelian groups
7927#Upper bounds for the cardinality of s-distances codes
7928#On the symmetric difference of two sets in a group
7929#Some results about pursuit games on metric spaces obtained through graph theory techniques
7930#Quasi-symmetric designs and self-dual codes
7931#Quotients of Coxeter complexes and buildings with linear diagram
7932#The upper layers of the ISO/OSI reference model (PartII)
7933#FASTBUS cable segment master controlled via CAMAC
7934#On testing adherence to standards-concepts, criteria, patterns
7935#Reference models for standardization
7936#Data element standards: communication standards for end users
7937#Priorities of the american national standards institute
7938#Parallel adaptive full-multigrid methods on message-based multiprocessors
7939#Romberg integration using systolic arrays
7940#Restructuring SIMPLE for the CHiP architecture
7941#Computational models and task scheduling for parallel sparse Cholesky factorization
7942#Modelling, measurement, and simulation of memory interference in the CRAY X-MP
7943#International conference on vector and parallel computing (conference report)
7944#Propaedeutics of decision-making: supporting managerial learning and innovation
7945#Handling shared resources in a temporal data base management system
7946#An `intelligent' extraction and aggregation tool for company data base
7947#Toward representing management-domain knowledge
7948#On actions due to lack of information
7949#A strategy for vactorization
7950#Parallel implementation of multifrontal schemes
7951#Two parallel SOR variants of the Schwarz alternating procedure
7952#The mapping of 2-D array processors to 1-D array processors
7953#Fault-tolerance and performance analysis of beta-networks
7954#A lattice model for cellular (systolic) algorithms
7955#Superlinear speedup of an efficient sequential algorithm is not possible
7956#Parallel efficiency can be greater than unity
7957#Some problems of exploiting a pipeline processor
7958#Structuring parallel algorithms in an MIMD, shared memory environment
7959#Some issues in parallel processing as encountered on the Denelcor HEP
7960#Effects of synchronization barriers on multiprocessor performance
7961#Fast scan-line conversion using vectorisation
7962#Solving the generalized eigenvalue problem on a synchronous linear processor array
7963#Two and three dimensional FFTS on highly parallel computers
7964#Framework for formulation and analysis of parallel computation structures
7965#Systolic sorting in a sequential input/output environment
7966#Implementation of some concurrent algorithms for matrix factorization
7967#Parallelizing conjugate gradient for the CRAY X-MP
7968#The performance of FORTRAN implementations for preconditioned conjugate gradients on vector computers
7969#An extension of the language C for concurrent programming
7970#A note on the vectorization of scalar recursions (Short Communication)
7971#The parallel neighbour sort and 2-way merge algorithm (Short Communication)
7972#Practical applications involving uncertainty
7973#Knowledge resource tools for information access
7974#Business application of artificial intelligence knowledge based expert systems
7975#The VHSIC program
7976#Expert database systems theoretical aspects of reasoning about knowledge
7977#Current status and future trends in machine translation
7978#Technologies for machine translation
7979#Fujitsu machine translation system: ATLAS
7980#Problems of machine translation system - effect of cultural differences on sentence structure
7981#VENUS: two-phase machine translation system
7982#The Toshiba machine translation system
7983#Science an technology agency's Mu machine translation project
7984#Optimal ride height and pitch control for championship race cars
7985#A self-tuning robust controller
7986#A linear programming regulator applied to hydroelectric reservoir level control
7987#Optimal experiment designs with respect to the intended model application
7988#Estimation and direct adaptive control of delay-differential systems
7989#From time series to linear system-part I. Finite dimensional linear time invariant systems
7990#An application of multivariable self-tuning regulators to drum boiler control
7991#Robust digital dead time compensator controller for a class of stabel systems
7992#Reduced-complexity LQR design using canonical correlation analysis
7993#Square root filtering via covariance and information eigenfactors
7994#The asymptotic stochastic stability in large of the composite stochastic systems
7995#Microcomputer control of high dynamic performance ac-drives--a survey
7996#Microprocessor-based control of industrial sewing machines
7997#Use of optimal control theory for computing optimal injection policies for enhanced oil recovery
7998#A parallel architecture for Kalman filter measurement update and parameter estimation
7999#The modified gain extended Kalman filter and parameter identification in linear systems
8000#Robust stabilization of distributed systems
8001#Robust controllers for uncertain linear multivariable systems
8002#Fenchel duality and smoothness of solution of the optimal routing problem
8003#Model reference adaptive control system of a catalytic fluidized bed reactor
8004#A distribution-free criterion for robust identification, with applications in system modelling and image processing
8005#Application of decomposition coordination methods to parameter identification problems in interconnected distributed parameter systems
8006#Performance of Kalman filter with missing measurements
8007#Multimodel strategies under random disturbances and imperfect partial observation
8008#On the order of stable compensators
8009#Infinite gain margin problem in multivariable feedback systems
8010#A remembrance of Philip McCord Morse 1903-1985
8011#The beginnings of operations research in the United States
8012#An analysis of Baltimore Gas and Electric Company's technology choice
8013#Optimal hydrocarbon reservoir production policies
8014#Deciding which queue to join: Some counterexamples
8015#Approximation formulations for the single-product capacitated lot size problem
8016#An allocation and distribution model for perishable products
8017#Scarf's state reduction method, flexibility, and a dependent demand inventory model
8018#Models for design and control of stochastic, multi-item batch production systems
8019#An asymptotic analysis of a queueing system with Markov-modulated arrivals
8020#Parameter imprecision in finite state, finite action dynamic programs
8021#On Johnson's two-machine flow shop with random processing times
8022#Optimal lot sizing, process quality improvement and setup cost reduction
8023#A cross decomposition algorithm for capacitated facility location
8024#Short term scheduling of vessels for shipping bulk or semi-bulk commodities originating in a single area
8025#Renormalization of seasonals in winters' forecasting systems: Is it necessary?
8026#A debugging model with independent flaws and random masking
8027#Perspectives on utility theory
8028#A survey of practical applications of examination timetabling algorithms
8029#Optimal response to oil spill: The strategic decision case
8030#Optimal flows in networks with multiple sources and sinks, with applications to oil and gas lease investment programs
8031#Production planning of style goods with high setup costs and forecast revisions
8032#Optimal lot-sizing algorithms for complex product structures
8033#A strongly polynomial algorithm to solve combinatorial linear programs
8034#An n-server cutoff priority queue
8035#The bulk service queue with a general control strategy: Theoretical analysis and a new computational procedure
8036#Clearing systems and (s, S) inventory systems with nonlinear costs and positive lead times
8037#Cycle times in two-sage closed queueing networks: Applications to multiprogrammed computer systems with virtual memory
8038#The reconciliation of decision analyses
8039#Partial information, dominance, and potential optimality in multiattribute utility theory
8040#VARI-METRIC: Improved approximations for multi-indenture, multi-echelon availability models
8041#A note on shot-noise and reliability modeling
8042#The complexity of the optimal searcher path problem
8043#Proving temporal properties of concurrent programs: a non-temporal approach
8044#Case-based reasoning: a computer model of subjective assessment
8045#A rule based approach to program development
8046#Comparison of optimization techniques in code generation
8047#Approximate image generalization with realistic effects
8048#The average case analysis of backtracking with multi-level dynamic search rearrangement
8049#Consolidation: a method for reasoning about the behavior of devices
8050#Scheduling in distributed computing systems
8051#On some most probable separations of complexity classes
8052#On via minimization and layer assignment problems
8053#Design and analysis of a voice/data internet transport system
8054#The design of a distributed concurrent simulation environment
8055#A horizontally reconfigurable architecture for extended precision arithmetic
8056#Systolic systems: algorithms and complexity
8057#Language and artificial intelligence conference report
8058#The design and analysis of algorithms for the maximum independent set and cyclic
8059#Spline approximations to spherically symmetric distributions
8060#A rapid generalized method of bisection for solving systems of non-linear equations
8061#B-convergence properties of defect correction methods. I
8062#B-convergence properties of defect correction methods. II
8063#Superconvergence for a mixed finite element method for elastic wave propagation in a plane domain
8064#A method for finding sharp error bounds for newton's method under the kantorovic assumptions
8065#Jensen's inequality for polynomials with concentration at low degrees
8066#Finite difference approximations to the Dirichlet problem for elliptic systems
8067#Multi-grid methods for Hamilton-Jacobi-Bellman equations
8068#Numerical solution of the obstacle problem by the penalty method. Part II. Time dependent problems
8069#Optimal addition of knots to cubature formulae for planar regions
8070#A convergence analysis of hopscotch methods for fourth order parabolic equations
8071#Spline approximant in Hilbertian subspaces of &OHgr;
8072#P-stability properties of runge-kutta methods for delay differential equations
8073#Regions of stability, equivalence theorems and Courant-Friedichs-Lewy condition
8074#On the Davis-Kahn-Weinberger solution of the Norm-Preserving dilation problem
8075#Finite element approximation of the dirichlet problem using the boundary penalty method
8076#Convergence results for an accelerated nonlinear cimmino algorithm
8077#On the multi-level splitting of finite element spaces
8078#Absolute monotonicity of rational functions occurring in the numerical solution of initial value problems
8079#An asymptotic finite element method for improvement of solutions of boundary layer problems
8080#About cubature formulas with a minimal number of knots
8081#Analyzing the RISC in gallium arsenide
8082#Microcomputer memory performance in a resource sharing distributed information processing enviornment
8083#An audio computer interface: a case study of structured electronic equipment design
8084#MFD2—Using serial 1/0 for a low cost flexible disk interface
8085#A stand-alone in-circuit emulator
8086#Microprocessors :1085"—Fourth Symposium on Microcomputer and Microprocessor Applications
8087#Verification of microprogram transformation commands for a firmware editor (revised)
8088#Microcomputer hardware education at a Czechoslovakian Technical University
8089#Trends in the development of microcomputer hardware and software
8090#FTSD '85: Fault-tolerant systems & diagnostics
8091#Experiments in dynamic programming inference of Markov networks with strings representing speech data
8092#A syntactic method for analysis of saccadic eye movements
8093#Algorithm partition and parallel recognition of general context-free languages using fixed-size VLSI architecture
8094#Boundary localization in an image pyramid
8095#An adaptive pattern analysis system for isolating EMI
8096#High speed error correction of phoneme sequences
8097#Bayes classification rule for the general discrete case
8098#Noise filtering in digital images and approximation theory
8099#Library networking at AT&T: new information needs and technologies in a competi tive environment
8100#Information services as a corporate resource in Exxon
8101#GMR Online
8102#A software architecture for the future
8103#Setting out to create the standard
8104#The perpetual Cadillac
8105#A productivity toolbox
8106#Dramatic change on a dynamic stage
8107#Moving on up
8108#Moving up from DOS
8109#Moving over to IBM
8110#Checks and balances
8111#Value-added consulting
8112#Building value-added software
8113#Hi-res color CRT meets stringent avionic requirements
8114#New-generation color displays scheduled for flight control system
8115#LC shutter glasses provide 3-D display for simulated flight
8116#Spatial misorientation exacerbated by collimated virtual flight display
8117#Miniature, lightweight hi-res CRT display features remote drive
8118#Signal mixing enhances 3-D imaging procedure
8119#Interlacing eliminates CRT perceptible flicker
8120#Network links PCs to wide range of systems, devices
8121#Library of Congress classification as an online retrieval tool: potentials and limitations
8122#Policies for microcomputers in libraries: an administrative model
8123#Answerman, the expert information specialist: an expert system for retrieval of information from library reference books
8124#Integrating subject pathfinders into a GEAC ILS: a MARC-formatted record approach
8125#New library technologies and physical problems
8126#The halo effect: psychological deterrence of electronic security systems
8127#Cooperative cataloging quality control in the OCLC Pacific network
8128#The Welch Medical Library Services billing system
8129#Potential applications of fuzzy sets in industrial safety engineering
8130#Paths of least resistance in possibilistic production systems
8131#Towards the development of human work-performance standards in futuristic man-machine systems: a fuzzy modeling approach
8132#Conditioning in fuzzy environment
8133#Fuzzy perturbation analysis, part 2: undirectional perturbation
8134#Fuzzy relations an fuzzy functions
8135#On fuzzy topological spaces
8136#Interactive color graphical postprocessing as a unifying influence in numerical analysis research
8137#Implementing FEA and CAD on personal computers and workstations
8138#The ADINA system in engineering practice
8139#Unification of electromagnetic and thermal analyses to determine losses and temperature distribution in a slot-embedded conductor
8140#The finite element machine: an assessment of the impact of parallel computing on future finite element computations
8141#Computation and its role in the unification of design
8142#Some issues associated with the validation of finite element analysis
8143#CAD/CAM,robotics and automated manufacturing and the connection to FEM
8144#Toward automated finite element modeling for the unification of engineering design and analysis
8145#Interactive finite element modeling at Ford Motor Company
8146#Implementation of a finite element software system with h and p extension capabilities
8147#CADS-a computer aided design system for unification of finite element programs
8148#EISI-EAL: a general engineering analysis and design language
8149#Information centres: marketing ploy and practical answer to DP backlogs
8150#Development and application of parallel processing
8151#Continuous real-time expert system for computer operations
8152#Benchmark results for microcomputers and large computers
8153#This paper describes a computational approach to edge detection. The success of the approach depends on the definition of a comprehensive set of goals for the computation of edge points. These goals must be precise enough to delimit the desired behavior of the detector while making minimal assumptions about the form of the solution. We define detection and localization criteria for a class of edges, and present mathematical forms for these criteria as functionals on the operator impulse response. A third criterion is then added to ensure that the detector has only one response to a single edge. We use the criteria in numerical optimization to derive detectors for several common image features, including step edges. On specializing the analysis to step edges, we find that there is a natural uncertainty principle between detection and localization performance, which are the two main goals. With this principle we derive a single operator shape which is optimal at any scale. The optimal detector has a simple approximate implementation in which edges are marked at maxima in gradient magnitude of a Gaussian-smoothed image. We extend this simple detector using operators of several widths to cope with different signal-to-noise ratios in the image. We present a general method, called feature synthesis, for the fine-to-coarse integration of information from operators at different scales. Finally we show that step edge detector performance improves considerably as the operator point spread function is extended along the edge.
8154#An edge in an image corresponds to a discontinuity in the intensity surface of the underlying scene. It can be approximated by a piecewise straight curve composed of edgels, i.e., short, linear edgeelements, each characterized by a direction and a position. The approach to edgel-detection here, is to fit a series of one-dimensional surfaces to each window (kernel of the operator) and accept the surfacedescription which is adequate in the least squares sense and has the fewest parameters. (A one-dimensional surface is one which is constant along some direction.) The tanh is an adequate basis for the step-edge and its combinations are adequate for the roof-edge and the line-edge. The proposed method of step-edgel detection is robust with respect to noise; for (step-size/noise) 2.5, it has subpixel position localization (position
8155#The analyses of visual data by stereo and motion modules have typically been treated as separate parallel processes which both feed a common viewer-centered 2.5-D sketch of the scene. When acting separately, stereo and motion analyses are subject to certain inherent difficulties; stereo must resolve a combinatorial correspondence problem and is further complicated by the presence of occluding boundaries, motion analysis involves the solution of nonlinear equations and yields a 3-D interpretation specified up to an undetermined scale factor. A new module is described here which unifies stereo and motion analysis in a manner in which each helps to overcome the other's short-comings. One important result is a correlation between relative image flow (i.e., binocular difference flow) and stereo disparity; it points to the importance of the ratio 驴 驴, rate of change of disparity 驴 to disparity 驴, and its possible role in establishing stereo correspondence. The importance of such ratios was first pointed out by Richards [19]. Our formulation may reflect the human perception channel probed by Regan and Beverley [18].
8156#A single two-dimensional image is an ambiguous representation of the three-dimensional world驴many different scenes could have produced the same image驴yet the human visual system is ex-tremely successful at recovering a qualitatively correct depth model from this type of representation. Workers in the field of computational vision have devised a number of distinct schemes that attempt to emulate this human capability; these schemes are collectively known as ``shape from...'' methods (e.g., shape from shading, shape from texture, or shape from contour). In this paper we contend that the distinct assumptions made in each of these schemes is tantamount to providing a second (virtual) image of the original scene, and that each of these approaches can be translated into a conventional stereo formalism. In particular, we show that it is frequently possible to structure the problem as one of recovering depth from a stereo pair consisting of the supplied perspective image (the original image) and an hypothesized orthographic image (the virtual image). We present a new algorithm of the form required to accomplish this type of stereo reconstruction task.
8157#This paper relates different kinds of language modeling methods that can be applied to the linguistic decoding part of a speech recognition system with a very large vocabulary. These models are studied experimentally on a pseudophonetic input arising from French stenotypy. We propose a model which combines the advantages of a statistical modeling with information theoretic tools, and those of a grammatical approach.
8158#Stereoscopic motion is an approach for comparing image change due to motion in a stereo pair of image sequences. Qualitatively, the relative image change shows that an object point is approaching, receding, or remaining at constant depth. Quantitatively, the relative change predicts where the object point will pass with respect to the camera system.
8159#In this correspondence we are interested in how interpretation and context restrictions can guide the analysis of ambiguous segmentations of images in computer vision systems. The final objective is to find image segments that can be interpreted (classified) such that their interpretations do not conflict with interpretations given to related segments. In the case that we have several possible labels for each segment, some of this ambiguity can be reduced by means of a relaxation process. In its discrete formulation, the relaxation operator examines pairs of related segments to see if they have incompatible labels, which are then discarded. This process is iterated until only compatible labels are left. In this work a new approach is proposed that considers all possible segmentations resulting from an ambiguous segmentation simultaneously in only one relaxation process. A new relaxation operator is defined that can be applied to ambiguous segmentations. In this way no backtracking is performed, ambiguity is reduced, and the best solution is still retained. The output of the process is a collection of segmentations and interpretations that is hopefully small enough so that each case can be considered separately.
8160#Comments on Takiyama's Analysis of the Multithreshold Threshold Element
8161#We propose a fast nearest neighbor finding algorithm, named tentatively an ordered partition, based on the ordered lists of the training samples of each projection axis. The ordered partition contains two properties, one is ordering驴to bound the search region, and the other is partitioning驴to reject the unwanted samples without actual distance computations. It is proved that the proposed algorithm can find k nearest neighbors in a constant expected time. Simulations show that the algorithm is rather distribution free, and only 4.6 distance calculations, on the average, were required to find a nearest neighbor among 10 000 samples drawn from a bivariate normal distribution.
8162#A mapping between one frame from an image sequence and the preceding or following frame can be represented as a displacement vector field. In most situations, the mere gray value variations do not provide sufficient information in order to estimate such a displacement vector field. Supplementary constraints are necessary, for example the postulate that a displacement vector field varies smoothly as a function of the image position. Taken as a general requirement, this creates difficulties at gray value transitions which correspond to occluding contours. Nagel therefore introduced the ``oriented smoothness'' requirement which restricts variations of the displacement vector field only in directions with small or no variation of gray values. This contribution reports results of an investigation about how such an ``oriented smoothness'' constraint may be formulated and evaluated.
8163#A parallel algorithm for syntactic image segmentation is introduced. Stochastic tree grammar is used as a context-generating model. It is shown that when this context-generating process is in the equilibrium state, a matched filter can be designed and applied in parallel to the image. This process can be used for image segmentation in a syntactic pattern recognition system to enhance the performance of the succeeding recognition process.
8164#This paper presents a powerful image understanding system that utilizes a semantic-syntactic (or attributed-synibolic) representation scheme in the form of attributed relational graphs (ARG's) for comprehending the global information contents of images. Nodes in the ARG represent the global image features, while the relations between those features are represented by attributed branches between their corresponding nodes. The extraction of ARG representation from images is achieved by a multilayer graph transducer scheme. This scheme is basically a rule-based system that uses a combination of model-driven and data-driven concepts in performing a hierarchical symbolic mapping of the image information content from the spatial-domain representation into a global representation. Further analysis and inter-pretation of the imagery data is performed on the extracted ARG representation. A distance measure between images is defined in terms of the distance between their respective ARG representations. The distance between two ARG's and the inexact matching of their respective components are calculated by an efficient dynamic programming technique. The system handles noise, distortion, and ambiguity in real-world images by two means, namely, through modeling and embedding them into the transducer's mapping rules, as well as through the appropriate cost of error-transformation for the inexact matching of the ARG image representation. Two illustrative experiments are presented to demonstrate some capabilities of the proposed system. Experiment I deals with locating objects in multiobject scenes, while Experiment II is concerned with target detection in SAR images.
8165#New asymptotic methods are introduced that permit computationally simple Bayesian recognition and parameter estimation for many large data sets described by a combination of algebraic, geometric, and probabilistic models. The techniques introduced permit controlled decomposition of a large problem into small problems for separate parallel processing where maximum likelihood estimation or Bayesian estimation or recognition can be realized locally. These results can be combined to arrive at globally optimum estimation or recognition. The approach is applied to the maximum likelihood estimation of 3-D complex-object position. To this end, the surface of an object is modeled as a collection of patches of primitive quadrics, i.e., planar, cylindrical, and spherical patches, possibly augmented by boundary segments. The primitive surface-patch models are specified by geometric parameters, reflecting location, orientation, and dimension information. The object-position estimation is based on sets of range data points, each set associated with an object primitive. Probability density functions are introduced that model the generation of range measurement points. This entails the formulation of a noise mechanism in three-space accounting for inaccuracies in the 3-D measurements and possibly for inaccuracies in the 3-D modeling. We develop the necessary techniques for optimal local parameter estimation and primitive boundary or surface type recognition for each small patch of data, and then optimal combining of these inaccurate locally derived parameter estimates in order to arrive at roughly globally optimum object-position estimation.
8166#In this paper, we attempt to place segmentation schemes utilizing the pyramid architecture on a firm footing. We show that there are some images which cannot be segmented in principle. An efficient segmentation scheme is also developed using pyramid relinking. This scheme will normally have a time complexity which is a sublinear function of the image diameter, which compares favorably to other schemes. The efficacy of our approach to segmentation using pyramid schemes is demonstrated in the context of region matching. The global features we use are compared to those used in previous approaches and this comparison will indicate that our approach is more robust than the standard moment-based techniques.
8167#We present a system that takes a gray level image as input, locates edges with subpixel accuracy, and links them into lines. Edges are detected by finding zero-crossings in the convolution of the image with Laplacian-of-Gaussian (LoG) masks. The implementation differs markedly from M.I.T.'s as we decompose our masks exactly into a sum of two separable filters instead of the usual approximation by a difference of two Gaussians (DOG). Subpixel accuracy is obtained through the use of the facet model [1]. We also note that the zero-crossings obtained from the full resolution image using a space constant 驴 for the Gaussian, and those obtained from the 1/n resolution image with 1/n pixel accuracy and a space constant of 驴/n for the Gaussian, are very similar, but the processing times are very different. Finally, these edges are grouped into lines using the technique described in [2].
8168#A closed curve in the plane can be described in several ways. We show that a simple representation in terms of radius of curvature versus normal direction has certain advantages. In particular, convolutional filtering of the extended circular image leads to a closed curve. Similar filtering operations applied to some other representations of the curve do not guarantee that the result corresponds to a closed curve. In one case, where a closed curve is produced, it is smaller than the original. A description of a curve can be based on a sequence of smoothed versions of the curve. This is one reason why smoothing of closed curves is of interest.
8169#Exact predictions of the performances of the Hough detection of straight lines in two-dimensional images are presented for rectangular and circular retinas, in Cartesian and normal parameterization, in the case of noisy signals. Detection of circles, under the same assumptions, is discussed. The limits of adaptive quantization to reduce intrinsic noise are presented, and it is shown that a signal processing approach is especially convenient to measure the performances of a detector based on the Hough transform.
8170#Comments on ``Scale-Based Description and Recognition of Planar Curves and Two-Dimensional Shapes''
8171#Comments on ``Low Level Segmentation: An Expert System''
8172#In this paper we introduce a novel representation of the significant changes in curvature along the bounding contour of planar shape. We call the representation the Curvature Primal Sketch because of the close analogy to the primal sketch representation advocated by Marr for describing significant intensity changes. We define a set of primitive parameterized curvature discontinuities, and derive expressions for their convolutions with the first and second derivatives of a Gaussian. We describe an implemented algorithm that computes the Curvature Primal Sketch by matching the multiscale convolutions of a shape, and illustrate its performance on a set of tool shapes. Several applications of the representation are sketched.
8173#We characterize some properties of the zero crossings of the Laplacian of signals驴in particular images驴filtered with linear filters, as a function of the scale of the filter (extending recent work by Witkin [16]). We prove that in any dimension the only filter that does not create generic zero crossings as the scale increases is the Gaussian. This result can be generalized to apply to level crossings of any linear differential operator: it applies in particular to ridges and ravines in the image intensity. In the case of the second derivative along the gradient, there is no filter that avoids creation of zero crossings, unless the filtering is performed after the derivative is applied.
8174#Scale-space filtering constructs hierarchic symbolic signal descriptions by transforming the signal into a continuum of versions of the original signal convolved with a kernal containing a scale or bandwidth parameter. It is shown that the Gaussian probability density function is the only kernel in a broad class for which first-order maxima and minima, respectively, increase and decrease when the bandwidth of the filter is increased. The consequences of this result are explored when the signal驴or its image by a linear differential operator驴is analyzed in terms of zero-crossing contours of the transform in scale-space.
8175#The problem of finding a description, at varying levels of detail, for planar curves and matching two such descriptions is posed and solved in this paper. A number of necessary criteria are imposed on any candidate solution method. Path-based Gaussian smoothing techniques are applied to the curve to find zeros of curvature at varying levels of detail. The result is the ``generalized scale space'' image of a planar curve which is invariant under rotation, uniform scaling and translation of the curve. These properties make the scale space image suitable for matching. The matching algorithm is a modification of the uniform cost algorithm and finds the lowest cost match of contours in the scale space images. It is argued that this is preferable to matching in a so-called stable scale of the curve because no such scale may exist for a given curve. This technique is applied to register a Landsat satellite image of the Strait of Georgia, B.C. (manually corrected for skew) to a map containing the shorelines of an overlapping area.
8176#A new method has been designed to identify and locate objects lying on a flat surface. The merit of the approach is to provide strong robustness to partial occlusions (due for instance to uneven lighting conditions, shadows, highlights, touching and overlapping objects) thanks to a local and compact description of the objects boundaries and to a new fast recognition method involving generation and recursive evaluation of hypotheses named HYPER (HY potheses Predicted and Evaluated Recursively). The method has been integrated within a vision system coupled to an indutrial robot arm, to provide automatic picking and repositioning of partially overlapping industrial parts.
8177#In this paper, a method of classifying objects is reported that is based on the use of autoregressive (AR) model parameters which represent the shapes of boundaries detected in digitized binary images of the objects. The object identification technique is insensitive to object size and orientation. Three pattern recognition algorithms that assign object names to unlabelled sets of AR model parameters were tested and the results compared. Isolated object tests were performed on five sets of shapes, including eight industrial shapes (mostly taken from the recognition literature), and recognition accuracies of 100 percent were obtained for all pattern sets at some model order in the range 1 to 10. Test results indicate the ability of the technique developed in this work to recognize partially occluded objects. Processing-speed measurements show that the method is fast in the recognition mode. The results of a number of object recognition tests are presented. The recognition technique was realized with Fortran programs, Imaging Technology, Inc. image-processing boards, and a PDP 11/60 computer. The computer algorithms are described.
8178#Two-dimensional digital curves are often uniformly approximated by polygons or piecewise linear curves. Several algorithms have been proposed in the literature to find such curves. We present an algorithm that finds a piecewise linear curve with the minimal number of segments required to approximate a curve within a uniform error with fixed initial and final points. We compare our optimal algorithm to several suboptimal algorithms with respect to the number of linear segments required in the approximation and the execution time of the algorithm.
8179#Many textures can be described structurally, in terms of the individual textural elements and their spatial relationships. This paper describes a system to generate useful descriptions of natural textures in these terms. The basic approach is to determine an initial, partial description of the elements using edge features. This description controls the extraction of the texture elements. The elements are grouped by type, and spatial relationships between elements are computed. The descriptions are shown to be useful for recognition of the textures, and for reconstruction of periodic textures.
8180#An approach is presented for the estimation of object motion parameters based on a sequence of noisy images. The problem considered is that of a rigid body undergoing unknown rotational and translational motion. The measurement data consists of a sequence of noisy image coordinates of two or more object correspondence points. By modeling the object dynamics as a function of time, estimates of the model parameters (including motion parameters) can be extracted from the data using recursive and/or batch techniques. This permits a desired degree of smoothing to be achieved through the use of an arbitrarily large number of images. Some assumptions regarding object structure are presently made. Results are presented for a recursive estimation procedure: the case considered here is that of a sequence of one dimensional images of a two dimensional object. Thus, the object moves in one transverse dimension, and in depth, preserving the fundamental ambiguity of the central projection image model (loss of depth information). An iterated extended Kalman filter is used for the recursive solution. Noise levels of 5-10 percent of the object image size are used. Approximate Cramer-Rao lower bounds are derived for the model parameter estimates as a function of object trajectory and noise level. This approach may be of use in situations where it is difficult to resolve large numbers of object match points, but relatively long sequences of images (10 to 20 or more) are available.
8181#In this paper we offer a critical evaluation of the partitioning (perceptual organization) problem, noting the extent to which it has distinct formulations and parameterizations. We show that most partitioning techniques can be characterized as variations of four distinct paradigms, and argue that any effective technique must satisfy two general principles. We give concrete substance to our general discussion by introducing new partitioning techniques for planar geometric curves, and present experimental results demonstrating their effectiveness.
8182#A continuous, straight-edged line is used for the visual navigation of an autonomous mobile robot in a factor environment. This line, which resides on the floor and contrasts with background, may also be used to determine range information. Two methods are developed for determining the range of an object in the sensor's field of view. The effects of various error conditions in the system geometry on each ranging method are determined. Equations are derived which yield the percent error in calculating ranges given estimates of these error conditions. Numerical examples using typical sensor parameters are given.
8183#This correspondence deals with the computation of structure and motion of rigid objects in space from image positions and optical flow. A test for rigid motion of objects in space is introduced which yields a new formulation of the problem. Assuming a central projection model for the viewing system, it is shown that image positions and optical flow at four points can achieve this perception.
8184#We report a pattern description and generation method of structural characters, and show some examples of Chinese and Korean character patterns actually generated. We also consider its educational and graphical applications. In this method, any character is regarded as a composite pattern constructed by several simpler subpatterns, and is described in terms of them by introducing three kinds of positional relationships among them. A composite pattern can become a subpattern, too. We call these patterns blocks. Syntactic grammar is defined to encode a pattern expression by two code strings, that is, a string of blocks and a string of production rules. They are used in generating patterns, namely, derivation of pattern expression from the code strings is defined as a process of pattern generation. By this description and generation method, we can encode structural characters without much memory, and generate natural shapes of patterns.
8185#The sum and difference of two random variables with same variances are decorrelated and define the principal axes of their associated joint probability function. Therefore, sum and difference histograms are introduced as an alternative to the usual co-occurrence matrices used for texture analysis. Two maximum likelihood texture classifiers are presented depending on the type of object used for texture characterization (sum and difference histograms or some associated global measures). Experimental results indicate that sum and difference histograms used conjointly are nearly as powerful as cooccurrence matrices for texture discrimination. The advantage of the proposed texture analysis method over the conventional spatial gray level dependence method is the decrease in computation time and memory storage.
8186#Bracket formulation of diffusion-convection equations
8187#Solitons from sine waves: analytical and numerical methods for non-integrable solitary and cnoidal waves
8188#Boundary circles for area-preserving maps
8189#Low-dimensional chaos in a driven damped nonlinear Schro¨dinger equation
8190#A chaotic blue sky catastrophe in forced relaxation oscillations
8191#Transient chaotic distributions in dissipative systems
8192#A functional equation for a segment of the He´non map unstable manifold
8193#Caching reduces the average cost of retrieving data by amortizing the lookup cost over several references to the data. Problems with maintaining strong cache consistency in a distributed system can be avoided by treating cached information as hints. A new approach to managing caches of hints suggests maintaining a minimum level of cache accuracy, rather than maximizing the cache hit ratio, in order to guarantee performance improvements. The desired accuracy is based on the ratio of lookup costs to the costs of detecting and recovering from invalid cache entries. Cache entries are aged so that they get purged when their estimated accuracy falls below the desired level. The age thresholds are dictated solely by clients' accuracy requirements instead of being suggested by data storage servers or system administrators.
8194#Typical concurrency control protocols for atomic actions, such as two-phase locking, perform poorly for long read-only actions. We present four new concurrency control protocols that eliminate all interference between read-only actions and update actions, and thus offer significantly improved performance for read-only actions. The protocols work by maintaining multiple versions of the system state; read-only actions read old versions, while update actions manipulate the most recent version. We focus on the problem of managing the storage required for old versions in a distributed system. One of the protocols uses relatively little space, but has a potentially significant communication cost. The other protocols use more space, but may be cheaper in terms of communication.
8195#Emerald is an object-based language for programming distributed subsystems and applications. Its novel features include 1) a single object model that is used both for programming in the small and in the large, 2) support for abstract types, and 3) an explicit notion of object location and mobility. This paper outlines the goals of Em-erald, relates Emerald to previous work, and describes its type system and distribution support. We are currently constructing a prototype implementation of Emerald.
8196#A stub generator for marshalling the arguments and results of remote procedure calls in heterogeneous environments is presented. The stub generator is itself language and machine independent, and derives all its knowledge of source languages and machine types from a set of language and machine specifications. These specifications can be paired in any combination to accommodate interlanguage calls between differing machines.
8197#A distributed operating system encourages a style of programming in which independently developed processes interact in a nontrivial fashion at run time. Server processes, for example, must deal with clients that they do not understand, and certainly cannot trust. Interprocess communications can be written in a traditional, sequential language with direct calls to kernel primitives, but the result is both cumbersome and error-prone. Convenience and safety are offered by the many distributed languages proposed to date, but in a form too inflexible for anything other than the pieces of a single distributed program. A new language known as LYNX overcomes the disadvantages of both these previous approaches. Novel features of LYNX address problems encountered in the course of practical experience, writing distributed programs without high-level language support. Chief among these features are a virtual circuit abstraction called the link, and an unconventional coroutine mechanism that allows a server to maintain nested contexts for interleaved conversations with an arbitrary number of clients.
8198#This paper describes the design of the Saguaro operating system for computers connected by a local-area network. Systems constructed on such an architecture have the potential advantages of concurrency and robustness. In Saguaro, these advantages are made available to the user through several mechanisms. One is channels, an interprocess communication and synchronization facility that allows the input and output of different commands to be connected to form general graphs of communicating processes. Two additional mechanisms are provided to support semitransparent file replication and access: reproduction sets and metafiles. A reproduction set is a collection of files that the system attempts to keep identical on a "best effort" basis. A metafile is a special file that contains symbolic pathnames of other files; when a metafile is opened, the system selects an available constituent file and opens it instead. The advantages of concurrency and robustness are also realized at the system level by the use of pools of server processes and decentralized allocation protocols. Saguaro also makes extensive use of a type system to describe user data such as files and to specify the types of arguments to commands and procedures. This enables the system to assist in type checking and leads to a user interface in which command-specific templates are available to facilitate command invocation.
8199#Two techniques are introduced to reduce the working storage requirement for the recent multifrontal method of Duff and Reid used in the sparse out-of-core factorization of symmetric matrices. For a given core size, the reduction in working storage allows some large problems to be solved without having to use auxiliary storage for the working arrays. Even if the working arrays exceed the core size, it will reduce the amount of input-output traffic necessary to manipulate the working vectors. Experimental results are provided to demonstrate significant storage reduction on practical problems using the proposed techniques.
8200#This paper presents a natural deduction proof of Hoare's logic carried out by the Edinburgh LCF theorem prover. The emphasis is on the way Hoare's theory is presented to the LCF, which looks very much like an exposition of syntax and semantics to human readers; and on the programmable heuristics (tactics). We also discuss some problems and possible improvements to the LCF.
8201#Products of automata
8202#Stochastic simulation
8203#The book of L
8204#Asynchrony and message passing in distributed systems
8205#Performance analysis of multiple-processor systems
8206#Dependability evaluation of parallel/distributed computer networks
8207#Temporal imagery: an approach to reasoning about time for planning and problem solving
8208#Impact of communication networks on fault-tolerant distributed computing
8209#Techniques for design and testing of iterative and systolic arrays
8210#An implementation of differentiation as a built-in function for a lambda-calculus graph-reduction machine
8211#Dynamic binding of separately compiled objects under program control
8212#Experimentation with an adaptive search strategy for solving a keyboard design/configuration problem
8213#Machine code optimization
8214#Mediators: a high-level language construct for distributed systems
8215#Sequential quadratic programming methods based on approximating a projected Hessian matrix
8216#A theory of information structure. I. General principles
8217#Collapsing binary data for algebraic multidimensional representation
8218#An axiomatic theory of conjoint expected risk
8219#A multivariate model for discrimination methods
8220#A history of the department of information science of the city university
8221#Jason Farradane and relational indexing
8222#Jason Farradane-a biobibliography
8223#Marketing of databases produced in the United Kingdom
8224#Financial press comment and company size: a comparison of UK and German companies
8225#Research on information interaction and intelligent information provision mechanisms
8226#Sichel's unification of bibliometric frequency distributions
8227#Patent groups and their relationship with journal literature
8228#The library and information system of the Chinese Academy of Sciences: a brief overview
8229#Biomedical information: education and decision support systems
8230#Weighting, ranking and relevance feedback in a front-end system
8231#Education and training in office technology
8232#Synopsis publishing for improving the accessibility of :10grey' scholarly information
8233#A critique of Brookes' logarithmic :10law'
8234#Moral issues in information science
8235#Communications: the challenge for the information manager
8236#Stone tablets to floppy disks and the question of downloading
8237#The real information society: present situation and some forecasts
8238#Collection and organization of written information by social scientists and humanists: a review and exploratory study
8239#Science on the periphery-a scientometric analysis of science in the ASIAN countries
8240#Electronic information systems analysis. Present and future information systems use by academics involved in development studies
8241#Towards information-based economies
8242#Can finding information be easy, fun and successful?
8243#An evaluation of information sources in household product poisoning
8244#A database translator of nuclear reaction data for international data exchange
8245#Time-life, world reporter and the secretary: experiments with end-users
8246#A study of the use of information sources by medical faculty staff in Nigerian universities
8247#An assessment of the major computerised databases relating to disabled people in the UK and Scandinavia
8248#A characterization of distributions which satisfy Prices's Law and consequences of the laws of Zipf and Mandelbrot
8249#Surface reconstruction and representation of 3-D scenes
8250#Nonparametric tests for edge detection in noise
8251#Computing relative neighbourhood graphs in the plane
8252#Tree classifier design with a permutation statistic
8253#Distances defined by neighborhood sequences
8254#On the inclusion of the recombination term in descretizations of the semiconductor device equations
8255#Particle simulation of compression waves
8256#A sequential refinement approach for parameter optimization in continuous dynamic models
8257#The effect of a continuously deforming coastline on the numerical simulation of storm surges in Bangladesh
8258#Stability of a class of hybrid computer models of dynamical systems
8259#Direct resolution of algebraic systems by approximations
8260#The complexity of analog computation
8261#On different classes of monoparametric stationary iterative methods for the solution of linear systems
8262#Beyond Desire: Pascal implementations of direct-executing simulation languages
8263#Problem partitioning in parallel processor simulation systems
8264#Inversion of matrices
8265#Solution of algebraic equations
8266#Inventory models under uncertainty: An adaptive approach
8267#An eigenvalue analysis for the evaluation of policy parameters in a system dynamics model
8268#Simulation of a reaction-diffusion system on large dimpled surfaces using a vector computer
8269#Asynchronous relaxation algorithms for optimal control problems
8270#A two-dimensional, second-order model for turbulent flow in the upper atmosphere
8271#Simulation of bipolar high-voltage devices in the neighborhood of breakdown
8272#The role of computer graphics in validating simulation models
8273#MULTISM: A model for simulating vehicular traffic on multi-lane arterial roads
8274#A fast simulation model for traffic flow on the basis of Boolean operations
8275#A model of vehicles movements in parking facilities
8276#Strategies for minimizing the effects of late truck arrivals on newspaper distribution systems
8277#On the properties of the sum of durations of perceived conflicts in air traffic control
8278#Computer simulation of holography for seismic purposes
8279#An improved regression analysis for automatic surface tension measurements
8280#Simulated performance of a data-driven database machine
8281#Fault diagnosis for a class of rearrangeable networks @
8282#FFT algorithms for SIMD parallel processing systems
8283#On permutations passable by the Gamma network
8284#Regular, area-time efficient carry-lookahead adders
8285#On the structure of parallelism in a highly concurrent PDE solver
8286#An optimization of queries in distributed database systems
8287#A wavefront algorithm for LU decomposition of a partitioned matrix on VLSI processor
8288#Optimizing joins between two partitioned relations in distributed databases
8289#A VLSI algorithm for the optimal detection of a curve
8290#A maximally pipelined tridiagonal linear equation solver
8291#Execution of OPS5 production systems on a massively parallel machine
8292#The DADO production system machine
8293#Analytic and numerical solutions of a nonlinear boundary-layer problem
8294#On sums of lognormal random variables
8295#Sound radiation by instability wavepackets in a boundary layer
8296#Nonlinear waves in a shear flow with a vorticity discontinuity
8297#On decoupling the H∞-optimal sensitivity problem for products of plants
8298#Weighted Hankel-norm approximation: Calculation of bounds
8299#Optimal diagonal scaling for infinity-norm optimization
8300#An H3WK0E-minimax approach to the design of robust control systems, Part II: All solutions, all-pass form solutions and :10 best solution
8301#Disturbance-generated bifurcations in a simple adaptive system: Simulation evidence
8302#Adaptive stabilization of not necessarily minimum phase plants
8303#A pole-assignment algorithm for linear state feedback
8304#Structural state space sensitivity in linear systems
8305#Asymptotic stability and estimating the region of attraction for the swing equatons
8306#An eigenvalue condition for sampled weak controllability of bilinear systems
8307#On the joint non-linear filtering-smoothing of diffusion processes
8308#Optimal adaptive server allocation in a network
8309#An optimal strategy for a conflict resolution problem
8310#Gain optimization for distributed plants
8311#Uniformly optimal control of linear time-invariant plants: Nonlinear time-varying controllers
8312#I-Inverness for polynomial matrices of non-constant rank
8313#On the stability margins of the Smith regulator
8314#An algebraic condition for controllability at infinity
8315#Some results on pole-placement and reachability
8316#Uniform controllable sets of left-invariant vector fields on compact lie groups
8317#On the optimal control of nonlinear systems
8318#On the largest feedback linearizable subsystem
8319#A simple characterization of optimal ARMA predictors
8320#On the sufficiency of the Hamilton-Jacobi-Bellman equation for optimality of the controls in a linear optimal-time problem
8321#Some comments on the behavior of sign-sign adaptive identifiers
8322#On improving control-loop robustness of model-matching controllers
8323#A circular stability test for general polynomials
8324#On positive definite solutions to the algebraic Riccati equation
8325#Sufficient conditions for the stability of a class of interconnected dynamic systems
8326#A lower bound on the integral of the nonlinear filtering error
8327#On finite dimensional realization theory of discrete time nonlinear systems
8328#Right-invertibility for a class of nonlinear control systems: A geometric approach
8329#Nonlinear system immersion, observers and finite-dimensional filters
8330#Correction to :20Pole placement for linear descrete-time systems by periodic output feedbacks”
8331#Nonlinear averaging theorems,and the determination of parameter convergence rates in adaptive control
8332#Stochastic adaptive pole-zero assignment with convergence analysis
8333#Optimal Hankel-norm approximation for stable systems with first-order stable weighting functions
8334#The Bruhat decomposition of finite Hankel matrices
8335#Conditions for internal stability of 2D systems
8336#Dynamic output feedback for observed variable-stucture control systems
8337#Stabilizability of linear systems with uncertain gains
8338#Feedback stabilization of the nonlinear pendulum under uncertainty: A robustness issue
8339#Strong D-stability
8340#Uniform controllable sets of left-invariant vector fields on noncompact lie groups
8341#Some remarks on estimation algebras
8342#An asymptotic property of nonlinear estimators arising as solutions to a certain class of convex programming problems
8343#Corrections to :20Ergodic control problem for one-dimensional diffusions with near-monotone cost”
8344#Correction to :20Uniformly optimal control of linear time-invariant plants: Nonlinear time-varying controllers”
8345#Symmetry breaking for a class of semilinear elliptic problems
8346#Travelling waves for forced Fishers's equation
8347#Local soltutions for a nonlinear degenerate hyperbolic equation
8348#On small period, large amplitude normal modes of natural Hamiltonian systems
8349#Remarks on sublinear elliptic equations
8350#Hele-Shaw type flows in Rn
8351#A higher-order sufficient condition for local surjectivity
8352#Admissibility, dichotomies and nonlinear ordinary differential equations
8353#Remarks on global existence for nonlinear parabolic equations
8354#Remarks on quasi(sub)minima
8355#Parameter estimation for elliptic equations in multidimensional domains with point and flux observations
8356#Nonselfadjoint resonance problems with unbounded perturbations
8357#Multiplicity results for ODE's with nonlinearities crossing all but a finite number of eigenvalues
8358#Solution profiles for some simple combustion models
8359#Numbers of zeros on invariant manifolds in reaction-diffusion equations
8360#Increasing solutions of (r(t)x(n))(n) = xf(t,x)
8361#A boundary value problem with a periodic nonlinearity
8362#The parallel sum of nonlinear monotone operators
8363#Asymptotic behavior of commutative semigroups of nonexpansive mappings in Banachspaces
8364#The contact set of rigid body partially supported by a membrane
8365#Existence results in an inverse problem of potential theory
8366#Global solutions for some nonlinear parabolic equations with nonmonotonic peturbations
8367#On the class of nonlinear evolution operators in Banach space
8368#Hopf bifurcation at a degenerate stationary pitchfork
8369#On existence and uniqueness of solutions of Hamilton-Jacobi equations
8370#Solutions of minimal period for a class of nonconvex Hamiltonian systems and applications to the fixed energy problem
8371#An oscillating solution for the porous medium equation
8372#Polya-Pade´ Fourier resonance reconstruction and singular perturbation theory
8373#Periodic sample solutions of second order ODE'S
8374#Nontrivial solutions of operator equations and Morse indices of critical points of min-max type
8375#Characterization of state-independent automata
8376#Decomposition of linear automata over residue rings into shift-registers
8377#A topological characterization of thinning
8378#On the construction of parallel computers from various bases of Boolean functions
8379#Infinite-word languages and continuous mappings
8380#Semantic analysis of inductive reasoning
8381#A simple proof of the Skolem-Mahler-Lech Theorem
8382#On the finite containment problem for Petri nets
8383#Alternation and &ohgr;-type Turing acceptors
8384#Test sets for finite substitutions
8385#Relational algebraic semantics of deterministic and nondeterministic programs
8386#Partial evaluation and &ohgr;-completeness of algebraic specifications
8387#Random generation of combinatorial structures from a uniform
8388#Complete sets of unifiers and matchers in equational theories
8389#More on the complexity of slice functions
8390#Concurrent and maximally concurrent evolution of nonsequential systems
8391#Efficient string matching with k mismatches
8392#Scott induction and closure under &ohgr;-sups
8393#Star-free sets of integers
8394#Specification and verification of decentralized daisy chain arbiters with &ohgr;-extended regular expressions
8395#Continuous semilattices
8396#Varieties of automated descendants of infinite trees
8397#The complexity of colouring problems on dense graphs
8398#A simple proof of a time-space trade-off for sorting with linear comparisons
8399#Structured algebraic specifications: A kernel language
8400#A fast numerical algorithm for the composition of power series with complex coefficients
8401#Coded systems
8402#Typing and computational properties of lambda expressions
8403#Boundedness, empty channel detection, and synchronization for communicating finite automata
8404#Dense orbital points of certain infinite word languages
8405#On pebble automata
8406#Computer systems analyst's view of the business organization
8407#Evaluation of first passage time densities for diffusion processes
8408#On some inequalities and generalized entropies: A unified approach
8409#Interactive decision making for multiobjective linear fractional programming problems with fuzzy parameters
8410#On foliations associated with differential equations of Euclidean type
8411#When is a field a Jacobi-field? A characterization of states on tensor algebras
8412#Extension of holomorphic functions with growth conditions
8413#Fock space representations of the Virasoro algebra-Intertwining operators-
8414#Radonification problem for cylindrical measures on tensor products of Banach spaces
8415#Conformal covariants
8416#The use of aggregation in causal simulation
8417#Counterfactuals
8418#Making believers out of computers
8419#An experimental logic based on the fundamental deduction principle
8420#Negation as failure: Careful closure procedure
8421#Incremental reconstruction of 3D scenes from multiple, complex images
8422#Controlling recursive inference
8423#Acceleration of extended Fibonacci sequences
8424#An adaptive grid method for Navier-Stokes flow computation II: Grid addition
8425#Efficient optimization of certain functionals in a hypercube
8426#Low frequency acoustic and electromagnetic scattering
8427#C:OS1:OE rational quadratic spline interpolation to convex data
8428#A least squares formulation of one-dimensional turbulence models
8429#On the economization of explicit Runge-Kutta methods
8430#Symmetric linear multistep methods for second-order differential equations with periodic solutions
8431#Implicit solution methods in computational fluid dynamics
8432#Multiple grid and Osher's scheme for the efficient solution of the steady Euler equations
8433#Moving finite element modelling of compressible flow
8434#Mesh generation by a sequence of transformations
8435#Accuracy of schemes with nonuniform meshes for compressible fluid flows
8436#New issues in PC graphics
8437#A mandelbrot program for the Macintosh
8438#A digital dissolve for bit-mapped graphics screens
8439#Sets and microsoft C version 4.0
8440#Error handling in Ada and Modula-2,large Turbo Pascal matrices
8441#Programming on the 80386
8442#Tnz: An 8-bit to 16-bit translator
8443#Modula-2 compilers for the IBM PC
8444#More, a file-browsing utility
8445#MS-DOS tricks
8446#Factoring in forth
8447#Curve fitting with cubic splines
8448#A first-order sorting algorithm
8449#Turbo prolog: The language
8450#High-speed thrills
8451#Directory traversal, trailing ˆZs, and horrifying experiences
8452#MS-DOS book, DOS file handles, and more
8453#The worm memory test
8454#Benchmarking C compilers
8455#An AVL tree database package
8456#Forth and the EMS
8457#Generic routines in Ada and modula-2, Pascal iterators
8458#A forth standards proposal
8459#Forth goes to sea
8460#Forth windows for the IBM PC
8461#The compuserve B protocol
8462#Binary trees, compilers
8463#Forth and the EMS
8464#Forth
8465#Crystallography and cohomology of groups
8466#The partial order of Iterated exponentials
8467#The Laplace transform inversion by inspection
8468#Points of finite order on Elliptic curves
8469#The shortest curve that meets all the lines that meet a convex body
8470#Factoring large numbers on a pocket calculator
8471#A "great theorems" course in Mathematics
8472#View of Riemann's hypothesis
8473#The number of three-dimensional convex polyhedra
8474#Combinatorial and functional identities in one-parameter matrices
8475#Binomial identities and hypergeometric series
8476#A conjecture related to Chi-Bar-Squared
8477#Curvature, circles, and conformal maps
8478#Counting the subgroups of some finite groups
8479#The diophantine equation X:OS2:OE + 7 = 2:OSn:OE
8480#The tumbling box
8481#The multiplication theorem for Fredholm operators
8482#Ludwig Bieberbach's conjecture and its proof by Louis Branges
8483#Non-sexist solution of the menage problem
8484#Chance expectancy with trial-by-trial feedback and random sampling without replacement
8485#A note on alternating series in several dimensions
8486#Infinitesimals, microsimplexes and elementary homology theory
8487#Is there an all-purpose tile?
8488#Forms of the resultant of two polynomials
8489#Infinite branches of the Phi-tree
8490#Homomorphisms on C(R)
8491#A note on Kronecker's approximation theorem
8492#When is a point x satisfying $\nabla f(x)= 0 a global minimum of f?
8493#A first derivative test for functions of several variables
8494#N] and the root test
8495#The power method for finding eigenvalues on a microcomputer
8496#Phase plane modeling of leg motion
8497#Elementary pattern discrimination (behavioural experiments with the fly musca domestica)
8498#Motor unit action potential field - modelling results
8499#A new model of the acoustic reflex
8500#Linear function neurons: Structure and training
8501#An intrinsic mechanism for the oscillatory contraction of muscle
8502#The relationship between signal response selectivity and the functional structure of complex retinal neural networks
8503#An inverse problem in neural processing
8504#A stochastic theory of phase transitions in human hand movement
8505#Associative recall properties of the trion model of cortical organization
8506#Perception of solid shape from shading
8507#Some new phenomena in the perception of glass patterns
8508#Efficiency of associative memory inherent in post-tetanique potentiation
8509#Effects of electrical coupling on the cone-horizontal cell circuit in the catfish retina
8510#Estimating the variance of a critical stimulus level from sensory performance data
8511#Non-linearities in cortical simple cells and the possible detection of zero crossings
8512#Texture discrimination by Gabor functions
8513#On shunting inhibition
8514#System analysis of phycomyces light-growth response with Gaussian white-noise-noise stimuli
8515#System analysis of phycomyces light-growth response: Single mutants
8516#System analysis of phycomyces light-growth response: Double mutants
8517#A continuous cable method for determining the transient potential in passive dendritic trees of known geometry
8518#The identification of nonlinear biological systems: LNL cascade models
8519#The identification of nonlinear biological systems: Wiener and Hammerstein cascade models
8520#The perception of moving comets at high retinal illuminance levels: A rod-cone interaction effect
8521#Basic processes of locomotor coordination in the rock lobster. I. statistical a lysis of walking parameters
8522#Basic processes of locomotor coordination in the rock lobster.II. simulation of leg coupling
8523#Simple neural models of classical conditioning
8524#Habituation rules for a theory of the cerebellar cortex
8525#The computation of structure from fixed-axis motion: Rigid structures
8526#Game dynamics and evolutionary transitions
8527#A spatio-temporal model of ganglion cell receptive field in the cat retina
8528#On the stationary state of Kohonen's self-organizing sensory mapping
8529#A mathematical model of the primary visual cortex and hypercolumn
8530#Minimum-order Wiener modelling of spike-output systems
8531#Constraints for joint angle control of the human arm
8532#An optimal monitor of the rapid-eye-movement brain state
8533#Threshold perception and saccadic eye movements
8534#The effect of saccades on threshold perception - a model study
8535#Simulation studies on the control of posture and movement in a multi-jointed limb
8536#Time course of the houseflies' landing response
8537#Fourier transform magnitudes are unique pattern recognition templates
8538#Connectionistic models of boolean category representation
8539#A model for the perception of curves in dot figures: The role of local salience of "Virtual Lines"
8540#Stochastic analysis of environmental fluctuations in a compartmental system
8541#Dynamics of chromatic adaptation in cones of freshwater turtle
8542#Adjustment errors of feedback guided human forearm movements elicited by random position signal sequences
8543#Extracellular potentials of single active muscle fibres: Effects of finite fibre length
8544#Optimized movement trajectories and joint stiffness in unperturbed, inertially loaded movements
8545#Dynamic shape
8546#A self-similar stack model for human and machine vision
8547#A stochastic model of retinotopy: A self organizing process
8548#Introduction: Expert systems in Forth
8549#The internals of FORPS: a FORth-based production system
8550#Tokenized rule based system
8551#A Forth oriented real-time expert system: a FORTES polysomnographer
8552#Implementation of an experimental micro-computer based medical diagnosis system
8553#An approach to natural language parsing
8554#A review of knowledge engineering and expert systems: toward expert operators in Forth
8555#Fuzzy query language
8556#Extending Forth in a camac controlled muon channel
8557#Forth in the computer numerical control environment
8558#Exception handling in Forth
8559#State sequence handlers
8560#User-oriented suggestions for floating-point and complex-arithmetic Forth standard extensions
8561#A wordset for error propagation arithmetic
8562#A microcoded machine simulator and microcode assembler in a Forth environment
8563#A Forth implementation of the heap data structure
8564#Object oriented extensions to Forth
8565#Discrete event simulation in Forth
8566#Plotter drivers as an exercise in Forth wordset design
8567#1985 FORML conference abstracts
8568#The MAGIC/L programming language
8569#Forth as the basis for an integrated operations environment for a space shuttle scientific experiment
8570#HFORTH: A high level business language in FORTH
8571#Fifteen programmers, 400 computers, 36,000 sensors and FORTH
8572#Pragmatic VLSI design environment
8573#Top-down design in Forth
8574#Forth implementation in a high-level language
8575#Measurement of interrupt response time of PDP-11/44 and PDP-11/23 computers with a CAMAC interface
8576#An implementation of MC6800 fig-Forth under Unix
8577#Forth-based software for real-time control of a mechanically-scanned ultrasonic imaging system
8578#Fast and flexible Forth programming in a femtosecond laser lab
8579#Stack frames and local variables
8580#Should VARIABLE be an immediate state-sensitive word?
8581#Readable and efficient parameter access via argument records
8582#Run-time error handling in FORTH using SETJMP and LNGJMP for execution control (or, GOTO in Forth)
8583#Distributing data in a networking environment
8584#Applying expert principles to computer systems development
8585#European expert systems project for systems developers
8586#Intelligent page printing systems
8587#Trends in printer technology
8588#Basic printers
8589#Mainframe graphics for business presentations
8590#Presentation slides using NASA technology
8591#Data dictionary systems and their application in auditing
8592#Preparing for the auditor
8593#Accounting on micros
8594#Application of DBMS
8595#Standards and system development
8596#Demanding higher productivity
8597#Managing deregulation
8598#Messaging standards and IBM's SNA
8599#C standardization
8600#Standby redundancy
8601#Is prototyping counterproductive?
8602#Image analysis problems, posed mathematically as variational principles or as partial differential equations, are amenable to numerical solution by relaxation algorithms that are local, iterative, and often parallel. Although they are well suited structurally for implementation on massively parallel, locally interconnected computational architectures, such distributed algorithms are seriously handi capped by an inherent inefficiency at propagating constraints between widely separated processing elements. Hence, they converge extremely slowly when confronted by the large representations of early vision. Application of multigrid methods can overcome this drawback, as we showed in previous work on 3-D surface reconstruction. In this paper, we develop multiresolution iterative algorithms for computing lightness, shape-from-shading, and optical flow, and we examine the efficiency of these algorithms using synthetic image inputs. The multigrid methodology that we describe is broadly applicable in early vision. Notably, it is an appealing strategy to use in conjunction with regularization analysis for the efficient solution of a wide range of ill-posed image analysis problems.
8603#Image processing methods (segmentation) are presented in connection with a modeling of image structure. An image is represented as a set of primitives, characterized by their type, abstraction level, and a list of attributes. Entities (regions for example) are then described as a subset of primitives obeying particular rules. Image segmentation methods are discussed, according to the associated image modeling level. Their potential efficacity is compared, when applied to cytologic image analysis.
8604#Edge detection is the process that attempts to characterize the intensity changes in the image in terms of the physical processes that have originated them. A critical, intermediate goal of edge detection is the detection and characterization of significant intensity changes. This paper discusses this part of the edge detection problem. To characterize the types of intensity changes derivatives of different types, and possibly different scales, are needed. Thus, we consider this part of edge detection as a problem in numerical differentiation. We show that numerical differentiation of images is an ill-posed problem in the sense of Hadamard. Differentiation needs to be regularized by a regularizing filtering operation before differentiation. This shows that this part of edge detection consists of two steps, a filtering step and a differentiation step. Following this perspective, the paper discusses in detail the following theoretical aspects of edge detection. 1) The properties of different types of filters-with minimal uncertainty, with a bandpass spectrum, and with limited support-are derived. Minimal uncertainty filters optimize a tradeoff between computational efficiency and regularizing properties. 2) Relationships among several 2-D differential operators are established. In particular, we characterize the relation between the Laplacian and the second directional derivative along the gradient. Zero crossings of the Laplacian are not the only features computed in early vision. 3) Geometrical and topological properties of the zero crossings of differential operators are studied in terms of transversality and Morse theory.
8605#This paper comments on the optimality of the Laplacian of a Gaussian edge detection filter which localizes edges through zero crossings in the filtered image. The arguments of both Marr and Hildreth, and Dickey and Shanmugam are reviewed to establish that the filter is optimal in the sense of maximizing output image energy near edge features. This filter's principal advantage over other edge detectors is that its response is user-adjustable through selection of a single parameter, the Gaussian standard deviation. However, no clear method for the selection of this parameter has been provided. The problem is addressed here by applying the filter to two ideal periodic edge models blurred by a Gaussian distribution point-spread function. The observed response to the edge spacing and blur standard deviation is then translated into a filter parameter design procedure. The problems of optimum filter performance in the presence of additive Gaussian noise are then addressed. The problem of selecting the sampled filter's coefficient word size is dealt with in a companion paper.
8606#A companion paper describes the design and implementation of the Laplacian of a Gaussian edge detection filter which localizes edges through zero crossings in the filtered image. Accuracy in the presence of noise has been found to be proportional to the square root of the filter's standard deviation. Digital implementation of any continuous filter requires sampling and coefficient quantization. The sampled filter was examined, but a method is proposed here for selection of a minimum coefficient word size for direct-form implementation to satisfy in-band rejection bounds.
8607#This paper details the design and implementation of ANGY, a rule-based expert system in the domain of medical image processing. Given a subtracted digital angiogram of the chest, ANGY identifies and isolates the coronary vessels, while ignoring any nonvessel structures which may have arisen from noise, variations in background contrast, imperfect subtraction, and irrelevent anatomical detail. The overall system is modularized into three stages: the preprocessing stage and the two stages embodied in the expert itself. In the preprocessing stage, low-level image processing routines written in C are used to create a segmented representation of the input image. These routines are applied sequentially. The expert system is rule-based and is written in OPS5 and LISP. It is separated into two stages: The low-level image processing stage embodies a domain-independent knowledge of segmentation, grouping, and shape analysis. Working with both edges and regions, it determines such relations as parallel and adjacent and attempts to refine the segmentation begun by the preprocessing. The high-level medical stage embodies a domain-dependent knowledge of cardiac anatomy and physiology. Applying this knowledge to the objects and relations determined in the preceding two stages, it identifies those objects which are vessels and eliminates all others.
8608#We consider the collision-detection problem for a three-dimensional solid object moving among polyhedral obstacles. The configuration space for this problem is six-dimensional, and the traditional representation of the space uses three translational parameters and three angles (typically Euler angles). The constraints between the object and obstacles then involve trigonometric functions. We show that a quaternion representation of rotation yields constraints which are purely algebraic in a seven-dimensional space. By simple manipulation, the constraints may be projected down into a six-dimensional space with no increase in complexity. The algebraic form of the constraints greatly simplifies computation of collision points, and allows us to derive an efficient exact intersection test for an object which is translating and rotating among obstacles.
8609#In this paper, we describe a new model of bilevel digital images of line drawings. The key idea is that the constraints of generating the line drawings are available to select patterns which are considered to be a certain local appearance of line drawings. Concretely, when a bilevel digital image of line drawings is observed by 3 脳 3 pixels' unit mesh, the patterns occurring in the unit mesh are restricted by the constraints that the digital image is line-structured. At first, lines in a digital image are strictly defined and then two assumptions related to the minimum line width and observing unit mesh are introduced. It is theoretically derived what kinds of patterns occur under these conditions and we call them ``legal patterns,'' while the other patterns not satisfying above conditions are called ``illegal patterns.'' Next, new representations such as SYM pictures and LSC pictures, which consist only of legal patterns, are proposed as a model of bilevel digital images of line drawings and the algorithms to transcribe the original bilevel digital image into the new representations in the model are introduced. Finally, the experimental results are evaluated from the viewpoint of the amount of data involved in the new representations. The results show that our theory is well-fitted to actual images and that many useful and practical applications will be derived not only in the field of documents processing, but also of digital communication.
8610#In many application fields (e.g., aerospace and biomedical image processing), one has to deal with a sequence of images whose observation is made difficult by unpredictable relative movements of the camera and the scene. In order to obtain a stable display, the displacement of each image in the sequence with respect to one chosen as a reference must be preliminarily determined. This would usually require two-dimensional algorithms, involving a considerable computational effort. This work discusses a new algorithm for image registration, which requires only one-dimensional Fourier transformations. Preliminary experimental results are reported.
8611#Gaussian filtering is an important tool in image processing and computer vision. In this paper we discuss the background of Gaussian filtering and look at some methods for implementing it. Consideration of the central limit theorem suggests using a cascade of ``simple'' filters as a means of computing Gaussian filters. Among ``simple'' filters, uniform-coefficient finite-impulse-response digital filters are especially economical to implement. The idea of cascaded uniform filters has been around for a while [13], [16]. We show that this method is economical to implement, has good filtering characteristics, and is appropriate for hardware implementation. We point out an equivalence to one of Burt's methods [1], [3] under certain circumstances. As an extension, we describe an approach to implementing a Gaussian Pyramid which requires approximately two addition operations per pixel, per level, per dimension. We examine tradeoffs in choosing an algorithm for Gaussian filtering, and finally discuss an implementation.
8612#The properties of the ``magnifying glass'' method of clustering are discussed. These properties, which include unbiased and consistent estimation of the mean for Gaussian distributions and biased and inconsistent estimation of the mean for non-Gaussian distributions, lead to the development of a technique for testing data to determine whether or not it is Gaussian. An example of a non-Gaussian distribution is given to show the sensitivity of the proposed Gaussian test.
8613#This paper reports the results of a numerical comparison of two versions of the fuzzy c-means (FCM) clustering algorithms. In particular, we propose and exemplify an approximate fuzzy c-means (AFCM) implementation based upon replacing the necessary ``exact'' variates in the FCM equation with integer-valued or real-valued estimates. This approximation enables AFCM to exploit a lookup table approach for computing Euclidean distances and for exponentiation. The net effect of the proposed implementation is that CPU time during each iteration is reduced to approximately one sixth of the time required for a literal implementation of the algorithm, while apparently preserving the overall quality of terminal clusters produced. The two implementations are tested numerically on a nine-band digital image, and a pseudocode subroutine is given for the convenience of applications-oriented readers. Our results suggest that AFCM may be used to accelerate FCM processing whenever the feature space is comprised of tuples having a finite number of integer-valued coordinates.
8614#Relaxation labeling processes are a class of mechanisms that solve the problem of assigning labels to objects in a manner that is consistent with respect to some domain-specific constraints. We reformulate this using the model of a team of learning automata interacting with an environment or a high-level critic that gives noisy responses as to the consistency of a tentative labeling selected by the automata. This results in an iterative linear algorithm that is itself probabilistic. Using an explicit definition of consistency we give a complete analysis of this probabilistic relaxation process using weak convergence results for stochastic algorithms. Our model can accommodate a range of uncertainties in the compatibility functions. We prove a local convergence result and show that the point of convergence depends both on the initial labeling and the constraints. The algorithm is implementable in a highly parallel fashion.
8615#The multiple grid(MG) chain code which uses four different square grids is proposed to encode line drawings. The main processes adopted in the code are: 1) a grid selection algorithm which allocates quantization points only to the vicinity of the course of a line drawing, 2) labeling rule on quantization points which makes the frequency of some codes larger than that of other codes, and 3) quantization points allocation-not to the corners, but to the sides of a square which makes the straight line segments larger without increasing quantization error. A performance comparison of various chain codes is made from the viewpoints of the encoding efficiency, naturalness of the encoded lines, and the rate distortion measure. Also, the superiority of the MG chain code to other codes is shown. At last, application of the MG chain code to the electronic blackboard system is explained.
8616#This paper considers the problem of measuring properties of digitized straight lines from the viewpoint of measurement methodology. The measurement and estimation process is described in detail, revealing the importance of a step called ``characterization'' which was not recognized explicitly before. Using this new concept, BLUE (Best Linear Unbiased) estimators are found. These are calculated for various properties of digitized straight lines, and are briefly compared to previous work.
8617#The problem of m-D filtering using sequential scanning is considered. It is shown that the optimal causal filter and the performance measure depend on the scan selected. Examples show that this effect can be significant. Possible techniques to select a suitable scan are analyzed.
8618#The convergence of the fuzzy ISODATA clustering algorithm was proved by Bezdek [3]. Two sets of conditions were derived and it was conjectured that they are necessary and sufficient for a local minimum point. In this paper, we address this conjecture and explore the properties of the underlying optimization problem. The notions of reduced objective function and improving and feasible directions are used to examine this conjecture. Finally, based on the derived properties of the problem, a new stopping criterion for the fuzzy ISODATA algorithm is proposed.
8619#Knotted periodic orbits in suspensions of Smale's horseshoe: period multiplying and cabled knots
8620#Study of a nonlinear 4th dimension combustion system and general: to a 2nd degree class of homogeneous problems
8621#Chemical waves inelectric field-modelling
8622#Numerical study of a billiard in a gravitational field
8623#Random matrices as models for the statistics f quantum mechanics
8624#Asymptotic shapes of power spectra of intermittent chaos near its onset point
8625#Stability analysis on a set of calcium-regulated viscoelastic equations
8626#The structure of a strange attractor
8627#Periodic solutions generated by Ba¨cklunk transformations
8628#Existence of exponentially unstable periodic solutions and the non-integrability of homogeneous Hamiltonian systems
8629#Solutions of the Boussinesq equation
8630#A study of correlation functions for the delta-function Bose gas
8631#Connection formulae for Painleve´ V functions.II. The &dgr; function Bose gas problem
8632#Extracting qualitative dynamics from experimental data
8633#Four-dimensional mapping model for two-frequency electron cyclotron resonance heating
8634#Mode selection in nearly-self sustained explosive crystallization
8635#Estimation of nonlinear transfer functions for fully developed turbulence
8636#Critical behaviour and intermittency in Sinai's billiard
8637#New graphical method for the iteration of one-dimensional maps
8638#Resonance bands in a two degree of freedom Hamiltonian system
8639#Matched solution of nonlinear forced equations and Rossby vortices
8640#Comments on a simple cellular automaton in spin representation
8641#Multiple bifurcation problems for chemical reactors
8642#Lectures on applied mathematics in combustion. Past contributions and future problems in laminar and turbulent combustion
8643#Local and global parametric analysis of reacting flows
8644#Some mathematical aspects of flame chaos and flame multiplicity
8645#Adaptive numerical methods for reacting flows
8646#Billiards in polygons
8647#Chaotic dynamics of a bouncing ball
8648#Universality and scaling of period-doubling bifurcations in a dissipative distributed medium
8649#On the prediction of local patterns in cellular automata
8650#Soliton-like behavior in automata
8651#Some nonlinear three-dimensional motions of an elastic string
8652#Universality in the transition to chaos of dissipative systems
8653#The Painleve´ property, a modified Boussinesq equation and a modified Kadomtsev-Petviashvili equation
8654#Unrestricted algorithms for reciprocals and square roots
8655#On computing INV blick preconditioning for the conjugate gradient method
8656#Errorbounds for multistep methods revisited
8657#On numerical evaluation of double integrals of an analytic function of two comple X variables
8658#Convex interpolating splines of arbitrary degree III
8659#Initial approximations in Durand-Kerner's root finding method
8660#Generating combinations in parallel
8661#An o(n log n) minimal spanning tree algorithmn for n points in the plane
8662#Brownian motion and algorithm complexity
8663#An upper bound for the speedup of parallel best-bound branch-and-bound algorithm
8664#An algorithm for the enumeration of spanning trees
8665#Phase-lag analysis of explicit Nyström methods fory″-f(x,y)
8666#Multivariate Pade´ approximants revisited
8667#On regularization and descretization control for the umerical solution of inverse problems in parabolic equations
8668#Derivative free multipoint iterative methods for simple and multiple roots
8669#Local error control in SDIRK-methods
8670#Circle contractive linear methods
8671#An explicit cubic iteration for &pgr;
8672#A one-way,stackless quisksort algorithm
8673#The convergence of interpolatory product integration rules
8674#Pancyclism and Meyniel's conditions
8675#Ki-covers I: Complexity and polytopes
8676#Extensions of ordered sets having the finite cutset property
8677#Magic cubes and hypercubes of order 3
8678#Steiner quadruple systems having a prescribed number of quadruples in common
8679#The Johnson graph J(d,r) is unique if (d,r) ≠ (2,8)
8680#Explicit construction of exponential sized families of K-independent sets
8681#Generalized Hilton construction for embedding d-ary quasigroups
8682#Maximal difference matrices of order ≤0
8683#A theorem of associative block designs
8684#On the density of B2-bases
8685#Small solution of linear Diophantine equations
8686#Domination parameters for the bishops graph
8687#Embedding maximal cliques of sets in maximal cliques of bigger sets
8688#A sufficient condition for oriented graphs to be Hamiltonian
8689#The chromatic number of graphs which induce neither K1,3 nor K5 - e
8690#Locally geodesic cycles in 2-self-centered graphs
8691#Finite type graphs and some graph operations, II
8692#On the existence of certain generalized Moore geometries, Part III
8693#On the chromatic uniqueness of bipartite graphs
8694#A combinatorial bijection between linear extensions of equivalent orders
8695#A note on `On antipodal graphs'
8696#Characterization of the Cartesian product of complete graphs by convex subgraphs
8697#On the sphericity of the graphs of semiregular polyhedra
8698#A note on infinite transitive graphs
8699#Maximum determinants of complementary acyclic matrices of zeros and ones
8700#Combinatorial cycles of a polynomial map over a commutative field
8701#Switching classes of directed graphs and H-equivalent matrices
8702#Inequalities for the number of monotonic functions of partial orders
8703#The size of graphs uniquely hamiltonian-connected from a vertex
8704#On the uniformity of the closed-set lattice of a tree
8705#Enumeration of Platonic maps on the torus
8706#Expected hitting times for a random walk on a connected graph
8707#Neighborhood perfect graphs
8708#Transitivity on sets of independent points in geometric lattices
8709#Multinomial matrices
8710#The ith Ramsey number for matchings
8711#On the covering of pairs by quadruples
8712#Sharply transitive partially ordered sets
8713#The bandwidth problem and operations on graphs
8714#Cyclic codes over GF(q) with simple orbit structure
8715#Do local majorities force a global majority?
8716#An algorithm for generating necklaces of beads in two colors
8717#Switching invariant two-path signed graphs
8718#Permanent of the Laplacian matrix of trees with a given matching
8719#On the number of tournaments with prescribed score vector
8720#Some existence conditions for partially balanced arrays with 2 symbols
8721#Metric transforms of finite spaces and connected graphs
8722#On kernels in i-triangulated graph
8723#On a method for random graphs
8724#A note on superbrittle graphs
8725#Minimal clique partitions and pairwise balanced designs
8726#A contribution to the theory of voltage graphs
8727#On k-graceful, countably infinite graphs
8728#Concerning the spectrum of perpendicular arrays of triple systems
8729#A new feasibility condition for distance-regular graphs
8730#Orbits in uniform hypergraphs
8731#An extremal coloring problem on matrices
8732#An application of the Ramsey theorem to ordered r-tournaments
8733#Partition of digraphs into paths or circuits
8734#Natural spanning trees of are recurrent
8735#Note on some determinants of q-binomial numbers
8736#Video education
8737#Video educator Sam Gibbon: The man who looks through kids's eyes
8738#Micro marketers
8739#Bringing technology to special education in the Bayou State
8740#Proceedings of the 8th UFEM Symposium on Unification of finite element software systems
8741#A multitasking kernel
8742#In search of a sine
8743#Echelon's Z-system
8744#Series 32000 corss assembler
8745#Turbo Pascal and Modula-2'
8746#PL/68K
8747#A simple OS for real time applications
8748#Bringing up the 68000
8749#COM: an 8080 simulator for the MC68000
8750#A unix-like shell for MS DOS
8751#Trojan horse programs
8752#Eurotra: general overview
8753#General view of the design methodology
8754#The , T model for translation
8755#The levels of representation
8756#The interface structure level of representation
8757#The small-size experiment
8758#Linguistic research in the Greek group
8759#Linguistic research in the Danish group
8760#Linguistic research in the Belgo-Dutch group
8761#The Eurotra dictionaries
8762#Software: an overview
8763#Description of the virtual machine implementation
8764#An appropriate environment for software construction
8765#Environments for Eurota
8766#Organizational aspects
8767#Appendix 1: Eurotra glossary
8768#Appendix 2: Articles about Eurotra
8769#Rapid and post editing two methods for a specific activity
8770#LSP-automatic translation and information technology
8771#Esperanto as the focal point of machine translation
8772#Evolution of the automatic German-Japanese translation system
8773#Concept of a wide-area computer network
8774#Protocol-verification algorithm using the inspection method
8775#Method of evaluating the performance of local-area networks
8776#Effect of reliability parameters on the efficiency of a local-area network with a star structure
8777#Analytic adaptive model of a base band system in an ECMA CSMA/CD environment
8778#Local-area network based on computers of the elektronika T3-29 series.
8779#Local area networks in integrated production facilities
8780#Local-area network hardware of SM1800 microcomputers
8781#Decomposition of parallel logical control algorithms according to a specified partition of the set of sentences
8782#Use of signature analysis for testing and diagnostics of digital network structures
8783#Methods of organizing conflict resolution in specialized multiprocessor systems
8784#Implementation and analysis of the TRIMOSBUS self-clocking interface
8785#Analysis of correctness of synchronization in systems design of terminal installations
8786#Architecture of an integrated wide-area radio data network
8787#Analysis of communications networks with channel blocking
8788#Adaptive switching with variable frame length
8789#High-speed arrangements for multiple access to a baseband system in local-area ntworks
8790#Protocol of combined access to baseband of local-area network
8791#Contention-resolution algorithm for a local-area network with random multiple access
8792#Priority-based multiple access in CSMA/CD local-area data networks
8793#Modern design principles for data-transmission devices and facilities
8794#Local-area network as an environment for implementing computer-aided design of crcuit boards
8795#Organization of multiprocessing of interruptable tasks in a homogeneous computersystem
8796#Pascal implementation of transactions for network data banks
8797#Structural approach to software implementation of Boolean functions
8798#Synthesis of diagnostic test for discrete components connected in series
8799#Formal description languages for computer network protocols: a survey
8800#ISO transport protocol classes
8801#One method of analyzing computer networks
8802#Transport stations and gateways for computer networks
8803#Hybrid routing algorithm for computer networks
8804#Simulation of data networks based on the aggregate approach
8805#Control of distributed transactions in a computer network
8806#Semidynamic page-replacememt algorithms and modification of the working-set algorithm
8807#Technique for estimating the parameters of network devices for digital data processing in a homogeneous environment
8808#Analysis of the organization of a common computational resource consisting of specialized devices
8809#Method of implementing pseudo-random number generators on the basis of microprocessors
8810#Distribution of tasks among the units of a computer network
8811#Optimizing the structure of ring data transmission
8812#The structure of a network terminal complex of a local network for scientific research automation
8813#Backward error recovery in distributed systems
8814#A control method and a device for multiple access to the medium of a high speed ring data transmission system of a local computer network
8815#An analysis of cross-effects of hardware and software during the startup adjustment of local computer networks
8816#A local data transmission network of a distributed control systems
8817#Structural organization of super-high speed computers and systems: performance evaluation methods
8818#Network access method for US-7920 interface converter
8819#Decompositional design of automata based on PLA with memory
8820#Evaluating the performance of multiprocessor computer systems in case of collisions in a block-structured common memory
8821#Software design for a multifunctional simulation system of programmable multiporcessor structures
8822#Traces are histories of signal values. Traces can be used for describing and formally reasoning about digital circuits, at the register-transfer level where there is synchronous logic. Two proofs are given for an example circuit, and proved with the aid of a mechanical theorem-prover. The first proof is of correctness - that the required behaviour is a consequence of internal structure. The second proof is of consistency - that the given structure can in fact exist.
8823#This paper presents the design of a distributed system based in a centralized parallel bus. The architecture of the system is described and the design of the bus and communication processor is analysed.
8824#Cyclic cohomology of AUxeandAUx,x–1e
8825#A file maintenance model, called the multiple random access storage units model, is introduced. Storage units can be accessed simultaneously, and the parallel processing of an associative query is achieved by distributing data evenly among the storage units. Maximum parallelism is obtained when data satisfying an associative query are evenly distributed for every possible query. An allocation scheme called M-cycle allocation is proposed to maintain large files of data on multiple random access storage units. The allocation scheme provides an efficient and straightforward indexing over multidimensional key spaces and supports the parallel processing of orthogonal range queries. Our analysis shows that M-cycle allocation achieves the near-optimum parallelism for processing the orthogonal range queries. Moreover, there is no duplication of records and no increase in insertion/deletion cost.
8826#A new way to increase file space in dynamically growing files is introduced in which substantial improvement in file utilization can be achieved. It makes use of partial expansions in which, instead of doubling the space associated with some part of the file, the space grows at a slower rate. Unlike previous versions of partial expansion in which the number of buckets involved in file growth is increased by less than a factor of two, the new method expands file space by increasing bucket size via “elastic buckets.” This permits partial expansions to be used with a wide range of indexed files, including B-trees. The results of using partial expansions are analyzed, and the analysis confirmed by a simulation study. The analysis and simulation demonstrate that the file utilization gains are substantial and that fears of excessive insertion cost resulting from more frequent file growth are unfounded.
8827#Expert systems for microcomputers: an introduction to artificial intelligence
8828#Writing and word processing for engineers and scientists: how to get your message across in today's high technology world
8829#Technology's crucible
8830#Expert systems: a non-programmer's guide to development and applications
8831#The elements of artificial intelligence: an introduction using LISP
8832#Engineering mathematics handbook: definitions, theorems, formulas, tables (3rd ed.)
8833#Op-Amp handbook; 2nd ed.
8834#Source data entry alternatives
8835#Ethical dilemmas in production and inventory control
8836#An incremental primal sieve
8837#An efficient ELL(1)-parser generator
8838#Generation of efficient LALR parsers for regular right part grammars
8839#Algorithms for routing in planar graphs
8840#Exponential queueing systems with non-stationary parameters
8841#Total correctness of CSP programs
8842#Nearly optimal hierarchies for network and formula size
8843#A faster approximation algorithm for the Steiner problem in graphs
8844#Proceedings on Third international conference on logic programming
8845#The role of logic programming in the Fifth Generation Computer Project
8846#An abstract machine for restricted AND-parallel execution of logic programs
8847#Efficient management of backtracking in AND-parallelism
8848#An intelligent backtracking algorithm for parallel execution of logic programs
8849#Delta Prolog: a distributed backtracking extension with events
8850#OLD resolution with tabulation
8851#Logic programs and alternation
8852#Intractable unifiability problems and backtracking
8853#On the complexity of unification sequences
8854#How to invent a Prolog machine
8855#A sequential implementation of Parlog
8856#A GHC abstract machine and instruction set
8857#A Prolog processor based on a pattern matching memory device
8858#An improved version of Shapiro's model inference system
8859#A framework for ICAI systems based on inductive inference and logic programming
8860#Rational debugging in logic programming
8861#Using definite clauses and integrity constraints as the basis for a theory formation approach to diagnostic reasoning
8862#Some issues and trends in the semantics of logic programming
8863#Parallel logic programming languages
8864#P-Prolog: a parallel logic programming language based on exclusive relation
8865#Making exhaustive search programs deterministic
8866#Compiling OR-parallelism into AND-parallelism
8867#Shared memory execution of committed-choice languages
8868#Logic program semantics for programming with equations
8869#On the semantics of logic programming languages
8870#Towards a formal semantics for concurrent logic programming languages
8871#Design of a Prolog-based machine translation system
8872#Parallel logic programming for numeric applications
8873#Sequential and concurrent deterministic logic grammars
8874#A parallel parsing system for natural language analysis
8875#Equivalences of logic programs
8876#Qualified answers and their application to transformation
8877#Procedures in Horn-clause programming
8878#Higher-order logic programming
8879#Abstract interpretation of Prolog programs
8880#Verification of Prolog programs using an extension of execution
8881#Detection and optimization of functional computations in Prolog
8882#Control of logic program execution based on the functional relations
8883#Declarative graphics
8884#Test-pattern generation for VLSI circuits in a Prolog environment
8885#Using Prolog to represent and reason about protein structure
8886#A new approach for introducing Prolog to naive users
8887#Prolog programming environments: Architecture and implementation
8888#Design overview of the NAIL] system
8889#A superimposed codeword indexing scheme for very large Prolog databases
8890#Interfacing Prolog to a persistent data store
8891#A general model to implement DIF and FREEZE
8892#Cyclic tree traversal
8893#Completeness of the SLDNF-resolution for a class of logic programs
8894#Choices in, and limitations of, logic programming
8895#Negations and quantifiers in NU-Prolog
8896#Gracefully adding negation and disjunction to Prolog
8897#Memory performance of Lisp and Prolog programs
8898#The design and implementation of a high-speed incremental portable Prolog compiler
8899#Compiler optimizations for the WAM
8900#Fast decompilation of compiled Prolog clauses
8901#Logic continuations
8902#Cut and Paste—defining the impure primitives of Prolog
8903#Tokio: logic programming language based on temporal logic and its compilation to Prolog
8904#The OR-forest description for the execution of logic programs
8905#Proceedings of the eighteenth annual ACM symposium on Theory of computing
8906#Bounded-width polynomial-size branching programs recognize exactly those languages in NC1
8907#Almost optimal lower bounds for small depth circuits
8908#With probability one, a random oracle separates PSPACE from the polynomial-time hierarchy
8909#Two lower bounds for branching programs
8910#On nontrivial separators for k-page graphs and simulations by nondeterministic one-tape Turing machines
8911#How hard is it to marry at random? (On the approximation of the permanent)
8912#Private coins versus public coins in interactive proof systems
8913#The complexity of optimization problems
8914#A provably efficient algorithm for dynamic storage allocation
8915#Tight bounds for minimax grid matching, with applications to the average case analysis of algorithms
8916#Four pages are necessary and sufficient for planar graphs
8917#Making data structures persistent
8918#Rotation distance, triangulations, and hyperbolic geometry
8919#A new approach to the maximum flow problem
8920#Fast algorithms for convex quadratic programming and multicommodity flows
8921#Parallel hashing—an efficient implementation of shared memory
8922#Limits on the power of concurrent-write parallel machines
8923#New lower bounds for parallel computation
8924#Deterministic selection in O(loglog N) parallel time
8925#Linear programming with two variables per inequality in poly-log time
8926#Deterministic coin tossing and accelerating cascades: micro and macro techniques for designing parallel algorithms
8927#Introducing efficient parallelism into approximate string matching and a new serial algorithm
8928#Parallel evaluation of division-free arithmetic equations
8929#Explicit expanders and the Ramanujan conjectures
8930#Non-blocking networks
8931#An optimal sorting algorithm for mesh connected computers
8932#Optimal simulations between mesh-connected arrays of processors
8933#Classifying learnable geometric concepts with the Vapnik-Chervonenkis dimension
8934#Reasoning about fair concurrent programs
8935#A note on one-way functions and polynomial-time isomorphisms
8936#The complexity of reasoning about knowledge and time
8937#Almost all primes can be quickly certified
8938#Uniform closure properties of P-computable functions
8939#A fast parallel algorithm to compute the rank of a matrix over an arbitrary field
8940#A fast parallel algorithm for determining all roots of a polynomial with real roots
8941#Finding irreducible polynomials over finite fields
8942#Pseudo-random permutation generators and cryptographic composition
8943#Limits on the security of coin flips when half the processors are faulty
8944#Fault tolerance in networks of bounded degree
8945#A linear-time algorithm for triangulating simple polygons
8946#Topologically sweeping an arrangement
8947#Constructing higher-dimensional convex hulls at logarithmic cost per face
8948#Further applications of random sampling to computational geometry
8949#Probing convex polytopes
8950#Two probabilistic results on rectilinear Steiner trees
8951#Computing the volume is difficult
8952#Aspects of information flow in VLSI circuits
8953#Proceedings of the ACM Conference on The history of personal workstations
8954#I originally accepted this keynote honor for five reasons: to respond to Alan Perlis' request (he told me I could present anything from a new taxonomy to personal reminiscences); second, to identify the important artifacts that should be preserved in The Computer Museum; third, to posit a framework of the history of workstations that can be written in the next century (we're all too close to create it); fourth, to summarize my own involvement on interactive computing including timesharing and large personal computers (both styles of use led to personal workstations); finally, to record my work on Digital's VAX Homogeneous Computing Environment that was totally announced last year. I led the architecture for this environment over the decade from 1973 to 1982 and was strongly influenced by the personal workstation computing movement including Ethernet. This work hasn't been described outside of product brochures.
8955#A personal view of the personal work station: some firsts in the Fifties
8956#The ideas and developments reviewed briefly are mainly from six sources: (1) the M.I.T. Lincoln Laboratory during the middle and late 1950s, (2) Bolt Beranek and Newman in 1957-1962, (3) the ARPA program in 1962-1964, (4) IBM Research in 1964-1966, (5) Ivan Sutherland's lab at Harvard in 1967, and (6) Project MAC at M.I.T. in 1968-1972.For instance, there were (1) cloud filter stations with light guns and light pens, (2) a single 1024x1024 scope display time-shared four ways and a workstation for studying technical documents, (3) Rand tablets. Teagher tables, and Bernstein's horizontal text-editing display onto which both the human editor and the computer editor could write (and understand each other), (4) a computer system especially for computer-based education and a powerful vector graphics display system, (5) a PDP-1-based, single-user workstation with four display screens, a paper tape unit, a magnetic tape unit, a printer, and the beginnings of Sutherland's virtual space displays, and (6) graphics over the ARPANET and a multi-window workstation based on the Evans and Sutherland LDS-1.One of the key insights to be offered explains why workstations have vertical instead of horizontal (desk-like) display surfaces. Part of the plot is that, when, in the 50s or 60s, a cathode-ray tube was mounted face-up, some of the phosphor fell down onto the electron gun and caused a short circuit. Another part is that Fredkin and DEC simply got mixed up about which way the PDP-1 display ought to swivvel.
8957#In 1964 only large mainframe computers existed, each with its own separate set of users. If you were lucky the computer was timeshared, but even then you could not go far away since the terminals were hardwired to it or connected by local phone line. Moreover, if you wanted data from another computer you moved it by tape and you could forget wanting software from a different type of computer. Thus, most users were tied by their computer and terminal to a very restricted enviornment.Today, in 1985, your terminal could well be a microcomputer networked with a very large, worldwide collection of other computers. You can obtain data and software from all these computers relatively easily with room for improvement) or, where convenient, use the software and data on its home computer by remote access, computer to computer.This change, which has occurred over the past 20 years, is in part a massive and evolutionary change in computer technology, and in part a modest and revolutionary change in communications technology. The revolution in communications started with an experiment in computer networking, the ARPANET, and grew into a communications revolution called packet switching. Today virtually all the world is linked by packet switched communications service so that any terminal can access almost any computer in the world. This packet switched data network has grown up independent of the telephone network, but over the next 20 years the basic fabric supporting all switched services (data, telephone and video) appear likely to become converted to packet switching, completing the revolution.
8958#The concept of a mathematical laboratory has been developing throughout the lifetime of computers. The capabilities made available in systems supporting these laboratories range from symbolic integration, differentiation, polynomial and power series manipulation; through mathematical simulation; to direct control experimental systems. About 1961 two trends, one toward what has become known as on-line computation, the other toward time sharing gained enough recognition to develop national support and subsequently have come to represent what is now known as modern computation. An on-line system provides interactive facilities by which a user can exert deterministic influence over the computation sequence; a time-sharing system provides a means by which partial computations on several different problems may be interleaved in time and share facilities according to predetermined sharing algorithms. For reasons of economy it is hard to put a single user in direct personal control (on-line, that is) of a large scale computer. It is equally or more difficult to get adequate computation power for significant scientific applications out of any small scale economical computer. Consequently, on-line computing has come to depend upon time-sharing as its justifiable mode of implementation. On the other hand, valuable on-line applications have formed one of the major reasons for pushing forward the development of time-sharing systems. At present, both efforts have reached such a stage of fruition that one finds many systems incorporating selective aspects of the early experimental systems of both types. In this chapter, we will bring out some of the key features of highly interactive direct control systems that have implications for continuing design effort aimed at furthering the development of experimental mathematical laboratories. We then present a brief description of the foundations of an existing facility at the University of California at Santa Barbara and illustrate its use in a typical application. Finally, we discuss some extension of the system which will provide deeper power for future experimental applications.
8959#The augmented knowledge workshop
8960#Between 1972 and 1980, the first distributed personal computing system was built at the Xerox Palo Alto Research Center. The system was composed of a number of Alto workstations connected by an Ethernet local network. It also included servers that provided centralized facilities. This paper describes the development of the hardware that was the basis of the system.
8961#The personal distributed computing system based on the Alto and the Ethernet was a major effort to make computers help people to think and communicate. The paper describes the complex and diverse collection of software that was built to pursue this goal, ranging from operating systems, programming environments, and communications software to printing and file servers, user interfaces, and applications such as editors, illustrators, and mail systems.
8962#The LINC represents one of the earliest attempts to put the stored program computer into the form of a general instrument for laboratory use. In a deliberate departure from the technology of Timesharing then just beginning nearly two decades of development, the LINC was designed for use by individual experimenters and thus anticipated features of the modern personal computer and personal workstation. Built at M.I.T. in 1962, its immediate forebears were the TX-0, ARC-1, and L-1 computers, in turn direct descendents of the M.I.T. Whirlwind and MTC computers. Of course the LINC in its day was neither personal computer nor personal workstation but simply the LINC.The LINC was an outgrowth of interactions between two M.I.T. groups of scientists and engineers: the Communications Biophysics Laboratory interested in the quantification of neuro-electric activity, and the Lincoln Laboratory Digital Computer Group engaged in the development of advanced computers. Twelve LINCs were placed initially in biomedical research laboratories across the country under a unique NIH/NASA-sponsored evaluation program. Ultimately more than 1200 LINC or LINC variants were manufactured commercially for worldwide use. The basic system design went on to influence the design of the DEC PDP-4 and PDP-5 computers, which in turn helped to pave the way to the PDP-8.
8963#Scientific computing systems for individuals were pioneered early at Hewlett-Packard, beginning with the 9100A Desktop Calculator in 1968. Extensions of this first machine were soon seen in Personal Peripherals, such as Printers, Tape Cartridges, and Plotters, and followed by Graphic CRT Displays. By early 1972, the Desktop unit had been augmented by a very powerful Pocket Calculator, the ground-breaking HP 35A.This paper traces the evolution of these machines to the present day, following four main themes: 1. Scientific Desktop Computers; 2. Personal Calculators and Portable Computers; 3. Personal Peripherals; and 4. Personal Business Computers.The underlying technologies are described, as well as the product definitions and the market development. The company organization is described in some detail, since it appears both unorthodox in the industry and particularly appropriate for certain elements of the accomplishments.Some of the key people will be highlighted for their personal contributions, but the theme will revolve rather around the Team structure that seems responsible for the continued success in many of these product sectors.The paper concludes with considerations about two corollary impacts of this pioneering effort: 1. The development of Data-Domain design and test methodologies; and 2. The impact of Pocket Calculators on the mathematical skills and procedures of our society.
8964#From its beginning, the technology of personal workstations has been driven by visions of a future in which people would work in intimate partnership with computer systems on significant intellectual tasks. These visions have been expressed in various forms: Memex (Bush, 1945), Man-Machine Symbiosis (Licklider, 1960), NLS (Engelbart, 1963), Dynabook (Kay, 1977), and others.The tight coupling between human and computer required by these visions necessitated advances in the ways humans and computers interact. These advances have slowly begun to accumulate into what might be called a user technology. This user technology includes hardware and software techniques for building effective user interfaces: bitmapped displays, menus, pointing devices, “modeless” command languages, animation, and interface metaphors. But it must include a technical understanding of the user himself and of the nature of human-computer interaction. This latter part, the scientific base of user technology, is necessary in order to understand why interaction techniques are (or are not) successful, to help us invent new techniques, and to pave the way for machines that aid humans in performing significant intellectual tasks.In this paper, we trace some of the history of our understanding of users and their interaction with workstation—the personal part of personal workstations. In keeping with the spirit of other papers at this conference, we have centered this review around our own experiences, perspectives, and work and have not attempted a complete history of the field. In concentrating on our own work, we do not wish to mimimize the importance of others' work; we simply want to tell our own story. Our focus is on what we have learned about users in our years of studying them and how we see our findings relating to the original visions of the personal workstation.
8965#Inefficiency of Nash equilibria
8966#Approximation to optimization problems: an elementary review
8967#Envelopes and geometrical covers of side-payment games and their market representations
8968#On the duality gap in nonconvex optimization
8969#Polyhedral combinatorics and network reliability
8970#An application of the theory of weak convergence to the dynamic perishable inventory problem with discrete demand
8971#Nonsmooth Milyutin-Dubovitskii theory and Clarke's tangent cone
8972#An axiomatic model of unbounded utility functions
8973#NBU processes with general state space
8974#Multivariate new better than used distributions
8975#The orthogonal decomposition of games and an averaging formula for the Shapley value
8976#A solvable one-dimensional model of a diffusion inventory system
8977#Explicit solution of a two-dimensional deterministic inventory problem
8978#On repeated games with complete information
8979#On the augmented Lagrangian
8980#Combinatorial theorems on the simplotope that generalize results on the simplex and cube
8981#Linear programming for finite state multi-armed bandit problems
8982#A note on M. N. Katehakis and Y.-R. Chen's computation of the Gittins index
8983#Optimal consecutive-2-out-of-n systems
8984#An inventory model with limited production capacity and uncertain demands. I. The average-cost criterion
8985#An inventory model with limited production capacity and uncertain demands. II. The discounted-cost criterion
8986#Transversality conditions for some infinite horizon discrete time optimization problems
8987#A sequential stochastic assignment problem in a partially observable Markov chain
8988#Computational complexity of some problems in parametric discrete programming. I
8989#Explicit solution of a general consumption/investment problem
8990#Forward recursion for Markov decision processes with skip-free-to-the-right transitions. Part I. Theory and algorithm
8991#Markov decision processes with a Borel measurable cost function—the average case
8992#Measure-based values of non-atomic games
8993#On minimizing the expected makespan and flow time in stochastic flow shops with blocking
8994#Probabilistic algorithm for the directed traveling salesman problem
8995#Double-exponential utility functions
8996#Layered augmenting path algorithms
8997#A stochastic calculus model of continuous trading: optimal portfolios
8998#A note on positive dynamic programming
8999#Automedica - Special issue: Orthopaedic research procedures and techniques
9000#Measurements in diagnosis and treatment of musculoskeletal disease
9001#The effect of vibration on the spine of the seated individual
9002#Biplanar radiography for measurement of spinal shape and motion
9003#Digital image processing and computer graphics methods in spine research
9004#Surface shape analysis of spinal deformity
9005#Quantitative techniques for analysis of gait
9006#In vivo measurement techniques for orthopaedic research
9007#Biomechanics of the elbow joint
9008#Acoustic emission in bone
9009#The use of finite element modelling in the prediction of pathologic fracture in patients with metastatic cancer
9010#Quantification of forces exerted by internal fixation devices for custom-planned scoliosis correction surgery
9011#Scoliosis surgical correction assessment: relationship of back topographical changes to spinal biomechanics
9012#Temporal change of Landsat MSS albedo estimates in arid rangeland
9013#On the nature of models in remote sensing
9014#Assessing grassland biophysical characteristics from spectral measurements
9015#An AVHRR investigation of surface emissivity near Lake Eyre, Australia
9016#Single scattering of parallel direct and axially symmetric diffuse solar radiation in vegetative canopies
9017#Evaluation of spectral reflectance models to estimate corn leaf area while minimizing the influence of soil background effects
9018#Computer-aided brightness temperature map of Indian subcontinent—inference on soil moisture variations
9019#Macintosh graphics: a reference encyclopedia for MacPaint, MacDraw, and graphicssystems in Microsoft BASIC and Macintosh Pascal
9020#Resolution of Ada-related concerns in DoD-STD-2167, revision A
9021#DoD-STD-2167 default Ada design and coding standard
9022#The real issues in Ada education/training
9023#Can IBM keep growing?
9024#IBM's protean ways
9025#Staying alive
9026#A bang and a whimper
9027#MIPS and reality
9028#Very large projects
9029#The right stuff
9030#Boeing's pc practices
9031#NLP takes off
9032#Change sweeps market
9033#Pioneering: It hasn't been easy
9034#A workstation case study
9035#Cost-justifying OA
9036#Software: What's hot and what's not
9037#The art of software takeovers
9038#Grow your own programmers
9039#Waiting for ISDN
9040#Outfitting the computer room
9041#Staying in power
9042#Proceedings of the 1986 SIGPLAN symposium on Compiler construction
9043#Software Engineering Institute and Wang Institute of Graduate Studies on Software engineering education: the educational needs of the software community
9044#People are our most important product
9045#The experimental aspects of a professional degree
9046#Cognitive science view of software engineering
9047#Software engineering education: an idealized scenario
9048#Essential elements of software engineering education revisited
9049#Software engineering and computer science: how do they differ?
9050#The environment for the software engineer
9051#Considerations for graduate software engineering education: an Air Force perspective
9052#Why is software engineering so difficult
9053#Technology selection education for software engineers
9054#Graduate-level software engineering education: a practitioner's viewpoint
9055#Some observations on the nature of the software engineering "Problem" and their implications for software engineering education
9056#Adapting to changing needs: a new perspective on software engineering education at Texas Christian University
9057#The software engineering first degree at Imperial College, London
9058#The master of software engineering program at Seattle University after six years
9059#Academic/industrial collaboration in a postgraduate Master of Science degree in software engineering
9060#Skills versus knowledge in software engineering education: a retrospective on the Wang Institute MSE program
9061#Experience with a software engineering project course
9062#Software engineering project laboratory: the bridge between university and industry
9063#Software projects in an academic environment
9064#Exercises in software engineering
9065#Trends in National Science Foundation funded research and their impact on software engineering education
9066#Software engineering: anomalies in today's education and a prospectus for the future
9067#Education for the future of software engineering
9068#Report of the software engineering principles working group
9069#Proposed curriculum for a Master of Software Engineering (MES)
9070#Educational needs of the software community
9071#Report of the current software engineering curricula working groups
9072#The geography of science: disciplinary and national mappings
9073#A two-phase approach to making decisions involving goal uncertainty
9074#Co-word search: a system for information retrieval
9075#A comparative study of new product development
9076#The selection and implementation of a computerised information retrieval system in a small information unit
9077#Third order asymptotic properties of maximum likelihood estimators for gaussian ARMA processes
9078#Limit theorems for the multivariate binomial distribution
9079#The multivariate Laplace-De Moivre theorem
9080#Some sojourn time problems for 2-dimensional Gaussaian processes
9081#On estimation of matrix of normal mean
9082#Learn-merge invariance of priors: a characterization of the Dirichlet distributions and processes
9083#Crame´r-von Mises statistics based on the sample quantile function and estimated parameters
9084#Computation of variance components by the MINQUE method
9085#Invariant prediction regions with smallest expected measure
9086#Strongly and weakly harmonizable stochastic processes of H-valued random variables
9087#Third order efficient tests in exponential lattice models
9088#Approximations to the mean integrated squared error with applications to optimal bandwidth selection for nonparametric regression function estimators
9089#Thermal runaway in the earth's mantel
9090#Some stability results on advection-diffusion equations
9091#Pseudospherical surfaces and evolution equations
9092#An example of stability exchange in a Hamiltonian wave system
9093#Linear stability of miscible displacement processes in porous media in the absence of dispersion
9094#Resonantly interacting weakly nonlinear hyperbolic waves in the presence of shocks: A single space variable in a homogeneous, time independent medium
9095#A steadily translating pair of equal and opposite vortices with vortex sheets on their boundaries
9096#Amplitude expansions and normal forms in a model for thermohaline convection
9097#A proposal for toeplitz matrix calculations
9098#On the solution of the generalized wave and generalized spine-gordon equations
9099#Linearly coupled, slowly varying oscillators: The interaction of a positive-energy mode with a negative-energy mode
9100#Instabilities of waves on a free surface
9101#Dendrites in the small undercooling limit
9102#The superharmonic instability of finite-amplitude surface waves on water of finite depth
9103#Stability radii of linear systems
9104#Local feedback stabilization and bifurcation control, I. Hopf bifurcation
9105#An alternate stability analysis framework for adaptive control N
9106#A note on the structure of two subsets of the parameter space in adaptive control problems
9107#Necessary and sufficient conditions on Q ( = )C(l ( + )PC)–1) for stabilization of the linear feedback system S(P,C)
9108#On minimal order stabilization of single loop plants
9109#Robust stabilization of infinite dimensional systems by finite dimensional controllers
9110#Coprime factorization of discrete time-varying systems
9111#Nonpassivity of linear discrete-time systems
9112#Optimal controls for stochastic systems with singular noise
9113#Generalized Chebyshev band-pass prototype filters
9114#On some finite dimensional nonlinear filters for certain diffusions observed in correlated noise
9115#Solution to a problem of guarding territory
9116#Stabilizability nd detectability of linear periodic systems-Addendum
9117#The design and construction of a vital database
9118#Microcomputer availability to public library clients
9119#The user at the online catalogue
9120#CLANN comes of online age
9121#Launch of the Clann online library system
9122#Professionalism and the role of research in Australian librarianship
9123#To the network: The evolution of automated library systems at the New South Wales Institute of Technololgy
9124#New South Wales TAFE :20goes live”: Planning and implementation of online library services
9125#Action diagrams for systems analysts
9126#Gateway to Ethernet
9127#Security for distributed systems
9128#Data administration in the organization
9129#Networking made simpler
9130#RPGII enviornment on an IBM PC
9131#Requirements for a successful methodology in information systems design
9132#Management controls for information systems
9133#Overview of software engineering
9134#Disc cache for PCs
9135#Opportunity in freelancing
9136#Remote working
9137#Facing up to the skills shortage
9138#True staff communication
9139#Fibre optics in multiplexing
9140#A taxonomy of binary tree traversals
9141#Parallel generation of permutations and combinations
9142#Assessment of approximate algorithms: the error measure's crucial role
9143#Partial correctness of exits from concurrent structures
9144#On systolic array methods for band matrix factorization
9145#Order h2 methods for a singular two-point boundary value problem
9146#On Chebyshev quadrature for a special class of weight functions
9147#Computation of simple characters of a Chevalley group
9148#Switching between modified Newton and 0%ix-point iteration for implicit ODE-solvers
9149#On polynomial approximation in the uniform norm by the discrete least squares method
9150#Generalized consistent orderings and the accelerated overrelaxation method
9151#Convex interval interpolation with cubic splines
9152#A note on an error estimate for least squares approximation
9153#An algorithm for a class of nonlinear fractional problems using ranking of the vertices
9154#A characterization of a class of polynomial splines by convolution
9155#Partition of a bipartite hamiltonian graph into two cycles
9156#Rooted planar maps are well labeled trees
9157#On score sets for tournaments
9158#A measure of thickness for families of sets
9159#On certain geometries of type Cn and F4
9160#Hamiltonian decompositions of complete regular s-partite graphs
9161#On the cycle space of graphs
9162#An application of valuation theory to two problems in discrete geometry
9163#Universal tilings and universal (0,1)-matrices
9164#A decomposition of complete bipartite graphs into edge-disjoint subgraphs with star components
9165#Graph coloring and monotone functions on posets
9166#A polynomial time heuristic for certain subgraph optimization problems with guaranteed worst case bound
9167#Digraphs without directed path of length two or three
9168#A bijective proof of Cassini's Fibonacci identity
9169#The retraining impasse: suppositions and implications
9170#Curricular implications of a "computer for every student
9171#The educational computing backlash: can the swing of the pendulum be halted?
9172#A scale for assessing student attitudes toward computers preliminary findings
9173#The effects of microcomputers on children's attention to reading
9174#Microcomputers and preschoolers: working together in a classroom setting
9175#Changes in teachers' concerns about educational computing
9176#Teachers' attitudes toward educational computing: instructional uses, misuses, and needed improvements
9177#The moon, computers, and water rats
9178#Close encounters with educational software
9179#Computers in gifted education: reflections and program implications
9180#Computers in kindergarten: requirements for an early childhood education software package
9181#Teaching computer ethics: why, what, who, when, and how
9182#An approach to interactive solution of multicriterial optimization problems with linquistic modeling of preferences.
9183#Providing reliable an efficient communication sessions with controlled breaking and reestablishment of connections by means of an intelligent terminal
9184#Decentralized routing algorithn for packet-switched networks
9185#Effect of buffer blocking on the operating characteristics of a data link
9186#Local-area network architecture for high-performance computer systems
9187#Collision-free star broadcast medium
9188#Concept of designing an integrated multifunctional network service
9189#Static and dynamic allocation of software components in automated systems
9190#Analysis of efficiency of program execution in computer systems with page memory
9191#Technique for interactive solution of a class of logical and combinatorial problms.
9192#MS: a register-transfer language oriented toward description of hardware implementations of protocols.
9193#Scheduling of computer operations with allowance for exchange time in microprocesor computer systems
9194#This paper presents a computational model for the analysis of word forms of a highly inflectional, agglutinative language. We call the model "associative" as it directly links phonemic stimulus with its morphemic interpretation(s) under the guidance of a coherence constraint. The model has been fully implemented for Finnish. We discuss separately the abstract model and various algorithms to implement the model. We also demonstrate the implementation. The best features of the method are its efficiency and its capability of supporting open lexicons.
9195#The goal of this work is the enrichment of human-machine interactions in a natural language environment. Because a speaker and listener cannot be assured to have the same beliefs, contexts, perceptions, backgrounds, or goals at each point in a conversation, difficulties and mistakes arise when a listener interprets a speaker's utterance. These mistakes can lead to various kinds of misunderstandings between speaker and listener, including reference failures or failure to understand the speaker's intention. We call these misunderstandings miscommunication. Such mistakes can slow, and possibly break down, communication. Our goal is to recognize and isolate such miscommunications and circumvent them. This paper highlights a particular class of miscommunication - reference problems - by describing a case study and techniques for avoiding failures of reference. We want to illustrate a framework less restrictive than earlier ones by allowing a speaker leeway in forming an utterance about a task and in determining the conversational vehicle to deliver it. The paper also promotes a new view for extensional reference.
9196#Within the last 15 years, a variety of unsolved problems of interest primarily to operations researchers, computer scientists, and mathematicians have been demonstrated to be equivalent in the sense that a solution to any of them would yield a solution to all of them. This class of problems, known as NP-complete, contains many long-standing problems of scheduling, routing, and resource allocation. This note contains a demonstration that a problem of interest to applied linguistics also belongs to this class - namely, the process of extracting a minimum set of semantic primitives from a monolingual dictionary is NP-complete, implying that the task is currently computationally insoluble.
9197#In this paper we explore a new theory of discourse structure that stresses the role of purpose and processing in discourse. In this theory, discourse structure is composed of three separate but interrelated components: the structure of the sequence of utterances (called the linguistic structure), a structure of purposes (called the intentional structure), and the state of focus of attention (called the attentional state). The linguistic structure consists of segments of the discourse into which the utterances naturally aggregate. The intentional structure captures the discourse-relevant purposes, expressed in each of the linguistic segments as well as relationships among them. The attentional state is an abstraction of the focus of attention of the participants as the discourse unfolds. The attentional state, being dynamic, records the objects, properties, and relations that are salient at each point of the discourse. The distinction among these components is essential to provide an adequate explanation of such discourse phenomena as cue phrases, referring expressions, and interruptions.The theory of attention, intention, and aggregation of utterances is illustrated in the paper with a number of example discourses. Various properties of discourse are described, and explanations for the behavior of cue phrases, referring expressions, and interruptions are explored.This theory provides a framework for describing the processing of utterances in a discourse. Discourse processing requires recognizing how the utterances of the discourse aggregate into segments, recognizing the intentions expressed in the discourse and the relationships among intentions, and tracking the discourse through the operation of the mechanisms associated with attentional state. This processing description specifies in these recognition tasks the role of information from the discourse and from the participants' knowledge of the domain.
9198#Selectional constraints specify, for a particular domain, the combinations of semantic classes acceptable in subject-verb-object relationships and other syntactic structures. These constraints are important in blocking incorrect analyses in natural language processing systems. However, these constraints are domain-specific and hence must be developed anew when a system is ported to a new domain. A discovery procedure for selectional constraints is therefore essential in enhancing the portability of such systems.This paper describes a semi-automated procedure for collecting the co-occurrence patterns from a sample of texts in a domain, and then using these patterns as the basis for selectional constraints in analyzing further texts. We discuss some of the difficulties in automating the collection process, and describe two experiments that measure the completeness of these patterns and their effectiveness compared with manually-prepared patterns. We then describe and evaluate a procedure for selectional constraint relaxation, intended to compensate for gaps in the set of patterns. Finally, we suggest how these procedures could be combined with a system that queries a domain expert, in order to produce a more efficient discovery procedure.
9199#Natural language interfaces to computers must deal with wide variation in real-world input. This paper proposes that, in order to handle real-world input robustly, a natural language interface should be constructed in accord with principles of integrated processing: processing syntax and semantics at the same time, processing syntax and semantics using the same mechanisms, and processing language and memory using the same mechanisms. This paper describes an experimental natural language interface constructed according to these principles which displays the desired robustness. The success of this interface suggests that future real-world interfaces could achieve robustness by performing integrated processing.
9200#In a human dialogue it is usually considered inappropriate if one conversant monopolizes the conversation. Similarly it can be inappropriate for a natural language database interface to respond with a lengthy list of data. A non-enumerative "summary" response is less verbose and often avoids misleading the user where an extensional response might.In this paper we investigate the problem of generating such discourse-oriented concise responses. We present details of the design and implementation of a system that produces summary responses to queries of a relational data base. The system employs a set of heuristics that work in conjunction with a knowledge base to discover underlying regularities that form the basis of summary responses. The system is largely domain-independent, and hence can be ported relatively easily from one data base to another. It can handle a wide variety of situations requiring a summary response and can be readily extended. It also has a number of shortcomings which are discussed thoroughly and which form the basis for a number of suggested research directions.
9201#Lexical ambiguity and especially part-of-speech ambiguity is the source of much non-determinism in parsing. As a result, the resolution of lexical ambiguity presents deterministic parsing with a major test. If deterministic parsing is to be viable, it must be shown that lexical ambiguity can be resolved easily deterministically. In this paper, it is shown that Marcus's "diagnostics" can be handled without any mechanisms beyond what is required to parse grammatical sentences and reject ungrammatical sentences. It is also shown that many other classes of ambiguity can be easily resolved as well.
9202#A method for error correction of ill-formed input is described that acquires dialogue patterns in typical usage and uses these patterns to predict new inputs. Error correction is done by strongly biasing parsing toward expected meanings unless clear evidence from the input shows the current sentence is not expected. A dialogue acquisition and tracking algorithm is presented along with a description of its implementation in a voice interactive system. A series of tests are described that show the power of the error correction methodology when stereotypic dialogue occurs.
9203#Is MT linguistics?
9204#Process Name resolution is an important problem in fault-tolerant CSP programs. This paper gives a solution to the naming problem of reconfigured CSP program. The solution is discussed in the context of super process scheme and is based on a proposed implementation of CSP language. The advantages of the solution are two-fold: first, it does not change the communication conventions of CSP; second, it does not impose any extra overhead on the underlying operating system.
9205#Microprogramming is a technique for implementing machine language instruction sets -- it is critical in today's computer architectures and operating systems. An emulator is a set of microprograms that implements the architecture of one machine on another; microprogramming is often used in emulation to make one computer system appear as if it were another. This paper presents the architecture for a microprogrammed computer system, the VSEM. The simulated virtual computer system, its monitor and a simulated concurrent PASCAL are discussed. The usefulness of the VSEM, its monitor and the concurrent PASCAL as vehicles for instruction in systems programming is addressed.
9206#An informal description is given of three fault-tolerant clock-synchronization algorithms. These algorithms work in the presence of arbitrary kinds of failure, including "two-faced" clocks. Two of the algorithms are derived from Byzantine Generals solutions.
9207#Partition failure causes a major problem for the availability of a distributed database system. No protocol can consistently terminate all parts of a distributed transaction under all possible partitions, since some sites executing subtransactions may not know that other sites have already committed (or aborted) and, therefore, must wait until the failure is repaired. Under a site optimal termination protocol, the expected number of waiting sites is minimized, hence it maximizes the "availability" of a database system in the presence of partition failures. We introduce a new class of partition failures. We introduce a new class of termination protocols, called size-based termination protocols, and identify site optimal termination protocols within this class.
9208#Virtual memory management (VMM) schemes have been in use for several years. All the text books on Operating Systems, including the widely used ones [1, 2], present the ideas involved in some detail. However, none of these provides details of a rather important aspect, namely, table fragmentation. In [1] there is a passing reference (p. 229) "... The waste of storage due to excessively large tables is called table fragmentation", and in [2] there is no mention of it at all.
9209#Most pessimistic mechanisms for implementing atomicity in distributed systems fall into three broad categories: two-phase locking schemes, timestamping schemes, and hybrid schemes employing both locking and timestamps. This paper proposes a new criterion for evaluating these mechanisms: the constraints they impose on the availability of replicated data.A replicated data item is a typed object that provides a set of operations to its clients. A quorum for an operation is any set of sites whose co-operation suffices to execute that operation, and a quorum assignment associates a set of quorums with each operation. Constraints on quorum assignment determine the range of availability properties realizable by a replication method.This paper compares the constraints on quorum assignment necessary to maximize concurrency under generalized locking, timestamping, and hybrid concurrency control mechanisms. This comparison shows that hybrid schemes impose weaker constraints on availability than timestamping schemes, and locking schemes impose constraints incomparable to those of the others. Because hybrid schemes permit more concurrency than locking schemes, these results suggest that hybrid schemes are preferable to the others for ensuring atomicity in highly available and highly concurrent distributed systems.This research was sponsored by the Defense Advanced Research Projects Agecy (DOD), ARPA Order No. 3597, monitored by the Air Force Avionics Laboratory Under Contract F33615-81-K-1539.The views and conclusions contained in this document are those of the authords and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the US Government.
9210#The performance of any computing system is seriously affected by the performance of the resident operating system. Distributed computing systems are no different. There have been many successful attempts at harnessing the full potential offered by distributed computing's inherent flexibility. However by far the majority of these implementations have been made on homogeneous configurations; the complexity implicit in connecting a number of heterogeneous sub-systems into a single, unified distributed computing system, has precluded their realisation. The system designer has to compare the many characteristics of a design before deciding upon the final solution. In doing so the designer needs a framework, or model, upon which he can assess alternative strategies. Most of the models to date have been based upon the layered approach which simplfies the software strucutre but it cannot reflect the control infrastructure which is necessary to effect such facilities as reconfigurability, resilience. etc.
9211#Directory services and name servers have been discussed and implemented for a number of distributed systems. Most have been tightly interwoven with the particular distributed systems of which they are a part: a few are more general in nature. In this paper we survey recent work in this area and discuss the advantages and disadvantages of a number of approaches. From this, we are able to extract some fundamental requirements of a naming system capable of handling a wide variety of object types in a heterogeneous environment. We outline how these requirements can be met in a universal directory service.
9212#In the very large multiprocessor systems and, on a grander scale, computer networks now emerging, processes are not tied to fixed processors but run on processors taken from a pool of processors. Processors are released when a process dies, migrates or when the process crashes. In distributed operating systems using the service concept, processes can be clients asking for a service, servers giving a service or both. Establishing communication between a process asking for a service and a process giving that service, without centralized control in a distributed environment with mobile processes, constitutes the problem of distributed match-making. Logically, such a match-making phase precedes routing in store-and-forward computer networks of this type. Algorithms for distributed match-making are developed and their complexity is investigated in terms of message passes and in terms of storage needed. The theoretical limitations of distributed match-making are established, and the techniques are applied to several network topologies.
9213#An expanded approach to objects
9214#In conventional operating systems, the concepts of files and processes are typically quite distinct, both in the job control language and at the internal "system call" interface. In this paper, the elimination of this dichotomy is explored, and a concept termed the "extrafile" is described which provides a single model for both processes and files (in their most common usage). The generalisation of extrafiles to include data abstraction facilities is discussed, and it is argued that an extrafile containing dependency prescriptions can provide a useful tool. An implementation of extrafiles in UNIX is described.
9215#We present a method to simplify the implementation of a kernel supporting a high level concurrent language on a bare multiprocessor system.User and system level languages (with as much common syntax as possible) are defined. The system language consists of those constructs which do not require concurrency support, plus other facilities which make it well suited to write the kernel supporting the user language. Such constructs must provide the equivalent of a supervisor call interface within a high level language.All machine dependencies for both the system and user languages have been encapsulated in the code generation phase of the compilation process. Our method reduces the retargeting problem of a kernel to the orientability problem of the code generator.Finally our experiences in using such methodology are discussed.
9216#This paper describes a replication algorithm for directory objects based upon Gifford's weighted voting for files. The algorithm associates a version number with each possible key on every replica and thereby resolves an ambiguity that arises when directory entries are not stored in every replica. The range of keys associated with a version number changes dynamically; but in all instances, a separate version number is associated with each entry stored on every replica. The algorithm exhibits favorable availability and concurrency properties. There is no performance penalty for associating a version number with every possible key except on Delete operations, and simulation results show this overhead is small.
9217#A new mechanism for constructing highly available distributed programs is described. It combines remote procedure call with replication of program modules for fault tolerance.The set of replicas of a module is called a troupe. In a program constructed from troupes, what appears to the programmer as a single inter-module procedure call results in a replicated procedure call. A distributed program constructed in this way will continue to function as long as at least one member of each troupe survives.The semantics of replicated procedure calls and troupes are defined and algorithms are presented that support these semantics.
9218#We propose efficient algorithms to maintain a replicated dictionary using a log in an unreliable network. A non-serializable approach is used to achieve high concurrency. The solutions are resilient to both node and communication failures. Optimizations are developed for networks which are not completely connected.
9219#DPUP is a library of utilities that support distributed concurrent computing on a local area network of computers. The library is built upon the interprocess communication facilities in Berkeley Unix 4.2bsd. Thus it will run on any network, connected by an Ethernet, where each computer runs a version of the Unix operating system that supports the Berkeley Unix interprocess communication facilities. DPUP supports two models of distributed concurrent computation, a master-slave model based upon stream sockets, and a broadcast model based upon datagram sockets. With each model, facilities for creating and terminating remote processes, establishing communications between them, and sending and receiving data between these processes are provided. This paper describes the facilities provided in DPUP and gives examples of their use.
9220#Mathematical switches have been used to choose the suitable numerical scheme automatically at every computing step while solving differential equation problems with a multischeme approach. The concept of using mathematical switches in a numerical computation with a multiprocessor computer is feasible. The use of the switches in a multischeme computation yields a more accurate solution than the use of only a single scheme. We examined the use of two mathematical switches, namely, the one of exact error and of truncation error. The numerical results from the use of the former switch confirmed our conjecture that a combined solution of several schemes is indeed more accurate than one of an individual scheme. However, a switch of exact error is not practical and the one of truncation error is not satisfactory. Hence, further study is needed to design more practical and more satisfactory mathematical switches, and to establish the practical value on their use.
9221#A topic that does not seem to have been considered is how to do function evaluations in parallel, that is, how to evaluate a mathematical function, eg. exp, for several different arguments simultaneously on a machine with parallel processors eg. ILLIAC IV: that machine had 64 processors, whose reaction to a (parallel) command from the master computer was either to execute or (on a condition) to decline to execute the instruction.
9222#Evolution and use of the VME subsystem bus—VSB
9223#Teaching computer-aided enginering on the BBC microcomputer
9224#Data acquisition and control system for laboratory experiments
9225#Pingpong playing robot controlled byu a microcomputer
9226#Assembler monitor package to teach assembly language
9227#Simulation experiences in the development of software for digital signal processors
9228#Speech recognition system using Walsh analysis and dynamic programming
9229#Crossassembler for the TM32010 digital sinal processor
9230#Software controller for an arithmetic processor
9231#Industrial computer networks and the role of MAP, Part 1
9232#Transparent interfacing of speech recognizers to microcomputers
9233#Handprinted text reader that learns by experience
9234#New design for an 82720 based colour graphics generator
9235#Development equipment with switched memory decoding
9236#MIS manager's handbook: innovative strategies for successful management
9237#Designing portable computerized instruments
9238#Computer integrated manufacturing handbook
9239#Linear and interface circuits applications
9240#Data networks
9241#Concurrency control and recovery in database systems
9242#Covering a square by small perimeter rectangles
9243#Two poset polytopes
9244#Voronoi diagrams and arrangements
9245#Can you cover your shadows?
9246#On the union of Jordan regions and collision-free translational motion amidst polygonal obstacles
9247#Covering the plane with convex polygons
9248#Halfspace range search: an algorithmic application of k-sets
9249#More on k-sets of finite sets in the plane
9250#Given the devastating consequences of nuclear war, it is appropriate to look at current and planned uses of computers in nuclear weapons command and control systems, and to examine whether these systems can fulfill their intended roles.
9251#The ACM SIGOPS Workshop on Accommodating Heterogeneity was conducted in December 1985 in Eastbound, Wash., as a forum for an international group of fifty researchers to discuss the technical issues surrounding heterogeneous computing environments.
9252#A comparison of Cobol performance on the PC AT Enhanced versus an IBM 370 mainframe suggests that high-quality PC compiler implementations—combined with the new language features of the Cobol 85 Standard—are improving the PC environment for Cobol to the point where serious applications can now be developed and debugged on the PC, either to be run on the PC itself, or for eventual uploading to a mainframe.
9253#An iterative thinning algorithm reduces a two-dimensional pattern of strokes to its skeleton by removing layers of edge elements until each stroke has unit thickness. A parallel solution requires the independent calculation of new values for each iteration, using a window of nearest neighbors for each element. The traditional need for at least two subiterations can be avoided by modifying the window to permit the availability of intermediate calculations. Timings on an ICL DAP (an array processor) indicate an improvement of over 40 percent. Additional refinements are suggested to reduce noise in the final skeleton.
9254#Four methods to solve the all pairs examination problem are presented. The first two methods are based on the fold-over scheme. The remaining two methods are adopted from some parallel sorting algorithms. All of these approaches can be implemented on a linear systolic array.
9255#On the expressive power of data dependencies
9256#A regularity test for dual bordered OS systems
9257#A workload model representative of static and dynamic characteristics
9258#Constructing maximal slicings from geometry
9259#Graph theoretic closure properties of the family of boundary NLC graph languages
9260#NP-hard problems in hierarchical-tree clustering
9261#The complexity of combinatorial problems with succinct input representation
9262#Expanding the Forth dictionary beyond the 64K limit by using `Bodiless' code
9263#Improving the understandability of Forth code
9264#A window system
9265#An alternate Forth dictionary structure
9266#Conversion of a token threaded language to an addressed threaded language
9267#A direct threaded code TTL control unit
9268#A Forth-based object file format and relocating loader used to bootstrap portable standard LISP
9269#Tadeusz Kotarbinski and his general methodology: Lecture in honor of the 100th anniversary of the founding father of praxiology
9270#Demon-Based associative memories
9271#Chunking mechanism for a knowledge representation system
9272#Applications of GSLT (General system logical theory) to control in transformation systems
9273#Net-Management-problem determination and an approach to its solution
9274#Development of integrated office communication systems-methods and formable parameters
9275#Expert system based configuration of VSAM files
9276#The Karmarkar algorithm-idea,realisation,example,and numerical experience
9277#Generalized Levi conditions for weakly hyperbolic equations-An attempt to treat the degeneracy with respect to the space variables-
9278#Non-hypoellipticity for degenerate elliptic operators
9279#Stationary Fourier hyperprocesses
9280#On the spaces of self homotopy equivalences for fibre spaces II
9281#Jensen measures and maximal functions of uniform algebras
9282#On the stable homotopy of the real projective space of even low dimension
9283#0-1 laws of a probability measure on a locally convex space
9284#A dichotomy for derivations on On
9285#Reflection positivity for the complementary series of SL(S:2n,C)
9286#Forgetful homomorphisms in equivariant k-theory
9287#The completion of the maximal Op*-algebra on a Frechet domain
9288#Status and prospects of computerized information retrieval in China
9289#Networking in the field of vocational training information systems
9290#Assessing the impacts of new technology on library employees
9291#Third international conference on Geoscience Information-Report
9292#Open systems interconnection and the National Library of Australia: a personal view
9293#Open systems Interconnection and the National Library of Australia: the official view
9294#ISO/OSI Networking in the library environment
9295#Speech technology and its applications
9296#Electronic mail and Unix
9297#Review of electronic mail systems
9298#Electronic mail at British Gas
9299#Uses and limitations of APL
9300#Application of a fourth-generation environment
9301#Decision support on mainframes
9302#Market overview in desktop publishing
9303#Leasing contracts
9304#Buying and selling hardware
9305#Migrating to System/38
9306#Compact disc technology
9307#Getting the right response
9308#Job accounting
9309#Software reengineering
9310#Logic programming in system development
9311#Relational databases-benefits and drawbacks
9312#Operation systems review
9313#Computers for sales staff
9314#Commercial expert systems
9315#Expert systems go to work
9316#Railway route planning in Australia
9317#Expert systems using shells
9318#Patterned systems design
9319#Implementing FMS
9320#MAP and CIM
9321#Pressure-sensitive pads in data collection
9322#Applying a decision support system
9323#A software service
9324#Classic tools of systems analysis-why they have failed
9325#User agent for the Unix mail system
9326#Standards for programming practices
9327#Parallel processing
9328#Computers in clinical medicine
9329#Applying an EDP methodology to the California state lottery
9330#Unix in the IBM world
9331#How to succeed with ADA
9332#Automated tools for the analyst
9333#Artificial intelligence in the man/machine interface
9334#Succeeding in the IBM-compatible market
9335#Machine assisted translation with a human face
9336#Uniforms: an automatic forms facility
9337#Setting up an online database
9338#Security in local area networking
9339#Telecommunications: How to fix line glitches
9340#Telecommunications: The compuserve B protocol
9341#Modula-2: 68000 Cross assembler listings
9342#Sort-A general-purpose sorting program
9343#Structured programming: Overloading procedures, exporting opaque types, data hiding
9344#A variable metric minimizer
9345#Concurrency and Turbo Pascal
9346#The problems of parallelism
9347#Speeding MS DOS execution
9348#Automatic porting between Pascal dialects
9349#COM: An 8080 simulator for the MC6800
9350#The last of the shell support routines
9351#AI:BRIE -The Boca Raton inference engine
9352#AI: A cellular automation in expert-2
9353#AI: Modeling a system in prolog
9354#MODULA-2: A 68000 Cross assembler-part 1
9355#The great CRC mystery
9356#Fast integer powers for Pascal
9357#Learning Ada on a Micro
9358#The DOD Ada software repository
9359#Data abstraction with Modula-2
9360#C CHEST: A new shell for MS DOS
9361#16-BIT TOOLBOX: Recommended software
9362#A VLSI fast solver for tridiagonal linear systems
9363#A noncommutative algorithm for multiplying 5x5 matrices using 102 multiplications
9364#A note on anomalies in parallel branch-and-bound algorithms with one-to-one bounding functions
9365#Efficient selection on a binary tree
9366#Approximating functions by their Poisson transform
9367#Total domination in interval graphs
9368#On an asymptotic analysis of a tree-type algorithm for broadcast communications
9369#On the intersection of the class of linear context-free languages and the class of single-reset languages
9370#Semantics of a declarative language
9371#Some characterizations of finitely specifiable implicational dependency families
9372#Absence of individual starvation using weak semaphores
9373#A parallel O(log n) algorithm for the drawing of algebraic curves in an n x n square
9374#A note on the complete problems for complexity classes
9375#An alternative implementation of communication primitives
9376#Merging by the parallel jump searching algorithm
9377#The value of an array facility in Prolog
9378#Denotational semantics of communicating sequential programs
9379#A note on implementing Prolog in Lisp
9380#An in situ distributive sort
9381#A note on pure grammars
9382#Identification of one-and two-format steady-state vowels: a model and experiments
9383#Effects of syllable and word structure on segmental durations in spoken Italian
9384#A comparative study of the steady-state zones of German phones using centroids in the LPC parameter space
9385#Coarticulation strategies: preliminary implications of a detailed analysis of lower lip protrusion movements
9386#Neuromuscular specialization of the mandibular motor system: speech versus non-speech movements
9387#Coarticulation and motor encoding of labiality and nasality in CVCVCV nonsense words
9388#Laws for lips
9389#X-ray microbeam method for measurement of articulatory dynamics-techniques and results
9390#Influence of palate shape on lingual articulation
9391#Estimating articulatory motion from speech wave
9392#An acoustic of pathological voice and its application to the evaluation of laryngeal pathology
9393#Research on individuality features in speech waves and automatic speaker recognition techniques
9394#Speech analysis and synthesis methods developed at ECL in NTT-From LPC to LSP-
9395#Composite phoneme units for the speech synthesis of Japanese
9396#Vowel normalization by frequency warped spectral matching
9397#Recognition of phonemes using time-spectrum pattern
9398#Advances computer system applications in education: Emerging advacnes in hardware and software
9399#The next generation of AI-based teaching systems
9400#Advancing cognitive science through development of advanced instructional systems
9401#The power and the peril of the particular: Thoughts on a role for microcomputers in science and mathematics education
9402#Four generations of computerized test administration
9403#Critical research issues in the implementation of the next generation of educational technology
9404#Library Quarterly
9405#Collection overlap in the LCS network in Illinois
9406#Local area networks (Lan) in the special library. Part I-A Planning model
9407#Local area networks (Lan) in the special library. Part II-Implementation
9408#Dialoglink: A review of dialog's search assistance software
9409#Eliminating fees for online search services in a university library
9410#First look-Infomaster: A powerful information retrieval service for business
9411#Digital audio disc corporation. An interview with executives of a new Sony subsidiary-A manufacturer of CDROM
9412#Compact Disclosure: Realizing CDROM'S potential
9413#The use of keyboard Macros in online searching
9414#Cost effective computer-assisted legal research, or when two are better than one
9415#Maximizing the power of an electronic spreadsheet
9416#The inverted file-The laserdisk enviornment: The medium,issues,products and potential
9417#The dollar $ign-Searching for management and/or business information-removing the blinders
9418#Document delivery-Specifications and standards information for technical specialists
9419#A new two-sided cumulative sum quality control scheme
9420#Smoothing with split linear fits
9421#Generalized simulated annealing for function optimization
9422#Some new estimation methods for weighted regression where there are possible outliers
9423#Assessing influence in multiple linear regression with incomplete data
9424#Confidence bands for polynomial regression with fixed intercepts
9425#One-sided simultaneous lower prediction intervals for/future samples from a normal distribution
9426#Statistical inference for Pr(Y
9427#Data-dependent spectral windows: Generalizing the classical framework to include maximum entropy estimates
9428#A note on the use of prior interval information in constructing interval estimates for a gamma mean
9429#The geometry of constrained mixture experiments
9430#Jackknife-based estimators and confidence regions in nonlinear regression
9431#How much does stein estimation help in multiple linear regression?
9432#Generalized Burr-Pareto-Logistic distributions with applications to a uranium exploration data set
9433#Applying R2-Type measures to ordered categorical data
9434#The binomial failure rate common cause model
9435#Design considerations for calibration
9436#An exact test for comparing location parameters of K exponential distributions with unequal scales based on type II censored data
9437#An exact distribution-free analysis for accelerated life testing at several levels of a single stress
9438#A vestibulo-ocular reflex with no head movement
9439#A neural network model for selective attention in visual pattern recognition
9440#Representation of time-dependent correlation and recurrence time functions. A new method to analyse non-stationary point processes
9441#The depressor trochanteris motorneurones and their role in the coxo-trochanteral feedback loop in the stick insect carausius morosus
9442#Properties of the feedback system controlling the coxa-trochanter joint in the stick insect carausius morosus
9443#A model of the smooth pursuit eye movement system
9444#What kind of movement detector is triggering the landing response of the housfly?
9445#Local and global stability for population models
9446#Line source models for active fibers
9447#Mechanisms and asymmetries in visual perception of simultaneity and temporal or der
9448#The dynamic effects of inputs to spinal motorneurones of different type upon the outputs of &ggr;-Motorneurones mediated via recurrent inhibition
9449#A model of eye tracking of periodic square wave target motion
9450#A computational model of the error detector of human visual accommodation
9451#The minimization of muscular energy expenditure during inspiration in linear models of the respiratory system
9452#Linear behaviour in the aperture pupil of single photoreceptors: Consequences related to the degree of inhomogeneity
9453#Influence of the muscle fibre end geometry on the extracellular potentials
9454#System analysis of the goldfish olfactory bulb: Spatio-temporal transfer properties of the Mitrial cell granule cell complex
9455#Control mechanisms of a neural network
9456#A neural cocktail-party processor
9457#A stochastic after hyperpolarization model of repetitive activity in vestibular afferents
9458#Long term memory storage capacity of multiconnected neural networks
9459#On the definition of central pattern generator and its sensory control
9460#Plotting curves and data with microcomputers
9461#Pipeline processing with Modula-2
9462#Task minimization in a parallel graph search algorithm
9463#Graphical display of orbits of Halley's Comet and planets in UCSD Pascal
9464#Message-based synchronization in Modula
9465#Interfacing assembly language to Modula-2-A case study: Creating rapid screen displays for PC's
9466#Implementation and analysis of random variate generators in Ada
9467#Graphbug - a microprocessor software debugging tool
9468#Exception handling in the 68000, part 1
9469#Transputer communication link
9470#Microcomputer for the dynamics laboratory
9471#Flexible interface based on the peripheral interface structure
9472#Design for testability and built-in self-test for VLSI circuits
9473#Minimal M68000 system controllers for fast-acting multi-input multi-output processes
9474#Message-passing primitives for multimicroprocessor systems
9475#Simple IC tester using a database technique
9476#Logical operations on flag bits X5 and CY, definition of D3 and an undocumented feature of instruction DADrp in 8085
9477#The physics of driving backplane buses
9478#Futurebus—the independent standard for 32-bit systems
9479#Using futurebus in a fifth-generation computer
9480#Introduction to the fastbus
9481#Building up a system architecture using VMEbus
9482#Multibus II message passing
9483#Objective comparison of 32-bit buses
9484#Experiences in designing the M3 backplane bus standard
9485#Design and evaluation of a dual-microcomputer shared memory system with a shared I/O bus
9486#Realtime implementation of the viterbi decoding algorithm on a high-performance microprocessor
9487#Emerging local area network technologies
9488#Microprocessor-based delay generators
9489#32008-based single-board microcomputer
9490#Example of the use of the BBC microcomputer for data collection
9491#Proceedings of the ACM SIGART international symposium on Methodologies for intelligent systems
9492#The most important development in expert systems is the introduction and proliferation of frameworks, or shells, that allow rapid prototyping, easy expansion, and continued maintenance. Several shells are now in commercial use and have been used to build expert systems of recognized value. The state of the art and several new lines of development will be discussed. Some of the developments involve fundamental research in AI on knowledge representation and inference; others involve making the shell environments themselves more intelligent.
9493#Generic tasks in knowledge-based reasoning: a level of abstraction that supports knowledge acquisition, system design and explanation
9494#The use of the language discussed here, is to customize an expert-system (ES) construction tool, RAFFAELLO, in the application. We are concerned, here, with a version, being an ES itself, of the frame-definition and navigation component of RAFFAELLO. Allowed frame-topology may be deep, i. e. with an unbound depth of the tree. Frame schemata of the application ES are described by means of a production system (PS), “CuProS”, with particular conventions for conveying particular features: e. g. slotless repeatable subframes, or local CuProS'es in instance's subtrees, n-to-n relation insertion, retrieval - key local definition, ancestry-driven disambiguation of polysemic slots, etc. Examples are drawn from the application to ONOMATURGE, an ES for word-formation.
9495#This paper describes a method for performing knowledge base (re)organization in expert systems oriented to classification, interpretation and diagnosis problems. The methodology can be applied either to the input descriptions of a set of samples, giving thus a preliminary characterization of groups of samples, or to a set of intermediate level descriptions, supplied by a human expert or previously automatically learned. An example of application is also given.
9496#This paper reports on work being conducted for NASA to develop a simulation expert system called NESS that can assist the user to run digital simulations of dynamic systems and interpret the output data to determine system characteristics. The paper describes our design principle, system architecture and knowledge base. Finally, in order to demonstrate NESS' simulation and analysis capabilities, a session log involving a printwheel position controller is shown.
9497#This work is concerned with the initial design of an expert system for increasing utilization of evaluations in the social sciences. It is an empiric fact that evaluation findings in the social science have a very low and unpredictable utilization. An expert System for Utilization of Research (SUR) may serve both as a research tool (expert systems research and utilization research) and later as an aid to evaluators in the field. The system will be used to collect and store existing utilization research expertise, sort it and detect contradictions. A dynamic model of interaction of an evaluator and an organization will be developed, and the system will be used to simulate interactions and devise strategies and responses applicable to different scenarios. The system may also be used by the applied evaluator as a sophisticated tool for presentation of recommendations, and as a supportive guide for conducting good evaluations.
9498#Traditionally, scheduling problems have been viewed as static in nature (i.e., a schedule is developed for a particular planning horizon and adhered to) and were cast as having one or more clearly defined objectives (e.g., minimize overall completion time, maximize resource utilization, etc.). These problems were most commonly solved via application of optimal seeking algorithms, heuristics or simulation analysis [1] [5] [9] [10] [17]. The payload scheduling problem is representative of a class of scheduling problems which are highly dynamic in nature. That is, the various parameters can change at any time, and the objectives themselves may change also. The nature of this class of problems is such that they can be most effectively solved by knowledge based expert systems [2] [3] [8] [13] [19] [20].
9499#Supervising student teams who worked with expert practitioners to build prototype expert systems has yielded insights into the frustrations and rewards of the early stages of knowledge engineering. This paper presents these insights to the expert systems community, particularly those beginning their first project or entering a wholly new application area. We focus on example based rule induction shells without imprecision. While such tools are generally too limited for implementing a finished, deliverable expert system, they are useful for “breaking the ice” with a quick, inexpensive demonstration system while acquiring the vital first elements of the eventual expert knowledge base.
9500#The work described here addresses two problems: information overload of database users, and knowledge acquisition for use in Al systems. We have implemented programs that use artificial intelligence techniques to prepare high-level, intelligent summaries of databases, and that use empirical databases in turn, in combination with statistical and Al methods, to generate new domain knowledge base. Both programs are examples of the aquisition of knowledge from data: the Summarization Module fuses large amounts of data succinctly, the Discovery Module extracts new knowledge present implicitly in data. We describe the implementation of our programs and outline planned extensions which combine both approaches. This work is distinguished from current knowledge engineering approaches in that we prime the system with expert knowledge, and then use factual data to learn more about the domain.
9501#We describe a decidable algorithm to answer queries in circumscriptive theories, that allows the use of variable predicates. This significantly extends the results obtained in our earlier paper [P], where a similar algorithm was constructed for circumscriptive theories without variable predicates.Since prioritized circumscription is equivalent to a conjunction of parallel circumscriptions with variables, the algorithm can be used to answer queries in theories circumscribed by prioritized circumscription. The Closed-World Assumption (CWA) and its generalization, the Extended Closed-World Assumption (ECWA), can be considered as a special form of circumscription. Consequently, our method also applies to answering queries in theories using the Closed-World Assumption or its generalizations.For the sake of clarity, we restrict our attention to theories consisting of ground clauses. Our algorithm, however, has a natural extension to theories consisting of arbitrary clauses.
9502#The construction of data bases containing information concerning scientific libraries requires cooperation between experts of different scientific domains. These experts are the source of knowledge that help the librarian in the process of characterizing the documents by means of relevant features, relating them using a thesaurus and generating useful and informative classifications of the documents to facilitate its retrieval. In this work, we describe an implementation based on a knowledge acquisition process that uses a knowledge engineering methodology: Our system helps the expert in a domain, to elicitate the concepts that he uses and to characterize the documents of the domain. The system also helps the librarian in the design of the thesaurus and the classifications.
9503#This paper presents an approach to extending the relational system RTMS into one supporting a frame-based knowledge-representation system. A deductive front-end is used for extraction of implicit information from the explicit data stored in RTMS. The proposed extensions to the relational model include the relationships of aggregation and generalization, set-valued attributes, and virtual relations defined using axioms. We will present a query language that takes advantage of these extensions. A user can make a query against virtual relations as well as base relations. The queries can consist of new constructs introduced by the semantic front-end. The system is implemented on TI's Explorer Lisp Machine.
9504#A knowledge-based system approach is applied to the design of a document retrieval system for online retrieval of bibliographic material. The main components of the system are a language interface that understands user queries in pseudo natural language (i.e. queries that are restricted to subject domain concepts), a retrieval component that combines the expertise of subject-domain and retrieval experts, a help system that aids users in formulating and reformulating queries, and a user model builder that infers specific user characteristics. A comprehensive mathematical model based on fuzzy sets and fuzzy relations has been defined for the thesaurus and the retrieval mechanism and a prototypical system has been implemented in a modular fashion to test system response to changes in model parameters.
9505#Development of an information retrieval system that can be personalized to each user requires maintaining and continually updating an interest profile for each individual user. Since people tend to be poor at self-description, it is suggested that profile development and maintenance is an area in which machine learning and knowledge based techniques can be profitably employed. This paper presents a model for such an application of AI techniques.
9506#This paper outlines a procedure for performing induction under uncertainty. This procedure uses a probabilitic representation and uses Bayes' theorem to decide between alternative hypotheses (theories). This procedure is illustrated by a robot with no prior world experience performing induction on data it has gathered about the world. The particular inductive problem is the formation class descriptions both for the tutored and untutored cases. The resulting class definitions are inherenty probabilistic and so do not have any sharply defined membership criterion. This robot example raises some fundamental problems about induction—particularly it is shown that inductively formed theories are not the best way of making predictions. Another difficulty is the need to provide prior probabilities for the set of possible theories. The main criterion for such priors is a proagmatic one aimed at keeping the theory structure as simple as possible, while still reflecting any structure discovered in the data.
9507#The concept of a generalized assignment statement provides a basis for a unified approach to knowledge representation and inference. The basic idea underlying this approach is that a proposition, p, in a natural language may be viewed as an elastic constraint on a variable, X. More specifically, the meaning of p may be represented as p → X isr C in which → should be read as “translates into” and the right-hand member is a representation of the meaning of p in the form of a generalized assignment statement. In this statement, X plays the role of a constrained variable; C is the constraint on X; and r in the copula isr is a variable whose values define the role of C in relation to X. The prinipal values of r are d, standing for disjunctive; c, standing for conjunctive; p, standing for probabilistic; g, standing for granular; and h, standing for hybrid. Since in most cases the value of r is d, it is convenient to abbreviate isd to is. With this understanding, X is C should be interpreted as X isd C. In general, X, C, and r are implicit rather than explicit in p. Viewed in this perspective, the problem of meaning representation is that of explicitating X, C and r, given p. In general, X and C are defined procedurally. Thus the principal steps in representing the meaning of p are: (1) construction of an explanatory database, ED; (2) construction of a procedure which acts on ED and yields X; and construction of a procedure which acts on ED and yields C.If p1, …, pu are propositions in a knowledge-base, inference from p1, …, pu starts with representing the meaning of each p1 in the form of a generalized assignment statement, Xi isri Ci, i = 1, … n. Then the constraints are combined through the application of a collection of rules of inference, resulting in a computed constraint, C, on a specified variable Y as a function of the Ci. In general, the determination of C requires the solution of a non-linear program.Although the approach to knowledge representation and inference based on the concept of a generalized assignment statement does not follow the traditional lines, it is in fact quite natural and easy to understand. Several illustrative examples show how a proposition can be expressed as a generalized assignment statement, and how an answer to a question may be obtained through the solution of a nonlinear program. A particularly important application of the concept of a generalized assignment statement relates to the representation and inference from commonsense knowledge. More specifically, a distinguishing characteristic of commonsense knowledge is that the facts and rules which comprise such knowledges, e.g., birds can fly and tomatoes are red when they are ripe, are, for the most part, preponderantly rather than universally true. For this reason, the concepts of typicality, normality, and default play an essential role in most of the existing approaches to commonsense reasoning and knowledge representation.In an alternative approach based on the concept of a generalized assignment statement, a comparable role is played by the concept of usuality. As its name suggests, the concept of usuality relates to what is usual or, more precisely, to events of high probability. A basic concept which derives from usuality is that of a usual value of a variable. Thus, in the proposition a cup of coffee usually costs about fifty cents, about fifty cents is a usual value of the variable Cost (Cup Coffee)). In general, a usual value is imprecise and non-unique.Viewed in the perspective of usuality, commonsense knowledge may be regarded as a collection of usuality-qualified generalized assignment statements of the form usually (X is F) and usually (X is F if Y is R), in which F is a usual value of the variable X, R is a constraint on the conditioning variable Y, and usually is a fuzzy quantifier which is representable as a fuzzy proportion in the inverval [0,1]. Based on this view of commonsense knowledge, various inference rules for reasoning with usuality-qualified facts and rules are developed. In particular, it is shown that from usually (X is A) and usually (X is B), it follows that (2usually-1) (X is A ∩ B), where A ∩ B is the conjunction of A and B, and (2usually-1) is a fuzzy number which is less specific that usually. Rules of this type are of direct relevance to property inheritance in the presence of exceptions, to the combination of uncertain evidence in expert systems and, more generally, to inference under uncertainty.
9508#The role of inferencing with uncertainty is becoming more important in rule-based expert systems (ES), since knowledge given by a human expert is often uncertain or imprecise. We have succeeded in designing a VLSI chip which can perform an entire inference process based on fuzzy logic. The design of the VLSI fuzzy inference engine emphasizes simplicity, extensibility, and efficiency (operational speed and layout area). It is fabricated in 2.5 &mgr;m CMOS technology. The inference engine consists of three major components; a rule set memory, an inference processor, and a controller. In this implementation, a rule set memory is realized by a read only memory (ROM). The controller consists of two counters. In the inference processor, one data path is laid out for each rule. The number of the inference rule can be increased adding more data paths to the inference processor. All rules are executed in parallel, but each rule is processed serially. The logical structure of fuzzy inference proposed in the current paper maps nicely onto the VLSI structure.A two-phase nonoverlapping clocking scheme is used. Timing tests indicate that the inference engine can operate at approximately 20.8 MHz. This translates to an execution speed of approximately 80,000 Fuzzy Logical Inferences Per Second (FLIPS), and indicates that the inference engine is suitable for a demanding real-time application. The potential applications include decision-making in the area of command and control for intelligent robot systems, process control, missile and aircraft guidance, and other high performance machines.
9509#Because of the impact that the choice of an expert system framework has on the success of expert system projects, it is important for anyone evaluating expert systems and expert system tools, whether casually or critically, to consider a variety of issues. As background, this paper provides a general description of the expert systems paradigm, and detailed descriptions of two expert system frameworks for reasoning under uncertainty. Although both of the expert systems described have roots in the Bayesian theory, their differences are significant enough to fuel a discussion of the most significant issues in evaluating the applicability of particular expert system frameworks. We cover knowledge representation and knowledge structures, the initial phases of knowledge engineering, tuning and validating the knowledge base, as well as utilization of the finished expert system.
9510#Emitter and system hierarchies are represented by inference nets and propositional relationships. Emitters are the primitive objects of the domain and systems consist of relationships among emitters. Evidence gathered concerning the identification of emitters must be used to classify both emitters and systems. Evidential reasoning and inference nets are used to to combine information at each level. Methods of direct and indirect transfer of evidence between levels are presented.
9511#In estimating minimax values, an important topic in the study of heuristic game tree searches, a pathological phenomenon sometimes results when the conventional minimax procedure is used as a back-up process. In this paper exact methods are derived for two different games, one using product-propagation rules as a back-up process and another not using any back-up process. The method of estimating minimax values in a heuristic game tree search should depend on both the static evaluation function and the structure of the game tree; it can be very different for different games.
9512#We are here concerned with the problem of forming multiple criteria decision functions when the aggregation process is controlled by a linguistic quantifier.
9513#In various considerations of computer science (for instance in image processing and databases) one faces the following situation: Given a set (of points or of documents) one considers a descending sequence of equivalence relations (“approximation spaces of order &Xgr;”). These equivalence relations determine a sequence of closure operations Cli. Given a set X, the approximation sequence of X is simply Cli(X)i&xgr;. We characterize here those sets X which satisfy the condition: X = ∩{Cli(X): i&Xgr;}.
9514#Most artificial intelligence applications require reasoning with uncertainty and incompleteness. Such information is not captured in terms of simple true and false values nor in terms of probabilistic estimates when relevant statistical data are lacking. In this paper, we extend Nilsson's probabilistic logic, a semantic generalization of logic, in which the truth value of a sentence is a probability value between Ø and 1 to evidential logic in the framework of Dempster-Shafer theory.
9515#The study of independence (dependence) between the condition and decision attributes is an important issue in decision theory. Most important applications in artificial intelligence are non-deterministic. It is shown that algebraic dependence is not adequate in these situations, and probabilistic independence provides a correct measure of information uncertainty for expert system design.
9516#Logic can be defined as the formal study of reasoning; if we replace “formal” by “mechanical” we can place almost the entire set of methodologies used in the field of automated theorem proving (ATP) within the scope of logic. Because of the goals of ATP, if not always the methodologies, ATP has been considered to be within the domain of AI. We explore the methodologies of ATP, including the logics that underlie the theorem provers, and discuss some of the mechanisms that utilize these logics. These include term rewriting systems, mathematical induction, inductionless induction and even mixed integer programming. The ATP field, via resolution, has even provided the foundation for an exciting AI and database programming language, PROLOG. We conclude with a new method for extending the PROLOG system to work with non-Horn clause sets within a positive logic format, particularly simple for “slightly non-Horn” clause sets.
9517#We present some extensions to Scheme which increase its expressiveness within a purely declarative framework. We give constructs for sets and universal and existential quantifiers, allowing backtracking to be expressed easily. These constructs combine the expressiveness of set notation with the efficiency of lists, and have a simple semantics that is based on lists. We also give a nonstandard definition of fixpoints and a notation for it. These extensions, together with a convenient form of memo function, have been implemented as reasonably efficient macros in Scheme. The dramatic increase in conciseness of programs is illustrated by examples. These features bring us closer to executable specifications of programs and are therefore relevant for automatic program generation. We discuss extensions to Prolog-style languages that might enable them to approximate the same expressive power.
9518#A fixpoint semantics is given for logic programming using domain theory, with undefined as one truth value, allowing negation, and arbitrary data structures. This generalizes the conventional semantics, and agrees with it on 'successes' for Horn clause programs. Consequences of requiring the data structure to be a compact topological space and the given relations to be continuous are investigated, extending results in the last chapter of Lloyd's book.
9519#The purpose of this paper is to investigate the relationship between two approaches to the formalization of non-monotonic reasoning - J. McCarthy's approach based on the notion of Circumscription [Mc] and the Autoepistemic Logic approach of R. Moore [Mr]. Since these two approaches differ considerably in scope, we will limit our attention to the situation where some common ground can be found. Namely, we consider only the propositional case of parallel circumpsription, when all predicates of a formula T are circumscribed simultaneously.
9520#We have suggested that a new kind of logical study that focuses on individual deductive steps is appropriate to agents that must do commonsense reasoning. In order to adequately study such reasoners, a formal description of such “steps” is necessary. Here we carry further this program for the propositional case. In particular we give a result on completeness for reasoning about agents.
9521#A resolution proof or a derivation of the empty clause from a set of clauses S = {C1, C2, …, Ck} is called a tree resolution if no clause Ci is used in more than one resolvent. We show that an unsatisfiable set of clauses S has a tree resolution proof if and only if there is a general semantic tree for S in which no clause appears in more than one terminal node. As an important application of this result, we derive a simple algorithm for obtaining a tree resolution proof, if one exists. The tree resolution proofs are important because they allow us to obtain the shortest “explanation”.
9522#We present a definition of property inheritance with exceptions in terms of a formal model of default reasoning called nonconclusive reasoning. Our model resolves both types of ambiguity encountered in inheritance with exceptions and avoids the need for explicit exceptions without resorting to extralogical mechanisms to derive them.
9523#Analogical reasoning is a significant cognitive process that has heretofore not been modelled by artificial intelligence researchers in a computationally tractable manner. Recently, several new approaches have shown significant promise using analogical processes for problem solving and learning. Among the first and most comprehensive, the ARIES project demonstrated that analogical problem solving is a computationally tractable means of exploiting past experience to solve new problems of increasing complexity. Two methods were developed: transformational analogy, with solutions to related problems are incremently transformed into the solution of a new problem, and derivational analogy with the problem solving strategies, rather than the resultant solutions, are transferred across like problems.However, many interesting questions remain unanswered, including: How closely related should problems be prior to analogical transfer? How does one measure similarity? What is the relation of analogical transfer to human problem solving capabilities? What roles does analogy play in learning? Should analogical reasoning be part of a decision analysis engine to bring past experience to bear in evaluating likely consequences of candidate decisions? Should analogical reasoning be considered an integral aspect of any unified problem solving architecture striving to model human cognition? After a glimpse into the basic ARIES model, partial answers to these questions are discussed based on recent advances. Some of these new directions are rooted in concrete computational and psychological results; others are of a more speculative nature.
9524#Machine learning, a field concerned with developing computational theories of learning and constructing learning machines, is now one of the most active research areas in artificial intelligence. An inference-based theory of learning will be presented that unifies basic learning strategies. Special attention will be given to comparing and unifying inductive learning and deductive learning strategies.Inductive learning strategies include empirical techniques for learning from examples and learning from observation and discovery. Deductive learning techniques include analytic learning on the basis of the explanation of a given fact using prior domain knowledge. We will show that the “similarity-based learning” (a form of inductive learning) and the “explanation-based learning” (a form of deductive learning) are two extremes in the spectrum of techniques representing different relative role of the learner's prior knowledge and the information supplied to the learner. We will also show how inductive and deductive learning can be integrated within one theoretical framework. Some experimental results will be used to illustrate presented ideas.
9525#In a classic learning experiment, a higher vertebrate is presented with two levers. To start, a reward is given if the left lever is pushed, no reward is given if the right lever is pushed. After a certain period of time, T, the meaning of the two levers is interchanged. Now a reward is given if the right lever is pushed and no reward is given if the left lever is pushed. This happens for the same period of time T. Once again there is an interchange in the meaning of the two levers for the period of time T. This alternation is repeated a number of times.Higher vertebrates exhibit learning in this situation. With each repeated period of time T, they gradually adapt their response to the correct lever. In other words, at first they are slow to change from one lever to another, but they gradually learn that the reward at each lever is being changed with period T.The above experiment strongly suggests that memory retention is being adjusted to the length of time that a reward is given at each lever. While it is difficult to determine the exact mechanism by which this is done, there is an easy feedback control system which models this behavior. This is shown below.In the system of Figure 1, if the error signal is too large, say exceeds a specified critical error, there is a decrease, s, in the memory length. If the error signal is low, say falls below the critical error, there is an increase, p, in the memory length. As described, this is a binary alternative in the change of memory length, as shown in Figure 2. It is of course possible to have more than two alternatives in the changes of memory length. In [1] the above system was applied to the tracking of a maneuvering aircraft, where it is assumed that the aircraft follows a periodic linear spline function. That is, the aircraft in the absence of noise follows the path shown in Figure 3.There are a certain number of samples of the aircraft position during each time interval T. The noise disturbances at each sample are chosen to be independent samples of normally distributed noise of mean 0 and constant standard of deviation &sgr;.To simplify, let the filter model be a straight line, least squares model. Other models are possible, for example a straight line, weighted least squares model.Let E be the error signal. In [1], p = 0 when |E| ≤ &Kgr;&sgr;, s = 1 when |E| &Kgr;&sgr;, where &Kgr; is a constant and &Kgr;&sgr; is the critical error. While recursive filter models are given in [1], the operation may be viewed here as a sequence of nonrecursive linear regressions over f sample points, where f is the adjusting memory length.In Figure 4, if the error signal is less than &Kgr;&sgr;, the memory length increases from 7 to 8, fitting points 11 to 18. This corresponds to p = 0 because there is no penetration into past history prior to point 11.In Figure 4, if the error signal is greater than &Kgr;&sgr;, the memory length decreases from 7 to 6, fitting points 13 to 18. This corresponds to s = 1 because there is a shrinkage of memory length by 1.Other values for p and s are possible. In the above we have seen a binary alternative where either f increases by 1 (p = 0) or f decreases by 1 (s = 1). Many questions remain on the choice of alternatives. In what follows, we answer the questions below.Is there any improvement in going from 2 alternatives, where f increases or decreases by 1, to 3 alternatives, where f increases by 1, decreases by 1, or remains the same?Is there any improvement in using 2 alternatives corresponding to p = 1 (f increases by 2) and s = 2 (f decreases by 2)?Is there any improvement in using 2 alternatives corresponding to high values of s and p?First, is there any improvement in allowing f to remain unchanged, as well as increasing or decreasing by one? We have made a number of simulations to test this, and find no discernible improvement over the binary alternative (just increasing or decreasing by one). From the standpoint of models for learning systems, this result is not surprising.Second, the system in which p = 1 and s = 2 shows improvement over the system in which p = 0 and s = 1. The latter may be found in [1]. The improved performance of the former is shown in Figure 5.Apparently in Figure 5, the improvement stems from the fact that f increases or decreases by a greater amount. For p = 1, the model penetrates into past history by 1, increasing f by 2 rather than 1. For s = 2, the model shrinks f by 2, rather than 1.Note that in Figure 5 the learning is rapid, in that the overshoot at each knot of the spline function rapidly decreases, through the sequence at knots B, C, D, E, F.As can be seen in Figure 5, the period T is rapidly learned by the filter output. This is apparent by viewing the filter output from knot E to knot F. In fact, the filter value of f in steady state has a root-mean-square error of only 3.5 sample points with essentially no bias error. Third, could high increases or decreases in f lead to improved performance? The answer is a definite no. The performance in such cases is very poor. Apparently the best performance may be found around p = 0 and s = 1, or p = 1 and s = 2, as noted above.
9526#The BACON system, developed by Langley, Simon and Bradshaw, has shown the utility of a data driven discovery system. A new system, called FAHRENHEIT, has been built which extends BACON, making it more robust and allowing it perform a wider range of discovery activity. The new system extends BACON in several ways: 1) It determines the scope of a law by making simulated experiments, and by searching for regularities that describe the scope boundaries. 2) The world model in which the experiments are performed is more sophisticated. 3) The order in which the data are considered is placed under the control of FAHRENHEIT so that the system continues the discovery process even if no regularity is found for a particular variable.
9527#We demonstrate in this paper that the principles of inductive learning can be precisely formulated and hopefully better understood based on the theory of rough sets introduced by Pawlak. We discuss some statistical aspects of evaluating and forming decision rules from examples of expert decisions. We also suggest a method of comparing decision rules inferred by different learning algorithms from the same set of samples.
9528#This is a theoretical expositional exploration into the underlying needs of concept formation. The main purpose is to identify and discuss the differing forms of categorization in the context of possible machine learning and representation of those concepts. Conceptualization is the process of developing the abstractions that are needed to support reasoning. The formation of the machine equivalent of human concepts is critical to the development of a general, machine based reasoning capacity. An aid in understanding conceptual categorization is prototype theory. It helps to identify the building block tools that are used to construct categories and taxonomies. When developing taxonomic structures, framing conflicts can occur in terms of how things should be clustered together, what should be the relative hierarchal levels, and what should be subordinate to what.
9529#A model for self-adaptation in a colony of robots to changes occurring in the environment is presented. The model employs two levels of computations : one at a metalevel and the other at a lowerlevel. The metalevel computations produce a learning behaviour in the robot which is responsible for the adaptation and those at the low-level control the robot motions. Inductive learning is employed as the learning strategy. An instance of the 'Producer-Consumer' problem is presented in this context.
9530#Because uncertain and provisional reasoning is an inherent part of intelligent systems, a diverse (and competing) array of formalisms for handling uncertain inference has been developed in theory and practice. Each of these formalisms tends to be argued and justified on its own ground, starting from assumptions which ensure its “correctness” or “optimality.” It is argued here, however, that the key concept for an intelligent system is viability - it is as unproductive to seek “correctness” in open inference systems as it would be to prove the “optimality” of a biological organism. Several inference formalisms are examined in the light of this criticism. The viability of systems based on these formalisms is seen to rest critically on their robustness to changes in their context. The assumptions which usually function to hold that context fixed must thus be critically examined.
9531#For the purposes of this paper self-improvement will be defined to be the automatic development of problem solving heuristics. The reason for such a narrow definition will be indicated. Precise formulation of the concepts of problem and game will form the basis for the discussion of self-improving programs and an attempt to deal with the question of their adequacies.The relationship between self improvement and the process of learning will be established in specific cases. The idea of “proof generalization” as a basis of self-improvement will also be discussed. Case studies, where they exist and are understood will be indicated.
9532#We have entered an era of intelligent system development in which fifth and sixth generation computing systems are expected to emulate and enhance natural intelligence. However, human knowledge processes are not well-understood and it is tempting to base the technology of intelligent systems on formal reasoning rather than human psychology. In particular, the attempt to base knowledge processing in fifth generation computing systems on logic programming suggests that we should examine the rationale behind standard logic. It was developed as a foundation for arithmetic and psychological considerations were ruled out as irrelevant. We should consider that there may be systems of logic more appropriate to knowledge processing. Logical and psychological system theories based on an axiom of unrestricted predication are plausible and attractive alternatives to standard logic. It is suggested that the design of logical inference processors should take such systems into account, and that investigation of the logical, psychological and systemic foundations of knowledge are fundamental to the development of intelligent systems.
9533#The following paper defines the problem of writing symbolic explanation facilities for computer simulations. Our approach towards this problem draws from an existing body of research on a related problem, that of writing an explanation facility for an expert system. We discuss the notion of an explanation facility for a computer simulation with reference to a specific inventory control simulation (Gaither, 1982). We believe, however, that the structure of our explanation facility for Gaither's simulation reflects the structure of human explanatory activities, and thus may be usefully applied in a variety of problem domains.
9534#Underlying concepts of “conceptual modelling” are examined. A systematic layered approach is presented in order to improve techniques recently used.
9535#Spaceprobe is an experimental system for representing and reasoning about such things as beliefs, wants, fictions, hypotheses (both possibilities and counterfactuals), situations, generalizations, and time in a uniform and principled way. It is based on the theory of Knowledge Partitioning and Simulative Reasoning [2, 4, 5].
9536#Artificial intelligence methodologies are being applied to support decision making at all levels of military operations. Applications being studied include assessing force readiness, reliability and capability; planning complex missions; and integrating data from multiple sources. Unclassified research is addressing the considerable challenges presented by supporting such decision making in time-sensitive environments. We examine current efforts to utilize artificial intelligence in the military, discuss difficulties which need to be resolved before intelligent systems can become fully operational, and identify potential applications of artificial intelligence for the Military Airlift Command of the U. S. Air Force.
9537#An expert system is being developed as a step towards a more automated environment for processing satellite data of a region of the Atlantic Ocean and for interpreting the data with respect to mesoscale events. Oceanic events of interest include the Gulf Stream boundaries, warm-core rings, and cold-core rings.
9538#In this paper a prototype Expert System oriented to signal and pattern analysis is described together with a general methodology based on a hypothesize-and-test strategy similar to the one used by a human expert. This paper focuses on the knowledge base architecture and on its use. In order to make it capable of dealing with noisy patterns, the knowledge description is based on Fuzzy logic and the inference engine is able to reason about the knowledge it uses. The system is being applied to the phonetic analysis of the voice signal in speech recognition, as a case study.
9539#New concepts of knowledge representation systems, like object and attribute factors, connectedness relations, and seven kinds of homomorphisms of knowledge representation systems are introduced. Some properties of these homomorphisms, related to factors and connectedness, are shown. The theory presented here may be used to aggregate sets of objects, attributes, and descriptors of the original system in order to produce a simpler system, which preserves the description function of the original system. In some applications, the new system is sufficient representation of the original one.
9540#The use of rule-based methodologies in the development of Expert Systems is widespread. In order to provide good explanations in these systems it is desirable that the rules be prime. The difficulty of expressing control in such rules, and thus arriving at a desirable sequencing of events, has led to pragmatic additions to the basic methodology. Recent developments in the theory of decision processes have provided new insight into the form of a desirable sequencing. Prime rules, even when augmented by sophisticated control strategies, cannot generate from backward chaining all these desirable sequencings. Furthermore, if one of these desirable sequencings happens to be generated from prime rules it may be by luck rather than design.
9541#Computer-simulated plant evolution
9542#Flight simulation
9543#Materials for information and communication
9544#Electronic and magnetic materials
9545#Photonic materials
9546#Features and objects in visual processing
9547#RT-ASLAN: A specification language for real-time systems
9548#Safety analysis of timing properties in real-time systems
9549#On hierarchical design of computer systems for critical applications
9550#Design of reliable software in distributed systems using the conversation scheme
9551#PODS—A project on diverse software
9552#Real-time Euclid: a language for reliable real-time systems
9553#Evaluation of competing software reliability predictions
9554#A statistical methodology for the study of the software failure process and its application to the ARGOS center
9555#Extensions to an approach to the modeling of software testing with some performance comparisons
9556#The application of formal methods to the assessment of high integrity software
9557#Science
9558#Mindworks
9559#Educom Review
9560#The next generation of personal computers
9561#Computer-intensive campuses: strategies, plans, implications
9562#Computers in the classroom: educational process and higher order skills
9563#Beyond word processing: computer software for writing effective prose
9564#MIS performance evaluation generally includes consideration of issues such as timeliness, efficiency, effectiveness, and user satisfaction. Much of this can be subjective. For individual applications more objective criteria are necessary to monitor operational occurrences that affect overall performance.This article discusses measuring a system's performance with an application profile, describes the components that make up a profile spreadsheet, and highlights benefits derived from its use as a management tool.
9565#This research article reports on those factors project team members perceive as leading to systems development success. The amount of perceived impact of environmental variables, task variables and personal characteristics of project team members on systems success was explored. Results demonstrate that project team members are concerned with group process issues as well as with technical issues within the ranks of the project team. The sobering finding in their responses was that information systems personnel perceive neither management support nor user involvement as critical to the successful development of systems.
9566#A field survey was conducted to study the factors associated with the use of data processing chargeback information in organizations. The aim of this research was to identify the organizational and budgetary characteristics associated with how the output of a chargeback system is used by user-managers to control their data processing costs. It was found that involvement in budget preparation, accountability for meeting the data processing budget, and cost variability of the charges were the most important factors to consider when designing data processing chargeback systems.
9567#This article presents special event data for use in database management systems, along with a case study of the collection and representation of such data for an organization. Special event data account for structural changes and pattern interruptions in the time series data of an organization's performance measures, and are important for the strategic management activities of evaluating management's past actions and forecasting exogenous variables such as demand for products and services. Most organizations do not have a practice of collecting, storing, or sharing special event data so this valuable resource is lost as employees forget the past or take new jobs. Now that organizations are widely implementing DBMSs, it is possible and important to provide special event data. Data in the hands of individual end user can lead to errors in interpretation and use. Special event data, if they are included in the database, can help to alleviate this problem by sharing knowledge on shard data.
9568#The new technology of computer graphics makes it possible to create images on the screen that literally appear to pop out into the room. This is accomplished by creating separate images for the left and right eye and filtering them so that each eye receives the appropriate image. In the context of a scattergram, the binocular disparity information is interpreted by the brain as the z axis of a three dimensional x-y-z scattergram. In this article a convenient anaglyph method of accomplishing this on a standard IBM PC is presented. Also, a multi-color method using polarized projection is described and tested. The effectiveness of stereoscopic presentations is investigated within the context of managerial decision-making problems. When used to present continuous data in an x-y-z scattergram, the stereoscopic presentation resulted in greater accuracy and faster answers. However, when used with 3-D block diagrams to present semi-discrete data of the type usually presented by crosstab tables, the technique was less successful than a conventional crosstab presentation.
9569#A test of the relationship between job characteristics and data requirements was conducted. Information system uses in five public sector service organizations participated in a cross-sectional field survey. Results indicate that some job characteristics are related to data manipulation requirements, while others are related to data quality. The results support past findings outside the CBIS field that complex, nonroutine tasks with low analyzability require less precise information and more information processing than simple, routine tasks.
9570#This article examine the progress of MIS as a scholarly field of study since 1980. In this examination, MIS is identified as emerging from a supporting base of three foundational fields: computer science, management science, and organization science. Hypotheses related to this emergence are tested by an analysis of data on 271 MIS articles published during th e period 1980-84 in six academic journals and one conference proceedings. Each article is described by its work point (the field of study represented by the publication in which the article appears) and its reference point (as represented by the distribution of the article's publication citations). Results of the analysis support the proposition that MIS is emerging as a distinct field of study, with its own cumulative tradition.
9571#This study investigates the usage pattern and sources of assistance for personal computer(PC) users in twelve organizations. The study found that PCs attract new computer users and the extent of PC usage was correlated with prior computer knowledge. The most important reason for using PCs was for specific professional work. Although managers spend fewer hours than their staff using their PCs, there was no relationship between the diversity of applications and organizational position. Overall, users were satisfied with their PCs, but not with the information they obtained from the written sources (i.e., manuals, documents, and journals). The best source of information for PC users were their own colleagues and their organization's information systems staff. Moreover, "lead users" played an important role as consultants to other users.Two divisions of a large manufacturing firm in our sample introduced PCs concurrently but under different policies. The two units provided a natural setting for assessing the impact of the technology. In the division that underwent extensive planning prior to the introduction of this technology, we found that users made significantly more use of internal consulting. In contrast, in the other division, where management had adopted an "individual initiatives and maximum freedom" policy for introducing this technology, the users made significantly less use of internal consulting, approaching outside vendors instead even though they felt the information obtained from the vendors was significantly lower in quality. Implications fort he management of personal computer technology are discussed.
9572#This article describes the risks of information systems success achieved in the absence of appropriate regard for the potential impacts. A framework, developed from some general considerations of using technological change for competitive advantage, is proposed as a way of assessing the risks. Finally, some suggestions are made for management policies and procedures to insure that potentially high-risk projects receive the appropriate degree of attention before they are implemented.
9573#The rapid growth of end-user computing is a double-edged sword: it offers new opportunities for improving the effectiveness of organizations, but it also create new risks for a firm's information resources. This paper describes an organized approach for effectively managing end-user computing. It is based on the definition of "service support levels" which link support services to responsibilities. These levels form the basis of a cooperative effort between the MIS department and the end user.
9574#This article identifies the issues which MIS management rates as most important and most difficult to solve over the next two years. The results were obtained from a 1985 opinion survey of MIS managers in over 100 St. Louis area companies. The most important issues fall into three categories: aligning MIS with corporate goals, software development, and end-user computing; the least important issues were narrowly focused or more technical. Comparison with prior research reveals that the alignment and end-user computing issues have increased in importance. The results indicate that MIS managers are more oriented to corporate than to technical issues.
9575#Auditors and systems analysts are increasingly called upon to determine the impact of a disaster striking the computer system. Current risk analysis methods rely on some variation of expected value analysis. The expected value method suffers from serious drawbacks in this application because probabilities of disaster are difficult to estimate and the loss distributions are likely to be highly skewed. This article presents an improved methodology for dealing with EDP risk analysis and contingency planning. It is based on the concept of stochastic dominance and it provides a more accurate comparison of the various contingency plans by dealing with estimates of the entire loss distribution. This methodology also focuses on the differences between contingency plans, rather than on the cause of the disaster. The application of this methodology is illustrated for the case of a hypothetical medium-sized bank using aggregated data.
9576#Comparison of motivational patterns of information systems (IS) and non-information systems people in the same occupational group reveals no significant differences. This finding contrasts with prior writings. Conceptually, this study focuses on a more complete set of motivators of productive work behavior. Methodologically, it measures motivators with a constrained-choice checklist, samples employees from the insurance industry, and statistically tests for IS and non-IS differences within clerical/operations, technical/professional, and managerial occupational groups. Until further study shows otherwise, this study suggests that IS people are as motivationally normal while doing their job as other workers in their occupational group.
9577#This article describes the design, implementation, and evaluation of an integrated voice-data-video information system for crisis management at Southern California Edison (SCE). It was developed for top managers to help prevent and control problems that might arise with their nuclear power generating station at San Onofre, California. The article describes some of the system's unique design features, and the lessons that SCE learned from implementation. It concludes by providing a generic set of prescriptions for the design and implementation of information systems for crisis management.
9578#There are three important considerations in DSS development. (1) Decision making involves both primary and secondary processes, where secondary processes concern selecting appropriate decision making tools, approaches, and information. (2) In making decisions, humans are subject to numerous cognitive limitations. (3) In order for end users to develop DSS. sophisticated, problem0-oriented DSS generators must replace technically demanding DSS tools. These three considerations can be effectively addressed by including expert system components in DSSs. An expert DSS for statistical analysis is proposed and used as an illustration. Decision making scenarios are used to indicate the potential of such a system. IN particular, it appears that an expert DSS can provide support for both primary and secondary decision making and help ameliorate human cognitive limitations.
9579#The bandwidth minimization problem for caterpillars with hair length 3 is NP-complete
9580#A spectrum enveloping technique for iterative solution of central difference approximations of convection-diffusion equations
9581#The null space problem I. complexity
9582#Column LU factorization with pivoting on a message-passing multiprocessor
9583#Neighborhoods of dominant convergence for the SSOR method
9584#Fredman-Kolmo´s bounds and information theory
9585#Optimal numberings of an N N array
9586#An approximation to the stationary distribution of a nearly completely decomposable Markov chain and its error bound
9587#An approximation to the stationary distribution of a nearly completely decomposable Markov chain and its error analysis
9588#Computing the structural index
9589#Sequence alignments with matched sections
9590#Cascade addition and subtraction of matrices
9591#Mathematical aspects of the relative gain array (AΦHA—T)
9592#New REDUCE packages often require additions to the REDUCE syntax. In this note we present a detailed description of REDUCE parsing tools and step-by-step instructions of adding new statements.
9593#As has been pointed out [Schwartz & Sharir, 1983b], various problems of motion planning can be expressed as cylindrical algebraic decompositions [Collins, 1975; Arnon et al., 1984]. The purpose of this note is to discuss a particularly simple such problem, and show what actually happens during the decomposition (as far as we could take it). There is no pretence at originality, except perhaps in the conclusions.
9594#In all versions of REDUCE, the function ABS (i.e., absolute value) is either not defined in the algebraic mode or, when it is defined, assumes that the domain of its variable is the one of semi-definite positive real numbers. This implies that, for instance in REDUCE 3.2 [1], ABS(±X) simplifies to X.
9595#In this paper a method is proposed to determine the precise number of zeros of any real parameter polynomial with polynomial coefficients (two by two primes) in the unit disk. It deals with some questions of stability of biomedical, physical systems with parameters [2], [3], [6], [7].
9596#Standard Lisp on IBM 360 & 370 proposed and implemented by A. C. Hearn and J. Fitch et al. of the University of Utah had still several bugs and some execution-time inefficiency. This paper describes these bug-fixings, modifications and additions of comfortable features, and some improvements in the stack operation and compiler-interface which contribute to a speed-up of the factor of about 1.2~1.6. It also urges the necessity of variety of datatypes for a more practical Lisp system, such as vectors, hash tables, bit/byte strings.
9597#Relating software requirements to software design
9598#Twenty-two programming tools were introduced in coordinated exercises as part of a programming methods course. Twenty-two or twenty-four graduate students with work experience responded to a survey asking about previous and intended use of the tools. The survey showed that many tools were new and useful to the students. My conclusion is that it is worthwhile to incorporate a module on coding quality and tools in software engineering programs.
9599#Graphical views of parallel programs
9600#A procedure for evaluating a software prototype is presented. The need to assess the prototype itself arises from the use of prototyping to demonstrate the feasibility of a design or development strategy. The assessment procedure can also be of use in deciding whether to evolve a prototype into a complete system. The procedure consists of identifying evaluation criteria, defining alternative design approaches, and ranking the alternatives according to the criteria.
9601#The structure of the software process
9602#A systematic study of the software process will require a vocabulary in which various process models, methods and approaches can be described, compared and contrasted. This paper describes a meta-model that might provide such a vocabulary, illustrates how it might be used, and poses some example questions of the kind that such a meta-model should help in answering.
9603#Foundational problems in software process research
9604#A spiral model of software development and enhancement
9605#Thoughts on the software process
9606#This paper is an extended, written, version of a presentation to the Second Process Workshop. It presents a systematic, top down, approach to the design of integrated project and programming support environments (IPSEs) using the ISTAR project at Imperial Software Technology Ltd as an illustration. In the context of the Workshop the talk was intended to describe an approach to software development and evolution in general. If that be his concern the reader may so interpret the text. Alternatively it may be seen as an introduction to ISTAR and a contribution to IPSE development technology.
9607#On the role of domain knowledge-based approaches to software development
9608#This paper addresses three distinct but strongly related topics in the life cycle and environments area:•Failure of the traditional life-cycle-model due to missing support for feedback loops.•An alternative model which represents development states and rules of well-structured project progress on the basis of abstract properties of the underlying documents.•Software engineering environment support for the proposed model.
9609#Highly conducting transparent undoped indium oxide films deposited below 100:9D C by activated reactive evaporation
9610#Prevention of thermal surface damage in GaAs by encapsulated annealing in an arsine ambient
9611#Damage constant and deep level transient spectroscopy in neutron irradiated GaAsP alloys
9612#Lattice mismatch and the nature of dissolution in the LPE of Pb salt compounds
9613#The effect of growth rate variation on the conductivity and morphology of polypyrrole thin films
9614#Supercooling studies and LPE growth of Hg1–xCdxTe
9615#ArF excimer laser induced CVD of aluminum oxide films
9616#OMVPE growth of CdTe on InSb substrates
9617#Homogeneous semi insulating GaAs crystal growth by a new LEC technique with As injection into melt during growth
9618#Vacuum chemical epitaxy utilizing organometallic sources
9619#Growth and structural properties of low defect, sub grain free CdTe substrates grown by the horizontal Bridgman technique
9620#A study of alloyed AuGeNi/Ag/Au based ohmic contacts on the Al0.48In0.52As/Ga0.47InO.53 As as system
9621#Selective LPE growth of In0.53Ga0.47 As on semi insulating InP
9622#Redistribution of implanted chlorine in SiO2 films on silicon during subsequent oxidation
9623#Particulates: a direct origin of oval defects in GaAs layers grown by molecular bean epitaxy
9624#Electromigration and microstructural properties of Al Si/Ti/Al Si VLSI metallization
9625#Structural and Electrical properties of polycrystalline silicon films deposited by low pressure chemical vapor deposition with and without plasma enhancement
9626#The 1986 Electronic materials conference (abstracts)
9627#Intentional ptype doping by carbon in metalorganic MBE of GaAs
9628#Chemical oxidative polymerization as a synthetic route to electrically conducting polypyrroles
9629#GA1–xInxAs—InP InP abrupt heterostructures grown by MOVPE at atmospheric pressure
9630#Diffusion of Cd and Hg in liquid Te
9631#OMVPE growth of the metastable III/V alloy GaAs0.5Sb0.5
9632#Growth of silicon doped dislocation free GaAs crystals by the LEC technique for optical device applications
9633#OMVPE growth of InP and Ga0.47In0.53AS as using ethyldimethylindium
9634#Photoluminescence and Raman scattering from superlattices made by phase locked epitaxy
9635#Interdiffusion in HgCdTe/CdTe structures
9636#Low pressure MOVPE of InP from trimethylindium and phosphine
9637#A hybrid access method in a multiple access channel
9638#On the modeling of shared resources with various lock granularities using queueing networks
9639#Approximate characterization of nonstationary discrete time G/G/I systems
9640#Towards performance improvement of cut-through switching in computer networks
9641#Comparison of external sorting and internal sorting in virtual memory
9642#The composite bound method for computing throughout bounds in multiple class environments
9643#Modeling and analysis of a communication switching processor
9644#A sensitivity study of the clustering approach to workload modeling
9645#An adaptive communications protocol for network computers
9646#A comparison of receiver-initiated and sender-initiated adaptive load sharing
9647#Third GI/NTG Conference on measurement, modelling and evaluation of computer systems
9648#International seminar on computer networking and performance evaluation
9649#An algorithm for finding nearest neighbours in (approximately) constant average time
9650#Fuzzy measures in determining seed points in clustering
9651#Shortest path solves edge-to-edge visibility in a polygon
9652#Interactive curve drawing by segmented Bezier approximation with a control parameter
9653#`Continuous' functions on digital pictures
9654#Image space transforms for detecting straight edges in industrial images
9655#Algorithm for interactive forming matrix data representation and estimation of its efficiency
9656#How to discriminate shapes using shape vector
9657#Computing depth from stereo images by using optical flow
9658#A simplified method of detecting structure in Glass patterns
9659#The class concept is one component of objectoriented programming systems that has proven useful in organizing complex software. In experimenting with classes for geometric modeling applications, we have devised a class hierarchy that yields some conceptual order in the midst of diverse representations of shapes. Rather than search for a uniform primitive representation, we accept the diversity and build a framework combining dissimilar models in an orderly manner.
9660#Various techniques have been developed that employ projections of the world as seen from a particular viewpoint. Blinn and Newell introduced reflection mapping for simulating mirror reflections on curved surfaces. Miller and Hoffman have presented a general illumination model based on environment mapping. World projections have also been used to model distant objects and to produce pictures with the fish-eye distortion required for Omnimax frames. This article proposes a uniform framework for representing and using world projections and argues that the best general-purpose representation is the is projection onto a cube. Surface shading and texture filtering are discussed in the context of environment mapping, and methods are presented for obtaining diffuse and specular surface illumination from prefiltered environment maps. Comparisons are made with ray tracing, noting that two problems with ray tracing驴obtaining diffuse reflection and antialiasing specular reflection驴can be handled effectively by environment mapping.
9661#The well-known z-buffer algorithm for solving the visible surface problem has a number of points in its favor, the main one being that it can be very efficiently implemented at little additional cost in many existing frame-buffer systems. The traditional software implementation of the algorithm assumes explicit initialization of both the image buffer and the z-buffer before each image is generated. We will describe a simple technique for synchronizing initialization and image generation so the two can be performed in parallel, effectively elimination the time needed for explicit initialization of the frame buffer. The technique assumes a modest investment in additional hardware within the frame buffer.
9662#This article discusses a basic architecture for a user interface management system and the problem of updating a display in response to interactive commands. The basic architecture is then extended to include basic editing and browsing processes on arbitrary data structures. Editing templates are presented as a technique embodying the entire manipulation process for a particular data structure/data display combination. In conjuction with the user interface management system, Such templates are able to automatically provide a majority of the code required in an interactive applicaton.
9663#Prolog is a userful tool for geometry and graphics implementations because its primitives, such as unification, match the requiements of many geometric algorithms. During the last two years, we have implemented programs to solve several problems in Prolog, including a subset of the Graphical Kernel System, convex-hull calculation, planar graph traversal, recognition of groupings of objects, Boolean combinations of polygons using multiple precision rational numbers, and cartographic map overlay. Certain paradigms or standard forms of geometric programming in Prolog are becoming evident. They include applying a function to every element of a set, executing a procedure so long as a certain geometric pattern exists, and using unification to propagate a transitive function. This article describes the experiences, including paradigms of programming that seem useful, and finally lists what we see as a advantaes and disadvantages of Prolog.
9664#Texture mapping is one of the most successful new techniques in high-quality image synthesis. It can enchance the visual richness of raster-scan images immensely while entailing only a relatively smann increase in computation. The technique has been applied to a number of surface attributes: surface color, surface normal, specularity, transparency, illumination, and surface displacement驴to name a few. Although the list is potentially endless, the techniques of texture mapping are essentially the same in all cases. This article surveys the fundamentals of texture mapping, which can be spilt into two topics: the geometric mapping that warps a texture onto a surface, and the filtering necessary to avoid aliasing. An extensive bibliography is included.
9665#In 1977 Frank Crow introduced a new class of algorithm for the generation of shadows. His technique, based on the concept of shadow volumes, assumes a polygonal database and a constrained environment. For example, polyhedrons must be closed, and polygons must be planar. This article presents a new version of Crow's algorithm, developed at the Universite de Montreal, which attempts a less constrained environment. The method has allowed the handling of both open and closed models and nonplanar polygons with the viewpoint anywhere, including any shadow volume. It does not, however, sacrifice the essential features of Crow's original version: penetration between polygons is allowed and any number of light sources can be defined anywhere in 3D space, including the view volume and any shadow volume. The method has been used successfully in the film Tony de Peltrie and is easily incorporated into an existing scan-line, hidden-surface algorithm.
9666#The computer graphics metafile
9667#The computer graphics virtual device interface
9668#GKS-3D: a three-dimensional extension to the graphical kernel system
9669#PHIGS: a standard, dynamic, interactive graphics interface
9670#Language bindings for computer graphics standards
9671#NBS's role in computer graphics standards
9672#Powerful, inexpensive processors, low-cost storage, and high-resolution color displays make single-user, networked, multiprogrammed computer workstations suitable replacements for the time-shared mainframe environment of the scientific and engineering professional. Distributed processing via networks of workstations connected to larger server machines, which are in turn connected to national and international networks, allows a completely new form of computer-aided organization for institutions. The flexibility and speed of such machines mean that a new revolution in information processing and human activity support is inevitable. The professional workstation project has as its immediate goal a networked, distributed system of single-user workstations. Each will use the Unix operating system and provide powerful object-oriented graphics tools that will enhance the productivity of scientific and engineering professionals.
9673#In the early 1980's, large computing systems became capable of supporting response times of 300 ms for transactions consisting of 500,000 instructions. In interactive environments this produced an unexpectedly large (卤100 percent) increase in the productivity of scientists, engineers, and programmers. An investigation of the findings by cognitive researchers led to a reconciliation of the productivity improvement and response time. This article examines the implications of this, and suggests several strategies for further productivity improvements. Cognitive research models are augmented with additional theory to develop an analytic model of interaction between the problem-solver and the computational system. This analytic model predicts that improvements in system response time and data entry technology can produce even greater gains in productivity.
9674#Typical computer workstations employ window managers for creating, destroying, and arranging windows on the screen. Window managers generally follow either a desktop metaphor, allowing windows to overlap each other like sheets of paper on a desk, or they use a tiling model, arranging each window with a specific size and location that avoids overlap. Desktop models allow for the most layout freedom, but can be frustrating to use when dealing with a large number of windows that must all be visible at once. Tiling models guarantee that each window will be completely visible on the screen, but thus far have provided relatively poor mechanisms for controlling layout decisions. This article describes work in tiled window management featuring a constraint-based layout mechanism. With it the user can specify the appearance of individual windows and constrain relationships between windows, thus exercising necessary control over the tiling process. We discuss our constraint model and then detail an implementation approach that would make use of those constraints.
9675#This article describes WHIM, the Window Handler and Input Manager, a window management system being developed as part of the QuickSilver operating system project at IBM's Almaden Research Center. Another version of WHIM runs under AIX on the IBM PC RT. This article contrasts and compares the overlapped window scheme used in WHIM with the tiled window scheme used in other systems. The advantages of the window management scheme used in WHIM are detailed, and the effect of display interfaces on the window manager is described.
9676#This article describes a system that allows a reduced-function workstation, an Apple Macintosh, to perform as a low-end node in an Apollo Domain workstation network. Programs that run in the Apollo environment do not have to be modified to be accessed from the Macintosh; the appropriate system subroutines are intercepted and recast into a suitable form. Each Apollo workstation can support from two to three Macintosh PCs, making the average cost per console as little as $5000. A similar project is underway for the IBM PC family of computers.
9677#This articles summarizes the work at SIGMEX Systems Limited from its origin in 1982 just prior to the publication of the draft of the International Graphics Standard, GKS. This article covers the original concept of the GKS workstation as defined in the Standard, its realization, the practical implications, and the real-world application of the resulting intelligent workstation device.
9678#In this article we propose algorithms that address the two basic problems encountered in generating continuous-tone images by ray tracing: speed and aliasing. We examine previous approaches to the problem and then propose a scheme based on the coherency of an auxiliary data structure imposed on the original object domain. After investigating both simple spatial enumeration and a hybrid octree approach, we developed 3DDDA, a 3D line generator for efficient traversing of both structures. 3DDDA provides an order of magnitude improvement in processing speed compared to other known ray-tracing methods. Processing time is found to be virtually independent of the number of objects involved in the scene. For large numbers of objects, this method actully becomes faster than scan-line methods. To remove jags from edges, a scheme for identifying edge orientation and distance from pixel center to true edge has been implemented. The time required for antialiasing depends on the total length of the edges encountered, but it is normally only a fractional addition to the time needed to produce the scene without antialiasing.
9679#A system of Constructive Solid Geometry (CSG) enables an engineering designer to compose threedimensional shapes by combining simpler ones. Definitions of such objects are represented by tree structures or directed acyclic graphs. Most existing systems convert this representation to a more conventional boundary representation of the solids in order to render pictures from the model. More recently, a number of systems have been described that render the pictures directly from the CSG structure. We describe such a system. We render a scene by ray tracing from a directed acyclic graph. This process is made efficient for large models by using an adaptive method of space division to reduce the number of intersection calculations needed.
9680#This article describes a method of representing a solid design procss using a tree structure. This representation supposrts UNDO and REDO operations for regenerating any solid in a previous stage of the design. The implementations of invertible set operations is also given in detail.
9681#The term "virtual camera" is often used in computer graphics, but it usually represents a mere abstraction for labeling the projection mechanism from 2D to 3D. We believe that a virtual camera should be a software entity that can be manipulated in the same way as cameramen manipulate real cameras. This article presents a model of a virtual movie camera and describes typical effects used by cameramen, including panning, tilting, tracking, zooming and spinning. Matte effects are introduced using an actorbased polygonal clipping method, and practical examples of such multiple-image effects as fades and wipes are presented.
9682#We discuss in this article the need for a minimum suite of raster display routines, the design requirments for such a suite of routines, and the specifications for a package satisfying these design requirements. Finally, we outline our experience with the implementation and use of the resulting package in an educational environment. In the Appendix we give a detailed specification of the actual package we have developed and the user manual for that package.
9683#This note describes a procedure that enables a designer or draftsperson with limited mathematical training to discover interactively the construction of a wide variety of tangency and intersection problems. Requiring very little code to implement, it supplements the standard tangency constructions available on commercial turnkey computer-aided-design systems with a flexibility unavailable even through the inclusion of the numerous special-purpose algorithms available in the literature.
9684#Recent developments in electrostatic plotting techonology-specifically in areas related to the plotter's speed, density, and color-forced processing requirements for graphics controllers beyond what is possible with traditional approaches. New market segments in the VLSI field, which were opened by the introduction of color, created more demanding applications, exceeding 10 million graphic elements per single E-size drawing. Conventional technology and architecture cannot generate the performance requirements within the given cost constraints. The new RPM (Raster Processing Machine) controller is based on a unique modular pipeline architecture, VLSI implementation of rasterizing routines, and parallel processing for performance and bottleneck by passing. For simple plots a single board processor based on the Motorola 68000 provides conversion from random graphic elements to the raster form required. As plot complexity increases, a special bipolar processor with a writable control store is added. For applications covering large graphic constructs with special texture (often needed for color generation), two custom chips on a dedicated VLSI board are added to the system. Multiplicity of processors and buses is possible for additional throughput. The controller's performance, along with the analysis of potential constraints, is also described.
9685#This paper details a scheme for producing display images of atomic models. The scheme relies on a combination of a restricted atomic model, specialized sorting for visibility, and dedicated hardware to produce icons. Building such an imaging device became possible due to sharply decreasing costs of off-the-shelf memory chips and related support hardware. The device is a test bed for understanding the display procedure necessary for this task;insight gained from operation of the device is leading to guides for a reimplementation in dedicated bit-slice technology and specialized VLSI devices.
9686#This article will discuss issues that must be considered in the design of a VLSI (very large scale integration) 32-bit microprocessor specialized for graphics applications. With a properly chosen architecture, a single-chip graphics processor should provide a cost-effective means for achieving high performance in color bit-mapped graphics displays for PCs and workstations. The goal in selecting an architecture is to reduce the components required for a medium-to high-resolution display so they fit easily on a single, small, printed-circuit card. At the same time the processing speed must result in screen updates that occur without perceptible delay. These improvements should enable bit-mapped graphics displays to replace the text-only displays that have seen wide-spread use in cost-sensitive applications.
9687#A new system, Pixel-powers, has been designed for the rapid rendering of curved surfaces. This system is a generalization of the design of our logic-enhanced framed buffer memory system, Pixel-planes. Our new design can directly evaluate quadratic expressions of the form Ax2 + Bxy + Cy2 + Dx + Ey + F for every pixel (x,y) in the image in parallel. Sample images generated by a high-level simulation of the new system are shown.
9688#Interactive computer graphics display requirements have generally been met is one of two ways: by highly specialized systems designed for a particular application, or, more frequently, by devices with a limited set of display functions common to a wide range of applications. A third alternative, presented here, is to use a high-performance, general-purpose display architecture to provide both common and application-specific graphics functions. A sampling data display to solid modeling, shows that significant improvements in interactivity can be obtained by microprogramming such a machine.
9689#A two-pass spatial transform technique that does not exhibit the aliasing artifacts associated with techniques for spatial transform of discrete sampled images is possible through the use of a complete and continuous resampling interpolation algorithm. The algorithm is complete in the sense that all the pixels of the input image under the map of the output image fully contribute to the output image. It is continuous in the sense that no gaps or overlaps exist in the sampling of the input pixels and that the sampling can be performed with arbitrary precision. The technique is real time in the sense that it can be guaranteed to operate for any arbitrary transform within a given time limit. Because of the complete and continuous nature of the resampling algorithm, the resulting image is free of the classic sampling artifacts such as graininess, degradation, and edge aliasing.
9690#The art of Prolog: advanced programming techniques
9691#Prolog programming: applications for database systems, expert systems, and natural language systems
9692#Knowledge systems and Prolog: a logical approach to expert systems and natural language processing
9693#Logic for problem-solving
9694#A multiproccessing computer system composed of loosely-coupled Forth micro-chip modules
9695#A microcoded machine simulator and microcode assembler in a Forth environment
9696#A micro-based ASW trainer in Forth
9697#A machine to implement a generalized Forth environment
9698#A Forth implementatiton of the heap data structure
9699#Real-time state machine implementation programming techniques
9700#A Forth based iconic interface
9701#Interactive videodiscs control and computer-based training on the Apple Macintosh
9702#Microcomputer control of a machine tool
9703#The design of a low cost CAD/CAM system
9704#DEBUGGER: the design of a test aid to support the development of an embedded com
9705#Exception handling in Forth
9706#Why the Q-bus lives on
9707#Advances in STD system capability
9708#S100 in commercial applications
9709#An independent user's view of backplane bus standards
9710#Local variables
9711#Forth automates intrinsic viscosity determinations
9712#System development via prototyping in the analytical laboratory
9713#What's wrong with Forth?
9714#Some problems in implementations of the Forth standards
9715#A tokenized rule processing system
9716#Concrete suggestions for a Forth floating point standard
9717#Plotter drivers as an exercise in Forth wordset design
9718#Forth in the computer numerical control environment
9719#Under the hood of a superchip: the NOVIX Forth engine
9720#Forth for a multimicroprocessor control system
9721#A versatile software control system for a triple quadruple mass spectrometer
9722#Implementing Forth for the multics operating system
9723#A process monitor
9724#Object oriented extensions to Forth
9725#State sequence handlers
9726#Combining Forth and the rest of the computer world: dynamic loading of subroutines written in other languages and their use as Forth words
9727#The need for standard test-suite
9728#NAPLPS decoding in Forth
9729#Controlling an integrated automatic parameter characterization system with Forth
9730#REvised REcursive AND? 'REPTIL :IS
9731#Production testing of domestic clothes dryers using LMS Forth
9732#Honeywell Source
9733#Keeping the wheels of justice rolling
9734#Computer network aids New Hampshire
9735#National computer policies
9736#Corporate partnership in education
9737#Distributed transaction processing
9738#Clairol hot lines
9739#Survivability in distributed systems
9740#Honeywell Source
9741#Healthcare cost containment: the private sector
9742#RX for a hospital's revenue crunch
9743#Automation and healthcare: a discussion
9744#Information management for healthcare services
9745#Ambulatory patient care system-city of Houston
9746#Micro-to-mainframe links: an examination and comparison
9747#Boston ad agency gains competitive edge
9748#Unique, online bound fund trading system
9749#The role of controls in data processing systems
9750#Expert systems for forecasting
9751#A parallel block iterative scheme applied to computations in structural analysis
9752#A dynamic programming algorithm for covering problems with (greedy) totally balanced constraint matrices
9753#A property of the legendre differential equation and its discretization
9754#Parametric lower bound for on-line bin-packing
9755#A stable method for the LU factorization of M-matrices
9756#Efficient algorithms for optimization and selection on series-parallel graphs
9757#Convergent iterations for computing stationary distributions of markov
9758#On an invariant of graphs and the reliability polynomial
9759#Weighted averages of radon transforms on ZK-2-
9760#On the smallest positive singular value of a singular M-matrix with applications to ergodic Markov chains
9761#Curves on Sn-1 that lead to eigenvalues or their means of a matrix
9762#Convexity in graphs and hypergraphs
9763#Relationships between l1 metrics on rankings: The case of ties
9764#A short proof of the rectilinear art gallery theorem
9765#A variable-complexity norm maximization problem
9766#Keldysh chains and factorizations of matrix polynomials
9767#The distribution of prefix overlap in consecutive dictionary entries
9768#The dual variable method for the solution of compressible fluid flow problems
9769#The second immanantal polynomial and the centeoid of a graph
9770#The arithmetic of the digital computer: A new approach
9771#Counter-examples in dynamical systems via normal form theory
9772#Analytical methods for recovering coefficients in differential equations from spectral data
9773#Optimizing pacemaker battery life
9774#Iterative methods for elliptic problems and the discovery of “q”
9775#Initial-boundary value problems for linear hyperbolic systems
9776#Some reminiscences about Richard C. Diprima 1927-1984
9777#Taylor-vortex flow: a dynamical system
9778#Asymptotic analyses in isothermal fluid film lubrication theories
9779#Methods for global concave minimization: A bibliographic survey
9780#On front-tracking methods applied to hyperbolic systems of nonlinear conservation laws
9781#L0-stable splitting methods for the simple heat equation in two space dimensions with homogeneous boundary conditions
9782#Split-step methods for the solution of the nonlinear Schro¨dinger equation
9783#Numerical approximations for a miscible displacement process in porous media
9784#Analysis of a fully discrete scheme for neutron transport in two-dimensional geometry
9785#Optimal isoparametric finite elements and error estimates for domains involving curved boundaries
9786#On the multi-level splitting of finite element spaces for indefinite elliptic boundary value problems
9787#Collocation for two-point boundary value problems revisited
9788#Matrix-free methods for stiff systems of ODE's
9789#A nonlinear parallel algorithm with application to the Stefan problem
9790#Spline interpolation at a bi-infinite knot sequence
9791#Making the Oslo algorithm more efficient
9792#Partially symmetric cubature formulas for even degrees of exactness
9793#On a numerical differentiation
9794#Folds on the solution manifold of a parametrized equation
9795#A nonmonotone line search technique for Newton's method
9796#A semi-implicit method for hyperbolic problems with different time-scales
9797#Finite element approximation of the nonstationary Navier-Stokes problem, part II: Stability of solutions and error estimates uniform in time
9798#A moving finite element method with error estimation and refinement for one-dimensional time dependent partial differential equations
9799#Mesh-independent spectra in the moving finite element equations
9800#Boundary conditions in Chebyshev and Legendre methods
9801#On the convergence of stability constants
9802#Order results for implicit Runge-Kutta methods applied to differential/algebraic systems
9803#An efficient implementation of a conformal mapping method based on the Szego¨ kernel
9804#A numerically stable circular harmonic reconstruction algorithm
9805#Piecewise-polynomial quadratures for Cauchy singular integrals
9806#On the convergence of some cubic spline interpolation schemes
9807#On the successive projections approach to least-squares problems
9808#Generalized deflated block-elimination
9809#Stability of finite difference schemes for two-point boundary value problems
9810#On the condition of the linear systems associated with discretized BVPs of ODEs
9811#Analysis of a singularly-perturbed linear two-point boundary-value problem
9812#Asymptotic expansions and boundary conditions for time-dependent problems
9813#Convergence cones near bifurcation
9814#The Sarkovskii sequence and stable periodic orbits of maps of the interval
9815#Stable attracting sets in dynamical systems and in their one-step discretizations
9816#On the efficient numerical solution of systems of second order boundary value problems
9817#A pseudo-arclength continuation method for nonlinear eigenvalue problems
9818#Convergence of inner iterations for finite-difference approximations to the linear transport equation
9819#The Riccati transformation in the solution of boundary value problems
9820#A note on the relationship between finite-difference and shooting methods for ODE eigenvalue problems
9821#Characterization and computation of singular points with maximum rank deficiency
9822#Time discretization of an integro-differential equation of parabolic type
9823#Collocation for singular boundary value problems of second order
9824#The use of metalorganic chemical vapor deposition ot prepare device quality Ga(AsP) strained layer superlattices
9825#Giant polarization in high polymers
9826#The growth and characteristics of device quality InP/Ga1-xInxAsyP1-y double heterostructures by atmospheric pressure MOVPE using trimethylindium
9827#The effect of isolated dislocations in substrate and device properties in low dislocation czochralski GaAs
9828#The determination of impact ionization coefficients in In0.2Ga0.8 As/GaAs strained layer superlattice mesa photodiodes
9829#The effect of hydrogen on boron diffusion in SiO2
9830#The growth of GaAs, AlGaAs, InP and InGaAs by chemical beam epitaxy using group III an V alkyls
9831#Reduction of dislocations in GaAs and InP epitaxial layers by quasi ternary growth and its effect on device performance
9832#Electrical and photo luminescence properties of ZnSe epitaxial layers grown on GaAs (100) by atmospheric pressure MOVPE: the role of substrate temperature
9833#Effects of various implant species and post anneal treatments on Si N channel MOSFETS
9834#Processing characteristics of tin and tungsten oxides relevant to production of gas sensors
9835#OMVPE growth of 660 nm AlGaAs double heterojunction LEDs
9836#Determination of the Si-conducting polymer interfacial properties using A C impedanc techniques
9837#Photo CVD system for silicon nitride film
9838#Rapid thermal annealing of implanted GaAs
9839#Molecular beam epitaxy of In1-xGaxAsyP1-y(y:8V2.2x) lattice matched to ImP using gas cells
9840#Studies of the Ga1-XInxAs1-ySby quaternary alloy system I. liquid phase epitaxial growth and assessment
9841#Studies of the Ga1-xInxAs1-ySby quaternary alloy systems: II characterisation by far infrared reflectance spectroscopy
9842#Limit cycles in the Josephson equations
9843#Breakdown of stability in singularly perturbed autonomous systems I. Orbit equations
9844#Jumps of solutions of the equations εx″=f(t,x,.-x-)
9845#Asymptotic analysis of singular singularly perturbed boundary value problems
9846#Second order nonlinear singular perturbation problems with boundary conditions of mixed type
9847#A priori bounds and existence of positive solutions for singular nonlinear boundary value problems
9848#A free boundary problem arising from the leaching of saline soils
9849#A relation between semi-inverse and Saint-Venant solutions for prisms
9850#On the behavior of the solutions to the Lamm equation of the ultracentrifuge II
9851#R-separation for heat and Schröinger equations I
9852#An integral transform involving heun functions and a related eigenvalue problem
9853#Discretized fractional calculus
9854#The representation of functions as Laplace and Laplace-Stieltjes transforms
9855#On zeros of interpolating polynomials
9856#Asymptotics for the greatest zeros of orthogonal polynomials
9857#Orthogonal polynomials, measures and recurrence relations
9858#On the existence of conjugate points for a second order ordinary differential equation
9859#Global simplification of a singularly perturbed almost diagonal system equation
9860#Oscillation results for second order differential systems
9861#Comparison theorems for certain differential systems of arbitrary order
9862#On the stability of a distributed network
9863#Semigroups generated by a neutral functional differential equation
9864#Stability in a reaction-diffusion model of mutualism
9865#A parabolic-hyperbolic free boundary problem
9866#Standing wave solutions for a system derived from the Fitzhugh-Nagumo equations for nerve conduction
9867#Regularization for a class of nonlinear evolution equations
9868#Bifurcation in doubly-diffusive systems I. Equilibrium solutions
9869#Bifurcation in doubly-diffusive systems II. Time periodic solutions
9870#The generalized inverse of an unbounded linear operator
9871#Linearization stability for an inverse problem in several-dimensional vave propagation
9872#A nonlinear integral operator arising from a model in population genetics IV. clines
9873#Stability of a surface determined from measures of potential
9874#Absolutely continuous spectra of second order differential operators with short and long range potentials
9875#Asymptotic behavior of periodic strain states
9876#Quasi inner products of analytic functions with applications to special functions
9877#Univalence constraints on the Schwarz-Christoffel parameters
9878#Critical values and representation of functions by means of compositions
9879#Polynomial analogues of prolate spheroidal wave functions and uncertainty
9880#Validation of recoverable concurrent software systems based on the programmer-transparent coordination scheme
9881#Computational characterization of a hybrid biochip
9882#Multiprocessor sparse LU decomposition with controlled fill-in
9883#Design of a communication port and implementation of a reconfigurable media translation gateway
9884#Towards a representation of Lisp semantics
9885#Debugging programs in a distributed system environment
9886#Performance evaluation of hierarchical simulators: distributed model transformations and mappings
9887#A formal approach to realtime parallel processing
9888#Multiple-access communications with prioritized service
9889#High-resolution printing without a frame buffer
9890#Performance evaluation of the time warp distributed simulation mechanism
9891#Surfaces in early range image understanding
9892#Proving correctness of asynchronous circuits using temporal logic
9893#A family of software architectures for the support of software life cycle entities in a distributed environment
9894#An object-oriented data model for managing computer-aided design and computer-aided manufacturing data bases
9895#Robin Hood hashing
9896#Relational data base systems applied to manufacturing management information systems
9897#Analysis of distributed system software design based on structured petri net model
9898#Pattern analysis using event-covering
9899#A unified representation of uncertainty
9900#Routing, flow control and fairness in computer networks
9901#Optimal memory management strategies for query processing
9902#Scheduling data transfers in networks
9903#A moving experience
9904#Keeping cool
9905#Banking on Big Blue
9906#Putting on the cuffs
9907#Chaining is the ability to pipeline two or more vector instructions on Cray-1 like machines. We show how to optimally use this feature to compute (vector) expression trees, in the context of automatic code-generation. We present a linear-time scheduling algorithm for finding an optimal order of evaluation for a machine with a bounded number of registers.
9908#As part of an effort to develop an optimizing compiler for a pipelined architecture, a code reorganization algorithm has been developed that significantly reduces the number of runtime pipeline interlocks. In a pass after code generation, the algorithm uses a dag representation to heuristically schedule the instructions in each basic block.Previous algorithms for reducing pipeline interlocks have had worst-case runtimes of at least O (n4). By using a dag representation which prevents scheduling deadlocks and a selection method that requires no lookahead, the resulting algorithm reorganizes instructions almost as effectively in practice, while having an O (n2) worst-case runtime.
9909#Partitioning and scheduling techniques are necessary to implement parallel languages on multiprocessors. Multiprocessor performance is maximized when parallelism between tasks is optimally traded off with communication and synchronization overhead. We present compile-time partitioning and scheduling techniques to achieve this trade-off.
9910#We report on a compiler for Warp, a high-performance systolic array developed at Carnegie Mellon. This compiler enhances the usefulness of Warp significantly and allows application programmers to code substantial algorithms.The compiler combines a novel programming model, which is based on a model of skewed computation for the array, with powerful optimization techniques. Programming in W2 (the language accepted by the compiler) is orders of magnitude easier than coding in microcode, the only alternative available previously.
9911#Aggregate valued attributes, which store collections of keyed elements, are required in attribute grammars to communicate information from multiple definition sites to multiple use locations. For syntax directed editors and incremental compilers, symbol tables are represented as aggregate values. We present efficient algorithms for incrementally maintaining these aggregate values and give an incremental evaluation algorithm that restricts attribute propagation to attributes dependent only upon information within the aggregate value that has changed.
9912#Attribute grammars have been used for many years for automated compiler construction. Attribute grammars support the description of semantic analysis, code generation and some code optimization in a formal declarative style. Other tools support the automation of lexical analysis and parsing. However, there is one large part of compiler construction that is missing from our toolkit: run-time environments. This paper introduces an extension of attribute grammars that supports the generation of run-time environments. The extension also supports the generation of interpreters, symbolic debugging tools, and other execution-time facilities./
9913#While efficient new algorithms for interprocedural data flow analysis have made these techniques practical for use in production compilation systems, a new problem has arisen: collecting and using interprocedural information in a compiler introduces subtle dependences among the procedures of a program. If the compiler depends on interprocedural information to optimize a given module, a subsequent editing change to another module in the program may change the interprocedural information and necessitate recompilation. To avoid having to recompile every module in a program in response to a single editing change to one module, we must develop techniques to more precisely determine which compilations have actually been invalidated by a change to the program's source. This paper presents a general recompilation test to determine which procedures must be compiled in response to a series of editing changes. Three different implementation strategies, which demonstrate the fundamental tradeoff between the cost of analysis and the precision of the resulting test, are also discussed.
9914#In semantics-directed compiler generation one is faced with the problem of how to translate a source semantic definition of a programming language into on equivalent target semantics closer to an implementation. Most of the existing works solve this problem in a non constructive way : a target semantics is exhibited first and then only proved correct against the source. We try to show that target semantics can be derived from source semantics in a constructive way and so that some correctness ideas are automatically preserved. The framework is denotational semantics.
9915#A transformation is presented for replacing conventional local attribute references in attribute grammars by upward remote references. The purpose of the transformation is to enhance readability of the grammar and to facilitate easy storage optimization.
9916#In the traditional formulation of attribute grammars (AGs) circularities are not allowed, that is, no attribute-instance in any derivation tree may be defined in terms of itself. Elsewhere in mathematics and computing, though, circular (or recursive) definitions are commonplace, and even essential. Given appropriate constraints, recursive definitions are well-founded, and the least fixed-points they denote are computable. This is also the case for circular AGs.This paper presents constraints on individual attributes and semantic functions of an AG that are sufficient to guarantee that a circular AG specifies a well-defined translation and that circularly-defined attribute-instances can be computed via successive approximation. AGs that satisfy these constraints are called finitely recursive.An attribute evaluation paradigm is presented that incorporates successive approximation to evaluate circular attribute-instances, along with an algorithm to automatically construct such an evaluator. The attribute evaluators so produced are static in the sense that the order of evaluation at each production-instance in the derivation-tree is determined at the time that each translator is generated.A final algorithm is presented that tells which individual attributes and functions must satisfy the constraints.
9917#We present an overview of the design of a machine-code-level, global (intraprocedural) optimizer that supports several front-ends producing code for the Hewlett-Packard Precision Architecture family of machines. The basic optimization strategy is described, including information about the division of responsibilities between various components of the compiler. Optimization algorithms are described, including a discussion of the dataflow information they require. Measurements showing the collective and individual effects of various optimizer components are presented.The performance data presented here was collected using a preliminary version of the optimizer. Development is continuing and further improvements are expected.
9918#We describe, and give experience with, a new method of intraprocedural data flow analysis on reducible flow-graphs[9]. The method is advantageous in imbedded applications where the added value of improved performance justifies substantial optimization effort, but extremely powerful data flow analysis is required due to the code profile.The method is unusual in that (1) various kinds of forward data flow analysis are done simultaneously, so that benefit is derived from informative interactions (e.g. between constant propagation[7] and alias analysis[8]) and (2) we abandon insistence on reaching a least fixed point, allowing us to handle extremely broad classes of information (e.g., inequality of array indices, which implies non-aliasing in array references).We argue that the gain from using a very rich framework more than offsets the loss due to non-minimal fixed points, and justify this with a 'thought experiment' and practical results.
9919#The Experimental Portable Standard Lisp Compiler (EPIC) is a compiler testbed for experimentation with, and development of, Lisp compilation strategies. EPIC uses an architectural description of the target machine to increase portability, and performs extensive optimizations in the form of source-to-source transformations, register allocation, and peephole optimization. It introduces machine-specific instructions early to enable machine-specific optimizations in the initial passes. EPIC produces better code than the original Portable Standard Lisp compiler, has an improved portability model, and is easier to maintain.
9920#Since the introduction of LALR parsing, several algorithms have been presented for the computation of the lookahead sets needed to produce an LALR parser. The algorithm in Aho and Ullman[1] has perhaps received the widest exposure. The recent algorithms by DeRemer and Pennello[2] and Park, Choe, and Chang[4] are the most efficient.A new algorithm has been developed from an algorithm originally based on the Aho and Ullman algorithm and subsequently modified to take advantage of the efficiencies introduced by the DeRemer and Pennello algorithm. The new algorithm performs better than the Park, Choe, and Chang algorithm, and both perform better than the DeRemer and Pennello algorithm. The reasons for the relative performances are easily understood when the algorithms are presented in a common light.
9921#We present a practical technique that provides an LR (0) parser with either fixed or arbitrary look-ahead. The construction algorithm is based on certain paths in the LR (0) state diagram, which must be restricted to a maximum length m. The technique determines the amount of look-ahead required, and the user is spared the task of guessing it. Instead, the user provides m. In situations where single symbol look-ahead is sufficient, the corresponding grammar class (called LAR (m )) is identical to the NQLALR (1) class. For practical grammars that require arbitrary look-ahead, the storage requirements typically do not exceed an amount linear in the size of the corresponding LR (0) parser. The technique is shown to work for a practical programming language grammar, and has been used to solve particular cases of the PL/1 keyword problem.
9922#LR parsers can be made to run 6 to 10 times as fast as the best table-interpretive LR parsers. The resulting parse time is negligible compared to the time required by the remainder of a typical compiler containing the parser.A parsing speed of 1/2 million lines per minute on a computer similar to a VAX 11/780 was achieved, up from an interpretive speed of 40,000 lines per minute. A speed of 240,000 lines per minute on an Intel 80286 was achieved, up from an interpretive speed of 37,000 lines per minute.The improvement is obtained by translating the parser's finite state control into assembly language. States become code memory addresses. The current input symbol resides in a register and a quick sequence of register-constant comparisons determines the next state, which is merely jumped to. The parser's push-down stack is implemented directly on a hardware stack. The stack contains code memory addresses rather than the traditional state numbers.The strongly-connected components of the directed graph induced by the parser's terminal and nonterminal transitions are examined to determine a typically small subset of the states that require parse-time stack-overflow-check code when hardware does not provide the check automatically.The increase in speed is at the expense of space: a factor of 2 to 4 increase in total table size can be expected, depending upon whether syntactic error recovery is required.
9923#In a compiling system that attempts to improve code for a whole program by optimizing across procedures, the compiler can generate better code for a specific procedure if it knows which variables will have constant values, and what those values will be, when the procedure is invoked. This paper presents a general algorithm for determining for each procedure in a given program the set of inputs that will have known constant values at run time. The precision of the answers provided by this method are dependent on the precision of the local analysis of individual procedures in the program. Since the algorithm is intended for use in a sophisticated software development environment in which local analysis would be provided by the source editor, the quality of the answers will depend on the amount of work the editor performs. Several reasonable strategies for local analysis with different levels of complexity and precision are suggested and the results of a prototype implementation in a vectorizing Fortran compiler are presented.
9924#We present a method that combines a deep analysis of program dependences with a broad analysis of the interaction among procedures. The method is more efficient than existing methods: we reduce many tests, performed separately by existing methods, to a single test. The method is more precise than existing methods with respect to references to multi-dimensional arrays and dependence information hidden by procedure calls. The method is more general than existing methods: we accommodate potentially aliased variables and structures of differing shapes that share storage. We accomplish the above through a unified approach that integrates subscript analysis with aliasing and interprocedural information.
9925#Asynchronous CALL statements are necessary in order to use more than one processor in current multiprocessors. Detecting CALL statements that may be executed in parallel is one way to fill this need. This approach requires accurate approximations of called procedure effects. This is achieved by using new objects called Region and Execution Context. An algorithm to find asynchronous CALL statements is given. It involves a new dependence test to compute data dependence graphs, which provides better results than previous ones even when no CALL statements are involved. This method has been implemented in Parafrase and preliminary results are encouraging.
9926#We have completed an implementation of the Russell programming language [Don 85]. This effort has been very helpful in the evaluation of the original language design. It has also served to pinpoint the difficulties in implementing languages with type systems as general as that of Russell.Russell treats both functions and types as data objects which can be freely manipulated by the program. Most operators present in conventional programming languages are viewed as function calls. In spite of this, our compiler produces surprisingly efficient machine code, even with minimal effort invested in the code generator.The generality of the language served to simplify some aspects of the compiler. We focus on the separate compilation mechanism.The most difficult implementation problem is that of inferring typing information omitted by the programmer. We argue that this is an essential part of type checking a language such as Russell. Our current solution is only partially satisfactory.
9927#Static evaluation underlies essentially all techniques for a priori semantic program manipulation, i.e. those that stop short of fully general execution. Included are such activities as type checking, partial evaluation, and, ultimately, optimized compilation.This paper describes a novel approach to static evaluation of programs in functional languages involving infinite data objects, i.e. those using normal order or “lazy” evaluation. Its principal features are abstract interpretation on a domain of demand patterns, and a notion of function “reversal”. The latter associates with each function f a derived function f' mapping demand patterns on f to demand patterns on its formal parameter. This is used for a comprehensive form of strictness analysis, aiding in efficient compilation.This analysis leads to a revised notion of basic block, appropriate as an intermediate representation for a normal order functional language. An implementation of the analysis technique in Prolog is sketched, as well as an effort currently underway to apply the technique to the generation of optimized G-machine code.
9928#Whilst widely recognised as an excellent means for solving problems and for designing software, functional programming languages have suffered from their inefficient implementations on conventional computers. A route to improved runtime performance is to transform recursively defined functions into programs which execute more quickly and/or consume less space. We derive equivalent imperative programming language loops for a large class of linear recursive functions of which the tail-recursive functions form a very small subset. We first identify a small set of primitive function defining expressions for which we determine the corresponding loop-expressions. We then determine the loop-expressions for linear functions defined by any expressions which are formed from those primitives. In this way, a very general class of linear functions can be transformed automatically into loops in the parsing phase of a compiler, since the parser has in any case to determine the hierarchical structure of function definitions. Further transformation may involve specific properties of particular defining expressions, and adopt previous schemes. In addition, equivalent linear functions can be found for many non-linear ones which can therefore also be transformed into loops.
9929#ORBIT: an optimizing compiler for scheme
9930#Extant peephole optimizers can perform many optimizations that are handled by higher-level optimizers. This paper describes a retargetable instruction reorganizer that performs targeting and evaluation order determination by applying a well known algorithm for optimal code generation for expressions to object code. By applying the algorithm to object code after code generation and optimization, a phase ordering problem often encountered by higher-level optimizers is avoided. It minimizes the number of registers and temporaries required to compile expressions by rearranging machine instructions. For some machines, this can result in smaller and faster programs. By generalizing its operation, the reorganizer can also be used to reorder instructions to avoid delays in pipelined machines. For one pipelined machine, it has provided a 5 to 10 percent improvement in the execution speed of benchmark programs.
9931#This paper describes a compiler with a code generator and machine-directed peephole optimizer that are tightly integrated. Both functions are performed by a single rule-based rewriting system that matches and replaces patterns. This organization helps make the compiler simple, fast, and retargetable. It also corrects certain phase-ordering problems.
9932#I have designed and built a compiler construction tool that automates much of the case analysis necessary to exploit special purpose instructions on a target machine. Given a suitable description of the target machine, my analysis identifies instruction sequences that are equivalent to single instructions. During code generation, these equivalences can be used to avoid inefficient instruction sequences in favor of more efficient instructions.I present a working prototype of the instruction set analyzer needed in the framework outlined by [Giegerich 83]. In contrast to the work presented in [Davidson and Fraser 80, 84], I analyze machine descriptions during compiler construction, rather than analyzing instruction sequences that occur during code generation. [R Kessler 84] describes a system which analyzes machine descriptions during compiler construction, but which which is limited to discovering instructions that are equivalent to instruction sequences of length 2. The techniques presented here can identify instruction sequences of arbitrary length that are equivalent to single instructions.I have applied this analysis to the descriptions of two machines, and used the results to replace hand-written case analysis routines in an otherwise table-driven code generator [Henry 84].
9933#Register allocation is an important component of most compilers, particularly those for RISC machines. The SPUR Lisp compiler uses a sophisticated, graph-coloring algorithm developed by Fredrick Chow [Chow84]. This paper describes the algorithm and the techniques used to implement it efficiently and evaluates its performance on several large programs. The allocator successfully assigned most temporaries and local variables to registers in a wide variety of functions. Its execution cost is moderate.
9934#In previous work in global register allocation, the compiler colors a conflict graph constructed from liveness dataflow information, in order to allocate the same register to many variables that are not simultaneously live. If two procedures are in separately compiled modules, however, the compiler must do this allocation separately for each procedure. As a result, the two procedures might use different registers for the same global, or the same register for different locals.We can remove these problems if we delay the register allocation until link time. Our compiler produces object modules that can be linked and run without global register allocation, but includes with each object module a body of information describing how the module uses variables and procedures. A link-time register allocator then decides which variables are used most frequently, selects registers for them, and rewrites the code to reflect the decision that these variables reside in registers rather than in memory. Construction of the call graph allows us to use the same register for locals of procedures that are not simultaneously active, giving us most of the advantages of a full-scale coloring without the expense.When we use our method for 52 registers, our benchmarks speed up by 10 to 25 percent. Even with only 8 registers, the speedup can be nearly that large if we use previously collected profile information to guide the allocation. We cannot do much better, because programs whose variables all fit in registers rarely speed up by more than 30%. Moreover, profiling shows us that we usually remove 60% to 90% of the loads and stores of scalar variables that the program performs during its execution, and often much more.
9935#The complexity of parallel algorithms
9936#Fixpoint semantics
9937#Combination and acquisition of conditional knowledge
9938#A planning model with problem analysis and operator hierarchy
9939#The Odin system: an object manager for extensible software environments
9940#Proving gypsy programs
9941#A solution to the deadlock problem using petri nets implemented in Prolog
9942#A model of syntax-directed transduction of unrestricted grammars using 2PDA with multisymbol matching production rules
9943#The effect of asymmetric deletions on binary search trees
9944#A VLSI architecture for concurrent data structures
9945#Data acquisition for an earth coupled heat pump system
9946#Scan line access memories for high speed image rasterization
9947#A software paradigm for the development of portable multiprocess-oriented computer graphics algorithms
9948#Multiprocessor scheduling with practical constraints
9949#Abstraction and the methodical development of fault-tolerant software
9950#An expert system for harmonization of chorales in the style of J. S. Bach
9951#Distributed, replicated computer bulletin board service
9952#Improved bounds for network flow algorithms with applications
9953#Compile-time type checking for functional programming
9954#Dynamic, distributed resource allocation on regular SW-Banyans
9955#On the formal specification and verification of CIM architectures using LOTOS
9956#Practical aspects of algorithmic solutions to gas pulsation problems of pipeline systems
9957#A Study of fuzzy logic controller robustness using the parameter plane
9958#A provisioning information system (PRINS)
9959#Printed circuit pack (PCP) yield prediction
9960#Standardization aspects on software for CAD of control systems
9961#Microprocessor based ignition controller for the automobile industry
9962#8th symposium `Computer at the University'
9963#High-Tech Buildings '86
9964#CADCAM '86
9965#Machine intelligence
9966#Bicycles and spanning trees
9967#Telephone problems with failures
9968#Adjacency Matrices
9969#Updating LU factorizations for computing stationary distributions
9970#The geometry of m-Sequences: Three-valued crosscorrelations and quadrics in finite projective geometry
9971#On the number of real quadratic factors of polynomials
9972#Labelled graphs with small vertex degrees and P-recursiveness
9973#An analogue of the shannon capacity of a graph
9974#Probabilities for intersecting systems and random subsets of finite sets
9975#On the reduction of a matrix to triangular or diagonal form by consimilarity
9976#Super line-connectivity properties of circulant graphs
9977#Vector computations for sparse linear systems
9978#A generalized parity function and its use in the construction of perfect codes
9979#The characters of the infinite symmetric group and probability properties of the Robinson-Schensted-Knuth algorithm
9980#The number of maximal independent sets in a tree
9981#Efficient vertex- and edge-coloring of outerplanar graphs
9982#Parallel algorithms for nonlinear problems
9983#Balloting labelling and personnel assignment
9984#Generalized binary binomial group testing
9985#The exponential accuracy of Fourier and Chebyshev differencing methods
9986#Spectral methods in time for hyperbolic equations
9987#Higher order single step fully discrete approximations for second order hyperbolic equations with time dependent coefficients
9988#Preconditioning by fast direct methods for nonself-adjoint nonseparable elliptic equations
9989#The approximation of solutions of elliptic boundary-value problems via the p-version of the finite element method
9990#On finite-difference methods for solving discrete-ordinates transport equations
9991#Optimal choice of a truncation level for the truncated SVD solution of linear first kind integral equations when data are noisy
9992#The stability of finite rank methods with applications to integral equations
9993#On the Galerkin and collocation methods for a Cauchy singular integral equation
9994#Refinement methods of Newton type for approximate eigenelements of integral operators
9995#A mesh-independence principle for operator equations and their discretizations
9996#Analogues of Dixon's and Powell's theorems for unconstrained minimization with inexact line searches
9997#Acceleration of convergence of vector sequences
9998#Convergence and stability properties of minimal polynomial and reduced rank extrapolation algorithms
9999#Minimum norm quadratures which satisfy nonstandard interpolating conditions
10000#Optimal inclusion of a solution set
10001#Numerical methods for reflection inverse problems: Convergence and nonimpulsive sources
10002#Approximate Riemann solvers and numerical flux functions
10003#Stable explicit schemes for equations of the Schro¨dinger type
10004#Analyses of spline collocation methods for parabolic and hyperbolic problems in two space variables
10005#The rate of convergence of a class of block Jacobi schemes
10006#Almost globally convergent interval methods for discretizations of nonlinear elliptic partial differential equations
10007#Numerical methods for stiff two-point boundary value problems
10008#A uniformly accurate finite element method for a singular perturbation problem in conservative form
10009#Conditioning of collocation matrices and discrete Green's functions
10010#The order of accuracy for deferred corrections using uncentered end formulas
10011#Some error estimates for the p-version of the finite element method
10012#Stability of collocation at Gaussian points
10013#Quasilinear multistep methods and variable step predictor-corrector methods for neutral functional differential equations
10014#The behavior of differential correction in difficult situations
10015#Object-oriented programming: Themes and variations
10016#Reloading a human memory: A new ethical question for artificial intelligence technology
10017#CYC: Using common sense knowledge to overcome brittleness and knowledge acquistion bottlenecks
10018#Cognitive technologies: The design of joint human-machine cognitive systems
10019#The blackboard model of problem solving
10020#Artificial intelligence: A rand perspective
10021#R & D Cooperation in AI: Report on the U.S. and Japanese panel, IJCAI 1985
10022#Artificial intelligence and ethics: An exercise in the moral imagination
10023#A knowledge system that integrates heterogeneous software for a design application
10024#A simple view of the Dempster-Shafer theory of evidence and its implication for the rule of combination
10025#Recent and current artificial intelligence research in the Department of Computer Science, State University of New York at Buffalo
10026#Artificial intelligence research and applications at the NASA Johnson Space Center
10027#On a class of superlinear sturm Liouville problems with arbitrarily many solutions
10028#Characterizations of the Friedrichs extensions of singular Strum Liouville expressions
10029#Sta¨kel equivalent integrable Hamiltonian systems
10030#Integrability of Klein Gordon equations
10031#On the infinitely many solutions of a semilinear elliptic equation
10032#A maximum principle for an elliptic system and applications to semilinear problems
10033#On the eigenvalue problem for coupled elliptic systems
10034#A sensity dependent diffussion equation in population dynamics: stabilization to equilibrium
10035#Hopf bifurcation in two component flow
10036#Global Hopf bifurcation for Volterra integral equations
10037#Kinetic equations with reflecting boundary conditions
10038#On functions representable as a supremum of a family of smooth functions II
10039#Positivity of the poisson kernel for the continuous q Jacobi polynomials and some quadratic transformation formulas for basic hypergeometric series
10040#Inequalities and numerical bounds for zeros of ultraspherical polynomials
10041#A note to the paper of Ahmed, Muldoon and Spigler
10042#A new proof of Watson's product formula for Laguerre polynomials via a Cauchy problem associated with a singular diffrential operator
10043#An analytical expression for coefficients arising when implementing a technique for indefinite integration of products of special functions
10044#Recurrence relations for the coefficients in Jacobi series solutions of linear differential equations
10045#Invariant curves for mappings
10046#Breakdown of stability in singularly perturbed autonomous systems II. Estimates for the solutions and application
10047#On the global representation of the solutions of second-order linear differential equations having an irregular singularity of rank one in :3WKby series in terms of confluent hypergeometric functions
10048#Disconjugacy and comparison theorems for second order linear systems
10049#Evolution problems with hysteresis in the source term
10050#On the fractal dimension of attractors for viscous incompressible fluid flows
10051#Existence and control of plasma equilibrium in a Tokamak
10052#The scalar Riemann problem in two spatial dimensions: piecewise smoothness of solutions and its breakdown
10053#On the identification of parameters in general variational inequalities by asymptotic regularization
10054#Real continued fractions and asymptotic expansions
10055#Borel summability and converging factors for some everywhere divergent series
10056#Nielsen's generalized polylogarithms
10057#p ary sequency and orderings of the Chrestenson functions
10058#Another conjectured :9q Selberg integral
10059#q Wilson functions of the second kind
10060#Erratum and addendum: analytic functions related to the distributions of exponential growth
10061#The linear quadratic optimal control problem with delays in state and control variables: a state space approach
10062#Riccati equations for hyperbolic partial differential equations with L2(0,T;L2(γ)) dirichlet boundary terms
10063#Estimation of coefficients and boundary parameters in hyperbolic systems
10064#Similarity and reduction for time varying linear systems with well posed boundary conditions
10065#Large deviations estimates for systems with small noise effects, and applications to stochastic systems theory
10066#Invariance concepts in infinite dimensions
10067#Diffusions for global optimizations
10068#Necessary and sufficient conditions for isolated local minima of nonsmooth functions
10069#Solving the linear complementarity problem in circuit simulation
10070#The matching of nonlinear models via dynamic state feedback
10071#On the sensitivity minimization problem for linear time varying periodic systems
10072#Differential games and directional derivatives of viscosity solutions of Issacs' equations II
10073#Generalized solutions of constrained optimization problems
10074#Symmetry and stability in Taylor Couette flow
10075#Bifurcations in doubly diffusive systems III. Interaction of equilibrium and time periodic solutions
10076#Secondary bifucations of a thin rod under axial compression
10077#Exact boundary conditions at an artificial boundary for partial differential equations in cylinders
10078#Chemical surface reactions and nonlinear stability by the method of energy
10079#On the spectral properties of a class of elliptic functional differential operators arising in feedback control theory for diffusion processes
10080#On the construction of series solutions to the first biharmonic boundary value problem on a rectangle
10081#Abstract nonlinear Volterra equations with positive kernels
10082#Eigenvalues of differentiable positive definite kernels
10083#Positive definite CP kernels
10084#Uniform asymptotic solutions of a class of second order linear differential equations having a turning point and a regular singularity, with an application to Lengendre functions
10085#Asymptotic behavior of the invariant density of a diffusion Markov process with small diffusion
10086#Electrostatics and the zeros of the classical polynomials
10087#In a new institution, planning a Macintosh network proceeded in step with planning a campus and a library building. The initial installation connected twenty-five Macintosh and DOS computers, and four network printers using Farallon Computing PhoneNet system LocalTalk hubs, wiring, and connectors. After three years of growth, the network consists of over fifty devices, including servers, netmodem, router, and Internet gateway. Migration toward individual microcomputer connections to Ethernet and CD-ROM servers is under development.
10088#Generalized of Zemanian spaces of generalized functions which have orthonormal series expansions
10089#Analyticity spaces of self adjoint operators subjected to perturbations with applications to Hankel invariant distribution spaces
10090#Theoretical and numerical structure for reacting shock waves
10091#A multigrid continuation method for elliptic problems with folds
10092#On an adaptive grid refining technique for finite element approximations
10093#Computing the CS decomposition on systolic arrays
10094#Computing the generalized singular value decomposition
10095#Computing the singular value decompostion of a product of two matrices
10096#Computing the polar decomposition with applications
10097#Condition number estimators in a sparse matrix software
10098#On general row merging schemes for sparse given transformations
10099#A linear time implementation of profile reduction algorithms for sparse matrices
10100#The operator compact implicit method for fourth order ordinary differential equations
10101#An investigation into th stability properties of second derivative methods using perfect square iteration matrices
10102#Continuation and local perturbation for multiple bifurcations
10103#On the reconciliation of clashing boundary conditions in cell discretization
10104#Linear inversion of ban limit reflection seismograms
10105#Inverse scattering with noisy data
10106#A simple approximate random choice method for scalar conservation laws
10107#A Monte Carlo method for scalar reaction diffusion equations
10108#Convergence of random method with creation of vorticity
10109#Cancellation errors in quasi Newton methods
10110#Misclassification probabilities for quadratic discrimination
10111#Integration in finite terms with special functions: the logarithmic integral
10112#An amortized analysis of insertions into AVL trees
10113#The signature of a plane curve
10114#Self adjusting heaps
10115#The complexity of languages generated by attribute grammars
10116#Upper and lower time bounds for parallel random access machines without simultaneous writes
10117#The Boyer Moore Galil string searching strategies revisited
10118#Efficient simulations among several models of parallel computers
10119#An O(EV log V) algorithm for finding a maximal weighted matching in general graphs
10120#Optimal termination protocols for network partitioning
10121#Computational complexity: on the geometry of polynomials and a theory of cost: II
10122#A provably good algorithm for the two module routing problem
10123#Alphabetic minimax trees of degree atmost t
10124#On shortest paths in polyhedral spaces
10125#An efficient algorithm for generating linear transformations in a shuffle exchange network
10126#Variable sized bin packing
10127#Logarithmic depth circuits for algebraic functions
10128#Algebraic computations of scaled pade´ fractions
10129#Average case complete problems
10130#The ultimate planar convex hull algorithm
10131#Computing the largest empty rectangle
10132#Simple general approximations for a random variable and its inverse distribution function based on linear transformation of a nonskewed variate
10133#An exhaustive analysis of multiplicative congruential random number generators with modulus 231-1
10134#Numerical solutions for Bayes sequential decision problems
10135#Computations of mixtures of dirichlet processes
10136#Finite algorithms for Huber's m estimator
10137#Numerical methods foB]robust regression: linear models
10138#A new method in order of determine the most significant members within a large sample, in problems of surface approximations
10139#Computing thr minimum eigenvalue of a symmetric positive definite Toeplitz matrix
10140#Solution of systems of complex linear equations in the l∞0E norm with constraints on the unknowns
10141#Efficient algorithms for computing the condition number of a tridagonal matrix
10142#A note on monitoring the stability of triangular decomposition of sparse matrices
10143#An algorithm for simultaneous orthogonal transformation of several positive definite symmetric matrices to nearly diagonal form
10144#RGSD an algorithm for computing the Kronecker structure and reducing subspaces of singular A-&lgr;B pencils
10145#A Hamiltonian QR algorithm
10146#Front tracking applied to Rayleigh Taylor instability
10147#A front tracking method for one dimensional moving boundary problems
10148#A general family of nodal schemes
10149#A finite difference scheme for the equilibrium equations of elastic bodies
10150#Fully adaptive solutions of one dimensional mixed initial boundary value problems with applications to unstable problems in combustion
10151#Interpolation schemes for collocation solutions of two point boundary value problems
10152#Smoother interpolants for Adams codes
10153#Implementing dense linear algebra algorithms using multitasking on the CRAY X-MP-4 (or approaching the Gigaflop)
10154#A knowledge-based human-computer cooperative system for ill-structured management domains
10155#A discrete control model of operator function: A methodology for information dislay design
10156#Information management of drug-drug interactions based on a formal representation
10157#A relational approach to monitoring controls
10158#A reward scheme for production systems with overlapping conflict sets
10159#What can we learn from experiments in multiobjective decision analysis?
10160#Fourier coding and reconstruction of complicated contours
10161#The manufacturing game: A formal approach to manufacturing software
10162#A syntactic approach to three-dimensional object recognition
10163#The emergence of Zipf's law: Spontaneous encoding optimization by users of a command language
10164#Generalization in operational contexts: What does it mean? Can it be done?
10165#Aesthetics and the decision sciences
10166#Generalization in decision research: the role of formal models
10167#Two views of generality
10168#Knowledge representation and utilization for optimal route search
10169#IMOLP: An iteractive method for multiple objective linear programs
10170#Bounded utilities and ruin constraints
10171#A rule-based model for the human operator in a time-constrained competing-task environment
10172#Database queries with fuzzy linguistic quantifiers
10173#Similarity measures based on a fuzzy set model and application to hierarchical clustering
10174#The use of multiple sources for the modeling and coding of nonstationary images
10175#Subjective MSE measures
10176#On measuring the complexity of monitoring and controlling large-scale systems
10177#Adaptive pattern recognition with random costs and its applications to decision trees
10178#A systems approach to three-dimensional multibody systems using graph-theoretic models
10179#Nonlinear programs with complicating variables: Theoretical analysis and numerical experience
10180#Open-loop experiments for modeling the human eye movement system
10181#Synthesizing knowledge: A cluster analysis approach using event covering
10182#Fuzzy set theory in medical diagnosis
10183#GISMO: A visual problem-structuring and knowledge-organization tool
10184#Default and inexact reasoning with possibility degrees
10185#A user preference guided approach to conflict resolution in rule-based expert systems
10186#Fuzzy information retrieval based on a fuzzy pseudothesaurus
10187#Absorbing and ergodic discretized two-action learning automata
10188#Bootstrapping ARMA models: Some simulations
10189#Adaptive least squares for parametric spectral estimation and its appliction to pulse estimation and deconvolution of seismic data
10190#Optimal edge detector evaluation
10191#Image multmodeling and a two-dimensional multicategory Wiener filter
10192#Lexicographic codes, or lexicodes, are defined by various versions of the greedy algorithm. The theory of these codes is closely related to the theory of certain impartial games, which leads to a number of surprising properties. For example, lexicodes over an alphabet of sizeB=2^{a}are closed under addition, while ifB = 2^{2^{a}}the lexicodes are closed under multiplication by scalars, where addition and multiplication are in the nim sense explained in the text. Hamming codes and the binary Golay codes are lexieodes. Remarkably simple constructions are given for the Steiner systemsS(5,6,12)andS(5,8,24). Several record-breaking constant weight codes are also constructed.
10193#An(n, k, d)linear code overF=GF(q)is said to be {em maximum distance separable} (MDS) ifd = n - k + 1. It is shown that an(n, k, n - k + 1)generalized Reed-Solomon code such that2leq k leq n - lfloor (q - 1)/2 rfloor (k neq 3 {rm if} qis even) can be extended by one digit while preserving the MDS property if and only if the resulting extended code is also a generalized Reed-Solomon code. It follows that a generalized Reed-Solomon code withkin the above range can be {em uniquely} extended to a maximal MDS code of lengthq + 1, and that generalized Reed-Solomon codes of lengthq + 1and dimension2leq k leq lfloor q/2 rfloor + 2 (k neq 3 {rm if} qis even) do not have MDS extensions. Hence, in cases where the(q + 1, k)MDS code is essentially unique,(n, k)MDS codes withn > q + 1do not exist.
10194#An approach for efficient utilization of fast Hadamard transform in decoding binary linear block codes is presented. Computational gain is obtained by employing various types of concurring codewords, and memory reduction is also achieved by appropriately selecting rows for the generator matrix. The availability of these codewords in general, and particularly in some of the most frequently encountered codes, is discussed.
10195#Jamming is studied as a game in the binary adder channel. The legal user controls simultaneously the encoder and the decoder by the choice of a key; the jammer controls the channel by the choice of an interference signal. For any given pair of encoder and decoder, this leads to a two-person zero-sum game. It is shown that this game can be solved in many cases of interest. In particular, an exact measure of performance is derived for the class of so-called direct sequence systems.
10196#A modified differential encoding structure is proposed and optimized based upon the concept of preposterior analysis from the theory of alphabet-constrained data compression. Using preposterior analysis, the quantizer input sequence is chosen to minimize the expected distortion over a fixed but arbitrary interval, say,Nsamples long. By computing the expected distortion over future inputs, preposterior analysis allows future behavior to be modeled, but without an encoding delay as in tree coding. The optimized quantizer input sequence is not simply the prediction error as in classical differential pulse code modulation, but it is a weighted combination of the current prediction error and past encoding errors. The optimization is accomplished using a backward dynamic programming argument.
10197#Shannon's two-way channel problem has attracted the attention of information theorists for many years. In a classic paper Shannon gave both an outer and an inner bound to the capacity region of the two-way channel. Schalkwijk recently obtained an improvement to the inner bound for the Blackwell multiplying channel (BMC). We present the first improvements on Shannon's outer bound. Calculation shows that our results are close to optimum when applied to the BMC.
10198#The source coding problem is considered for secret sharing communication systems (SSCS's) with two or three channels. The SSCS, where the informationXis shared and communicated through two or more channels, is an extension of Sbannon's cipher communication system and the secret sharing system. The security level is measured with equivocation; that is,(1/N)H(X|W_{i}), (1/N)H(X|W_{i}W_{i}), etc., whereW_{i}andW_{j}are the wire-tapped codewords. The achievable rate region for the given security level is established for the SSCS's with two or three channels.
10199#An algorithm for solving a discrete-time Wiener-Hopf equation is presented based upon Euclid's algorithm. The discrete-time Wiener-Hopf equation is a system of linear inhomogeneous equations with a given Toeplitz matrix M, a given vector b, and an unknown vectorlambdasuch thatMlambda = b. The algorithm is able to find a solution of the discrete-time Wiener-Hopf equation for any type of Toeplitz matrices except for the all-zero matrix, while the Levinson algorithm and the Trench algorithm are not available when at least one of the principal submatrices of the Toeplitz matrixMis singular. The algorithm gives a solution, if one exists, even when the Toeplitz matrixMis singular, while the Brent-Gustavson-Yun algorithm only states that the Toeplitz matrixMis singular. The algorithm requiresO(t^{2})arithmetic operations fortunknowns, in the sense that the number of multiplications or divisions is directly proportional tot^{2}, like the Levinson and Trench algorithms. Furthermore, a faster algorithm is also presented based upon the half greatest common divisor algorithm, and hence it requiresO(t log^{2} t)arithmetic operations, like the Brent-Gustavson-Yun algorithm.
10200#For a complex-valued deterministic signal of finite energy band-limited to the normalized frequency band|w| leq piexplicit coefficients{a_{kn}}are found such that for anyTsatisfying0 < T leq 1/2,left| f(t)-sum^{2n}_{k=1}a_{kn}f(t - kT)right| leq E_{f}cdot beta^{n}whereE_{f}is the signal energy andbeta doteq 0.6863. Thus the estimate off(t)in terms of2npast samples taken at a rate equal to or in excess of twice the Nyquist rate converges uniformly at a geometric rate tof(t)on(- infty , infty). The suboptimal coefficients{a_{kn}}have the desirable property of being pure numbers independent of both the particular band-limited signal and of the selected sampling rate1/T. It is also shown that these same coefficients can be used to estimate the value ofx(t)of a wide-sense stationary random process in terms of past samples.
10201#New "instrumental" tests for detecting and diagnosing changes in the poles of a signal having unknown time-varying zeros are proposed. Numerical results for nonstationary scalar signals are given. The extension of these tests to the vector case may be used for vibration monitoring.
10202#A new form of the extended Yule-Walker equations of a stationary autoregressive moving-average (ARMA) scheme is proposed. An algorithm using the new form is also given for calculating the parameters of the ARMA process from its autocovariance function without a proof of its convergence.
10203#A nonlinear phase estimator for a phase-shift keyed (PSK)-modulated carrier has been developed by Viterbi and Viterbi. Their analysis is extended, and an optimal or "matched" nonlinearity is derived for the estimator.
10204#It is shown that the number of de Bruijn sequences of ordernand linear complexitycis not a multiple of four for everynandc.
10205#Nondegenerate quadrics of PG(2l, 2^{s})have been used to construct ternary sequences of length(2^{2sl+1} - 1)/(2^{s} - 1)with perfect autocorrelation function. The same construction can be used for degenerate quadrics for this case as well as quadrics of PG(N,q), withNarbitrary andq = p^{s}, for any primep. This is possible because it is shown that ifQ subseteq {rm PG} (N, q)is a quadric, possibly degenerate, that has the same size as a hyperplane, then, providedQitself is not a hyperplane, the hyperplanes of PG(N,q)intersectQin three sizes. These sizes depend on whetherNis even or odd and the degeneracy ofQ. Finally, a connection to maximum period linear recursive sequences is made.
10206#The problem of recursively estimating the unknown parameters of a scalar autoregressive (AR) signal observed in additive white noise, including signal power and noise variance, is considered. A state-space model in a canonical but noninnovations form is used to represent the noisy AR signal. An algorithm based on a system identification/parameter estimation technique known as the recursive prediction error method is presented for recursive parameter estimation. Two simulation examples illustrate the effectiveness of the proposed algorithm.
10207#A class of infinitepm 1sequences is presented whose autocorrelation function is zero for all nonzero shifts.
10208#Bounds on the coding capacity of Gaussian channels are obtained when the power constraint on the signal is mismatched to the channel noise. In the case of some feedback channels in which the noise has a Cramér-Hida representation of finite multiplicity, an exact expression for the coding capacity is given.
10209#Using earlier methods a combinatorial upper bound is derived for|C|. cdot |D|, where(C,D)is adelta-decodable code pair for the noisy two-access binary adder channel. Asymptotically, this bound reduces toR_{1}=R_{2} leq frac{3}{2} + elog_{2} e - (frac{1}{2} + e) log_{2} (1 + 2e)= frac{1}{2} - e + H(frac{1}{2} - e) - frac{1}{2}H(2e),wheree = lfloor (delta - 1)/2 rfloor /n, n rightarrow inftyandR_{1}resp.R_{2}is the rate of the codeCresp.D.
10210#Rueppel has conjectured that, for allngeq 1, the subsequence consisting of the firstndigits of the binary sequence(1,1,0,1,0,0,0,1,0^{7},1,0^{15},1, cdots )has linear complexitylfloor (n + 1)/2 rightfloor. This conjecture is proved, and a minimum length generator is found for eachn. The proof utilizes properties of an element in an extension field of the field of rational functions over GF(2).
10211#Recently Ernvall has characterized all the modulimfor which the arithmetic distance induces a metric ofZ_{m}. This gives us several new classes of moduli for which it is natural to study the properties of arithmetic codes. We shall consider the existence of binary perfect arithmetic codes.
10212#The blowing-up lemma says that if the probability with respect to a product measure of a setAsubseteq {cal X}^{n} ({cal X}finite,nlarge) is not exponentially small, then itsl_{n}-neighborhood has probability almost one for somel_{n} = O(n). Here an information-theoretic proof of the blowing-up lemma, generalizing it to continuous alphabets, is given.
10213#In many linear predictive coding (LPC) speech compression systems the encoding of the LPC parameters is performed using a product code book scheme. One possible approach consists in organizing the set of LPC reproduction models as the Cartesian product of a vector code book describing the shape of each reproduction LPC model and a scalar codebook describing the gain or energy. We first present a formal development of rate-distortion theoretic results for distortion functions based on quotients of input and reproduction symbols. We also obtain theoretical bounds for the rate-distortion function of the gain term of LPC systems (which, depending on the quantization scheme, can use about10-25percent of the transmission rate), as well as asymptotic (small distortions) approximations to the performance of the optimal scalar quantizer for these gain terms, when the overall fidelity criterion is the Itakura-Saito distortion measure, which is a member of the class of quotient distortion measures. The approximations and bounds are compared finally with experimental results.
10214#The generalized Lloyd algorithm for vector quantizer design is analyzed as a descent algorithm for nonlinear programming. A broad class of convex distortion functions is considered and any input distribution that has no singular-continuous part is allowed. A well-known convergence theorem is applied to show that iterative applications of the algorithm produce a sequence of quantizers that approaches the set of fixed-point quantizers. The methods of the theorem are extended to sequences of algorithms, yielding results on the behavior of the algorithm when an unknown distribution is approximated by a training sequence of observations. It is shown that as the length of the training sequence grows large that 1) fixed-point quantizers for the training sequence approach the set of fixed-point quantizers for the true distribution, and 2) limiting quantizers produced by the algorithm with the training sequence distribution perform no worse than limiting quantizers produced by the algorithm with the true distribution.
10215#For a class of stationary Gaussian sources and the squared-error distortion measure, an asymptotically optimal tree coding scheme is derived using tree codes with finite branch length. The distribution of the reproduction process is derived in an explicit form, and using the random coding argument and results from the theory of branching processes with stationary ergodic environmental processes, the source coding theorem is proved. The theorem is applicable to all Gaussian sources with a power spectrum that satisfies the Lip 1 condition with no restriction on the coding rate.
10216#The error-trapping technique, whenever applicable, is easy to implement. Here we investigate the capability of this technique, specially based on the permutation decoding concept. The object is to give exact lower bounds on the code lengthn, for givenk, of the "multiple-error-correcting'' binary(n, k, t)cyclic codes by applying cyclic(T)and squaring(U)(or square rooting) group(T, U)permutations for1)two-step(T, U)permutation decodable codes(todd- and even-valued) and2)three-step(T,U)permutation decodable codes(todd-valued andt = 2). Finally, some general results are presented for the codes that are not permutation decodable for the specific(T, U)group permutations. The derivation of the results involves only the symbol positions of the errors, and consequently, the results are directly applicable to cyclic codes over GF(2^{m}).
10217#Techniques are presented for the construction of error-correcting codes for semiconductor memory subsystems that are organized in a multibit-per-chip manner. These codes are capable of correcting all single-byte errors and detecting all double-byte errors, where a byte represents the number of bits that are fed from the same chip to the same codeword.
10218#Schemes are developed whereby the number of arithmetic operations needed in a fast finite field transform employing factor-type algorithms are decreased by using a chord property of the intermediate variables. Noticeable improvements in both the Good and the Cooley-Tukey forms of fast algorithms are possible. A proof of the limited chord properties of the intermediate variable is included, and several numerical examples for comparison purposes are given.
10219#The structure and performance of a maximum likelihood (ML) receiver for reception in spatially distributed interference channels when a multielement array capability is available are described. Under the assumption of Gaussian interference, the receiver consists of an optimum ML array processor followed by a sequence estimator implemented using the Viterbi Algorithm. Numerical results are provided to illustrate the symbol error probability performance of this optimum ML receiver. A completely adaptive realization of this scheme is described with performance illustrated through simulation.
10220#A model that accounts for uncertain data dependency is developed by generating a large class of stationary stochastic processes, each with the same univariate distribution. This class can be considered to be a contamination class about the nominal independent and identically distributed (i.i.d.) process distribution. The class is developed specifically for application to robust detector and estimator design based on asymptotic variance. Application of this dependency class leads to an intuitively pleasing result: the minimax variance estimators and the maximin efficacy detectors are the same as obtained using i.i.d, asymptotic estimation and detection theory. Thus our technique generalizes previously obtained robust design results for i.i.d, data to this dependent data case.
10221#The problem of detecting a change from one given stationary and ergodic stochastic process to another such process is considered. It is assumed that both stochastic processes are processes with memory and that they are mutually independent. A sequential test is proposed and analyzed. It is proved that the proposed test is asymptotically optimal in a mathematically precise sense.
10222#The minimum cross entropy spectral analysis procedure (a generalization of maximum entropy spectral analysis) is formulated as a convex programming problem, and its unconstrained dual convex programming problem is shown. In this dual setting the Lagrange multipliers are precisely the dual variables, and the numerical solution values are easily determined by any of a number of nonlinear programming codes. This result vastly simplifies the computation of all such spectral density estimates.
10223#The statistical analysis of recursive nonlinear filters is generally difficult. The analysis of recursive median filters has been limited to the trivial cases of signals with a small number of quantization levels and to small window sizes. A block state description of recursively filtered signals is developed, and by applying this description to threshold decomposition, closed-form expressions for the statistics of recursive median filters are obtained. In this case, the number of quantization levels and the window size do not increase the analysis complexity since the output statistics depend on the distribution of a single-threshold filtered binary signal. The statistical decomposition is also developed for nonrecursive median filter operations yielding a connection from classical order statistics to the threshold decomposition approach. Finally, some statistical properties are derived for recursively median-filtered signals.
10224#Recursive estimation of the univariate probability density functionf(x)for stationary processes{X_{j}}is considered. Quadratic-mean convergence and asymptotic normality for density estimatorsf_{n}(x)are established for strong mixing and for asymptotically uncorrelated processes{X_{j}}. Recent results for nonrecursive density estimators are extended to the recursive case.
10225#Two-dimensional (2-D) spectrum estimation from raw data is of interest in signal and image processing. A parametric technique for spectrum estimation using 2-D noncausal autoregressive (NCAR) models is given. The NCAR models characterize the statistical dependency of the observation at location s on its neighbors in all directions. This modeling assumption reduces the spectrum estimation problem to two subproblems: the choice of appropriate structure of the NCAR model and the estimation of parameters in NCAR models. By assuming that the true structure of the NCAR model is known, we first analyze the existence and uniqueness of Gaussian maximum likelihood (GML) estimates of NCAR model parameters. Due to the noncausal nature of the models, the computation of GML estimates is burdensome. By assuming specific boundary conditions, computationally tractable expressions are obtained for the likelihood function. Expressions for the asymptotic covariance matrix of the GML estimates as well as the simultaneous confidence bands for the estimated spectrum using GML estimates are derived. Finally, the usefulness of the method is illustrated by computer simulation results.
10226#We study the computational complexity of the art gallery problem originally posed by Klee, and its variations. Specifically, the problem of determining the minimum number of vertex guards that can see ann-wall simply connected art gallery is shown to be NP-hard. The proof can be modified to show that the problems of determining the minimum number of edge guards and the minimum number of point guards in a simply connected polygonal region are also NP-hard. As a byproduct, the problem of decomposing a simple polygon into a minimum number of star-shaped polygons such that their union is the original polygon is also shown to be NP-hard.
10227#We show that binary cyclic codes of lengthn = 2^{m} - 1with generatorg(x)=m_{1}(x)m_{7}(x)have minimum distance< 5unlessm = 5(and possiblym = 11, 13, or 17).
10228#It is shown that a cyclic codeCof lengthqover GF(q)is the maximum distance separable if and only if either1) qis a prime, in which caseCis equivalent, up to a coordinate permutation, to an extended Reed-Solomon code, or2) Cis a trivial code of dimensionk in {1, q - 1, q }. Hence there exists a nontrivial cyclic extended Reed-Solomon code of lengthqover GF(q)if and only ifqis a prime.
10229#Massey and Omura recently developed a new multiplication algorithm for Galois fields based on the normal basis representation. This algorithm shows a much simpler way to perform multiplication in finite field than the conventional method. The necessary and sufficient conditions are presented for an element to generate a normal basis in the field GF(2^{m}), wherem = 2^{k}p^{n}andp^{n}has two as a primitive root. This result provides a way to find a normal basis in the field.
10230#It is shown that the Fisher information matrix appropriate to estimation of the parameters of a multitone signal by use of equally spaced samples is singular only if duplicates modulo2pi /Texist among the tone frequencies. This confirms a hypothesis of Rife and Boorstyn.
10231#The problem of representing a Markov process as a reverse-time Markov process is discussed. Diffusions and finite-state Markov processes are two important classes of Markov processes for which this problem has been considered. A gap in a paper of Castanon is pointed out which discusses diffusions; reverse-time finite and discrete-state Markov processes are then considered using martingale methods.
10232#The discrete-time detection of a constant signal in corrupting noise is considered. First the case where the noise is independent and identically distributed is considered, and the criterion of asymptotic relative efficiency is employed to investigate the effect on the detector's performance induced by altering the form of the detector nonlinearity from that of the locally optimal nonlinearity. The results show that the resultant degradation in performance can be bounded in terms of theL_{2}distance between the locally optimal nonlinearity and the nonlinearity of interest. We then extend our results to the case of weakly dependentphi-mixing noise and see that, in particular, asymptotic relative efficiency can be viewed as a mapping between metric spaces that is continuous at the point of interest.
10233#An asymptotic formula is derived for the Cramer-Rao lower bound on unbiased estimates of the parameters of Gaussian autoregressive moving-average (ARMA) processes, in the case where the measurements are not contiguous, but follow a periodic pattern of misses. The formula is then used to illustrate the behavior of the bound for some specific examples.
10234#Estimation of the value of a regression function at a point of continuity using a kernel-type estimator is considered and improvements by a jackknife technique are discussed. It is seen that a so-called generalized jackknife estimator asymptotically improves upon an ordinary kernel-type estimator. However, for a fixed sample size the generalized jackknife method may inflate the mean-square error.
10235#The parameter estimation problem for counting process observation is considered. It is assumed that the intensity of the counting process is adapted to the family of o-algebras generated by the counting process itself and that the intensity depends linearly on some deterministic constant parameters. An on-line parameter estimation algorithm is then presented for which convergence is proved by using a stochastic approximation type lemma.
10236#A class of suboptimal Wiener filters is considered, and their computational and statistical performances (and the trade-off between the two) are studied and compared with those for known classes of suboptimal Wiener filters. A general model of a suboptimal Wiener filter over a group is defined, which includes, as special cases, the known filters based on the discrete Fourier transform (DFT) in the case of a cyclic group and the Walsh-Hadamard transform (WHT) in the case of a dyadic group. Statistical and computational performances of various group filters are investigated. The cyclic and the dyadic group filters are known to be computationally the best ones among all the group filters. However, they are not always the best ones statistically and other (not necessarily Abelian) group filters are studied. Results are compared with those for the cyclic group filters (DFT), and the general problem of selecting the best group filter is posed. That problem is solved numerically for small-size signals(leq 64)for the first-order Markov process and random sine wave corrupted by white noise. For the first-order Markov process with the covariance matrixB^{(S,l)} = rho^{|s-l|}asrhoincreases, the use of various non-Abelian groups results in improved statistical performance of the filter as compared to the DFT. Similarly, for the random sine wave with covariance matrixB^{(s,l)} = cos lambda (s - l)aslambdadecreases, non-Abelian groups result in a better statistical performance of the filter than the DFT does. However, that is compensated for by the increased number of computations to perform the filtering.
10237#To use probabilistic functions of a Markov chain to model certain parameterizations of the speech signal, we extend an estimation technique of Liporace to the eases of multivariate mixtures, such as Gaussian sums, and products of mixtures. We also show how these problems relate to Liporace's original framework.
10238#A simple approach to the adaptation of a linear filter to cope with spectral uncertainties is presented. Based on the calculation of the total output error power, including the errors of spectral estimation, a criterion is proposed for deciding whether the estimated filter is effective at any given frequency. By forcing the filter response to unity at all ineffective frequencies, an improvement in performance is obtained.
10239#A method for spectral calculation ofq-ary digital signals encoded byp-ary convolutional codes is developed. We have assumed a parallel encoding process such that for a code with ratek/nand constraint lengthm, the encoder can be modeled as a Mealy machine ofkinputs,noutputs, and(m - 1) kq-ary memory cells. From this model and from the generator matrix of the code, the characterizing matrices of the Mealy machine are found in a straightforward way. Two assumptions are made on the statistics of the input signal. 1) The input sequence is a wide-sense stationary vector process of dimensionk. 2) The input vectors are statistically independent. With these assumptions and from the characterizing matrices of the Mealy machine, the method developed by Cariolaro and Tronca can be readily used. The continuous and discrete components of the spectrum of the coded signal are expressed in matrix form, which is particularly appropriate for computer programming.
10240#It is shown that in a digital communication system that uses an(N,K)linear code, the symbol error rate, measured on the information symbols, is a function of the encoderGused for the code. An algorithm is proposed, identical in nature to that encountered in unequal error protection codes, for finding an optimal linear encoderG_{0}that minimizes the symbol error rate for a fixed complete standard array decoder.
10241#Motivated by a problem in optical communication, we consider the general problem of maximizing the entropy of a stationary random process that is subject to an average transition cost constraint. Using a recent result of Justesen and Hoholdt, we present an exact solution to the problem and suggest a class of finite state encoders that give a good approximation to the exact solution.
10242#The classical result of Lloyd for the optimum scalar quantizer in the asymptotic case of fine quantization is derived from first principles. The derivation is offered as a simple alternative to Lloyd's original and elegant piece of analysis, and the result is used to derive the optimum compander. We then show why a compander that presents uniformly distributed random variables to the quantizer is not a good idea.
10243#Proc. of the 1986 third annual conference, Vol. 1 on Electronic printing systems: directions in digital imaging
10244#The use of database systems for managerial decision making often incorporates information-retrieval capabilities with numeric report generation. Of great concern to the user of such a system is the response time associated with issuing a query to the database. This study presents a procedure for estimating response time for one of the most frequently encountered physical storage mechanisms, the indexed file. The model provides a fairly high degree of accuracy, but is simple enough so that the cost of applying the model is not exorbitant. The model incorporates the knowledge that the distribution of access key occurrences is known to follow Zipf's law. It first estimates the access time required to complete the query, which includes the time needed for all input and output transactions, and CPU time used in performing the search. The effects of multiple users on an individual's response time are then assessed using a simple regression estimation technique. The two-step procedure allows for the separation of access time from multiuser influences.
10245#We consider nested relations whose schemes are structured as trees, called scheme trees, and introduce a normal form for such relations, called the nested normal form. Given a set of attributes U, and a set of multivalued dependencies (MVDs) M over these attributes, we present an algorithm to obtain a nested normal form decomposition of U with respect to M. Such a decomposition has several desirable properties, such as explicitly representing a set of full and embedded MVDs implied by M, and being a faithful and nonredundant representation of U. Moreover, if the given set of MVDs is conflict-free, then the nested normal form decomposition is also dependency-preserving. Finally, we show that if M is conflict-free, then the set of root-to-leaf paths of scheme trees in nested normal form decomposition is precisely the unique 4NF decomposition [9, 16] of U with respect to M.
10246#End-to-end transport protocols continue to be an active area of research and development involving (1) design and implementation of special-purpose protocols, and (2) reexamination of the design and implementation of general-purpose protocols. This work is motivated by the perceived low bandwidth and high delay, CPU, memory, and other costs of many current general-purpose transport protocol designs and implementations. This paper examines transport protocol mechanisms and implementation issues and argues that general-purpose transport protocols can be effective in a wide range of distributed applications because (1) many of the mechanisms used in the special-purpose protocols can also be used in general-purpose protocol designs and implementations, (2) special-purpose designs have hidden costs, and (3) very special operating system environments, overall system loads, application response times, and interaction patterns are required before general-purpose protocols are the main system performance bottlenecks.
10247#From sand to circuits: and other inquiries
10248#Personal bibliographic indexes and their computerisation
10249#Quality control in automation
10250#Stochastic adaptive control for exponentially convergent time-varying systems
10251#Quasi-variational inequalities and ergodic impulse control
10252#The pencil (sE–A) and controllability-observability for generalized linear systems: a geometric approach
10253#Intractable problems in control theory
10254#Stochastic minimization with constant step-size: asymptotic laws
10255#An exact formula for a linear quadratic adaptive stochastic optimal control law
10256#Sufficient optimality conditions for stratified control problems
10257#The gradient projection method using Curry's steplength
10258#An RKH space approach to state feedback control for a class of linear stochastic systems
10259#Higher order conditions with and without lagrange multipliers
10260#Nilpotent approximations of control systems and distributions
10261#Legendre-Tau approximations for functional differential equations
10262#Finite time controllers
10263#A multi-response quadratic control problem
10264#Open loop control of water waves in an irregular domain
10265#Finite dimensional compensators for infinite dimensional systems with unbounded input operators
10266#Minimal order estimation of multivariable discrete-time stochastic linear system
10267#Iterative techniques for the Nash solution in quadratic games with unknown parameters
10268#On the Hessian of Lagrangian and second order optimality conditions
10269#Necessary conditions for a domain optimization problem in elliptic boundary value problems
10270#Differential games of generalized pursuit and evasion
10271#Dynamical realizations of homogeneous Hamiltonian systems
10272#Minimum variance control of discrete time multivariable Armax systems
10273#Existence theorems for optimal control and calculus of variations problems where the states can jump
10274#Optimal control for variational inequalities
10275#On the efficiency and optimality of allocations II Nikolaos
10276#An approach to simultaneous system design, I. Semialgebraic geometric methods
10277#State estimation and control of conditionally linear systems
10278#Global realizations of analytic input-output mappings
10279#Identifiability of spatially-varying conductivity from point observation as an inverse Sturm-Liouville problem
10280#Hyperbolic state space decomposition for a linear stochastic delay equation
10281#Optimal control with state-space constraint I
10282#Decoupling nonlinear systems, noncommutative generating power series and Lie algebras
10283#On an algorithm for optimal control using pontryagin's maximum principle
10284#On the regularity of the Kuhn-Tucker curve
10285#The generic local time-optimal stabilizing controls in dimension 3
10286#An optimization problem with volume constraint
10287#The Dirichlet-Neumann boundary control problem associated with Maxwell's equations in a cylindrical region
10288#Local realizations of nonlinear causal operators
10289#The value function in optimal control: Sensitivity, controllability, and time-optimality
10290#Strong controllability of nonlinear systems
10291#On limit cycles of feedback systems which contain a hysteresis nonlinearity
10292#Generalized quasiconvex mappings and vector optimization
10293#Singular optimal control: A geometric approach
10294#Phase portrait of the matrix Riccati equation
10295#Ambush strategies in search games on graphs
10296#Limiting distribution for random optimization methods
10297#On the interplay of singular perturbations and wide-band stochastic fluctuations
10298#On seminormality of integral functionals and their integrands
10299#The optimal projection equations for finite-dimensional fixed-order dynamic compensation of infinite-dimensional systems
10300#An example on the effect of time delays in boundary feedback stabilization of wave equations
10301#Optimal interpolation with convex splines of second degree
10302#Distortion-free compressibility of individual pictures, i.e., two-dimensional arrays of data, by finite-state encoders is investigated. For every individual infinite pictureI, a quantityrho(I)is defined, called the compressibility ofI, which is shown to be the asymptotically attainable lower bound on the compression ratio that can be achieved forIby any finite-state information-lossless encoder. This is demonstrated by means of a constructive coding theorem and its converse that, apart from their asymptotic significance, might also provide useful criteria for finite and practical data-compression tasks. The proposed picture compressibility is also shown to possess the properties that one would expect and require of a suitably defined concept of two-dimensional entropy for arbitrary probabilistic ensembles of infinite pictures. While the definition ofrho(I)allows the use of different machines for different pictures, the constructive coding theorem leads to a universal compression scheme that is asymptotically optimal for every picture. The results are readily extendable to data arrays of any finite dimension.
10303#Variable-length codes can be used in entropy coding the outputs of an optimum entropy-constrained quantizer. Transmitting these codes over a synchronous channel; however, requires a buffer connecting the entropy coder to the channel. In a practical application, this buffer is of finite size and hence might overflow or undertow. To alleviate this difficulty, we use an adaptive scheme in which the quantizer parameters are changed successively according to the state of the buffer. Rate-distortion performance of optimum entropy-constrained quantizers in conjunction with this adaptive scheme is studied for the class of generalized Gaussian sources. It is demonstrated through simulations that the overflow/ undertow problem can be practically eliminated at the cost of a negligible increase in average distortion. Furthermore, it is shown that the efficiency of this system is more pronounced at high rates and for more broadtailed source densities. Easily computable upper and lower bounds on the average distortion of the adaptive system are developed.
10304#The main result is a new lower bound for the minimum distance of cyclic codes that includes earlier bounds (i.e., BCH bound, HT bound, Roos bound). This bound is related to a second method for bounding the minimum distance of a cyclic code, which we call shifting. This method can be even stronger than the first one. For all binary cyclic codes of length< 63(with two exceptions), we show that our methods yield the true minimum distance. The two exceptions at the end of our list are a code and its even-weight subcode. We treat several examples of cyclic codes of lengthgeq 63.
10305#Two kinds of algorithms are considered.1)If *** is a binary code of lengthn, a "soft decision" decoding algorithm for *** changes an arbitrary point ofR^{n}into a nearest codeword (nearest in Euclidean distance).2)Similarly, a decoding algorithm for a latticeLambdainR^{n}changes an arbitrary point ofR^{n}into a closest lattice point. Some general methods are given for constructing such algorithms, ami are used to obtain new and faster decoding algorithms for the Gosset latticeE_{8}, the Golay code the Leech lattice.
10306#Coding schemes in which each codeword contains equally many zeros and ones are constructed in such a way that they can be efficiently encoded and decoded.
10307#A "coordinate recurrence" method for solving sparse systems of linear equations over finite fields is described. The algorithms discussed all requireO(n_{1}(omega + n_{1})log^{k}n_{1})field operations, wheren_{1}is the maximum dimension of the coefficient matrix,omegais approximately the number of field operations required to apply the matrix to a test vector, and the value ofkdepends on the algorithm. A probabilistic algorithm is shown to exist for finding the determinant of a square matrix. Also, probabilistic algorithms are shown to exist for finding the minimum polynomial and rank with some arbitrarily small possibility of error.
10308#The problem of calculating the probability density function of the output of anRCfilter driven by a binary random process with intervals generated by an equilibrium renewal process is studied. New integral equations, closely related to McFadden's original integral equations, are derived and solved by a matrix approximation method and by iteration. Transformations of the integral equations into differential equations are investigated and a new closed-form solution is obtained in one special case. Some numerical results that compare the matrix and iteration solutions with both exact solutions and approximate solutions based upon the Fokker-Planck equation are presented.
10309#Variance expressions are derived for four unbiased centroid estimators of an asymmetrical spectrum of the complex envelope of a narrow-band Gaussian process. These estimators are obtained by cross-correlating the undistorted or hard-clipped component and the time derivative of the undistorted or hard-dipped quadrature component of the complex envelope. When both components are hard-clipped, the variance expression of the centroid estimator is a generalization of Blachman's zero-crossing analysis. The variance of the centroid estimator obtained from finite records of the undistorted components is shown to be smaller than that of the other three estimators whenm_{2} > 5.32mu_{1}^{2}, wheremu_{1}andm_{2}are the first simple and second central spectral moments respectively. However, whenm_{2} < 5.32mu_{1}^{2}, the variance of the centroid estimate obtained from one hard-clipped component is shown to be smallest. Furthermore, the dependence of the variances on both the magnitude and direction of spectral asymmetry is shown to be different for the four centroid estimators considered.
10310#The nonparametric estimate derived from the Hermite orthogonal system of the functionalI=int f^{2}(x) dxwherefis an unknown probability density, is studied. Sufficient conditions for the weak and strong consistency of the estimate are presented, and the rate of convergence is given. In particular, under mild assumptions onf, the rate of mean-square error convergence isO(n^{-1}), whereas for almost complete convergence it isO((n^{-1} log n)^{1/2}). Moreover, several possible applications in the area of nonparametric inference of the estimate are indicated.
10311#Consider a Gaussian multiple-access channel shared byKusers who transmit asynchronously independent data streams by modulating a set of assigned signal waveforms. The uncoded probability of error achievable by optimum multiuser detectors is investigated. It is shown that theK-user maximum-likelihood sequence detector consists of a bank of single-user matched filters followed by a Viterbi algorithm whose complexity per binary decision isO(2^{K}). The upper bound analysis of this detector follows an approach based on the decomposition of error sequences. The issues of convergence and tightness of the bounds are examined, and it is shown that the minimum multiuser error probability is equivalent in the Iow-noise region to that of a single-user system with reduced power. These results show that the proposed multiuser detectors afford important performance gains over conventional single-user systems, in which the signal constellation carries the entire burden of complexity required to achieve a given performance level.
10312#The optimum nonlinearity is defined for detection of a weak signal when minimal knowledge of the dependency structure of the observations is available. Specifically, it is assumed that the observations form a one-dependent strictly stationary sequence of random variables and that only a finite number of moments of the marginal density and the correlation coefficient between consecutive observations are known. It is assumed that the bivariate densities involved can be represented as diagonal series, using orthonormal polynomials. Using efficacy as a performance measure, the optimum nonlinearity is required to satisfy a saddle-point condition over this class of bivariate densities.
10313#Various linear and nonlinearR(r,m)codes having parameters(2^{m}, 2^{k}, 2^{m-r})withk=sum_{i=0}^{r}left(^{m}_{i}right)are constructed fromR(r,q)andR(r,p)codes,m=p+q. A dual construction forR(m-r,m)codes fromR(p-r,p)andR(q-r,q)codes is also presented,m=p+q. As a simple corollary we have that the number of nonequivalentR(r,m)codes is at least exponential in the length (forr>1). ForR(m-r,m)codes, the lower bound is doubly exponential in the length (forr>1).
10314#LetC(B)denote the binary cyclicANcode with generatorA, whereAB=2^{n} - 1. It is known thatC(B)is equidistant ifBis a prime powerp^{k}, where either2or-2is primitive moduloBprovidedpequiv 1 pmod{3}{rm if} k > 1. It is conjectured that these are the onlyBsuch thatC(B)is equidistant. We have verified this forB < 100 000. Several results are established that further limit the possibilities for counterexamples to the conjecture.
10315#The state splitting algorithm of Adler, Coppersmith, and Hassner for graphs with edges of fixed length is extended to graphs with edges of variable lengths. This has the potential to improve modulation code construction techniques. Although the ideas of state splitting come from dynamical systems, completely graph-theoretic terms are used.
10316#It is shown that the asymptotic probability of error of a binary equiprobable hypothesis test for observed Poisson point processes with rateslambda_{i}(t)=b_{i}(t)+(rho_{i}(t)+z)^{2}, i=0,1, z rightarrow infty, is equal to the error probability of optimum deterministic-signal detection in additive white Gaussian noise when the signals coincide with the square roots of the point-process rates. The implication of this result in the error rate analysis of optical digital communication systems is discussed.
10317#Previous literature on detector design has presented many tractable results using efficacy as a performance functional, which is a small signal or local approach. Some nonlocal issues of memoryless detection are considered. We argue that the asymptotic exponential rate of decrease of error probabilities, or Bayes risk, provides the appropriate asymptotic measure of performance. A main contribution is the development of an approximation for nonlocal design that retains the tractability of the efficacy approach. We have proved the local consistency of our approximation. Also, as a consequence of the analysis, new proofs for Pitman-Noether-like theorems have been obtained.
10318#The sample variance is commonly used to estimate the variance of stationary time series. When the second-order statistics of the process are known up to a scaling factor, this estimator is generally inefficient. In the case of an autoregressive (AR) process with unknown parameters, the sample variance is shown to be asymptotically efficient. However, the sample variance of a moving-average (MA) process with unknown parameters is generally an inefficient estimator. Closed-form expressions are derived for the Cramer-Rao hound associated with the variance estimation problem and for the variance of the sample-variance estimator, for both AR and MA processes.
10319#It has been observed previously that downlink noise correlation has no effect on the average error probability of a differentially phase shift keyed (DPSK) satellite system when the symbols are equiprobable. We show thai this observation holds for a satellite system exhibiting amplitude-modulation-to-amplitude-modulation (AM-AM) conversion effects and amplitude-modulation-to-phase-modulation (AM-PM) conversion effects. It is also shown thai noise correlation has no effect even when a constant phase error is caused by the delay line of the DPSK receiver in terrestrial and satellite links.
10320#Proof is given that no regular or synchronizable universal codeword sets can achieve optimality. Some asymptotic properties of a remarkable class of regular codeword sets related to the Fibonacci representation of integers are also obtained.
10321#Memoryless discrete-time detection of a known time-varying signal in dependent non-Gaussian noise is considered. Optimal detectors are specified for cases where the detector nonlinearity is time-invariant and time-varying. A performance comparison is provided by way of examples.
10322#Professor Richard Bellman: Academician, scholar, practitioner and patron of fuzzy sets
10323#A characterization of the extension principle
10324#Automated fuzzy and probabilistic inference
10325#Generalized k-nearest neighbor rules
10326#On some optimization problems under uncertainty
10327#Fuzzy adaptive learning model of decision-making process
10328#Optimal clustering of fuzzy data via fuzzy dynamic programming
10329#Towards `human-consistent' multistage decision making and control models using fuzzy sets and fuzzy logic
10330#Induction of inference rules for expert systems
10331#Fuzzy modeling and control of multilayer incinerator
10332#Set-valued statistics and its application to earthquake engineering
10333#Invariant sets of arcs in network flow problems
10334#An assignment algorithm with applications to integrated circuit layout
10335#A solvable case of quadratic 0-1 programming
10336#On an application of convexity to discrete systems
10337#On pre-periods of discrete influence systems
10338#Structural rigidity II: almost infinitesimally rigid bar frameworks
10339#Conditions for the existence of solutions of the three-dimensional planar transportation problem
10340#On the membership problem for regular DNLC grammars
10341#A note on finding a maximum empty rectangle
10342#An improvement on Dijkstra's method for finding the shortest path in a network
10343#Antisymmetrical neural networks
10344#Testing homotopy equivalence is isomorphism complete
10345#Conference proceedings on Electronic printing systems---Directions in digital imaging
10346#Corporate publishing and the evolving structure
10347#Xerox's directions in electronic publishing
10348#Directions in corporate publishing
10349#The corporate publishing environment and market
10350#The next generation of computer-aided publishing systems
10351#The status of exchange formats for color pictures
10352#A survey of graphics standards and their role in information exchange
10353#Paperless documents—How do you find the pieces?
10354#Using the electronic service bureau: help or hindrance to inplant?
10355#Providing corporate publishing services
10356#The role of the service bureau in electronic publishing
10357#Servicing the corporation by merging text and graphics
10358#Pagewright and the main frame connection
10359#Desk top publishing: today and the future
10360#Publishing not perishing: low cost, high performance electronic publishing systems
10361#New applications for desk top publishing including financial reports
10362#Bringing work station publishing capabilities to the IBM PC
10363#Where does the PC fit into the corporate publishing picture?
10364#PC's with full page display for technical manuals—text and graphics
10365#Requirements and solutions for electronic corporate documentation
10366#What is the ideal PC resident RIP
10367#Criteria in selecting and justifying a corporate publishing system
10368#Technical graphic applications in corporate publishing
10369#Electronic technical illustrating: state of the art
10370#Distributed data base publishing for total integration
10371#Electronic document publishing in the product development environment
10372#Technical illustrations in corporate publishing
10373#What users really want
10374#Burroughs product information publishing—present and future plans
10375#Saving money in documentation with MCS graphics
10376#Implementing an integrated electronic publishing system—an Intergraph user's viewpoint
10377#Use of and plans for an integrated distributed data base publishing system
10378#From Versacomp to graphics for technical publications
10379#Sales information publishing systems
10380#Control of a multi-document author based electronic process
10381#Standards, generic code and electronic delivery
10382#How technology is changing the publishing industry
10383#KEEPS: A total approach to electronic publishing
10384#Electronic publishing, where we have been and where we are going
10385#Firms report big productivity gains with new electronic publishing technology
10386#In house data base and technical publishing on large scale computers
10387#Cost justification for electronic publishing systems
10388#Xyvision technical documentation in the service bureau environment
10389#One year user report—distributed technical publishing—illustrators and authors
10390#Transformation from CAD into electronic technical illustrating
10391#Experience from a KEEPS user in an electronic publishing service bureau
10392#Key-sequence data sets on indelible storage
10393#The average complexity of depth-first search with backtracking and cutoff
10394#On-the-fly decoder for multiple byte errors
10395#Design and performance of a magnetic head for a high-density tape drive
10396#Symmetric stochastic Petri nets
10397#Compiling circular attribute grammars into Prolog
10398#Least-squares storage-channel identification
10399#A maximum-energy-concentration spectral window
10400#On yield, fault distributions, and clustering of particles
10401#Representing modelling knowledge in an intelligent decision support system
10402#A logic programming framework for planning and simulation
10403#A graph representation for management of logic models
10404#An intelligent system for formulating linear programs
10405#Understanding and validating results in model-based decision support systems
10406#A model management system to support policy analysis
10407#An entity-relationship approach to model management
10408#Data as models: an approach to implementing model management
10409#Model management systems: design for decision support
10410#Knowledge sharing and negotiation support in multiperson decision support systems
10411#Future directions in model management
10412#An algorithm is proposed for the design of ``on-line'' learning controllers to control a discrete stochastic plant. The subjective probabilities of applying control actions from a finite set of allowable actions using random strategy, after any plant-environment situation (called an ``event'') is observed, are modified through the algorithm. The subjective probability for the optimal action is proved to approach one with probability one for any observed event. The optimized performance index is the conditional expectation of the instantaneous performance evaluations with respect to the observed events and the allowable actions. The algorithm is described through two transformations, T1, and T2. After the ``ordering transformation'' T1 is applied on the estimates of the performance indexes of the allowable actions, the ``learning transformation'' T2 modifies the subjective probabilities. The cases of discrete and continuous features are considered. In the latter, the Potential Function Method is employed. The algorithm is compared with a linear reinforcement schenme and computer simulation results are presented.
10413#This paper presents the dynamic programming approach to the design of optimal pattern recognition systems when the costs of feature measurements describing the pattern samples are of considerable importance. A multistage or sequential pattern classifier which requires, on the average, a substantially smaller number of feature measurements than that required by an equally reliable nonsequential classifier is defined and constructed through the method of recursive optimization. Two methods of reducing the dimensionality in computation are presented for the cases where the observed feature measurements are 1) statistically independent, and 2) Markov dependent. Both models, in general, provide a ready solution to the optimal sequential classification problem. A generalization in the design of optimal classifiers capable of selecting a best sequence of feature measurements is also discussed. Computer simulated experiments in character recognition are shown to illustrate the feasibility of this approach.
10414#The basic concept of learning control is introduced. The following five learning schemes are briefly reviewed: 1) trainable controllers using pattern classifiers, 2) reinforcement learning control systems, 3) Bayesian estimation, 4) stochastic approximation, and 5) stochastic automata models. Potential applications and problems for further research in learning control are outlined.
10415#The problem of grammatical inference is introduced, and its potential engineering applications are demonstrated. Inference algorithms for finite-state and context-free grammars are presented. The application of some of the algorithms to the inference of pattern grammars in syntactic pattern recognition is illustrated by examples.
10416#Inference of high-dimensional grammars is discussed. Specifically, techniques for inferring tree grammars are briefly presented. The problem of inferring a stochastic grammar to model the behavior of an information source is also introduced and techniques for carrying out the inference process are presented for a class of stochastic finite-state and context-free grammars. The possible practical application of these methods is illustrated by examples.
10417#The purpose of this paper is to demonstrate how a syntactic approach and, in particular, a tree system may be used to represent and classify fingerprint patterns. The fingerprint impressions are subdivided into sampling squares which are preprocessed and postprocessed for feature extraction. A set of regular tree languages is used to describe the fingerprint patterns and a set of tree automata is used to recognize the coded patterns. In order to infer the structural configuration of the encoded fingerprints, a grammatical inference system is developed. This sytem utilizes a simple procedure to infer the numerous substructures and relies on a reachability matrix and a man-machine interactive technique for the inference of complex structures. The 92 fingerprint impressions were used to test the proposed approach. A set of 193 tree grammars was inferred from each sampling square of the 4 脳 4 sampling matrix which is capable of generating about 2 脳 1034 classes for the fingerprint patterns.
10418#Description or discrimination of boundary curves (shapes) is an important problem in picture processing and pattern recognition Fourier descriptors (FD's) have interesting properties in this respect. First, a critical review is given of two kinds of FD's. Some properties of the FD's are given and a distance measure is proposed, in terms of FD's, that measures the difference between two boundarv curves. It is shown how FD's can be used for obtaining skeletons fobjects. Finally, experimental results are given in character recognition and machine parts recognition.
10419#The problem of pattern recognition is discussed in terms of single-entity representation versus multiple-entity representation. A combined syntactic-semantic approach based on attributed grammars is suggested. Syntax-semantics tradeoff in pattern representation is demonstrated. This approach is intended to be an initial step toward unification of syntactic and statistical approaches to pattern recognition.
10420#Science Digest
10421#A boy and his brain machine
10422#Gossip as creativity
10423#Hierarchical reasoning: simulating complex processes over multiple levels of abstraction
10424#On random strings and sequence comparisons
10425#Modeling the penalty costs of software failure
10426#A study of inductive inference machines
10427#The control and simulation of a robotic arm using micro-processor based distributed control approach
10428#A study of complexity metrics as surrogate measures of software maintainability
10429#Refinement of expert system knowledge bases: a metalinguistic framework for heuristic analysis
10430#The management of computing in a turbulent environment: organizational responses to the advent of personal computing
10431#A user interface mangement system generator
10432#A study of Marco level complexity metrics
10433#A methodological approach to a re-usable fuzzy expert system
10434#Routing as a flow control strategy within an integrated circuit/packet-switched communications network
10435#Integrating marker-passing and problem-solving: a spreading-activation approach to improved choice in planning
10436#Resource-efficient parallel algorithms (VLSI)
10437#Microcomputer application in aquatic toxicity testing
10438#Generalized and/or graphs as a modeling tool for diagnostic problem solving
10439#Performance evaluation of the pipe computer architecture
10440#Life in an associative memory: tales demons tell
10441#Formal specification and verification of hierarchical VLSI design
10442#Diagnosing problem-solving
10443#Printed circuit thirty-two gigahertz gallium-arsenide field-effect transistor oscillator
10444#Performance analysis and network bandwidth parameters for multicluster MIMD systems
10445#Performance measurement, modelling, and evaluation of integrated concurrency control and recovery algorithms in distributed database systems
10446#Low cost management of replicated data
10447#Dychart: a model for open systems
10448#Debugging the communication behavior of distributed programs in a message-based system
10449#Multidimensional tree-structured file spaces
10450#The SAGA Editor: a language-oriented editor based on an incremental LR(1) parser
10451#On interfacing HDL to knowledge bases
10452#On periodic real-time scheduling algorithms
10453#Recognition of three-dimensional objects by rendering function matching
10454#A reconfigurable network for the evaluation of broadband mac/data link layer communication protocols
10455#Steel yields in Pa.
10456#Graphically speaking with Dr. Edward R. Tufte
10457#Friendly or frivolous?
10458#Twenty-first century software
10459#System architect's apprentice (SARA) as the foundation for a methodology-oriented Ada programming support environment
10460#Fault diagnosis in computing networks
10461#The logical data model: a new approach to database logic
10462#External sorting: I/O analysis and parallel processing techniques
10463#Growth optimal investment strategies
10464#Routing problems in the physical design of intergrated circuits
10465#The design and implementation of Modula-2DL
10466#The pairwise intersection problem for monotone polygons
10467#Three-dimensional migration on the Cray X-MP
10468#Plan recognition and discourse analysis: an integrated approach for understanding dialogues
10469#Performance modelling of database management systems
10470#Non-linear convex programming with linear constraints: informatics and algorithms for a class of adaptive two-segment methods
10471#A logic-based programming system
10472#Discrete valued orthogonal functions
10473#Orderings and some combinatorial optimization problems with geometric applications
10474#Fast ordering of reduced fill-in sparse least squares problems
10475#Extensions to the relational data model model for statistical database applications
10476#Nonclausal logic programming
10477#Interpreting line drawings of curved objects
10478#A programming language to support transformational refinement
10479#Adaptive self-organizing logic networks
10480#A query optimization method for use in a generalized database
10481#A non-cognitive formal approach to knowledge representation in artificial intelligence
10482#Epsilon precedence grammars and languages
10483#Processor architecture and cache performance
10484#Neural networks, pattern recognition, and fingerprint hallucination
10485#Representing information about files
10486#Knowledge in a distributed environment
10487#Software testing: a new methodology and a theory of complexity
10488#On a computer architecture for dynamic finite element analysis
10489#Transferability of medical knowledge-base: a case study between internist-1 and help
10490#The Archimedes system: microarchitecture description language and retargetable microcode debugging
10491#The Clay VLSI layout language
10492#Language independent syntactic error recovery for LL(1) grammars using follow set testing
10493#Query translation in a heterogeneous distributed database on hypergraph models
10494#A general empirical study of the reconstruction problem: probabilistic and possibilistic systems
10495#Applications of rewriting techniques
10496#Free-form deformation in a constructive solid geometry modeling system
10497#An equational approach to decision support systems
10498#Bootstrap statistics for expert data interpretation
10499#Hardware system for realtime signal processing software development
10500#Exception handling in the 68000,Part2
10501#Interactive development environment for single-board computers
10502#Microcomputer processing of 10 MHz acoustic signals
10503#6800 coprocessor for a 6502 bus
10504#On the eigenvalue problem for a class of band matrices including those with Toeplitz inverses
10505#LU-decompositions of tridiagonal irreducible H-matrices
10506#Inverse problem for means of matrices
10507#Incomplete factorization of singular M-matrices
10508#Packings by complete bipartite graphs
10509#Values of graph-restricted games
10510#The cyclic coloring problem and estimation of spare hessian matrices
10511#Difference methods for the numerical solution of time-varying singular systems of differential equation
10512#A packing problem you can almost solve by sitting on your suitcase
10513#Simplified reliabilities for consecutive-k-out-of-n systems
10514#On the spectral radius of complementary acyclic matrices of zeros and ones
10515#Using the QR factorization and group inversion to compute, differentiate ,and estimate the sensitivity of stationary probabilities for markov chains
10516#Expanders and diffusers
10517#Characterization and recognition of partial 3-trees
10518#An application of the singular value decomposition to manipulability and sensitivity of industrial robots
10519#A multiplier method for identifying keyblocks in excavations through jointed rock
10520#Hard enumeration problems in geometry and combinatorics
10521#On the geometry of Kaluza-Klein theories
10522#A chaotic solution of systems with almost periodic forcing
10523#Axial displacement of a disc inclusion embedded in a penny-shaped crack
10524#Bifurcation of subharmonic solutions in time-reversible systems
10525#Surface and interface oscillations of a rotating visco-elastic liquid column of immiscible liquids
10526#The inviscid stability of swirling flows: large wavenumber disturbances
10527#On a nonlinear evolution problem of particle transport theory with nonconstant collision frequencies
10528#Constrained normalization of Hamiltonian systems and perturbed Keplerian motion
10529#Bifurcation at nonsemisimple 1:-1 resonance
10530#A uniform asymptotic expansion for the Jacobian elliptic function sn(u,k)
10531#Boundary layer growth on a circular cylinder in a semi-infinite fluid
10532#Field in an open-ended waveguide satisfying impedance boundary conditions
10533#The Stefan problem in nonlinear heat conduction
10534#Approximation of evolution equations with polynomial reproducing nonlinearities
10535#Invariant solutions and constitutive laws for a nonlinear elastic rod of variable cross-section
10536#Nonlinear waves in a general magnetic fluid
10537#A comparison result for convection in bounded geometries
10538#Applying a fuzzy relation to describe influence of flux behavior in a printed coil
10539#Joint ventures and trade secrets
10540#Trade secret litigation and the presentation of the trade secret owner's case
10541#Business secrets across international borders: one aspect of the transborder data flow debate (Part II)
10542#Recovery of attorney's fees in trade secret cases: present law and a proposal
10543#Business secrets across international borders: one aspect of the transnational data flow debate (Part 1)
10544#Agricultural Labor Relations Board vs. Richard A. Glass Co., Inc. (California)
10545#Loveall v American Honda Motor Co.,Inc.(Tennessee)
10546#Engelhard Corp v Savin Corp (Delaware)
10547#Curtis v Complete Foam Insulation Corp (New York)
10548#Osage Glass, Inc v Donovan (Missouri)
10549#Protecting trade secrets in biotechnology
10550#Breach of confidence: assignability of rights
10551#Industrial espionage in the USA: business protection guide
10552#Simulation of dynamic systems using multirate integration techniques
10553#Development and sensitivity analysis of adaptive predictor for human eye movement model
10554#Transfer function and characteristic root errors for fixed-step integration algorithms
10555#An algorithm for transient dynamic analysis
10556#Pure mathematics applied
10557#Information technology and the Canadian House of Commons
10558#Small is beautiful: the next ten years in university computing
10559#The university computing service in the late 1980s
10560#Software cataloguing
10561#The measurement of the performance of communications protocols from the user's viewpoint
10562#Software engineering and educational support environments
10563#Enhanced management domain for low-cost local area networks
10564#Oakley on Alvey
10565#Campus and local area networking choices: IUNC Conference, University of Reading, 23-24 September 1985
10566#Computer Board Forum
10567#A data-driven parallel multi-stack reduction machine,FPM2, and its improvement
10568#Flex and the ICL Perq 2
10569#Implementation issues in persistent graphics
10570#Teaching silicon circuit design in a degree course
10571#The Aeneas Project—implementing the Nelson Report at Queen's University,Belfast
10572#Network protocols: IBM/University of Newcastle upon Tyne Seminar, September 1985
10573#Utilitas Mathematica
10574#Directed coverings of pairs by quadruples
10575#On D-optimal designs for completely nonlinear regression models
10576#Impulse propagation in liquid filled distensible tubes: a two-dimensional analysis
10577#The development of a time-domain model for transients on lossy, distorting coaxil cables
10578#Recursive constructions for resolvable and doubly resolvable 1-rotational Steiner 2-designs
10579#Multivariate filtered poisson processes and applications to multivariate stochastic modelling of mutagenicity and carcinogenesis
10580#Incomplete block designs for the 24 factorial
10581#On first passage probability distributions in continuous time Markov processes
10582#On the parameters of a certain exceptional block design
10583#Minimum number of edges in P4-connected graphs
10584#The convexity with respect to Gaussian distributions of divergences of order &agr;
10585#Numerical inversion of a second kind singular Volterra equation—the thin section equation of stereology
10586#Minimax and symmetric duality for non-linear mixed-integer programming problems
10587#A technique for obtaining nonisomorphic balanced incomplete block designs
10588#An optimization theorem with applications in some mathematical programming problems
10589#A lower bound for number of treatments in a main effect plus one plan for 24 factorials
10590#Areas and supradiagonalities of a path family
10591#On a fourth order boundary value problem
10592#All directed GDDs with block size three, λ1=0,exist
10593#Tables of some properties of sequences of paired events
10594#On the norm of combining alias matrices of balanced fractional 2m factorial designs of resolution 2:6J+1 derived from simple arrays
10595#On the optimality of block designs under a mixed effects model
10596#A large set of optimal embedded Hadamard matrices
10597#The pleasures and problems of working at home
10598#Picking the perfect laptop
10599#Student perceptions of skill acquisition through cases and a general management simulation
10600#Ackoff's management misinformation systems empirically revisited via simulation
10601#The importance of scaling for the Hermite bicubic collocation equations
10602#Numerical solution of nonlinear differential equations with algebraic contraints II: practical implications
10603#Maintianing solution invariants in the numerical solution of ODEs
10604#An upwind second-order scheme for compressible duct flows
10605#On generating test problems for nonlinear programming algorithms
10606#A comparison between some direct and iterative methods for certian large scale godetic least squares problems
10607#Generalizations of Davidson's method for computing eigenvalues of sparse symmetric matrices
10608#Linear least squares with bounds and liner constraints
10609#A generalization of the Frank matrix
10610#A hybrid Chebyshev Krylov subspace algorithm for solving nonsymmetric systems of linear equations
10611#GMRES: a generalized minimal residual algorithm for solving nonsymmetric linear systems
10612#A second-order accurate pressure correction scheme for viscous incompressible flow
10613#An aplicaiton of systolic arrays to linear discrete Ill posed problems
10614#Data structures for adaptive grid generation
10615#The application of cell discretization to a :20circle inthe square” model problem
10616#High order three point schemes for boundary value problems I. linear problems
10617#Automatic GKS stbility analysis
10618#The numerical calculation of traveling wave solutions of nonlinar parabolic equations
10619#The Numerical Schwarz alternating procedure and SOR
10620#On the scope of the method of modified equations
10621#An exterior Poisson solver using fast direct methods and boundary integral equations with applications to nonlinear potential flow
10622#Computation of the chi square and Poisson distribution
10623#A generalization of the method of correlated sampling for numerical interation
10624#Optimal point location in a monotone subdivision
10625#Constructing arrangements of lines and hyperplanes with applications
10626#A simple unpredictable pseudo random number generator
10627#Evaluating rational functions: infinite precision is finite cost and tractable on average
10628#Optimal approximations and polynomially levelable sets
10629#Probabilistic bounds on the performance of list scheduling
10630#Minimal representation of directed hypergraphs
10631#Representations and parallel computations for rational functions
10632#On the complexity of nonconvex covering
10633#Log-logarithmic selection resolution protocols in a multiple access channel
10634#Efficient algorithms for geometric graph search problems
10635#Planar multicommodity flows, maximum matchings and negative cycles
10636#Relativizations of unambiguous and random polynomial time classes
10637#Probablitiec related to father son distances in binary search trees
10638#Negation is powerless for Boolean slice functions
10639#On the Lagarias-Odlyzko algorithm for the subset sum problem
10640#Constant time generation of free trees
10641#Bounds for width two branching programs
10642#On the probable performance of Heuristics for bandwidth minimization
10643#The complexity of the membership problem for two subclasses of polynomial ideal s
10644#Noncomutative bilinear algorithms for 3x3 matrix multiplication
10645#Collections of functions for perfect hashing
10646#Recognizing composite graphs is equivalent to testing graph isomorphism
10647#Assessing the artificial intelligence contribution to decision technology
10648#An inductive search system: Theory, design, and implementation
10649#The dual expansion method: An application for evaluating the effects of population growth on development
10650#Interpretation of natural language database queries using optimization methods
10651#Directed graph representations of association structures: A systematic approach
10652#A pattern recognition and associative memory approach to power system security assessment
10653#Stochastic dynamics of neural networks
10654#A model for the fading of stabilized images in a visual system
10655#Manipulator inverse kinematic solutions based on vector formulations and damped least-squares methods
10656#Computation of multibody system dynamics by a multiprocessor scheme
10657#Automation effects in a multiloop manual control system
10658#Optimization of control parameters for genetic algorithms
10659#Fault diagnosis in a large dynamic system: Experiments on a training simulator
10660#Application of a mathematical model of human decisionmaking for human-computer communication
10661#Development and validation of a mathematical model of human decisionmaking for human-computer communication
10662#Significance testing of rules in rule-based models of human problem solving
10663#Goodness of fit in the user-computer interface: A hierarchical control framework related to “friendless”
10664#Field independence and proficiency in electrical fault diagnosis
10665#The influence of troubleshooting, education, and documentation on computer user satisfaction
10666#A transformation algorithm for estimating system laplace transform from sampled-data
10667#Subjective entropy of probabilistic sets and fuzzy cluster analysis
10668#An interactive fuzzy decisionmaking method using constraint problems
10669#Comments on “an exact kinematic model of the PUMA 600 manipulator”
10670#Variational methods for approximating solutions of $\nabla ^2 u(x) = f(x) + k(x)u(x)$ and generalizations
10671#A note on the three-particle lattice and the Henon-Heiles problem
10672#Stability criteria for a system involving two time delays
10673#Uptake curves for Fickian diffusion
10674#A cellk kinetics justification for Gompertz' equation
10675#Global analysis of a system of predator-prey equations
10676#First passage times for combinations of random loads
10677#On the performance of state-dependent single server queues
10678#An automatic method for generating random variates with a given characteristic function
10679#Bifurcation with memory
10680#Minimum transition values and the dynamics of subcritical bifurcation
10681#Patterns at primary Hopf bifurcations at a plexus of identical oscillators
10682#Geometric optics approach to reaction-diffusion equations
10683#Parabolic bursting in an excitable system coupled with a slow oscillation
10684#A method for solving moving boundary problems
10685#A singular perturbation approach to non-Markovian escape rate problems
10686#The Shannon sampling series and the reconstruction of signals in terms of linear, quadratic and cubic splines
10687#On the uniqueness of the inverse logarithmic potential problem
10688#On the uniqueness of the inverse potential problem for homogeneous polyhedrons
10689#Imperfect bifurcation with a slowly-varying control parameter
10690#Note on the initial formation of shocks
10691#The stabilization law for transonic flow
10692#Applications of Wiener's path integral for the diffusion of Brownian particles in shear flows
10693#Bounds on complexity in reaction-diffusion systems
10694#N species competition for a spatially heterogeneous prey with Neumann boundary conditions: steady states and stability
10695#Extreme value distribution for the largest cube in a random lattice
10696#Matrix Wiener-Hopf-Hilbert factorisation
10697#Asymptotic analysis of the waiting-time distribution for a large closed processor-sharing system
10698#Program derivation through transformations: The evolution of list-copying algorithms
10699#A new type-checker for a functional language
10700#Message-based functional operating systems
10701#Report on the Larch shared language
10702#A Larch shared language handbook
10703#Transformational programming and the paragraph problem
10704#Model of error propagation in systems of communicating processes
10705#Derivation of a distributed algorithm for finding paths in directed networks
10706#Rewriting systems on FP expressions to reduce the number of sequences yielded
10707#Script: a communication abstraction mechanism and its verification
10708#Two most nondeterministic programs
10709#Project management: New technology enhances old concepts
10710#Distributed data processing considerations
10711#Large business organizations' use of PC technology
10712#Are structured methods for systems analysis and design being used?
10713#Analysis of microcomputer DSS projects
10714#Microcomputing comes of age
10715#PC-DOS: The next "de facto" standard for micro-computer operating systems
10716#Information systems engineering and computer software engineering: There's a difference
10717#Expert systems for business applications: Potentials and limitations
10718#Transfer pricing for computer services in public utilities
10719#Telecommuters can qualify for tax breaks
10720#The most expensive person in your office
10721#The changing role of the systems analyst
10722#Tomorrow's computer graphics
10723#One systems document for one purpose
10724#Are automated tools changing systems analysis and design?
10725#The forecasting process: Guidelines for the MIS manager
10726#Qualities of a good forms designer
10727#The human connection in systems design
10728#Designing information systems for people
10729#The effect of the evolution of hardware and software on computer consulting
10730#Computer copyright law
10731#Introducing new technology
10732#Chargeout of information systems services
10733#Microcomputer audit guide
10734#Solving inventory problems by simulation
10735#Steps of successful project management
10736#How to implement a risk analysis system
10737#Selection systems for sales representatives
10738#Criteria for estimating module complexity
10739#Downloading: Data center mainframe to PCs in the real world
10740#Education requirements for the entry level business systems analyst
10741#A management approach to systems development projects
10742#Classifying sensory inspectors with heterogeneous inspection-error probabilities
10743#The effect of measurement error on the power of X¯-R charts
10744#One-sided distribution-free simultaneous prediction limits for p future samples
10745#The design of CUSUM quality control charts
10746#A statistical selection approach to binomial models
10747#Statistical effects of imperfect inspection sampling: II. Double sampling and link sampling
10748#Table for testing the difference between two poisson variables
10749#Amorphous silicon: from promise to practice
10750#Optical-fiber sensors challenge the competition
10751#All-digital jets are taking off
10752#Our expansive past and explosive future
10753#Quebec hydro: La Grande tour
10754#The lure of molecular computing
10755#Electroluminescence catches the public eye
10756#Software `doctor' prescribes remedies
10757#A framework for computer design
10758#Making your PC behave like another
10759#Detroit's 1987 models: new electronic inroads
10760#A matter of margins
10761#The real world
10762#The menacing microburst
10763#`Gold-plated' design
10764#Inside the `black box'
10765#One world
10766#Can power engineering education be reenergized?
10767#Discrete-event simulation
10768#Recipe for reliability: shake and bake
10769#Helping engineers help themselves
10770#Subzero engineering
10771#This chip's designers kept the hardware relatively simple and yet obtained high, IEEE-standard, floating-point performance.
10772#Pipelining, microsequencer start-up in parallel with bus arbitration, and a fully associative translation cache enhanced the performance of this 32-bit memory management device.
10773#The interchip communication protocols for the WE32100 microprocessor chip set had to be designed to support several ambitious architectural goals.
10774#Binary-decision-based controllers can be extended to execute structured microprograms and to compile high-level languages such as Micropascal.
10775#The VME subsystem bus
10776#A new standard provides a high-performance LAN solution for the quick transfer of large amounts of data.
10777#This device has been designed to provide IEEE 802.4 media access control in factory networks employing the GM MAP protocol.
10778#Intended for designers of kernels for distributed multinode systems, this debugger enables them to work in a Unix environment and to interact with the target nodes via a console.
10779#This specialized hardware assists program debugging and testing and program performance evaluation. It is installed like any other peripheral device.
10780#The high cost of braille output devices has prevented their wide use among the visually handicapped. Here, a much cheaper device is implemented.
10781#First Page of the Article
10782#A coordinate rotation algorithm can be used to correct the position of a microcircuit on a laser trimming platform. A software implementation of the algorithm was too slow, however. Special-purpose hardware solved the problem.
10783#P1296: The interprocessor communication standard
10784#Each node in the NCUBE/ten parallel processor is organized around a custom, VAX-like, 32-bit CPU chip. With 1024 nodes, the NCUBE/ten provides a throughput of 500 MELOPS.
10785#A modular multiprocessor merges existing chip sets and a sophisticated, functional programming approach to solve computationally intensive algorithms at mainframe speeds驴at a fraction of the cost.
10786#Simulation models are better than analytical ones for understanding systems that behave unpredictably. But no such models have been available for asynchronous parallel systems驴a situation the Euclid simulator corrects.
10787#A new, registered, asynchronous PAL device originated with suggestions from the manufacturer's customers.
10788#Manufacturing systems simulation using DSSL
10789#Methodology for the design of databases for engineering applications
10790#Computer-aided fatigue analysis
10791#Set theoretic operations on polygons using the scan-grid approach
10792#The application of CADCAM techniques at Harland and Wolff
10793#Hierarchical timing verification system
10794#Modelling and simulation of integrated circuits
10795#FSL: a fast structured logic design methodology for high speed GaAs digital integrated circuits
10796#PPL integrated circuit design methodology
10797#Automated design of MDS circuits and layout
10798#Wirability expert system
10799#Quadratic blending surfaces
10800#Generating wireframes from set-theoretic solid models by spatial division
10801#Design of axial turbomachine blade camber surfaces using the Be´zier technique
10802#Applying relational database techniques to solid modelling
10803#Linking plate/shell finite-element analysis and engineering drafting by meshed surface modelling
10804#Expert control
10805#A novel approach on a parameter self-tuning method in an ac servo system
10806#Model reduction and controller synthesis in the presence of parameter uncertainty
10807#Interaction measures for systems under decentralized control
10808#Nested &egr;-decompositions and clustering of complex systems
10809#Optimally robust redundancy relations for failure detection in uncertain systems
10810#Convergence analysis of ladder algorithms for AR and ARMA models
10811#Robust asymptotic tracking for linear systems with unknown parameters
10812#Two-step optimal thermal generation scheduling
10813#Optimal dynamic routing in Markov queueing networks
10814#Performance analysis of two-level structures on finite-precision machines
10815#A bound for a class of non-nested LOG team problems
10816#On the multivariable gain margin problem
10817#A Riccati equation approach to the stabilization of uncertain linear systems
10818#Robustness of Luenberger observers: Linear systems stabilized via non-linear control
10819#Observations weighted controllers for linear stochastic systems
10820#Feedback gain optimization in decentralized eigenvalue assignment
10821#Almost disturbance decoupling by a proportional derivative state feedback law
10822#Identification of non-minimum phase linear stochastic systems
10823#Optimal estimation for the satellite attitude using star tracker measurements
10824#Analysis of robust stochastic approximation algorithms for process identification
10825#A new forward-pass fixed-interval smoother using the U-D information matrix factorization
10826#Higher order dynamic equivalents for power systems
10827#Examination of the SPR condition in output error parameter estimation
10828#An alternative method for the long-term storage of microfilm
10829#New directions in information storage technology
10830#Technology eases court jam
10831#CNN: How micrographics helped cover the hostage crisis
10832#On-line COM unit increases output at TRW
10833#When success raises tough questions, information management provides answers
10834#Automated file management system helps manufacturer untangle knots
10835#CAR and optical disks provide exciting user options
10836#Opportunities and obstacles
10837#Systems integration is the key to effectively manage information
10838#Imaging processing: The next breakthrough
10839#Micrographics system takes bite out of crime
10840#Kenworth of Indianapolis keeps on trucking with automation
10841#Document management: Software is the link
10842#Videotex systems
10843#Microfilm and optical technologies—coexistence and transition
10844#COM—the line printer alternative: advantages of computer output microfile
10845#The dubious dangers of VDT radiation
10846#Saving space and money with records management
10847#Ore-Ida finds CAR system is streamlining information flow
10848#Records reflect history of Yakima Indian nation
10849#Where does the personal computer fit?
10850#The impact of CAR
10851#Coordinated micrographics adds to automated offices
10852#Michigan Blue Cross/Blue Shield adopts on-line COM strategy
10853#Current trends of Japan's micrographics and optical disk systems
10854#The critical role of the OA manager
10855#Digital's perspective on image management systems
10856#Critical hardware elements in electronic document imaging systems
10857#The role of information systems in Chrysler's resurgence
10858#Linear, structured covariance estimation: An application to pattern classification for remote sensing
10859#On the editing rate of the MULTIDIT algorithm
10860#Binary tree design using fuzzy isodata
10861#Determining hyperspherical classes of observations
10862#The use of data windows in feature extraction for high dimensional PR problems
10863#A multiclass nonparametric partitioning algorithm
10864#Detection of diffuse clusters in noise background
10865#Time effects comparison for software computation of images
10866#A measure of edge ambiguity using fuzzy sets
10867#A shape coding array
10868#Dialog Business connection: Dialog for the end-user
10869#Datext-Using business information on CDROM
10870#Laserdisk directory-Part 4
10871#Information liability-New interpretations for electronic publishing
10872#SearchMaster-Programmed for the end-user
10873#False Drops-How they arise...how to avoid them
10874#Total library integration at Xerox Corporation Technical Information Center-PartIII: Interlibrary loan...A close look at data entry,functions and procedures
10875#How to simulate an online search...A way to cope with mainframe crashes,carrier drops and other online demo misadventures
10876#Caduceus-People in medicine: Searching names online
10877#The silver disk-A planning model for optical product evaluation
10878#Technology and Society
10879#Managing the new technologies
10880#The laser at twenty-five
10881#Preserving sound
10882#Linear extrapolation in an iterative method for solving systems of equations
10883#The stability of a matrix version of a flow pivotal condensation
10884#General non-asymptotic estimates of the rate of convergence of iterative stochastic algorithms
10885#Optimal methods of smooth convex minimization
10886#Some inverse problems of magneto-telluric sounding for obliquely incident plane waves—I
10887#A spectral method of calculating the propagation constants of cellular waveguides
10888#Analytic and numerical solution of Fredholm's equation of the first kind arising in the inverse refraction problem
10889#Localization of the spectrum in the problem of normal oscillations of an elastic shell filled with a viscous incompressible fluid
10890#The scattering of internal waves by the periphery of an elastic plate
10891#Development of a statistical method of particles for problems in the relaxation of chemically reacting gas mixtures
10892#Amplitude-phase properties of the spectral coefficients of laminar media
10893#An estimate of the stability of a set of solutions for systems of linear equalities and inequalities
10894#Reproduction algorithms that are of optimal accuracy for derivatives of certain classes of functions
10895#On one family of exact solutions of the multidimensional non-linear heat equation
10896#The use of multipole sources in the method of non-orthogonal series in diffraction problems
10897#An implicit difference scheme for calculating non-stationary viscous flows with regions of strong non-uniformities
10898#An analysis of the modified exclusion method in certain problems
10899#The regularization of certain methods of minimizing of high order when the initial data are inaccurate
10900#The calculation of the Riemann zeta-function in the complex domain
10901#Algorithms of increased accuracy for solving integral equations of the first kind
10902#The simplification of singularly-perturbed equations of macrodynamics and the method of quasistationary concentrations
10903#Some inverse problems of magneto-telluric sounding for obliquely incident plane waves—II
10904#One-dimensional inverse problems of electrodynamics
10905#Two-group optimization of the method of statistical modelling of the radiation field for hydrogen-containing media
10906#Numerical calculation of the non-equilibrium flow around a wing in the thin shock-layer approximation
10907#Periodic solutions of some singularly-perturbed equations of the parabolic type
10908#On a laminar mixing layer at the boundary between two flows
10909#An approximate solution of an inverse diffraction problem
10910#On calculations in the problems of a collision-free plasma
10911#Modelling of one class of densities
10912#A multivariant travelling-salesman problem
10913#The Second All-Union Conference on Numerical Methods for Solving Kinetic Equations
10914#Object-Oriented programming using modula-2
10915#Ada dynamic strings revisited
10916#Software engineering in Modula-2 Implementing the GPIB (IEEE 488) in a laboratory
10917#Modula-2: Alternative to C for system programming
10918#Writing generic utilities in Modula-2
10919#Syntax-directed approach to algebraic simplification
10920#Synchronization by indirect action mechanism in ada
10921#Anycase, A Modula-2 Utility for ensuring case consistency in identifiers
10922#Minimal perfect hashing functions for Modula-2 word lists
10923#Processing equivalence relations
10924#Reviews of three Modula-2 development systems for the IBM PC
10925#Meta Ware professional Pascal,Release 2.6
10926#An interim ADA based preliminary and detailed program design language. Part III
10927#Comparison of linear regression Algorithms
10928#An efficient virtual hash algorithm for a spelling checker
10929#Modeling and implementation of concurrency control
10930#Elegant overlays: A scheme for organizing segmented Modula-2 programs
10931#The Modula-2 almost greater than operator
10932#Fuzzy operator programming techniques
10933#Establishing internal technical systems security standards
10934#FManaging the EDP audit and security functions
10935#Insuring computer risks
10936#Societal vulnerability to computer system failures
10937#Integrating security activities into the software development life cycle and the software quality assurance process
10938#Authentication: A concise survey
10939#Approaches to handling :10Trojan Horse' threats
10940#What to do when you have reason to believe your computer has been compromised
10941#Audit and security implications of electronic funds transfer
10942#Why not DES?
10943#Internal control in local area networks: An accountant's perspective
10944#A Chosen-plaintext attack on the microsoft BASIC protection
10945#How to control MVS user supervisor calls
10946#Self-controlled: A real-time expert system for and autonomous mobile robot
10947#Outward bound: Machine intelligence in deep space
10948#Design strategies for high-speed,lightweight robots
10949#Simulating robotic workcells on a micro
10950#A symbolic matrix manipulation package for the kinematic analysis of robot manipulators
10951#Use of artificial intelligence in automated process planning
10952#Developing an expert system for engineering
10953#Looking for trouble: Expert browsing in manufacturing data bases
10954#Creating and using a features data base
10955#Color graphics in engineering
10956#Describing the surface: Algorithms for geometric modeling
10957#Solving engineering problems in parallel with a loosely-coupled array of processors
10958#Giving assembly robots the right touch
10959#Using a computer for automatic proving of geometric theorems
10960#Some computational aspects of a method for rational approximation
10961#The entropy of a lattice quantizer can be lowered by breaking ties in rounding off in favor of the closest lattice point of highest probability. For a differential pulse-code modulation (DPCM) signal, this means rounding off toward the component of smallest norm. This variant of the algorithm of Conway and Sloane reduces entropy without sacrificing mean-square error.
10962#Unrestricted polar quantizers (UPQ's) were previously introduced to overcome the weak mean-squared error performance of polar coordinate quantizers for the independent bivariate Gaussian source when the number of levels was small (< 3bits /dimension). An asymptotic ntean-squared error analysis of the UPQ's with a general circularly symmetric source is presented. The performance of the UPQ's is shown to be asymptotically within0.17dB of that of the optimum bivariate quantizer. The results are extended to dimensions greater than two. Examples for the independent Gaussian source are included.
10963#Numerical stability of the marching technique
10964#Direct methods of calculating optimal programs in dynamic problems of vector optimization
10965#The sufficient conditions regarding the elements of minimizing sequences in optimal control problems
10966#The stability of lexicographic optimization problems
10967#The search for optimal guaranteed solutions of high-dimensionality problems of smi-infinite programming
10968#Study of a class of profit functions arising in a macro description of economic systems
10969#On an explicit method of solving a system of linear differential equations
10970#Some estimates of the solution of Vlasov's equation
10971#On the minimum of the mean value of the working damping functions for a stepped system
10972#Modelling turbulent flows in a plane channel
10973#The capacity of polynomial expansions of a set of algorithms for calculating estimates
10974#On the comparative magnitude of Gaussian growth coefficients for mutually inverse matrices
10975#On one sequence of iteration parameters
10976#On the solution of an inverse problem for the wave equation with the help of a regularizing algorithm
10977#The construction of test problems in integer-value programming with binary unknowns
10978#On a property of the collision integrals
10979#Search for the global extremum of a polynomial on a parallelepiped
10980#On some properties of the generalized gradient method
10981#Minimum search in concave problems, using the sufficient condition for a global extremum
10982#Numerical solution of mixed boundary value problems for second-order elliptic equations in an arbitrary domain
10983#Reduction of linear integral equations with a uniform error in the right-hand side
10984#Numerical methods of computing special functions of wave catastrophes
10985#Variation-difference schemes for problems in the mechanics of ideally elastoplastic media
10986#Different PN-approximations of the method of spherical harmonics
10987#An algorithm for the numerical extension of a generalized axially-symmetric potential from the symmetry axis
10988#An approach to the question of constructing effective recognition algorithms
10989#Determination of the extremal eigenvalues by the minimization of special functionals
10990#The equality of errors in classes of passive and sequential algorithms
10991#Unconditional minimization in eigenvalue problems with additional stipulations
10992#Approximate solution of integro-operator Volterra equations of the first kind
10993#Antenna potentials in problems of diffraction by a transparent body
10994#On the streamlines of helical flow
10995#What to do when the robot arrives
10996#Intuitive appraisals of expected value—a computer exercise
10997#The t-distribution and computer simulation
10998#Computers in the classroom
10999#Approximate analysis of asymptotic behavior in real time computing systems
11000#Algorithms for very large integer arithmetic
11001#Natural language and computers: a general survey of written text interpretation methods
11002#A knowledge acquisition system for expert systems
11003#Algebraic requirements definitions: a case study
11004#Derivation of arbitration distributed algorithms
11005#Document preparation, electronic pasting and quality printing
11006#Mascot 3: an informal introductory tutorial
11007#The Mascot method
11008#Mascot 3 and Ada
11009#Mascot 3: a testing strategy
11010#Coral 86
11011#Transition from Coral to Ada programming
11012#PolyForth: an electronics engineer's programming tool
11013#Features of artificial intelligence languages and their environments
11014#An introduction to Occam and the development of parallel software
11015#NewSpeak: an unexceptional language
11016#Software engineers and the IEEE
11017#Professional and technical responsibility of BCS members
11018#Languages and object-oriented programming
11019#A Modula-2 based image processing development system
11020#Eclipse—a distributed software development system
11021#The importance of building tools
11022#Ada software engineering examples by Do-While Jones
11023#A Modula-2 I/0 library proposal
11024#Review of CP/M Modula-2
11025#Fast identification of Ada and Modula-2 reserved words
11026#Adjusting to Ada. Part 1
11027#Modified transition matrix and fault testing in sequential logic circuits under random stimuli with a specified measure of confidence
11028#Organizational humanity and architecture: Duality and complementarity of papa-logic and mama-logic in managerial conceptualizations of change
11029#Controlled return to equilibrium of a dynamical system
11030#On the notion of state in mathematical systems theory
11031#Self-authorization: A characteristic of some elements in certain self-organizing systems
11032#Convolutional codes for phase-modulated channels
11033#Policy control through social monitoring
11034#Application of a perturbation theory for evaluation algorithms for identification of a continuous plant from discrete data
11035#On a generic modeling process of an expert system for ethical organizational administration
11036#Short-term memory as a metastable state.III. Diffusion approximation
11037#Cybernetic approach to meaningful measures of merit
11038#Design of a control room for the air force logistics command (AFLC) command, control, and communication and intelligence (C3I) system
11039#Curved surfaces in solid modeling: New hardware improves the view
11040#Closing the gap: A workstation-mainframe connection
11041#Building complex bodies: Combining computer animation with CAD
11042#Boundary elements: A biased view
11043#Computer-aided design of extrusion dies
11044#Calculating the bearing life for opposed mounts and unsteady loads
11045#Combining descriptive and computational geometry
11046#Spectral analysis of dual jerk waveforms in congenital nystagmus
11047#Maximum likelihood estimations in a nonlinear self-exciting point process model
11048#Control of eye movements by working memory load
11049#Neural computation of inner geometric pattern relations
11050#Eye-hand-coordination in man: A reaction time study
11051#Eye-hand-coordination: A model for computing reaction times in a visually guided reach task
11052#Motion sensitive yaw torque responses of the housefly Musca: A quantitative study
11053#Self stabilization of neuronal networks. I. The compensation algorithm for synaptogenesis
11054#Adaptation of transient responses of a movement-sensitive neuron in the visual system of the blowfly Calliphora Erythrocephala
11055#A spike generator mechanism model simulates utricular afferents response to sinusoidal vibrations
11056#Some reversible image operators from the point of view of cellular automata
11057#An analysis of the spatial mechanisms responsible for electrosensitivity in Rays-modelling results
11058#Dynamics of chromaticity horizontal cells in the freshwater turtle retina
11059#Phase evaluation in hypothetical receivers simulating ranging in bats
11060#Maximum-Entropy approximations of stochastic nonlinear transductions: An extension of the Wiener theory
11061#An efficient algorithm for cable theory, applied to blowfly photoreceptor cells and LMC's
11062#Are non-directional simple cells constructed from directional subunits?
11063#Associative recognition and storage in a model network of physiological Neurons
11064#A model of the nystagmus induced by off vertical axis rotation
11065#Ulam,the man and the Mathematician
11066#The graph reconstruction number
11067#A note on the matching numbers of triangle-free graphs
11068#Classes of interval graphs under expanding length restrictions
11069#On stockmeyer's non-reconstructible tournaments
11070#On graphs with prescribed Median I
11071#An upper bound for the Ramsey number r(K5–e)
11072#On the chromatic number of the product of graphs
11073#Bichromaticity of bipartite graphs
11074#Lower-bounds on the connectivities of a graph
11075#Some conditions for the existence of f-factors
11076#On superperfect noncomparability graphs
11077#An upper bound for the k-domination number of a graph
11078#The square of connected S(K1,3)-free graph is vertex pancyclic
11079#On partitioning the edges of graphs into connected subgraphs
11080#Cataloguing the graphs on 10 vertices
11081#Enumeration of cyclically 4-connected cubic graphs
11082#Aspects of expert systems applications in medicine
11083#Using generators for computer and research assisted economics teaching
11084#Computer-assisted analysis of multipersonal problem-solving and decision processes
11085#A convenient technique for constructing your own MPSX generator using dBASE II
11086#IBK-3D-an interactive threedimensional graphical system for PC's
11087#TOOLSIM-2, optimization of tool flow for production models
11088#Concepts for the implementation of the teletex service
11089#PC and Vtx-linked via frontend-processor
11090#Personal computer in academic education-a pragmatically oriented statement of opinion
11091#Help systems-assisting the user
11092#An approximation method for calculating the cost optimal blocking factor with sequential tape file processing
11093#Computer science as problem solving
11094#Computer science in South Africa
11095#Telework-Phenomenon, meaning, signification, problem
11096#A survey of software testing approaches and a proposal for an automated method for practical applications
11097#Requirements analysis and design of an electronic mail system
11098#LITSYS: Management of library catalogs with personal computers using an extended Codasyl database system
11099#An attribute grammar interpreter as a knowledge engineering tool
11100#The programming language OCCAM
11101#Efficient file system for microprocessor systems
11102#Using a microcomputer software system for modeling, simulation and games in sociological education at school and college level
11103#Computer-assisted information processing for research
11104#On convergence regions for quasilinearisation
11105#AT&T Technical Journal
11106#Quality: Theory and practice
11107#The AT&T quality system
11108#Quality in AT&T network systems
11109#Robust design: A cost effective method for improving manufacturing processes
11110#Design optimization case studies
11111#Achieving quality in the development process
11112#Effective management of software development
11113#In-process inspections of workproducts at AT&T
11114#Standard software quality metrics
11115#The history and evolution of quality in AT&T
11116#Statistical methods for reliability improvement
11117#Tools and techniques for VLSI quality
11118#AT&T Technical Journal
11119#ISDN Architecture
11120#ISDN Standards evolution
11121#AT&T Communications ISDN Architecture
11122#Planning for ISDN in the 5ESS switch
11123#ISDN Evolution in information systems architecture
11124#Making single-mode preforms by the MCVD process
11125#The AT&T soft touch-sensitive screen
11126#Wafer inspection with a laser scanning microscope
11127#Computer tomography of PKM and AKM exit cones
11128#Indian telephones: Troubled by under investment
11129#Circuit switched demand assignment multiple access
11130#The application of an expert system for information retrieval at the national archives
11131#Managing academia in the information age
11132#Development of an expert system prototype for determining software functional requirements for command management activities at NASA Goddard
11133#Technology Interview
11134#An interview on local area networks with Dr. Frank Burke acting archivist of the United States
11135#Federal Government local area networking issues
11136#Experiences with local area networks at the U.S Bureau of the Census
11137#IBM'S Grand Scheme
11138#A user's guide for evaluating the IBM token ring
11139#Trends in network media and wiring strategies: LAN life cycle cost implications
11140#A relational database management system in a network-A model
11141#dBase III plus
11142#Three dBase applications
11143#Custom-made software
11144#On considering microcomputer software for purchase
11145#Timesheet calculation using a spreadsheet
11146#ROMCats, Blue Sky, and the revolution of rising expectations
11147#Expanding memory and storage
11148#CAI-BRS after dark
11149#Acquisitions management information on a shoestring
11150#Taking stock with the Mac
11151#Micro Housekeeping
11152#Library instruction and the computer
11153#The calculating Mac
11154#Macros: Prokey and Superkey
11155#Squirrely Keyboards
11156#Memories are made of this
11157#Lance's authority system
11158#Mac tracks a conference
11159#Setting up an electronic bulletin board
11160#The language of electronic discourse
11161#The printer set-up program
11162#“Butter” and the “Low-priced spread”
11163#Microcomputer-based automated indexing of audio-visual reviews
11164#Bibliofile again
11165#The role of the academic library in campus microcomputer services
11166#Marginal niceties, Part II
11167#Streamlining reserve reading with a microcomputer
11168#Hardware basics for searchers, Part II
11169#The letter-perfect Mac
11170#The Macro function as used in dBase II and dBase III
11171#Learning to write with Macintosh, or saving the soul with a new machine
11172#Front end games
11173#Real librarians don't program...do they?
11174#Going online with America: The world of electronic bulletin boards
11175#Mac the bibliographer
11176#Book catalogs with two subject heading using dBase
11177#Marginal niceties
11178#Databases: How fault-tolerant are they?
11179#Library instruction and the computer: A bibliography
11180#Going online with America: The world of electronic bulletin boards, Part II
11181#Back at the drawing board
11182#Hardware basics for searchers, Part I
11183#Towards bibliographic control using a Macintosh 512K machine
11184#Prunet: designing a computer network in a university environment
11185#A conference on education and information Science
11186#Semantic analysis of ADA and resolution of the overload in the ART project
11187#Execution environment of the interpretation of ADA in the ART project
11188#An office automation application in the sector for the treatment of documents
11189#Tendencies in the information retrieval systems and of systems incorporating information retrieval
11190#Linguistic and extra-linguistic knowledge
11191#Symmetric rules for translation of english and chinease
11192#The translation method of Rosetta
11193#Programmed Learning and Educational Technology
11194#Varieties of computer-based training and the development of a hybrid technique
11195#Inactive video at work
11196#Computer-based training: A case for creative skills within development teams
11197#The role of news technology in training at work-A Luddite view
11198#Developing learning in the workplace: The travel industry's experience
11199#Learning in British Airways-A case of putting people first
11200#A study of technophobia among primary school teachers in Nigeria
11201#Get thee to an atelier]-A case study of the design and organization of a computer workshop
11202#Some observations on the introduction of microcomputers into a third world department of eduaction
11203#Programmed Learning and Educational Technology
11204#How are computers to be used in our schools?
11205#The design of educational software for children with severe learning difficulties
11206#Comparison of two microcomputer-assisted methods of teaching word decoding and decoding and encoding to non-vocal, non-writing and learning disabled students
11207#Performance contoured programming: A structure for microcomputer-based teaching of individuals with severe learning difficulties
11208#Evaluation of the CAGE authoring system for special education
11209#Natural language processing and the language-impaired
11210#Information technology and Braille examinations: An automated approach
11211#The need for interactive video in the education of the deaf
11212#Micros and children in developing countries
11213#Educational applications for viewdata as a tool for information retrieval
11214#Programmed Learning and Educational Technology
11215#The evolution of professional practice at the open university
11216#Microcomputers in course development
11217#Blind students and distance education: Some experiences with microcomputers and synthetic speech
11218#PLATO Across the curriculum: An evaluation of a project
11219#Computer-based learning in adult education: A South African case study
11220#Semantic descriptors and maps of meaning for videodisc images
11221#What is this thing called OPT?
11222#OPT-Fantasy or breakthrough?
11223#MRP,JIT, and OPT: What's b:20Best”?
11224#Using MRP for optimized schedules (Emulating OPT)
11225#OPT as enhancement to MRP II
11226#The incident case study in teaching production control
11227#Scheduling, sequencing, and dispatching: Alternative perspectives
11228#Production planning of many seasonal products on many lines
11229#Strategic issues in make-to-order manufacturing
11230#Some common myths and misconceptions about exponential smoothing
11231#Extending APICS certification to help American companies get there]
11232#How to design a college student internship program that works
11233#Controlling bulk issues in an MRP environment
11234#The evaluation of safety stock
11235#Motivation in manufacturing
11236#A minimum production lot-size formula for stockless production
11237#Lot sizing as a fixed-charge problem
11238#The penalties of using the EOQ: A comparison of lot-sizing rules for linear increasing demand
11239#A 50% increase in lot size and planned manufacturing lead time with no increase in WIP inventory
11240#Analyzing and pinpointing areas requiring corrective action
11241#Spreadsheets and optimization: Complementary tools for decision making
11242#MRP Systems are not all alike
11243#Exponential smoothing forecasting: Extreme values analysis
11244#Order quantities for materials with delayed billing
11245#Determining optimal cycle count frequency
11246#Produciton and inventory management software packages related to user reactions
11247#Management-What we can learn form the Japanese
11248#Design, bills of materials, and forecasting-The inseparable threesome
11249#An inventory management tool for a basic industry
11250#Formal/informal systems and MRP implementation
11251#Inventory signals: Some analogies
11252#Ordering inventory when the forecast is ridiculous
11253#The legal protection of computer software in West Germany
11254#Whelan Associates,Inc. v. Jaslow Dental Laboratories,Inc.: Toward a new understanding of copyrightable expression
11255#Software piracy limits U.S. export growth
11256#Intellectual property and innovation
11257#Shrink-wrap licensing in England
11258#Database protection and new storage technologies: An update
11259#U.S and Korea settle intellectual property dispute
11260#A simulation model for analyzing service times in a rotational position sensing disk system
11261#Modeling neural networks in scheme
11262#Comparison of the CRAY X-MP-4, Fujitsu VP-200, and Hitachi S-810/20
11263#Policy simulation in the natural resource sector
11264#Robot arm gains muscle and finesse
11265#A network simulation model of a fish processing facility
11266#Selecting random number seeds in practice
11267#Computer generated molecular modeling
11268#Directory of vendors of simulators, related services, and applicable computers--compiled
11269#Register allocation for unary binary trees
11270#Constructing O(nlogn) size monotone formulae for the kth threshold function of n Boolean variables
11271#The complexity of counting stable marriages
11272#On deterministic multi pass analysis
11273#The complexity of reliability computations in planar and acyclic graphs
11274#Filtering search: a new approach to query answering
11275#On a multidimensional search technique and its application to the Euclidean one centre problem
11276#Sparse sets lowness and highness
11277#Digital search trees revisited
11278#Reducing multiple object motion planning to graph searching
11279#Church-Rosser Thue systems that present free monoids
11280#Three dimensional circuit layouts
11281#Parallel algorithms for depth-first searches I. planar graphs
11282#Recursion schemes and recursive programs are exponentially hard to analyze
11283#A binary search with a parallel recovery of the bits
11284#Relative information capacity of simple relational database schemata
11285#Analysis of Henriksen's algorithm for the simulation event set
11286#Sungular hopf bifurcation to relaxation oscillations
11287#A constructive theory of isolas suported by parabolic cusps, centers and bifurcations points
11288#Steady-state solutions of the Euler equations in two dimensions II. Local analysis of limiting V-states
11289#Interaction of pulsating and spinning waves in condensed phase combustion
11290#Threshold conditions for two diffusion models suggested by nerve impulse conduction
11291#Competing subcommunities of mutualist and a generalized Kamke theorem
11292#Almost sure stability of linear stochastic systems with Poisson process coefficients
11293#On the optimality of (s,S)-policies in continuous review inventory models
11294#Difference methods for the predictions of band-limited signals
11295#On the asymptotic approximation of integrals
11296#Phaselocking in a reaction-diffusion system with a linear frequency gradient
11297#On the asymptotic behavior of a class of deterministic models of cooperating species
11298#Decay to uniform states in food webs
11299#Dual birth and death processes and orthogonal polynomials
11300#Estimation theory of selective reporting: The best-1-of-k report
11301#Asymptotic analysis of the Lyapunov exponent and rotation number of the random oscillator and application
11302#Instability of the harmonic oscillator with small noise
11303#Reflection from a one-dimensional, totally refracting random multilayer
11304#Asymptotic analysis of a state-dependent M/G/1 queueing system
11305#A novel method for solving the inverse scattering problem for time-harmonic acoustic waves in the resonance region II
11306#State machines and assertions: An integrated approach to modeling and verification of distributed systems
11307#Analysing a class of distributive partitioning sort algorithms
11308#Algebraic implementations preserve program correctness
11309#A derivation of a distributed implementation of Warshall's algorithm
11310#CIGALE: A tool for interactive grammar construction and expression parsing
11311#The study of one-dimensional cellular automata exhibiting group properties is presented. The results show that only a certain class of cellular automata rules exhibit group characteristics based on rule multiplication. However, many other of these automata reveal groups based on permutations of their global states. It is further shown how these groups may be utilized in the design of modulo arithmetic units. The communication properties of cellular automata are observed to map favorably to optimal communication graphs for VLSI layouts. They exploit the implementation medium and properly address the physical limits on computational structures. Comparisons of cellular automata-based modulo arithmetic units with other VLSI algorithms are presented using area-time complexity measures.
11312#Banyan networks, as well as many other self-routing networks, have a simple and regular topology, and can be easily diagnosed and maintained. However, like many other self- routing networks, Banyan networks have only one path between each input and output pair. Failures of a single link or node will make many paths unavailable, and certain traffic patterns can cause severe congestion in the networks.
11313#Verifying the correctness of sequential circuits has been an important problem for a long time. But lack of any formal and efficient method of verification has prevented the creation of practical design aids for this purpose. Since all the known techniques of simulation and prototype testing are time consuming and not very reliable, there is an acute need for such tools. In this paper we describe an automatic verification system for sequential circuits in which specifications are expressed in a propositional temporal logic. In contrast to most other mechanical verification systems, our system does not require any user assistance and is quite fast experimental results show that state machines with several hundred states can be checked for correctness in a matter of seconds!
11314#This paper is concerned with the performance evaluation of a realistic model of parallel computations. We present an efficient algorithm to determine the mean completion time and related performance measures for a task system: a set of tasks with precedence relationships in their execution sequence, such that the resulting graph is acyclic. A queueing network (QN) is used to model tasks executing on a single or multicomputer system. In the case of multicomputer systems, we take into account the delay due to interprocess communication. A straight- forward application of a QN solver to the problem is not possible due to variations in the state of the system (composition of tasks in execution). An accurate algorithm based on hierarchical decomposition is presented for solving task systems. At the higher level, the system behavior is specified by a Markov chain whose states correspond to the combination of tasks in execution. The state transition rate matrix for the Markov chain is triangular (since the task system graph was assumed to be acyclic), therefore it can be solved efficiently to compute the state probabilities and the task initiation/completion times. At the lower level, the transition rates among the states of the Markov chain are computed using a QN solver, which determines the throughput of the computer system for each system state. The model and the solution method can be used in performance evaluation of applications exhibiting concurrency in centralized/distributed systems where there are conflicting goals of load balancing and minimizing interprocess communication overhead.
11315#A new methodology for the layout design of several classes of useful VLSI structures is proposed. The approach produces a structured layout for commonly found computation structures, using regular elements called layout slices. Algorithms for optimal array realization are described that offer several significant advantages over existing layout schemes. Any network that can be decomposed into instances of these structures can therefore be realized using layout slices. Algorithms for the array realization of a class of arbitrary networks are also described. Several well-known structures such as trees, carry-save adders and cube-connected cycles can be realized using the proposed array layout methodology, not only with optimal area but also with several features necessary for practical implementation, e.g., access to key nodes, high area utilization and global signal routing. The proposed methodology is illustrated with actual layouts of useful circuits.
11316#In this correspondence, we present procedures for constructing universal fault detection test sets as well as fault location test sets for multivalued linear circuits, under a multiple stuck-fault model. The bin packing problem is involved in the procedures. The sizes of the fault detection test set and the fault location test set constructed for an n- variable v-valued linear tree circuit are 1 + ?n/(v - 1)? and 1 + ?n/ ?log2 v? ?, respectively. It has been proved that the sizes listed above are optimal for some cases.
11317#Achieving efficiency in database management functions is a fundamental problem underlying many computer applications. Efficiency is difficult to achieve using the traditional general-purpose von Neumann processors. Recent advances in microelectronic technologies have prompted many new research activities in the design, implementation, and application of database machines which are tailored for processing database management functions. To build an efficient system, the software algorithms designed for this type of system need to be tailored to take advantage of the hardware characteristics of these machines. Furthermore, special hardware units should be used, if they are cost- effective, to execute or to assist the execution of these software algorithms.
11318#Several hardware algorithms to search for a large number of keys in a database are presented. These algorithms allow some false matches but guarantee hits for the desired search keys. This imperfectness allows us to design a variety of simple hardware searchers by using only RAM's and shift registers. Analytic models are developed to compare the performances of these hardware devices. Applications of these devices for database systems are also discussed.
11319#This correspondence proposes a new fault model for system diagnosis, wherein the interaction among faulty subsystems and fault propagation is considered. Criteria for one-step diagnosability are given. Optimal design of diagnosable systems is also developed. As to sequential diagnosis, single-loop systems are studied in depth.
11320#Linear feedback shift registers have been proposed to generate test patterns for the self-test of logic networks. The probability of linear dependence among k bit positions of a subset of k bits in a maximum length shift register sequence is an outstanding problem. In this correspondence, we derive a formula for the calculation of the probability.
11321#Earlier spectral signature testing methods are extended to the multiple stuck-at fault model. The testability condition for multiple- input faults is established and a minimal spanning signature (MSS) is defined to cover all these faults. It is then shown that an MSS, which in most cases contains a single spectral coefficient, will detect over 99 percent of all input and internal multiple faults. An approach is described to obtain a complete signature for all multiple faults in any irredundant combinational network with comparatively small numbers of fan-outs. Tree networks that include XOR/XNOR gates are shown to be easily tested. Internally fan-out-free and general irredundant networks are also considered. A design approach is proposed to enable a network to be tested for all single and most multiple faults using a single coefficient, with the possible overhead being an extra control input.
11322#In this paper we present a new built-in test methodology for detecting and locating faults in digital systems. The technique is called roving emulation and consists of an off-line snap shot type emulation or simulation of operating components in a system. Its primary application is in testing systems in the field where real-time fault detection is not required. The primary performance measure of this test schema is taken to be the expected value of the error latency, i.e., the time required to detect a fault once it first occurs. The primary results of this paper deal with deriving equations for the error latency. We present both a probabilistic and service-waiting model to analyze the expected error latency in a system tested via roving emulation. The effects of various controllable and uncontrollable system parameters on error latency are studied. Finally, the technique is applied to a system consisting of combinational logic modules, and numerical results are presented.
11323#In this paper, a new model for parallel computations and parallel computer systems that is based on data flow principles is presented. Uninterpreted data flow graphs can be used to model computer systems including data driven and parallel processors. A data flow graph is defined to be a bipartite graph with actors and links as the two vertex classes. Actors can be considered similar to transitions in Petri nets, and links similar to places. The nondeterministic nature of uninterpreted data flow graphs necessitates the derivation of liveness conditions.
11324#The Language for temporal ordering specification (LOTOS) is a formal description technique whose development is under way within ISO, the International Organization for standardization, mainly for application to open systems interconnection (OSI) standards. The paper presents a LOTOS specification of the PROWAY interface for process control applicatioins, defined by IEC, the International Electrotechnical Commision. LOTOS is shown to be tailored for the specification of asynchronous systems. In particular, it proves suitable for the specification both of the services which define an interface and of the protocols which implement it. The paper shows how LOTOS supports formal reasoning aimed at establishing consistency between service and protocol specifications. Two examples of such a verification are developed that are related to the PROWAY interface. Finally, advantages and limitations of this approach are outlined.
11325#This paper examines several ways of implementing multigrid algorithms on the hypercube multiprocessor. We consider both the standard multigrid algorithms and a concurrent version proposed by Gannon and Van Rosendale. We present several mappings of the mesh points onto the nodes of the cube. The main property of these mappings, which are based on binary reflected Gray codes, is that the distance between neighboring grid points remains constant from one grid level to another. This results in a communication effective implementation of multigrid algorithms on the hypercube multiprocessor.
11326#A group of disks may be interleaved to speed up data transfers in a manner analogous to the speedup achieved by main memory interleaving. Conventional disks may be used for interleaving by spreading data across disks and by treating multiple disks as if they were a single one. Furthermore, the rotation of the interleaved disks may be synchronized to simplify control and also to optimize performance. In addition, check- sums may be placed on separate check-sum disks in order to improve reliability. In this paper, we study synchronized disk interleaving as a high-performance mass storage system architecture. The advantages and limitations of the proposed disk interleaving scheme are analyzed using the M/G/1 queueing model and compared to the conventional disk access mechanism.
11327#Synthesis of a family of matrix multiplication algorithms on a linear array is described. All these algorithms are optimal in their area and time requirements. An important feature of the family of algorithms is that they are modularly extensible, that is, larger problem sizes can be handled by cascading smaller arrays consisting of processors having a fixed amount of local storage. These algorithms exhibit a tradeoff between the number of processors required and the local storage within a processor. In particular, as the local storage increases the number of processors required to multiply the two matrices decrease.
11328#We describe and analyze row/column replacement, the technique currently used to control hard cell defects in semiconductor RAM's during manufacture. This strategy is shown to be asymptotically ineffective; it is demonstrated that this ineffectiveness may become a limiting issue for very large memory arrays.
11329#In this correspondence we develop a parallel algorithm to compute the all-pairs shortest paths and the diameter of a given graph. Next, this algorithm is mapped into a suitable VLSI systolic architecture and the performance of this proposed VLSI implementation is evaluated.
11330#The fault diagnosability problem is the problem of computing the maximum number of faulty units which a system can tolerate without losing its capability of identifying all such faulty units. We study this problem for the model introduced by Barsi, Grandoni, and Maestrini [2]. We present a new characterization of the model, and develop an efficient diagnosability algorithm for a system in this model.
11331#In this correspondence, the complex integer multiplier and adder over the direct sum of two copies of finite field developed in [1] is specialized to the direct sum of the rings of integers modulo Fermat numbers. Such multiplication over the rings of integers modulo Fermat numbers can be performed by means of two integer multiplications, whereas the complex integer multiplication requires three integer multiplications. Such multiplications and additions can be used in the implementation of a discrete Fourier transform (DFT) of a sequence of complex numbers. The advantage of the present approach is that the number of multiplications needed to compute a systolic array of the DFT can be reduced substantially. The architectural designs using this approach are regular, simple, expandable and, therefore, naturally suitable for VLSI implementation.
11332#Coherence and chaos in the driven damped sine-Gordon equation: measurement of the soliton spectrum
11333#Connection formulae for Painleve´ V functions
11334#Self-adjoint formulation of spherically symmetric hydrodynamics
11335#Steady solutions of the Kuramoto-Sivashinsky equation
11336#External field induced chaos in an infinite square well potential
11337#Kink-antikink interactions in the double sine-Gordon equation
11338#Transition to topological chaos for circle maps
11339#Chaotic perturbations of Kdv. I. rational solutions
11340#Nonlinear dynamics of a convection loop: a quantitative comparison of experiment with theory
11341#Discreteness effects on non-topological kink soliton dynamics in nonlinear lattices
11342#Some observations on the questions: is ventricular fibrillation "chaos"?
11343#An iterated implicit complex map
11344#A three-parameter shooting method as applied to a problem in combustion theory
11345#Frontiers of chaos
11346#Some open problem
11347#Visualizing mathematics: evolution of vortical flows
11348#The solitons of Zabusky and Kruskal revisited: perspective in terms of the periodic spectral transform
11349#Solitary wave collisions revisited
11350#Nonlinear dynamics in driven, damped sine-Gordon systems
11351#Chaos and coherent structures in partial differential equations
11352#The Kuramoto-Sivashinsky equation: a bridge between PDE's and dynamical systems
11353#Pattern selection and instability in nonlinear wave equation-an aspect of soliton and chaos
11354#Linearization on a submanifold of integrable Hamiltonians with polynomials potentials
11355#Aspects of the Painleve´ property for partial differential equations
11356#Algebras and manifolds: differential, difference, simplicial and quantum
11357#Multidimensional nonlinear evolution equations and inverse scattering
11358#The D-bar approach to inverse scattering and nonlinear evolutions
11359#On dispersive difference schemes
11360#Two-dimensional Schro¨dinger operator: inverse scattering transform and evolutional equations
11361#The Maxwell, Yang-Mills and Einstein equations and closed path parallel propagation
11362#Complete integrability of the Kadomtsev-Petviashvili equations in 2+1 dimensions
11363#Some nonlinear evolution equations and related topics arising in medical imaging
11364#Baxter equations and the Zamolodchikov model
11365#Corner transfer matrices and Lorentz invariance on a lattice
11366#Toda lattice equation and Wronskians in the 2d Ising model
11367#The Klein-Gordon-Maxwell nonlinear system of equations
11368#The direct linearizing transform for three-dimensional lattice equations
11369#Some new results on exactly solvable models
11370#The Hamiltonian structure for dynamic free boundary problems
11371#A paradigm for jointed Hamiltonian and dissipative systems
11372#How a swing behaves
11373#Characterization of hydrodynamic strange attractors
11374#Multi-scale expansions in the theory of systems integrable by the inverse scattering transform
11375#Turbulence in coupled map lattices
11376#ACM SIGPLAN Notices
11377#APL arrays can be perceived to consist of several parts. This concept is extended and rationalized. Together with keyed indexing, it allows to treat all entities in an APL system as arrays. The human interface to such a system is a recursive array editor (ae), which is isomorphic to the APL language.Finally, a design of such an editor for a workstation with bitmapped display is presented.
11378#Concurrent use of generic types in MODULA-2
11379#The general trend in the development of parser theory is in the direction of exploring implementing methods of increasing power. In particular, ways of improving the efficiency of LR parsers and the generation of LR tables have been receiving a lot of attention. The value of increasingly powerful tools is questioned from the point-of-view of the need to keep definitions of languages understandable to the programmer. Consideration is given to Wirth's contention that recursive descent is the method of choice and alternatives are suggested.
11380#Visionaries: An interview with professor Michael O'Leary
11381#Keyword input for C
11382#Number crunching in C
11383#A powerful, second-order universal closure operator is proposed and its usefulness in constructing clear, efficient programs is demonstrated.
11384#Protecting against uninitialized abstract objects in Modula-2
11385#A simple alternative to language-based editors that employ attribute grammars is proposed in the form of a language independent program editor. This system delegates semantic issues to the back end of the compiler in question, yet resolves all lexical and syntactic questions so that lengthy recompilation after an editing session is bypassed. Finally a prettyprinting-like system is outlined that deals with the text formatting problems in a language independent way.
11386#Ada vs. Modula-2: A response from the ivory tower
11387#Comments on “A View from the Trenches”. Ada vs. Modula-2 vx. Praxis
11388#The programming languages PASCAL and C belong to the class of algorithmic compiled languages, and feature comparable facilities. The syntax of C is more regular and enjoys less restrictions than that of PASCAL. Consequently, the syntax of C is significantly simpler than that of the PASCAL language. The design differences are particularly apparent as far as data types, operators, and system interface are concerned. PASCAL implements abstract data types (booleans, sets), whereas C defines data types that reflect the architecture of currently available computers. For PASCAL, the system interface is implemented via functions built in the language and is therefore not extensible by the user. Most of the practical implementations of the language require non standard extensions. In C, system calls and libraries of subroutines and macro instructions are provided to handle the system interface. The portability of applications then depends on the libraries and not on the compiler. A greater flexibility is thus achieved. The use of pointers and the rich set of operators of the C language make it more general than PASCAL, while retaining the principles of structured programming. Separate compilation is a standard feature of C, not of PASCAL. PASCAL compilers are often complex, while C compilers are simple and compact. C compilers include a macro processor, and the program verifier is a separate tool. The application programmers have more responsibility programming in C than in PASCAL, conversely, applications depend less on compilers in C than in PASCAL.
11389#Optimizing compilers are here (mostly)
11390#TRC is a compiler that is useful in building expert systems. The input is a rule based language. The output is a set of C language procedures. The principal advantages of TRC over existing expert system construction tools are speed of execution and portability of the code generated by TRC. The name TRC is an acronym for Translate Rules to C.
11391#Confessions of a used program salesman - The loves in My Life
11392#Recursion: A choice between readability and execution speed
11393#What it's like to be a POPL referee; or how to write an extended abstract so that it is more likely to be accepted
11394#Matrix manipulations in REDUCE [1] are governed by a matrix subprogram made by HEARN which works nicely but gives too restrictive possibilities to the user working exclusively in the algebraic mode. Specifically, apart from the basic algebraic operations, one has the possibilities to compute the inverse, the transpose, the determinant and the trace of a matrix.
11395#We describe the implementation of a translator from the algorithm description language ALDES to Common LISP. ALDES is the language of the SAC-2 computer algebra system. We indicate why this translation is beneficial. By giving examples we also show how the translation was made.
11396#GOEDEL is a language for the description of general symbolic manipulations. In this generality GOEDEL can be compared with LISP. However, GOEDEL is much higher than LISP and is more oriented to the application for algebraic calculations. Concerte mathematical manipulations e.g. of polynomials are realized by the invokation of GOEDEL procedures.
11397#The hybrid algorithm for solving the three-level linear programming problem
11398#A chi-square statistic for validating simulation-generated responses
11399#The problem of assigning students to course sections in a large engineering school
11400#The mixed cutting plane algorithm for all-integer programming
11401#A new cutting-stock heuristic for scheduling production
11402#Computational comparison of policy iteration algorithms for discounted Markov decision processes
11403#On a multiserver Markovian queueing system with balking and reneging
11404#A decision support system for database evolution using data model independent architecture
11405#Polynomial approximation technique for dynamic optimization problems
11406#Extensions of the dynamic programming method in the deterministic and stochasticassembly-line balancing problems
11407#Let{X_{i}}_{i=1}^{infty}be a sequence of independent Bernoulli random variables with probabilitypthatX_{i} = 1and probabilityq=1-pthatX_{i} = 0for alli geq 1. Time-invariant finite-memory (i.e., finite-state) estimation procedures for the parameter p are considered which takeX_{1}, cdotsas an input sequence. In particular, an n-state deterministic estimation procedure is described which can estimate p with mean-square errorO(log n/n)and ann-state probabilistic estimation procedure which can estimatepwith mean-square errorO(1/n). It is proved that theO(1/n)bound is optimal to within a constant factor. In addition, it is shown that linear estimation procedures are just as powerful (up to the measure of mean-square error) as arbitrary estimation procedures. The proofs are based on an analog of the well-known matrix tree theorem that is called the Markov chain tree theorem.
11408#A method is presented for parametric modeling of stationary random fields. The class of parametric models considered allows the most general elliptic field, and by linear constraints can include such special cases as isotropic, quarter plane, and separable fields. The technique, based on the cepstrum, has the great advantage of requiring only the use of fast Fourier transforms in the fitting process. Thus, unlike the fitting of two-dimensional autoregressions, no iteration is necessary. Other advantages are that any (Wiener) filters constructed from the fitted spectrum are guaranteed to be stable, and that the spectrum is guaranteed to be positive. Statistical tests for determining various special types of field from data are developed. The choice of model order is discussed as well.
11409#The large sample properties of a new class of histogram estimators whose derivation is based on an information theory criterion--the maximum entropy principle, which preserves the observed mass and mean--are studied. The pointwise strong consistency, the point-wise asymptotic normality, and the rate of convergence to normality are investigated. The asymptotic mean square error (MSE) of these estimates is also compared relative to the histogram based on spacings, the classicalk-nearest neighbor, the kernel estimator, and the generalizedk-nearest neighbor density estimator.
11410#LetCbe a code of lengthnand rateRover the alphabetA(Q)={ exp (2pi ir/Q): r=O,1, cdots ,Q-1}, and letd(C)be the minimum Euclidean distance ofC. For largen, the lower and upper bounds are obtained in parametric form on the achievable pairs(R, delta), wheredelta = d^{2}(C)/nholds. To obtain these bounds, the arguments leading to the Gilbert bound and the Elias bound, respectively, are applied to the alphabetA(Q). ForQ rightarrow infty, they are shown to be expressible in terms of the modified Bessel function of the first kind. The Elias type bound is compared with the Kabatyanskii-Levenshtein (K-L) bound that holds for less restrictive alphabets. It turns out that our upper bound improves the K-L bound fordelta leq 0.93.
11411#It is shown that for each integerb geq 1infinitely many optimum cyclicb-burst-correcting codes exist, i.e., codes whose lengthn, redundancyr, and burst-correcting capabilityb, satisfyn = 2^{r-b+1} - 1. Some optimum codes forb = 3, 4, and5are also studied in detail.
11412#A design procedure is presented for synthesizing threshold decodable rate1/nand(n - 1)/nself-orthogonal block codes obtained from truncating convolutional codes by generalized tail-biting (GTB). When GTB is applied to an equal error-protection threshold decodable convolutional code, the result is a class of unequal error-protection threshold decodable block codes. These codes are related to unequal error-protection codes previously described by Mandelbaum [1]. Furthermore, the codes of Mandelbaum are generalized.
11413#A trellis code is {em homogeneous} if the number of branches emanating from each node (or state) in the trellis diagram is constant. For example, convolutional codes are linear homogeneous trellis codes. A trellis code is {em nonhomogeneous} if the number of branches emanating from each node in the trellis diagram is not the same. The two-user binary adder channel is a multiple-access channel with two binary inputs,x_{1}andx_{2}, and one ternary output,y = x_{1} + x_{2}, where the addition is done in the real number field. The adder channel is synchronous if both encoders and the decoder maintain block (frame) synchronism. It is quasi-synchronous if the encoders do not start their blocks at the same time, but the decoder knows the position of each block. The difference between the starting times of the blocks is called the slippage. The channel is asynchronous if no block synchronism exists among the encoders and the decoder. Some uniquely decodable code pairs(C_{1}, C_{2})are presented that can be used to transmit information reliably over the quasi-synchronous binary adder channel with two users. One of the codes is a nonhomogeneous trellis code, the other is a common block code. Our code rates are better than Deaett-Wolf codes and are close to or equal to the asymptotic rates of Kasami {em et al}. A method for calculating the rates of nonhomogeneous trellis codes is described. An algorithm for finding more uniquely decodable code pairs for the quasi-synchronous binary adder channel is formulated.
11414#Calderbank, Heegard, and Ozarow [1] have suggested a method of designing codes for channels with intersymbol interference, such as the magnetic recording channel. These codes are designed to exploit intersymbol interference. The standard method is to minimize intersymbol interference by constraining the input to the channel using run-length limited sequences. Calderbank, Heegard, and Ozarow considered an idealized model of an intersymbol interference channel that leads to the problem of designing codes for a partial response channel with transfer function(1 - D^{N}) /2, where the channel inputs are constrained to bepm 1. This problem is considered here. Channel inputs are generated using a nontrivial coset of a binary convolutional code. The coset is chosen to limit the zero-run length of the output of the channel and so maintain clock synchronization. The minimum squared Euclidean distance between outputs corresponding to distinct inputs is bounded below by the free distance of a second convolutional code which we call the magnitude code. An interesting feature of the analysis is that magnitude codes that are catastrophic may perform better than those that are noncatastrophic.
11415#Zakai forms for the prediction and smoothing equations are obtained which, like the Zakai filtering equation, are linear in the unnormalized conditional expectation.
11416#Parl has previously given error bounds suitable for calculating Marcum'sQ-function. However, it is shown that additional terms in the error bound are necessary for accurate calculations of the generalizedQ-functionQ_{m}(alpha, beta). The values ofm, alpha, andbetathat result in successful algorithm completion are examined. Numerical results are presented for calculations of the noncentral chi-square distribution and the probability of detection for a classical multiobservation detection problem.
11417#The problem of determining the moments of the output of a resistance-capacitance (RC) filter driven by a random binary process is considered. It is assumed that the driving process is governed by an alternating renewal process. A method is given for computing the moments of any order, as well as the conditional moments and moments of the local maxima and minima. Explicit formulas are given for the second moment in the asymmetric case and second and fourth moments in the symmetric case.
11418#The following two problems are dealt with: P1) finding the smallest rate,R, of a binary code of lengthnadmitting a prescribed covering radiusrho n; P2) discovering whether a majority of codes with any rate larger thanRadmits the given covering radius. For the class of unrestricted (nonlinear) codes a solution to both problems is obtained by an elementary averaging argument. The solution to P1 isR = 1 - H(rho) + O(n^{-1} log n)and the answer to P2 is positive. As for the more interesting class of linear codes, Goblick's extension method shows that the solution to P1 is the same as in the unrestricted case; in contrast, P2 seems to remain an open question. A simple derivation of Goblick's result is presented, and a discussion is made of the positive conjecture concerning P2 for linear codes.
11419#The nonexistence of a uniformly-packed[70, 58, 5]codeC^{perp}is proved by examining geometries associated with the3-weight codeC.
11420#Codes possessing certain types of automorphisms are examined. In one case, the code can be decomposed as a direct sum of two subcodes, which can be viewed as shorter length codes. In a second case, the code itself corresponds to a shorter length code. Related results and applications are given.
11421#The usual(k_{2} + 1) times (k_{1} + 1)array code, in which the last row and the last column contain redundant bits, can correct any single error. However, if the bits are read diagonally instead of horizontally, the code can correct bursts of errors. It is shown that the(_{k}2 + 1) times (k_{1} + 1)array code with diagonal readout can correct any burst of length up tok_{1}if and only ifk_{2} geq 2(k_{1} - 1).
11422#It is well-known that variable-length coding schemes can be employed in entropy encoding of finite-alphabet sources. To transmit these codes over a synchronous channel, however, requires a buffer. Since in practice this buffer is of finite size, it is subject to both overflow and undertow. The buffer behavior is studied with particular application to Huffman coding of the outputs of an optimum uniform-threshold quantizer driven by a memoryless Gaussian source. Fairly general upper and lower bounds on the average terminal time are developed. Under certain conditions, the tightness of these bounds is verified, and asymptotic formulas are developed. As an example, an encoding scheme employing Huffman codes in conjunction with uniform quantization of memoryless Gaussian sources is considered, and the buffer behavior as a function of the buffer size and output rate is studied.
11423#A probabilistic polynomial-time algorithm for computing the square root of a numberx in {bf Z}/P{bf Z}, whereP = 2^{S}Q + 1(Qodd,s > 0)is a prime number, is described. In contrast to the Adleman, Manders, and Miller algorithm, this algorithm gets faster as s grows. As with the Berlekamp-Rabin algorithm, the expected running time of the algorithm is independent ofx. However, the algorithm presented here is considerably faster for values ofsgreater than2.
11424#The Maximum Entropy (ME) and Maximum Likelihood (ML) criteria are the bases for two approaches to statistical inference problems. A new criterion, called the Minimum Description Length (MDL), has been recently introduced. This criterion generalizes the ML method so it can be applied to more general situations, e.g., when the number of parameters is unknown. It is shown that ME is also a special case of the MDL criterion; maximizing the entropy subject to some constraints on the underlying probability function is identical to minimizing the code length required to represent all possible i.i.d, realizations of the random variable such that the sample frequencies (or histogram) satisfy those given constraints.
11425#The problem of achieving synchronization for variable-length source codes is addressed through the use of self-synchronizing binary prefix-condition codes. Although our codes are suboptimal in the sense of minimum average codeword length, they have the advantages of being generated by an explicit constructive algorithm, having minimal additional redundancy compared with optimal codes-as little as one additional bit introduced into the least likely codeword for a large class of sources-and having statistical synchronizing performance that improves on that of the optimal code in many cases.
11426#New upper bounds on the redundancy of Huffman codes are provided. A bound that for2/9 leq P_{1} leq 0.4is sharper than the bound of Gallager, when the probability of the most likely source letterP_{1}is the only known probability is presented. The improved bound is the tightest possible for1/3 leq P_{1} leq 0.4. Upper bounds are presented on the redundancy of Huffman codes when the extreme probabilitiesP_{1}andP_{N}are known.
11427#First Page of the Article
11428#The analysis of multiple response simulation output data: experiments of comparison
11429#Optimal M/G/1 server location on a tree network with continuous link demands
11430#On the set partitioning type formulation for the discrete location problem
11431#Parallel exponential queues with dependent service rates
11432#Network generation using the Prufer code
11433#A simple strategy for solving a class of 0-1 integer programming models
11434#Near-optimal solutions to one-dimensional cutting stock problems
11435#Abandonment value in capital budgeting: a mathematical programming approach
11436#A set of eight simple diagrams with accompanying explanations has proved quite effective as a tool for teaching the concepts of mutual exclusion and deadlock in an operating systems course. This note presents the diagrams in a manner suitable for direct reproduction as viewgraphs or class handouts and touches upon the major points in explaining the diagrams to students.
11437#The design and prototype implementation of an interpreter for a small BASIC-like language makes an excellent project illustrating the value of abstraction and modular decomposition. Such a project can be assigned in several different courses, either as a sequence of short assignments or as a term project.
11438#This paper describes an implementation of the relational database management system, OMEGA. OMEGA is designed to be "query language independent" in order to promote the investigation of experimental query languages by graduate students. OMEGA also supports the query language SQL and as such, is used in undergraduate database courses to demonstrate the features of SQL.
11439#A proposed redesign of the introductory service course in computer science
11440#A career component to the computer science curriculum cooperative education
11441#The use of LOGO as a first language in Computer Science is examined and compared to the use of Applesoft BASIC. The method for demonstrating LOGO's adequacy is based on comparisons with ACM's CS1 model.
11442#A language independent course in program design and programming for MIS students
11443#The theory and practice of Software Engineering is introduced to undergraduate computer science students in their third year at the University of Ife. It is taught as part of two Commercial Programming courses, one in the first semester and the other in the second semester. This paper discusses the modus operandi of this exercise and outlines the topics covered in the instruction.
11444#As the Ada programming language becomes established, it will have an impact on computer education. In the short term, there will be a need to provide Ada exposure to mature upper-level undergraduates who are already skilled in other languages. Although language proficiency is important, this exposure should not focus on language features but rather on the support Ada provides to modern software engineering practice. The content of a course providing such an exposure is described together with a pedagogical approach that proved to be quite successful.
11445#The use of the music operating system to supplement the teaching of cobol
11446#Hardware independent programming for a computer graphics course
11447#A liberal arts course in computer science should convey a computational view of nature. This is best achieved by focusing on a few ideas.
11448#Teaching a modern data structures course
11449#An undergraduate Computer Science course in Robotics has been offered for the past two semesters. Supporting the course is a laboratory with six Hero I robots. Students learn how to program the robots in 6808 assembly language.
11450#Exercises for introducing software engineering concepts in a data stuctures course
11451#Program visualization deals with the problem of showing the execution of a computer program. In this paper, program visualization is seen to also involve questions of how we conceptually view a program. One such view, namely viewing a program in terms of its action on its data structures, is investigated and a formal mathematical model for this view is presented. Examples are given to illustrate situations where this view is useful and where not so useful.
11452#The Myers-Briggs Type Indicator, Group Embedded Figures Test, the Learning Style Inventory, and a Type A-B Questionnaire were administered to introductory COBOL students along with marketing students to determine if results from these instruments would improve the predictability of student success in computer science. Demographic data was also gathered on the 83 subjects similarly to prior studies. No significant new findings were found in this study; the strongest variable was a student's major grade point average.
11453#Independent studies courses can be an effective means of providing the flexibility for a serious student with a well-planned career path to tailor his or her curriculum to meet the special requirements of the career plan, and to permit the students to experience and learn about subjects for which there is insufficient demand or resources to offer a regular course. The potential for abuse of this course is high as we found at East Tennessee State University. In addressing this issue, we found that we were also able to strengthen the written and oral communications skills which are so important to today's computing professionals. This paper describes the experiences we have had and the solution we discovered.
11454#There are several alternatives for transforming algebraic specifications into executable prototypes. In this note the Equation Interpreter (a rewrite rule interpreter) and the University of New Hampshire Prolog interpreter are viewed as target systems for executing prototypes. The efficiencies of these systems are compared with each other.
11455#Typed functional programming
11456#Extensible and threaded code language FORTH is very popular among amateur programmers but only few professionals admit they use it or are prepared to describe their experience.The author has been using a directly threaded variation of FORTH, called F, for development of a couple of software products. And although convinced of the language usefulness as an implementation tool he would like to point out a few problem areas which he encountered during the development and life time of these products.
11457#On some extensions of syntactic error recovery technique based on phrase markers
11458#Measurements of migratability and transportability
11459#In recent years, no programming language has received the international attention of PROLOG. Currently the Japanese Fifth Generation computing Systems Project (ICOT) is attempting to build an entire series of computers around this language in order to implement a new generation of computers based on symbolic inferencing techniques. In the United States and Europe, PROLOG is being used in relational database applications, natural language processing, theorem proving and automated reasoning, and a variety of other artificial intelligence applications.In this article, we compare several of the newer PROLOG interpreters and compilers with regard to their functionality. This information is useful to researchers in selecting the product which will be the most relevant to their applications.
11460#Fast Hough transform: A hierarchical approach
11461#A distributed system for analyzing time-varying multiresolution imagery
11462#Shape and motion of nonrigid bodies
11463#Closed form solutions to image flow equations for planar surfaces in motion
11464#Determination of the identity, position and orientation of the topmost object in a pile
11465#Identification of 3D objects from multiple silhouettes using Quadtrees/Octrees
11466#Task frames: Primitives for sensory-motor coordination
11467#Shape from perspective: A rule-based approach
11468#Hypothesis integration in image understanding systems
11469#Computer vision theory: The lack thereof
11470#Anything you can do, I can do better (no you can't)
11471#Quantity versus timing change in open order: A critical evaluation
11472#Revised report on the algorithmic language scheme
11473#On Hartmann's error-recovery scheme
11474#The RELFUN programming language is introduced as an attempt to integrate the capabilities of the relational and functional styles. Definitions of functions and relations are specified uniformly by valued Horn clauses, where rules return the value of their rightmost premise. Functional nestings are flattened to relational conjunctions, using a purified version of PROLOG's is-primitive. RELFUN functions may have non-ground arguments, like relations, and/or return non-ground values; their input and output arguments can be inverted like those of relations. Higher-order functions are definable as (function-) valued clauses, with funarg problems being avoided by the standard renaming of clause variables. RELFUN's operational semantics is specified as an abstract machine, which also yields its first (e-mailable) FRANZ LISP implementation.
11475#Solutions to the n Queens problem using tasking in Ada
11476#In their useful article "Pitfalls in Prolog Programming", Ng and Ma [1] discuss some ways that novice programmers can be confused while learning Prolog. They suggest that the confusions result from certain properties of Prolog, in particular the way that it diverges from the "ideal" of programming in pure logic. In fact, I suggest that Ng and Ma are attributing to Prolog powers that it simply does not have, and that confusions are usually the result of the novice's misplaced confidence in his abilities to reason about programs.
11477#In /Mä86/ (SIGPLAN Notices 3/1986) Männer proposes an extension of Pascal permitting the use of physical units in programs. We discuss his issues in this paper and describe our own somewhat different approach. Our language extension PHYSCAL of Pascal not merely satisfies the requirements suggested by /Mä86/, but also supports predefined units (International Standard), thorough realisation of the concept of scale factors, input/output facilities for numbers with units. The new concepts are motivated, and the language description is given formally and by examples. Finally we discuss some details of the realised language implementation by a PHYSCAL-to-Pascal preprocessor in an UNIX environment.
11478#Programming in Smalltalk-80: observations and remarks from the newly initiated
11479#The Pascal standard (BS6192/ISO7185) is due for revision in about 1987, with BSI as the "sponsoring body". Consideration of the revision began in 1984 within BSI. In addition, the Joint X3J9/IEEE-P77Ø Pascal Standards Committee (JPC) has coordinated a great deal of research into proposed extensions to classic Pascal. An ISO Pascal working group, mainly composed of BSI and JPC members, was set up in 1985 to produce an "Extended Pascal" standard; this group has agreed with JPC the contents of a draft for public comment.
11480#Alex is a scanner generator which translates the lexical description of a programming language into a scanner for that language. The scanner description language is easy to use, as it is intentionally small and simple. Alex as well as the generated scanners are written in Modula-2 and implemented on several microcomputers. The scanner generator may be used in conjunction with a compiler-compiler. As an example we show how to describe the lexical structure of Modula-2 with our tool. The scanner generated from that description is only about 20 percent slower than a hand-coded scanner.
11481#This paper introduces the "semi-syntactic lexical analyzer", a new concept of lexical analyzer which is capable of recognizing program fragments. The significant results of such an analyzer are that some syntactic analysis can be omitted, better intermediate or object codes can be generated and a new compiler model is thus derived. The main difference among currently used models and our new model is that currently used models separate input symbol stream into tokens, while our new model separates them into "meaningful units" (simple expressions or even part of an expression) if possible. We found that separating them into meaningful units is much easier for further analysis, translation and optimization.
11482#An overview of Miranda
11483#A powerful method of parsing is presented, that suits particularly well the Graham-Glanville code generation methodology. This parsing method can be applied to any prefix grammar. It is shown how a table is generated and used to achieve parsing efficiency.
11484#The microcomputer revolution in operations research
11485#Comparative performance of advanced microcomputer LP systems
11486#Nonlinear programming on a microcomputer
11487#Microcomputer simulation systems
11488#Comparing statistical software for microcomputers
11489#Forecasting software for microcomputers
11490#Microcomputers and the teaching of operations research
11491#Project management using a microcomputer
11492#Microcomputer systems for manufacturing planning and control
11493#Microcomputer-based vehicle routing and scheduling software
11494#Decision insight systems for microcomputers: a critical evaluation
11495#Expert systems, microcomputers, and operations research
11496#Down from the clouds: notes on :20Expert systems, microcomputers, and operations research”
11497#Creating a shell-based expert system
11498#Selecting an approach to knowledge processing
11499#Comment on “Expert systems, microcomputers, and operations research”
11500#Desktop computing in science and engineering: the next five years
11501#Implementation issues for operations research software
11502#Modeling with microcomputers for operations research
11503#Conversions on the net: the professionalism issue
11504#Should a computer literacy class be the first required course for data processing majors
11505#An interactive interpreter/graphic-simulator for IBM S/370 architecture assembly language
11506#And still more on retraining mathematics faculty to teach undergraduate computer science
11507#Teaching microcomputer concepts through modelling
11508#My freshmen learn recursion
11509#An instructional environment for programming using the Vax 11 with a three-colorprojector
11510#Subprograms in the first programming course: an early but non-trivial introduction
11511#Fewer control structures considered helpful
11512#A course in compiler construction will allow students to examine how a high-level language program is accepted as input and translated into assembly language or machine language so that the central processing unit receives instructions which it understands and can execute. This paper outlines the compiler construction course as it is taught at West Chester University, with emphasis on the compiler writing project assigned to the students.
11513#New microcomputer graphics routines designed for undergraduate teaching
11514#Second language courses are different beasts
11515#Pre-college computer use: U.S. versus Japan
11516#Increasing demand for software engineers has caused academia to search for means to incorporate software engineering into the existing computer science curriculum. This paper explores traditional software engineering instructional methods and then provides a case study of a two semester practicum modeled after specialized training programs. These practicums, integrated into the University of Idaho Computer Science program, require all computer science seniors to solve "real-world" software engineering problems for actual customers. The practicums serve as quality control exit requirements to ensure that computer science graduates have the software engineering skills required in industry and graduate school. The integrated nature of the computer science program uniquely provides experiential variety while fostering individual responsibility, group interaction skills, and practical experience.
11517#Simulation of digital networks can be enhanced by interactive graphics to provide an experimental environment that rivals breadboarding as a "hands-on" logic-design experience.The simulator described here allows interactive keyboard entries during the simulation interval providing activation of network switches and pulsers, restarting or slowing the simulation, graphical expansion of modules in terms of their internal components, graphical pan and zoom for better resolution of sub-networks, and multiple viewing windows onto the virtual space of the network. The simulation is three-level and event driven, and allows the specification of periodic clock signals of unlimited duration.A pre-processor allows the macro definition of modules and provides the necessary independence of local variables that is required for multiple instantiation. Although inherently recursive, the macro processor can be supplemented with library macros that support iterative specification. This feature allows the construction of networks with interated cell structures.
11518#The war of languages
11519#Third normal form made easy
11520#Certain skills are needed to teach computer-science course effectively. These skills range from the ability to write clear course objectives to the ability to present material well and to counsel students ably. Most of us need some assistance in sorting out these skills and creating from them a surefire, step-by-step teaching procedure. The suggestions that follow will help you do just that, enabling you to prepare and present your ideas in less time and with better results.Use this information as a checklist before, during, and after your course. During the course, you will probably want to obtain some feedback on your performance. You may want to either conduct a trial run with an audience of your colleagues or have someone sit in on your first few class meetings and check your performance. You could also read over the list before each class (always a good idea) and check your own performance right after each class.
11521#Student difficulty in expressing computing concepts in clear, concise English has stimulated me to introduce a writing assignment into various Computer Science courses. This article describes the problem, the goals of the assignment, and student improvement and reaction.
11522#Consistent generics in Modula-2
11523#This paper is to compare the dynamic and static approaches towards the analysis of the length equation, which is the most fundamental and important equation in the theory of software science. In addition to intuition, our empirical results give further support to the claim that dynamic approach is more appropriate than the static approach towards the theory of software science.
11524#We present an introductory description of Convert, a programming language applicable to symbol manipulation problems whose solution may be expressed in terms of transformation rules. We discuss the experience derived from our use of the language and mention some future applications.
11525#NEMO - A nicely modified YACC
11526#Reasonably priced compilers an interpreters for the IBM PC and compatible computers
11527#The line-oriented approach
11528#A programming language is an intermediate medium between the human user and the machine. Ideally it should reduce the gap between human reasoning and the machine's processing mechanism to the minimum. Accordingly, none of the contemporaryprogramming languages can be said to be ideal. Prolog is no exception. However, it is usually emphasized that programming in Prolog is very easy, even a beginner can handle it within a few hours of learning. The rationale behind this conception is that Prolog clauses are actually some logical statements, and logic is the basis of every rational subject. The problem arises in that Prolog programming is not equivalent to logic programming. Prolog still shares the effect of the influence of the fundamental Von Neumann computer architecture on conventional programming languages. If a user wants to write a Prolog program just according to his logical reasoning, he will probably fall into an unexpected trap of the language.
11529#A modification and extension of an algorithm for generalized cell mapping
11530#Conjugate gradient algorithms in nonlinear structural analysis problems
11531#Block-implicit multigrid calculation of two-dimensional recirculating flows
11532#Petrov-Galerkin formulations with weighting functions dependent upon spatial and temporal discretization: Applications to transient convection-diffusion problems
11533#The finite element solution of laminar combined convection from two spheres in tandem arrangement
11534#A new finite element formulation for computational fluid dynamics: V. Circumventing the Babus&caron;ka-Brezzi condition: A stable Petrov-Galerkin formulation of
11535#Variable explicit finite element methods for unsteady heat conduction equations
11536#Some integration formulas for a four-node isoparametric element
11537#Multilocation plant sizing and timing: a study of some decomposition procedures
11538#The allocation of interstage buffer storage capacity in production lines
11539#Advisory system for control chart selection
11540#Planning facilities layout in clinical laboratories using a group decision making process
11541#A heuristic procedure for determining manufacturing families from design-based grouping for flexible manufacturing systems
11542#Dynamic programming on an electronic spreadsheet
11543#Computer-aided facility location
11544#Expert systems—another frontier for industrial engineering
11545#Analysis and redesign of a military orders processing system
11546#Library layout via graph theory
11547#An application of stochastic geometric programming to heat exchanger design
11548#Managing the microcomputer memory to solve larger scale I.E. problems
11549#Pipeline inspection and maintenance by applications of computer data processing and robotic technology
11550#Some problems of the application of the computerized system for multiple machinery survey and the on-line permanent monitoring of large centrifugal compressors
11551#Real-time failure detection on complex mechanical structures via parallel data processing
11552#Model referenced monitoring and diagnosis - application to the manufacturing system
11553#Development and application of a flexible, modular monitoring an diagnosis system
11554#Learning procedures in machine tool monitoring
11555#Monitoring tasks on boring and milling production cells
11556#A diagnosis system based on fuzzy classification
11557#International conference on production research
11558#Engineering software
11559#The design of distributed transport systems as a major standard interface in computer integrated manufacturing
11560#A methodology for the automation of medium or small manufacturing companies
11561#A novel model reduction method and its application to a pilot distillation column
11562#Synchronization tools and a restart method in an experimental fault-tolerant automation system
11563#Analysis design and evaluation of man-machine systems: 2nd IFAC/IFIP/IFORS/IEA conference
11564#Flexible manufacturing systems
11565#Automation in warehousing
11566#An approach to model-based robot software for industrial applications
11567#Solid modeling in robotic vision
11568#Aproaches to industrial robots application in discrete manufacturing
11569#A message passing approach to robot programming
11570#Engineering robot actions in a computer integrated manufacturing environment
11571#A first order theory of common sense object positioning
11572#From goals to manipulator programs
11573#Design and control of mechanical hands for robots
11574#Accounting for member deformations in the determination of the dynamic behavior of robot-type structures
11575#Research work on robotics
11576#Multilevel marketing networks in less-developed countries
11577#Numerical solution of singular integral equations via initial value methods
11578#A numerical method for the motion of a mixture of two viscous incompressible fluids
11579#Two extension theorems for log-linear representations of positive probabilities
11580#A monotone method for constructing extremal solutions of second order scalar boundary value problems
11581#A note on the existence of traffic equilibria
11582#Stiffness characteristic and the applications of the method of lines on nonuniform grids
11583#An iterative aggregation-disaggregation algorithm for solving linear equations
11584#A class of algorithms for large scale nonlinear minimax optimization
11585#Introduction: Modeling problems in econometrics
11586#Empirical modeling in dynamic econometrics
11587#Testing strategies for model specification
11588#Statistical inference in non-nested econometric models
11589#Model selection for forecasting
11590#Testing causality using efficiently parametrized ARMA models
11591#Structural econometric modeling and time series analysis
11592#Structural time series modeling: A Bayesian approach
11593#Techniques of storing multiple bits of information in a single memory location are reviewed. Any of several states can be stored in ROM's by adjusting the threshold voltage or the size of a particular memory device. In dynamic RAM's, this can be achieved by varying the charge stored on the cell capacitor. The peripheral circuitry required to distinguish between the states stored in the memory areas is discussed.
11594#The multiple-valued logics obtained by introducing uncertainty and energy considerations into classical switching theory are studied in this paper. First, the nature of uncertain or unknown signals is examined, and two general uncertainty types called U-values and P-values are identified. It is shown that multiple-valued logics composed of U/P-values can be systematically derived from 2-valued Boolean algebra. These are useful for timing and hazard analysis, and provide a rigorous framework for designing gate-level logic simulation programs. Next, signals of the form (v, s) are considered where v and s denote logic level and strength, respectively, and the product vs corresponds to energy flow or power. It is shown that these signals form a type of lattice called a pseudo-Boolean algebra. Such algebras characterize the behavior of digital circuits at a level (the switch level) intermediate between the conventional analog and logical levels. They provide the mathematical basis for an efficient new class of switch-level simulation programs used in MOS VLSI design.
11595#We present a new complexity measure for Boolean functions based on partitions of combinatorial circuits into subcircuits, and give upper and lower bounds on the complexity for Boolean functions. Roughly speaking, for a function g whose range is the set of positive integers, g(n)-partition of a circuit is a partition of a circuit into subcircuits such that. 1) each subcircuit has at most g(n) output gates, through which gates in the subcircuit are connected to gates in another succeeding subcircuits and 2) each subcircuit has at most two preceding subcircuits where subcircuit N1 (N2) is said to precede (succeed) subcircuit N2 (N1) when there is a line directed from a gate in N1 to a gate in N2. Our main result, which is stated in terms of a lower bound theorem and an upper bound theorem, is a precise version of the following statement: For "almost all" n-argument Boolean functions fn, the minimum nu mber of subcircuits over g n)-partition of a circuit to compute fn is given as (2n/g(n)22g(n)) unless g(n) grows much more slowly than n as n increases. To prove the theorems, we regard a Boolean circuit, together with g(n)-partition of it, as the multivalued circuit composed of multivalued gates corresponding to the subcircuits obtained from the g(n)-partition.
11596#Basic multivalued building blocks constructed using CCD (charge-coupled devices) technology are presented. They are used to realize simple threshold functions. Existing techniques for decomposition of multivalued multithreshold functions into simpler subfunctions are reviewed. Usage of the CCD technology in implementation of these subfunctions is discussed. Two new decomposition techniques are proposed. Their aim is to obtain realizations that are better suited to CCD technology in terms of the maximum number of thresholds per element and the generation of negative weights. Synthesis techniques based on the proposed decompositions are presented and compared. Although 4-valued logic functions are stressed, the techniques are, in principle, applicable to functions of any radix.
11597#A heuristic method to obtain near-minimal covers of p-valued switching functions is introduced. First, we describe transform tools useful in the processing of MVL functions. They are: p-adic shifting, weighting, and implicant detecting transformations. Based on these tools, a direct cover algorithm is presented that uses local information for heuristic decision making. The heuristics are taken from weight coefficients calculated for canonical terms and implicants. The method allows to assign cost factors to implicants. Further, the algorithms can be modified easily, so as to correspond to various connectives (e.g., MAX, PLUS).
11598#Uncertainty in computer vision can arise at various levels. It can occur in the low level in the raw sensor input, and extends all the way through intermediate and higher levels. Ideally, at any level where decisions are being made on the basis of previous processing steps, a computer vision system must have sufficient flexibility for representation of uncertainty in any of these levels.
11599#The use of quaternary logic input and output signals for delivering information on and off chip could reduce the number of required package pins or increase the amount of information conveyed on a fixed number of package pins. In this correspondence, we discuss the performance of prototype CMOS binary-to-quaternary encoder and quaternary-to-binary decoder test circuits that have been realized on a gate array IC chip.
11600#Nine basic fuzzy logic circuits employing p-ch and n-ch current mirrors are presented, and the fuzzy information processing hardware system design at a low cost with only one kind of master slice (semicustom fuzzy logic IC) is described. The fuzzy logic circuits presented here will be indispensable for a "fuzzy computer" in the near future.
11601#In this correspondence, a new scheme is proposed in which ternary clocking signals are used to replace binary clocking signals in VLSI scan-testing designs. This scheme has the same advantage of high testability as the binary scan method [1], but it eliminates the mode- selecting signal line. Since this mode-selecting line must be routed to each flip-flop in the binary scan scheme, the saving is significant in reducing the circuit interconnection complexity and chip area. This correspondence describes the new ternary scheme in detail, and also suggests appropriate circuit designs using CMOS technology. Furthermore, comparisons are made between ternary scan and binary scan [3] and between ternary scan and a scan scheme using binary with a local decoder [2].
11602#The problem of diagnosability of a system with three-valued test outcomes was considered in earlier works [1]-[3]. However all these works assume the system to be modeled as in [4]. In this correspondence, we consider a more general model of the system and study the diagnosability criteria in presence of three-valued test outcomes. In this model, each unit is tested jointly by a number of other units of the system as opposed to each test being carried out by a single unit of the system as in [4]. Necessary and sufficient conditions for the diagnosability of a system under this general model have been presented in this correspondence. Throughout the correspondence, diagnosability without repair has been considered.
11603#The purpose of this correspondence is to survey the literature concerning the iterative properties of multivalued switching functions. These properties are important for the synthesis of switching circuits by cascades of simpler elements. Our presentation evolves around the graphs of transformations of finite sets. We discuss such topics as limitations of the computational capabilities of cascades, the existence of roots of given functions with respect to iteration powers, etc.
11604#A special group of ternary functions, called regular ternary logic functions, are defined. These functions are useful in switching theory, programming languages, algorithm theory, and many other fields if we are concerned with the indefinite state in such fields. This correspondence describes the fundamental properties and representations of the regular ternary logic functions.
11605#This correspondence deals with the computation of the Chrestenson spectrum of an n-ary, n-place, p-valued function by means of a systolic system. The design of a systolic system in a multiple-valued environment is discussed in details and some aspects are compared to binary realizations.
11606#Comparative performance of broadcast bus local area networks with voice and data traffic
11607#AI-based workstations and knowledge base server design for automated staffing in a local area network
11608#Getting a grip on tools
11609#The 1985 DP budget survey
11610#Fault tolerant blues
11611#Global, shared local
11612#Babbage observed
11613#In search of the perfect programmer
11614#Automatic program debugging for intelligent tutoring systems
11615#The consistent labeling problem and its algorithm: toward exact-case complexities and theory-based heuristics
11616#Profile: a model for generating source-level execution analyzers
11617#A computational model of music transcription
11618#Inferring domain plans in question-answering
11619#On the construction of heuristic functions
11620#An approach to incremental compilation of optimized code
11621#GIL-an experiment in goal-directed inductive learning
11622#Reasoning about systolic algorithms
11623#Parallelring: a token ring local area network with concurrency
11624#Stack-based implementations of concurrent high level languages
11625#Regular interactive algorithms and their implementations on processor arrays
11626#Perfect hashing for external files
11627#Informational and combinatorial aspects of reconstructibility analysis: a mathematical inquiry
11628#Issues in theoretical and practical complexity for heuristic search algorithms
11629#A classification and coding system for CAD/CAM applications in the electronics industry
11630#Rational interaction: cooperation among intelligent agents
11631#The De Bruijn multiprocessor networks
11632#Towards a natural language interface for computer aided design
11633#Physics for robots: representing everday physics for robot planning
11634#Entity structure representation for local area network simulation
11635#RED: a classificatory and abductive expert system
11636#Weighted matching algorithms
11637#Designing fault-tolerant algorithms for distributed systems using communication primitives
11638#Remote evaluation
11639#The computer as the core of health management in food animal populations
11640#Main memory database algorithms for multiprocessors
11641#A first order theory of software component interconnection languages in a maintenance environment
11642#Recognition of partially occluded parts
11643#Parallel processing model for logic programming
11644#A nonclausal inference method for program derivation
11645#Assignment of functional responsibility in perceptrons
11646#The effectiveness and efficiency of agglomerative hierarchic clustering in document retrieval
11647#Bounded parallelism in computer algebra
11648#An expert system for organic synthesis using automated reasoning
11649#The definition of Portals: a language for distributed computing
11650#A methodology, specification language, and automated support environment for com1uter-aided design systems
11651#Geometric complexity in location and distance problems
11652#INT-AID: the intelligent aid for relational database construction
11653#Constructing and analyzing specifications of real world systems
11654#A graphical simulation system for manufacturing systems
11655#A heuristic approach to scheduling hard real-time tasks with resource requirements in distributed systems
11656#Parallel algorithms for problems involving directed graphs
11657#A new approach to fast piping system design
11658#Simulation of demand paging in a local-area network with heterogeneous workstations
11659#Computer generation of meta-technical utterances in tutoring mathematics
11660#Kernel structures for a distributed operating system
11661#Implementation guide and users manual for a subset of PL/I on an Apple computer
11662#Integrated optical motion detection
11663#Scheduling algorithms for minimizing the number of tardy jobs
11664#A structured memory access architecture for LISP
11665#Control and management of large and dynamic networks
11666#The design and evaluation of a high performance SMALLTALK system
11667#The evaluation of instruction sets for language-oriented instruction set computerS
11668#On algebraic surfaces meeting with geometric continuity
11669#Using object descriptions in a schema network for machine vision
11670#A speech error correction algorithm for natural language input processing
11671#Recursive data type in SETL: automatic determination, data language description, and efficient implementation
11672#Persistent prototypes
11673#An experiment in the design of a microprocessor-based distributed discrete simulation language
11674#Automatic random logic layout synthesis-a module generator approach
11675#Design theory for nested relational databases
11676#Knowledge representation using linguistic fuzzy relations
11677#Lot size versus schedule disruption
11678#Can holding costs be overstated for just-in-time manufacturing systems?
11679#A guide to CAD/CAM: System selection, justification, and implementation
11680#Is it time for a physical exam of your materials requirement planning system?
11681#Japanese management techniques in small manufacturing companies: A strategy for implementation
11682#Use of the EOQ model for inventory analysis
11683#Scheduling product families
11684#MRP II in the service industries
11685#A review of lot-sizing techniques for deterministic time-varying demand
11686#Flexible manufacturing systems: An overview and bibliography
11687#Visions and realities: MRP as “System”
11688#A comparison of focus forecasting with averaging and exponential smoothing
11689#Optimal solution and graphical analysis for single-level discrete-demand lot sizing
11690#Survey of MRP nervousness issues
11691#A nomograph for EOQs with delayed billing offers
11692#MRP practices in a random sample of manufacturing firms
11693#A note on “The evils of lot sizing”
11694#Response to “A note on the evils of lot sizing in MRP”
11695#Comments on “Effect of lead time and service level on safety stock for a continuous review inventory system with independent demand”
11696#A note on “The impact of reduced setup time”
11697#“The impact of reduced setup time” revisited
11698#Knowledge systems: Principles and practice
11699#A continuous real-time expert system for computer operations
11700#Interfaces for knowledge-base builders' control knowledge and application-specific procedures
11701#A theory for the representation of knowledge
11702#Implementing a semantic interpreter using conceptual graphs
11703#Conceptual graphs for semantics and knowledge processing
11704#Storing and evaluating Horn-clause rules in a relational database
11705#Structures of rule-based belief functions
11706#An experimental computer architecture supporting expert systems and logic programming
11707#New scalar and vector elementary functions for the IBM system/370
11708#Fourier transform and convolution subroutines for the IBM 3090 Vector facility
11709#A vectorizing Fortran compiler
11710#Seismic migration on the IBM 3090 Vector facility
11711#Parallel iterative linear solvers for oil reservoir models
11712#Chemical and mechanical performance of flexible magnetic tape containing chromium dioxide
11713#Mixed theories of information can be thought of as direct consequences of relativistic information theory
11714#Information theory and thermodynamics. Statistical ensembles and meaning
11715#Self-adjoint association mechanism
11716#State of the art in research on the physics of self-organization of complex systems
11717#Artificial intelligence and the logic of the living
11718#The law of increasing entropy
11719#The informational substrata of psychic illnesses
11720#Future paths for integer programming and links to artificial intelligence
11721#Solving allocation and scheduling problems inherent in forest resource management using mixed-integer programming
11722#The general employee scheduling problem: an integration of MS and AI
11723#A mixed-integer programming model for evaluating distribution configurations in the steel industry
11724#A flexible, polynomial-time, construction and improvement heuristic for the quadratic assignment problem
11725#A multifactor model for international plant location and financing under uncertainty
11726#Nonlinear integer goal programming models for acceptance sampling
11727#Real-time task reallocation in fault-tolerant distributed computer systems
11728#Some results and experiments in programming techniques for propositional logic
11729#Hierarchical decomposition and simulation of manufacturing cells using Ada
11730#Strategy-related characteristics of discrete-event languages and models
11731#TCL- A Fortran-based pointer threaded command language for simulation
11732#Norway- A growing computer technology
11733#The geometry of machining for computer-aided manufacture
11734#Robot navigation algorithms using learned spatial graphs
11735#On the use of time-varying inertia lnks to increase the versatility of manipulators
11736#Kinematic path control of robot arms
11737#Robotics: the strategic issues
11738#The two-dimensional person: Technician/Writer Jim Suplee
11739#The consultant's derby, or, better get ready-there's a new world just around the corner
11740#Maintenence modeled as a dynamic system, plus a quote by Robert Mathis on the mobilization of knowledge as reuse
11741#War story: Software tools of the Pleistocene, plus a quote by John Garman of NASA on software change and compromise
11742#On the convergence in distribution of measurable multifunctions (Random Sets), Normal integrands, Stochastic processes and Stochastic infima
11743#On the convergence in probability of random sets (measurable multifunctions)
11744#Rolling planning horizons: Error bounds for the dynamic lot size model
11745#Generalized S-shapedness of reliability functions
11746#Upper bounds for single server queues with doubly stochastic poisson arrivals
11747#An upper bound theorem for polytope pairs
11748#The queue M/G/1 with Markov modulated arrivals and services
11749#Network reliability and inner-four-cycle-free graphs
11750#On the existence of easy initial states for undiscounted Stochastic games
11751#The uniqueness of stationary distributions for the GI/G/S queue
11752#Pointwise and uniformly good stationary strategies for dynamic programming models
11753#Searching LEXIS and WESTLAW- Part I
11754#Searching SOCIAL WORKS ABSTRACTS-A review
11755#Searching current events-Parts I
11756#Ten most searched databases by a business generalist-Part I: Or a day in the life of...
11757#ACT I on Dialog
11758#Database interviews Betty Eddison, Chairman, Inmagic Inc.
11759#Searching LEXIS and WESTLAW-Part II
11760#The biobusiness database
11761#Searching current events- Part 2
11762#What's in a name? Looking for people Online- current events
11763#More databases searched by a business generalist Part 2: A veritable cornucopia of sources
11764#Graphing online searches with Lotus 1-2-3
11765#The aerospace database
11766#Diary of a conversion- Lotus 1-2-3 to symphony 1.1
11767#A discrete model for the recovery of oil from a reservoir
11768#Multicriterion analysis of preferences by means of pairwise actions and criterion comparisons (MAPPACC)
11769#On a stefan problem involving a spherical region: Application of a Bergman-type expansion
11770#A successive approximation algorithm for Stochastic control problems
11771#Reclamation of stripmined lands: A multiattribute decision model
11772#A 1-dimensional cellular automaton which generates random sequences is discussed. Each site in the cellular automaton has value 0 or 1, and is updated in parallel according to the rule a'"i = a"i" "-" "1 XOR (a"i OR a"i" "+" "1) (a'"i = (a"i" "-" "1 + a"i + a"i" "+" "1 + a"ia"i" "+" "1) mod 2). Despite the simplicity of this rule, the time sequences of site values that it yields seem to be completely random. These sequences are analysed by a variety of empirical, combinatorial, statistical, dynamical systems theory and computation theory methods. An efficient random sequence generator based on them is suggested.
11773#We exhibit a compound sequential Bayes portfolio selection algorithm based solely on the past which not only lives off market fluctuations but follows the drift as well. In fact, this sequential portfolio performs as well (up to first order terms in the exponent) as the optimal portfolio based on advance knowledge of the n-period empirical distribution of the market. Moreover, to first order in the exponent, the capital resulting from this portfolio will be no less than the best of the available stocks. This is a result that holds for every sample sequence. Thus bull markets and bear markets can not fool the investor into over-committing or under-committing his capital to the risky alternatives available to him. The goal is accomplished by a choice of portfolio which is robust with respect to futures that may differ drastically from the past.
11774#Simple examples of nonlinear predictors arise when dealing with non-Gaussian linear processes. Non-Gaussian autoregressive schemes are discussed and the form of the best (nonlinear) predictor in mean square is determined in a few specific cases.
11775#An exact solution to certain multi-armed bandit problems with independent and simple arms is presented. An arm is simple if the observations associated with the arm have one of two distributions conditional on the value of an unknown dichotomous parameter. This solution is obtained relating Gittins indices for the arms to ladder variables for associated random walks.
11776#Multiple path integrals
11777#Stochastic approximation revisited
11778#Une suite {S"n} est recurrente lineaire d'ordre k s'il existe c"0 = 1, c"1,..., c"k tels que pour tout n = k, S"n - c"1S"n"-"1 + c"2S"n"-"2 - ... +/-c"kS"-"k = 0. Les specialistes [4] soulignent l'importance des suites recurrentes pour l'informatique theorique, et m'epargnent ainsi d'avoir a justifier l'objet de cet expose. Pour ce qui est des methodes, on part classiquement du polynome caracteristique x^k -c"1x^k^-^1 + ... +/-c"k et l'on exprime toute fonction des S"n comme fonction (symetrique) des racines de ce polynome et des conditions initiales. Or, si l'on ouvre un livre sur les fonctions symetriques comme [6], on trouve plusieurs identites entre bases de fonctions symetriques se presentant sous la forme de recurrences lineaires. Par economie, on identifie la recurrence consideree a l'une de ces recurrences classiques, beneficiant alors du riche acquit de la theorie des polynomes symetriques. Nous en donnons ici deux exemples. Quelques definitions sont tout d'abord necessaires.
11779#C. Loewner (Math. Z.63 (1955), 338-340) has shown that every non-singular totally positive matrix of finite order can be reached from the identity by forward solutions of the control equation dRdt = C(t)R, when C(t) varies in the class of Jacobi matrices with non-negative off-diagonal entries. We give a probabilistic solution of this equation by associating with it a finite-state non-stationary birth-and-death process and using the Feynman-Kac formula. This yields a probabilistic representation of non-singular totally positive matrices in terms of random evolutions. We then extend the representation to compound matrices by making use of a multi-particle system due to R. P. Feynman (Phys. Rev.76 (1949), 749-759, 769-789) and S. Karlin and J. McGregor (Pacific J. Math.9 (1959), 1141-1164). As applications, we obtain both the Jacobi-Liouville formula and the inequality of F. R. Gantmacher and M. G. Krein (''Oszillationsmatrizen, Oszillationskerne und kleine Schwingungen mechanischer Systeme,'' Akademie-Verlag, Berlin, 1964) for the principal minors of totally positive matrices by simple probabilistic arguments.
11780#Language, sublanguage, and the promise of machine translation
11781#Functional considerations in the postediting of machine translated output
11782#Sentence disambiguation by asking
11783#Essential requirements for a large-scale operational machine-translation system
11784#The lexicon in the background
11785#The intermediary language for multilanguage translation
11786#Semantics, translation, and anaphora
11787#The background to practical machine translation
11788#Computer aided translation project, University Sains Malaysia, Penang, Malaysia
11789#E/G Word, Japanese word processor for the Macintosh
11790#Barriers to plant transparency, barriers to plant rigidity—A sketch of the problems posed by the radical changes in work forms in the machine-building industry
11791#Specific applications of image processing to surface flaw detection
11792#Development of a computer control model for slab reheating furnaces
11793#A concise review of flexible manufacturing systems and FMS literature
11794#ICCAS 85
11795#Simulation in manufacturing
11796#A direct way to the binomial distribution
11797#Magic sets and other strange ways to implement logic programs (extended abstract)
11798#Convergence of sideways query evaluation
11799#A theoretical foundation of multi-level concurrency control
11800#Deleting completed transactions
11801#Safety of non-well-locked transaction systems
11802#A calculus for complex objects
11803#Some classes of multilevel relational structures
11804#Weak temporal relations
11805#Rearranging data to maximize the efficiency of compression
11806#Negation as failure for first-order queries
11807#Positivism vs minimalism in deductive databases
11808#The extended closed world assumption and its relationship to parallel circumscription
11809#On the properties and characterization of connection-trap-free schemes
11810#One flavor assumption and gamma-acyclicity for universal relation views
11811#The equivalence of solving queries and producing tree projections (extended abstract)
11812#Unifying functional and multivalued dependencies for relational database design
11813#Test data for relational queries
11814#A model-theoretic approach to updating logical databases
11815#Deciding properties of transactional schemas
11816#Availability in partitioned replicated databases
11817#On the integrity of databases with incomplete information
11818#Data independent recursion in deductive databases
11819#Parallel evaluation of recursive rule queries
11820#Sagiv,Y-On finite FD-acyclicity
11821#Solution of constrained generalized transportation problems using the pivot and probe algorithm
11822#Bottleneck assignment problems under categorization
11823#A graph coloring algorithm for large scale scheduling problems
11824#A vehicle routing improvement algorithm comparison of a “greedy” and a matching implementation for inventory routing
11825#On the robustness of the dominant eigenvalue of dynamic linear econometric models
11826#Requirements for model development environments
11827#Waste-water treatment: design and optimization using nonlinear search techniques
11828#Allocation of distinguishable servers
11829#An external reconstruction approach (ERA) to linear programming
11830#Proceedings of the third ACM-SIGOIS conference on Office information systems
11831#Research and evaluation models for the study of interactive video
11832#A theoretical framework for interactivating linear video
11833#An interactive videodisc drama: The case of Frank hall
11834#Production and evaluation of interactive videodisc lessons in laboratory instruction
11835#The efficacy of computer-assisted video instruction on rule learning and attitudes
11836#The effects of orienting objectives and review on learning from interactive video
11837#Using interactive videotaped-based instruction to teach on-the-job social skills to handicapped adolescents
11838#The effects of orienting, processing, and practicing activities on learning from interactive video
11839#Some critical factors that limit the effectiveness of machine intelligence technology in military systems applications
11840#The automated maneuvering board training system: An inprogress implementation evaluation
11841#An expert system for electronics troubleshooting based on qualitative causal reasoning
11842#Deriving ideal student models to propel intelligent tutoring systems
11843#Developing the technology for intelligent maintenance advisors
11844#Exploratory programming environments for designing ICAI
11845#A demonstration of an expert system for training device design
11846#Psychologically based techniques for improving learning within computerized tutorials
11847#Using an advance organizer to improve knowledge application by medical students in computer-based clinical simulations
11848#Efficacy of higher cognitive and factual questions in computer assisted instruction modules
11849#The accuracy of approximate string matching algorithms
11850#A comparison of children's reading comprehension and reading rates at three text presentation speeds on a CRT
11851#The accuracy of cognitive monitoring during computer-based instruction
11852#Computer-assisted instruction in academic libraries
11853#Computer-assisted instruction and music technology in education
11854#Real time generation of harmonic progressions in the context of microcomputer-based ear training
11855#A machine-independent data structure for the representation of musical pitch relationships: Computer-generated musical examples for CBI
11856#Using a touch tablet as an effective, low-cost input device in a melodic dictation CAI game
11857#Systematic evaluation strategies for computer-based music instruction systems
11858#This article explores the possibilities of IC interconnection routing in a multiprocessing environment. Some knowledge of multiprocessing environments and the interconnection routing problem is assumed. Multiprocesing approaches to the related problems of device placement and design rule checking are also being investigated, but will not be discussed here due to space limitations.
11859#It is accepted, generally, that Information Systems (IS) personnel have specific needs and present a unique set of problems for management. This position is challenged. It is our contention that IS personnel exhibit relatively few differences when compared with other, similar, occupational groupings. This does not imply, however, that the unique aspects of IS work are unimportant, or that attention need not be focused on understanding the determinants of particular behavioral outcomes. Rather, it suggests, that the effective management of the IS human resource may well rest more on general management practices than is commonly believed.This paper identifies managerial complaints about IS personnel and provides a summary of research findings. A model, based on accepted principles of worker behavior, intended to integrate much of the previous work, is presented. The IS staff is classified into categories and propositions about each are developed. Specific research questions are formulated which, when answered, will provide more insight into the unique aspects of IS work and will identify managerial strategies for improving employee performance and well being.
11860#It can be expected that people's opinions about the future will differ. Consequently a high degree of concurrence cannot be anticipated if a mixed group of academics and practitioners are asked to forecast aspects of the future of application systems development.
11861#In their study of user manager's systems needs, Alloway and Quillard surveyed 529 managers to determine whether current systems supported their information needs. Managers reported that only 44% of the installed base of application systems, most of which were transaction processing systems, were useful. Inquiry systems, which enabled managers to query data bases and to generate reports, and data analysis systems, which provided opportunities for modeling, simulating, and statistical analysis, were overwhelmingly favored by the managers surveyed. However, few of these analysis and inquiry systems existed (Alloway and Quillard, 1983).
11862#There is considerable disagreement as to whether or not a procedural language, such as COBOL, should be included in the junior/senior year course work of information systems students. The curriculum recommendations of the Association for Computing Machinery (ACM) includes a procedural language prerequisite for information systems students. The ACM curriculum course, "Program, Data, and File Structures", includes programming as a topic within the course.This article presents arguments against the inclusion of COBOL within the information systems curriculum. It is intended to promote debate within the academic community to determine if a procedural language should be included in the curriculum and if so, which language should be taught. Arguments for a Procedural Language.
11863#No matter what the reason for designing an information system in a particular way or acquiring a sysrtem with particular features, there is always a broader rationale which justifies the introduction of new automated information into the workplace. Inevitably, an executive, manager, or user has decided that the organization will be more productive - that is, its ability to get its work done will be enhanced by making new information available to the organization.
11864#The job titles given to application systems developers during the early 1970s seldom included anything other than SYSTEMS ANALYST and PROGRAMMER. By inspecting the appointments section of the computer press, it is noted that currently the job titles in use for people involved in application systems development include:Programmer business analystsystems designer chief programmerinformation analyst programmer analystsystems analyst knowledge engineerinformation centre consultantThis multiplicity of job titles is indicative of a job turbulence in the application software development industry.
11865#The 1980's has been described as the "age of communications." With it has come increasing recognition that modern electronic data transmission provides the critical infra-structure for all aspects of today's information-based society. While telecommunications and its component technology, data communications, has existed for over 150 years, it is in recent years that it has enjoyed explosive growth. This has been due to the confluence of powerful technical, economic and political forces, the most prominent among these being the orders of magnitude advances in information processing capacity and the continuing movement toward the deregulation of the electronic communications industry. The final court-ordered divestiture of AT&T in 1984 caused further acceleration of fundamental industry changes already well underway. A measure of the degree of this change is the explosive growth experienced by the telecommunications industry as a whole, which is estimated to have doubled its total annual revenues in the period 1980 to 1885 from $60 billion to $120 billion.[2]
11866#Electronic publishing and the information profession
11867#Expert systems for information retrieval?
11868#Where research is going
11869#Education for excellence: information, innovation and education
11870#Electronic and print publishing - a media marriage
11871#Not without us
11872#Current issues in confidentiality: Computerized information systems, medical records, and patient rights
11873#National computer policies: Whither the United States?
11874#Would you buy a shrink wrapped automobile?
11875#Why "the social aspects of science and technology" is not just an optional extra
11876#Careers in computer misuse - not so appealing after all
11877#The emerging legal thicket for electronic bulletin board operators and users
11878#Electronic surveillance and civil liberties: Testimony of Fred W. Weingarten before the House Judiciary Subcommittee on Courts, Civil Liberties and Administration of Justice
11879#The interactionist perspective on computer implementation
11880#When dealing with human communications and the use of technology to support this process, it is impossible to divorce the human elements from the technological ones. There is no fine boundary of measurable variables that can be established to draw the line along which we can look at clear cut cause and effect relationships in either direction across that boundary. Any attempt to make either the social system or the technological system the independent or dependent variable is only a short term artifice that might very well give the wrong indicators of what is happening. Once this premise is accepted, one is led to the necessity of viewing the introduction of any new communication technology as a series of incremental and evolutionary experiments on a total system. Whether consciously or unconsciously done, the people involved, the social relationships, and the technology are all design elements for the experiment. One cannot apply reductionist methods to the social studies of this area."Society is like a lawn, where every roughness is smoothed, every bramble eradicated, and where the eye is delighted by the smiling verdure of a velvet surface. He, however, who would study nature in its wildness and variety, must plunge into the forest, must explore the glen, must stem the torrent, and dare the precipice."--Washington irving
11881#The Human Relations perspective is one of six perspectives, suggested by Kling and colleagues, that analysts take when studying the impacts of computers. This short note looks at the assumptions of this perspective by focussing on a particular component of the human relations approach. This component is the participation or involvement of users in the implementation and management of communication systems in organizations. It very briefly notes prior literature on this component, with particular reference to sociotechnical systems research. This note considers the implications of using the human relations perspective and the focus on participation in light of results from a lengthy study of the management of word processign in 200 organizations. It concludes by considering the joint advantages of the other perspectives in analyses of participation.
11882#Computers, society, and Nicaragua
11883#I believe that the concept of a metric (or a dissimilarity measure) defined on a set of records is one of the most fundamental concepts related to information retrieval, although historically, the first science to introduce this concept as a basic one was, perhaps, numerical taxonomy. In the metric model the concept of the most relevant record should be interpreted as that of the closest (with respect to the chosen metric) record.
11884#Modern computerized information retrieval systems consist of mechanisms to acquire, describe (e.g., index), and store "documents", and to receive, analyze, and respond to queries for information for users. A key element is the index language, by which the users (or user intermediaries) and indexers can communicate. Modern technology allows natural language processing mechanisms to begin to be incorporated in the sense of matching terms found in the free text specification of the query and the free text within the document.
11885#In the past, several mathematical models for document retrieval systems have been developed [C82, S83, S83a, T76, WO84]. These models are used to formally represent the basic characteristics, functional components, and the retrieval processes of document retrieval systems. Two basic categories of models that have been employed in information retrieval are the vector processing models and the Boolean retrieval models.In the conventional vector space model (VSM), proposed by Salton [S71, S83] index terms are basic vectors in a vector space. Each document or query is represented as a linear combination of these basic term vectors. The retrieval operation consists of computing the cosine similarity function between a given query vector and the set of document vectors and then ranking documents accordingly. In this approach, the interpretation that the occurrence frequency of a term in a document represents the component of the document vector along the corresponding basic term vectors is made.The advantages of this model are that it is simple and yet powerful. The vector operations can be performed efficiently enough to handle very large collections. Furthermore, it has been shown that the retrieval effectiveness is significantly higher compared to that of the Boolean retrieval models. However, this vector model has been incorporated into very few commercial systems.In the strict Boolean retrieval systems [BU81, P84] the user query normally consists of index terms that are connected by Boolean operators AND, OR and NOT. The advantage of using Boolean connectives is to provide a better structure to formulate the user query. The major problem in such a system is that there is no provision for associating weights of importance to the terms which are assigned either to the documents or to the queries. In other words, the representation is binary, indicating either the presence or the absence of the various index terms. The output obtained in response to a query is not ranked in any order of presumed importance to the user. In most cases, the AND connectives tend to be too restrictive [BU81]. Mose commercially available retrieval systems essentially conform to this model.One of the challenges for researchers in information retrieval has been to achieve greater acceptance of the vector processing models in commercial systems. The main difficulty in this connection is due to the inability of the vector processing systems to handle Boolean queries. In recent years some progress has been made in expressing Boolean queries as vectors [S83a, S83b]. If attractive ways to achieve this are advanced, it would then be possible to modify existing systems to use vector processing techniques without a great deal of cost and effort.Another problem in the conventional vector space model is that it assumes that term vectors are orthogonal. It is generally agreed that terms are correlated and it is necessary to generalize the model to incorporate term correlations. A vector processing model termed the GVSM [WO84a, WO85] was proposed in response to this need. In the GVSM, the queries are assumed to be presented as a list of terms and corresponding weights. Thus, no provision is made for processing Boolean queries. However, the premises of the model naturally lead to a scheme for handling Boolean queries. In this paper we present the details of this scheme. This result will help achieve the aim of integrating vector processing capabilities into existing systems which use Boolean retrieval models.
11886#A concept-learning information retrieval system-basic ideas
11887#Information in data: using the Oxford English dictionary on a computer
11888#Help texts vs. help mechanisms: A new mandate for documentation writers
11889#Computer user manuals in print: Do they have a future
11890#Fingerprint identification using graph matching
11891#Synthesis of a road image as seen from a vehicle
11892#Online hand-sketched figure recognition
11893#Region adjacency and its application to object detection
11894#Determining motion parameters using intensity guided range sensing
11895#Avoiding explosive search in automatic selection of simplest pattern codes
11896#Two hierarchies associated with each clustering scheme
11897#Information is unquestionably today's most important commodity. Computer graphics, as a means of expressing that information, now appears in virtually every application area. When we began gathering information for this article, we intended to describe each job title and cross-reference each title by applications which utilize computer graphics. However, there no longer appears to be any application, no matter how seemingly obscure, where computer graphics is not used to some extent. For example, techniques similar to those used a few years ago in charting the surface of the moon are now being used in a Skin-Imaging Computer to select cosmetic supplies.The most important distinction in computer graphics careers is between working in the computer graphics industry and using computer graphics as a tool in an occupation whose main focus is not computer graphics. By "working in the computer graphics industry," we mean the jobs of researching, designing and marketing graphics equipment, researching and writing graphics languages, libraries and application software, preparing documentation, consulting on graphics hardware and software and teaching graphics courses. Careers in these areas require more extensive knowledge of computers in general and computer graphics in particular than do careers involving applications which use graphics work stations. In both cases, however, some specialty is required in addition to computer graphics experience.
11898#A research organization or graphics house often has a need for custom pictures for presentations or other purposes. These pictures may be prohibitively expensive, if not impossible to create, if they are produced by a commercial art firm. For groups that have such a need, an in-house computer-controlled camera may be a solution. To develop a quality system, users will have to overcome a series of electronic, mechanical, photographic and computer-related hurdles. This tutorial deals with adjustments to the system in four classes to achieve the best possible pictures. The adjustments are for clean signal, image placement and focus, contrast and brightness, and software interface. In each case, common problems are discussed, some options are given, and the chosen solution is explained.
11899#The SIGGRAPH education committee has been considering recommedations for inclusion of graphics in various curricula for higher education. Several issues of computer graphics in computer science or computer science/engineering curricula are identified here. Recommendations as outlined in this paper are being prepared through the SIGGRAPH education committee, and feedback by interested parties is needed and encouraged. Emphasis is on the enlarged scope of material available for graphics courses, and the need to identify legitimate "core" material for all undergraduates and elective material for students with strong interest in graphics specialization.
11900#A declarative language: SNARK
11901#Pattern-matching processing optimization in expert systems
11902#Queueing networks with semaphores
11903#Program transformations expressed by algebraic type manipulations
11904#Data networks: LAN and RDN (Remote Distance Networks)
11905#Teaching information science in high schools
11906#Statistical relational tables for statistical database management
11907#Gandalf: software development environments
11908#Axiomatizing software test data adequacy
11909#Guaranteed response times in a distributed hard-real-time environment
11910#Comments on "Number of faults per line of code"
11911#Selective silicon epitaxial growth for device-isolation
11912#Fabrication of microstructures with high aspect ratios and great structural heights by synchrotron radiation lithography, galvanoforming, and plastic moulding (LIGA process)
11913#The novolak calibration method applied to the GPC analysis of the UV photoresists
11914#Management Review
11915#Decision makers
11916#MRP?MRPII? OPT? CIM? FMS? JIT? Is any system letter-perfect?
11917#(Almost) as easy as 1-2-3: manufacturing overhaul at Lotus
11918#The productivity paradox
11919#Bar coding: industry shows its stripes
11920#Robots to invade U.S. industries
11921#Search strategy index
11922#Fullpaint: the professional paint program for the 512k Macintosh and beyond
11923#DAC-EASY accounting
11924#In pursuit of artificial intelligence
11925#Search strategy index
11926#Factfinder for the Macintosh
11927#Put it in print with Printer Boss
11928#Performance and capacity of centralized and distributed online catalogs: Part 1—centralized online catalogs
11929#OCLC's intelligent gateway service: online information access for libraries
11930#Electronic document interchange and the AAP Electronic Manuscript Project
11931#Benchmark and acceptance tests: why and when to use them
11932#TOMUS: the system's design and features
11933#Common sense wordworking II: the FinalWord II,WordPerfect 4.1, and PC-Write 2.5
11934#MicroLIAS: beyond the online public access catalog
11935#System performance
11936#System performance
11937#Vending database searching with public access terminals
11938#MARCON II: information control on a microcomputer
11939#Information technology reflected in public laws of the past decade
11940#Computer-assisted instruction in libraries: guidelines for effective lesson design
11941#DYNIX automated library systems
11942#Integrating a CD-ROM into an inhouse library system: Sirsi's lasertap
11943#Laser disks at the library door: the Microsoft First Interational Conference on CD-ROM
11944#CD-ROM search and retrieval software: the requirements and realities
11945#Bibliographic data elements for computer programs
11946#Standards: where are we headed?
11947#Large deviations for the maxima of some random fields
11948#Asymptotically efficient adaptive control in stochastic regression models
11949#On moments of ladder height variables
11950#We discuss estimation of parameters in functional and structural models in relation to Robbins' empirical Bayes and compound decision theories. We construct an efficient estimate of @n in the normal functional model, X"i independent N(@n, @q"i) Where@e @? @q"i^2 @? 1@e, @e 0,1 @? i @? n.
11951#The problem of setting a fixed width confidence interval for the mean of a normal distribution with unknown variance is considered. Several procedures are reviewed. An asymptotic lower bound for the expected sample size of any sequential sampling plan with the specified confidence coefficient is obtained as the width of the interval decreases to 0.
11952#Kesten showed that for certain random walks in a random environment the distribution of the environment as seen from the vantage point of the random walker converges to a limit distribution for large time. It is shown here that under additional hypotheses Kesten's result continues to hold for almost every typical fixed environment.
11953#A random walk technique is applied to linear differential equations.
11954#Algorithms and data representation. 2: evaluations, trees, graphs and text analysis
11955#Design aids for information applications. 2. Data base design
11956#Databases and database management from design to implementation: the practical approach
11957#Cooperative interfaces to information systems
11958#DIAGRAM: A grammar for dialogues
11959#An engine for intelligent graphics
11960#Considerations for the development of natural-language interfaces to database management systems
11961#Studies in the evaluation of a domain-independent natural language query system
11962#An interactive customization program for a natural language database query system
11963#The semantics-based natural language interface to relational databases
11964#Talking it over: the natural language dialog system HAM-ANS
11965#An expert interface for effective man-machine interaction
11966#Geometric design considerations for a 3-link robot arm
11967#A geometric investigation of the rational bezier scheme of computer aided design
11968#A DB search algorithm application in injection molding process control
11969#KET: A knowledge engineering tool
11970#A CNC System for a lathe using a low cost PC
11971#Shape preserving approximation
11972#Portable software: A new challenge for process control
11973#Flexible manufacturing systems '86
11974#COMPINT '85: Computer aided technologies
11975#In memoriam Fred Margulies
11976#Reflections on computer literacy and human understanding
11977#Robots in the classroom: Another of tomorrow's teaching tools today
11978#Toward a science of educational computing
11979#Utilizing teacher's concerns to improve microcomputer implementation
11980#A comparison of student achievement across three methods of presentation of a computer-based science simulation
11981#Microcomputer use in resource rooms with learning-disabled children
11982#Tools for a new age
11983#Uses of data bases in the classroom
11984#Computer literacy: Training and problem solving
11985#The use of spreadsheet software to teach business and economic concepts
11986#IdeaMap: An idea-composing enviornment
11987#Computers as an agent for educational change
11988#Computer programming in the schools: What should be taught?
11989#The unexpected treasure: Developing problem-solving skills through “Interactive Fantasies”
11990#A microcomputer approach to developing functional literacy among adolescents and adults
11991#Computers and the history classroom
11992#School psychology and computerized data handling systems: A confrontation
11993#Split size-rank models for the distribution of index terms
11994#Are there enduring patents?
11995#The dimensions of perceived accessibility to information: Implications for the delivery if information systems and services
11996#The personal computer: Missing link to the electronic journal/
11997#A bibliometric system which really works
11998#Inference control mechanism for statistical database frequency-imposed data distortions
11999#Teaching database management system use in a library school curriculum
12000#The effects of gender and age on preschool children's choice of the computer as a child-selected activity
12001#A probabilistic theory of indexing and similarity measure based on cited and citing documents
12002#Many planning methods are based on mathematical modeling. A multitude of computer aids covers different facets of the planning activity: data management, linear programming, statistical analysis, graphics, and word processing. However, the diversity and complexity of the available software inhibit the widespread use of computers for planning.The integrated Computer-Aided Modeling and Planning (CAMP) system offers a simple and coherent tool for the planner. A Data Definition Language provides the means for building data banks; a Model Definition Language provides the means for defining mathematical models featuring abstract linear programming, advanced array arithmetics, and assertions; a Picture Definition Language facilitates formation of tables and diagrams; a Text Definition Language combines word processing with illustrations of modeling results. The man-machine interface is based on interactive panels for controlling the planning process and on a command language for analyzing modeling results. A multilingual capability allows selection of the national language for interfacing with the system.The architecture of CAMP is presented, and its design, implementation, and use in regional planning are discussed.
12003#The death of creativity: is Common LISP a LISP-like language?
12004#Principles of programming languages: design, evaluation, and implementation (2nd ed.)
12005#In the days when computer systems were used primarily by people with technical backgrounds, human factors, if considered at all, were treated as a backroom activity---something to be done after the design and implementation had been completed. We are now in an era in which computer hardware and software are consumer items. Computer users range from school kids to adults and from non-technical office professionals to software engineers. In today's environment, computer companies, especially those who sell software, must offer products that are effective and easy to use to be successful in the marketplace.
12006#The Human-Computer Interaction Laboratory (HCIL) is a unit of the Center for Automation Research at the Univesity of Maryland. HCIL is an interdisciplinary research group whose participants are faculty in the Departments of Computer Science and Psychology and the Colleges of Library and Information Services, Business, and Education. In addition, staff scienctists, graduate students, and undergraduates contribute to this small, but lively community that pursues empirical studies of people using computers.Our support comes from industrial research projects, government grants, the State of Maryland, and the University of Maryland. Projects often become interrelated in surprising ways enabling individuals to cooperate constructively. Some of our efforts during the past year are described below.
12007#A between-subjects experiment was conducted to determine the effects of the presence/absence of menu titles on the search time and the number of incorrect choices made when navigating a hierarchical menu structure. Subjects were required to search for a randomly selected target item in a four level, three choices per level (43) menu structure. Subjects in the experimental group had titles for each sub-menu screen. Titles reflected the path traversed from the previous sub-menu screens. Control group subjects did not have titles displayed. While subjects in the experimental group did not search at a statistically significant faster rate, as the depth of the search (level) increased they did search with greater accuracy than those in the control group.
12008#Learning disabled students can derive great benefits from using work processors. The ability to produce a neat, printed copy can increase motivation and encourage writing for a wider audience. The editing power makes revision possible without tedious re-copying, thus freeing students and teachers to approach writing as a process involving repeated drafts. Specific problems with handwriting and spelling can also be circumvented. However, learning to use the editing capabilities often presents problems for students, especially those with learning difficulties. Word processors must be designed that are simple, easy to learn, and yet powerful. This study makes software design recommendations based on a study of learning disabled students learning to use word processing.Two groups of four LD students (4th-6th grade) were given twelve hours of word processing instruction using two word processors. Detailed records of progess and errors were made during learning and a final assessment task. Specific design problems are reported and recommendations are made for tasks such as cursor movement, insertion/deletion, use of nulls, blanks, and formatting characters, and overall organization.
12009#At the first meeting of the Interest Group on Individual Differences, held at CHI'85 (and reported in the July 1985 issue of the Bulletin), many attendees stated that they came to find out what was meant by "individual differences." Others had noticed differences among their users and were looking for guidelines to assist them in designing user-system interfaces to accommodate this variation. Still others, myself included, were familiar with one or two specific kinds of individual differences and had some ideas about their possible implications for USI design. Some of us had begun to investigate some of the differences, but no one seemed to have comprehensive information on the current state of knowledge about individual differences.
12010#The main problems of the ESTELLE communication protocol specification language are discussed by analyzing the present version of the ISO draft proposal language definition. Two different directions of the future development of ESTELLE are proposed. The first is the creation of the exact, formal semantic definition. The second direction of the language development leads to the high-level implementation languages. The separability technique (separate compilation) which can be used in the case of ESTELLE documents is investigated and a different structuring principle is suggested. The inner contradiction of the module instantiation is revealed and the construction of an alternative specification is suggested. The ESTELLE process concept is compared with an implementation process concept. Analyzing the structures of the protocol specifications it is pointed out that some implementation considerations are smuggled into the protocol specifications described in ESTELLE.
12011#This paper describes the interactive testing of ISO transport protocol we carryed out by using the so-called astride technique. The transport protocol class tested is class 2. So far more than two hundreds testing cases have been designed and applied. The testing design approach is based on empirical principles somewhat similar to those used in compiler validation. Testing results are discussed.
12012#This work originated from discussions on the interpretation of the ISO 8327 Session Protocol and the ISO 8326 Session Service. The author, who participated in the development of the above mentioned documents, discovered that many who attempted a thorough reading of them, either for implementing the Session layer or for a better understanding of the protocol, had a number of questions regarding the interpretation of the documents.There are two principal reasons for these difficulties. First, the state table description of the protocol in Appendix A of ISO 8326 and ISO 8327 is not formal, and thus subject to different interpretations. Second, there are actions which are not explained in Appendix A, but rather are described in the text. This means that even after having solved all questions related to Appendix A, one cannot be sure that an implementation is in fact correct.This paper is intended as an aid in interpreting the documents, and to correlate the plain text description to the state table description.A number of persons contributed to the contents of this paper, and it is impossible to list them all. The author, however, wishes to mention the major discussions that had with Albert Fleischmann and Stefan Pappe during their implementation of the Heidelberg Session layer; Colin West of the Zuerich Lab when he was attempting to devise a testing strategy for the above mentioned implementation; and Marten van Sinderen of the Twente University and Giuseppe Scollo of the Catania University when using LOTOS to describe the ISO Session layer.Wolfgang Effelsberg and Jim Staton of E. N. C., finally, deserve special thanks for their many valuable suggestions, both technical and structural, that they gave on the early versions of this document, which could now be titled "Hints for the interpretation of "Hints for the interpretation of the ISO Session Layer"".
12013#Computer aided design (CAD) -- the use of computer graphics, geometric modeling and database technology to assist the automation of the design process -- has been one of the major technical advances in the engineering field in the last decade. As an accessible means of reducing the time and labor involved in the design cycle in industry, it is viewed by officials of the People's Republic of China as an important part of the country's modernization of technology.
12014#For ten years we have joyfully overcome our insecurity with anarchy and successfully conducted the "business" of the Software Psychology Society. Our business has always been science; to improve our understanding of how people use computers. The two-horse team of computer science and psychology usually pulled in the same direction. Sometimes it leaned towards design guidelines, software, and hardware, other times it leaned towards cognitive models, personality theory, and human problem-solving. Mostly our travel was steadied by an appreciation of the importance of empirical studies, data collection, and controlled experiments with an occasional diversion into theoretical models or inspirational system designs. Our destinations have included programming and command language design, human-computer interaction models, menu selection strategies, natural language interaction, software engineering metrics and methods, educational packages, expert system user interfaces, voice communications and conferencing systems, screen readability, use of color, user interface management systems, and text editor design.
12015#The conclusion of the workshop on Planning for User Interface Standards (held at the CHI '85 conference in San Francisco) was that a reference model of human computer interaction should be developed before standards could reasonably be contemplated. That conclusion prompted the workshop on User Interface Reference Models which was held just prior to the CHI '86 conference in Boston. As the title implies we still do not have a reference model, but we have learned a lot in our search. The purpose of this paper is to convey the issues, process, problems, difficulties, suggested solutions, and directions that came to light during this workshop.
12016#I would like to review and extend the discussion of the layered structure model similar to the ISO Open Systems Interconnect model in the Report on the SIGCHI Workshop on Planning for User Interface Standards published in the October, 1985 SIGCHI Bulletin. First, I would like to compliment the people who worked on the report. They produced a document which I regard as correct, however incomplete. Bullinger and Faehnrich in Germany have published papers on what they regard as the User Interface Management System. I have integrated Figure 3 and Figure 4 from the CHI '85 Report with the diagrams from Bullinger et al to produce Figure 1. The layers added---semantic, syntactic and lexical---are commonly used in the implementation of compilers and interpreters and are supported by many tools referred to as compiler compilers i.e., yacc and lex from the UNIX system. In the ISO OSI reference model, interfaces exist at the vertical arrows between adjacent layers, protocols exist between peer layers. The term "user interface" conflicts with the ISO usage of "interface." I will instead refer to "human-computer dialog rules." Human-computer dialog rules are the set of peer layer protocols along with the user feedback rules, and appear as horizontal arrows on Figure 1. It is the set of human-computer dialog rules that should be standardized by SIGCHI members. Interfaces between the adjacent layers are implementation details and should be standardized by implementors.
12017#The proliferation of personal workstations and computer networks has enabled users to develop or otherwise access an ever wider range of applications. Unfortunately, the human-computer interface has not kept pace with the available hardware, nor with the aspirations of many users. Major advances are required with respect to the "style" of human-computer interaction -- advances in graphical techniques as well as other communications media. Moreover, this "style" should be as consistent as possible across applications. Much work remains to be done in achieving this consistency in the face of the wide variety of applications currently available. At the implementation level, much work remains to be done to accommodate heterogeneous hardware and software bases. For example, to what extent can we ensure that applications can run as well distributed over low-speed lines as over high-speed local area networks? How might we implement the human-computer interface in such a way as to be easily ported to a variety of operating systems, not just to a variety of machines running the same operating system?
12018#Recently, there has been a growing trend to develop interfaces which incorporate icons and various other visual symbols to represent system information. The idea behind this trend is that visual symbols can help reduce the complexity of the system and make it easier to understand and use. A problem with substituting this form of graphic interfacing for existing verbal command languages, however, is the extent to which abstract concepts, which underlie the operation of most systems, can be effectively represented in a graphic form that is both meaningful and discriminable.
12019#Constructing graphical user interfaces for interactive applications is a difficult and time consuming task, typically requiring extensive programming and experimentation with many prototypes. Thus, the ability to package portions of the specification of user interfaces into components that can be reused in the construction of many interfaces, and the ability to change an application's user interface without impacting the implementation of the functionality are crucial. These abilities can be realized in the measure that the dependencies between the implementation of an application's functionality and the user interface can be minimized.
12020#Warning: This is an article about how democracy has begun to come to computing. It is a challenge to those who would like to see it spread. I make no pretense of objectivity or dispassion (only accuracy). I want to make your blood boil and your face flush, impelling you out of lassitude into revolutionary commitment. I want to turn the "appliance operators" into "cybernetworkers," citizens of the information age.
12021#Two pieces on vender relations
12022#National science foundation information impact program
12023#The database tool and the information assembly line
12024#Computers and cultural change
12025#Ethical conflicts in the computing field - an undergraduate course
12026#The expert system represents the evolution of the computer from a tool to manipulate data to one which applies attributes of humans - reasoning, judgment, experience and "intelligence" - to the data, or at least appears to do so. Questions are thus raised about whether this evolution requires a concomitant evolution in the law governing liability for malfunction or misuse of computer systems. Historically, malfunctions of a computer system have been viewed as ultimately traceable to human error, usually in engineering or programming. The ability of an expert system to mimic a human expert has suggested that the humans involved in the creation or use of the system might be less liable than in the case of the nonexpert system, or that some form of liability should attach to the system itself. This article will explore how existing law would apply to expert systems, and consider whether new legal developments are required to deal with such systems.
12027#Recent development in real-time recognition of handprinted characters have resulted in a commercial device that reads "unconstrained," or free-form, handprinting. Unlike most devices that optically read machineprinted characters in finished text, this device is suitable for interactive system: It reads from a digitizing tablet while the user is writing.
12028#The quality of human-computer dialogues is greatly affected by the transducers used. When we consider input, there is a broad range of technologies available to the designer. However, most of us have experience with only a small number of these devices. With such limited experience, how can we begin to make the best choices in our designs?
12029#Entropy coding is a well-known tool for reducing the redundancy present in communication signals. As a signal's redundancy is reduced, the bandwidth required for its transmission over a low-noise channel also decreases. Memory requirements may likewise be reduced for coded information stored in low-error media. A method is presented for determining entropy codes by means of a sequence of multiply-and-accumulate and look-up operations. Structuring the process in such a fashion allows the effective use of a digital signal processor for dynamically generating adaptive codes in response to changing source statistics.
12030#A distributed system is an interconnected network of autonomous processing elements that is characterized by a decentralized control. In the last years, many activities have been addressed to the study and definition of distributed algorithms and languages, in order to design distributed applications and take advantage of the facilities of computer networks.
12031#Waiting times in a transport protocol entity scheduler
12032#Recently, there has been a great deal of interest in the possibility that the U.S. Department of Defense might transition to the use of the OSI Protocol Standards. There are many difficult issues involved in such a transition. This paper takes a brief look at the general issues involved and then proposes a first step toward OSI compatibility - the ability for DoD and OSI protocols to coexist on the same network. This is achieved through the implementation of a "Dual-IP Gateway", which supports both the DoD and OSI Internet Protocols.
12033#This paper presents an update of a model generated in the AMIGO project supported by the CEC (Comission of the European Community) in the framework of the action COST-11ter. It collects together comments made at the meeting of the IFIP WG6.5 held in Oslo, 2-5 December 1985. Acknowledgements go to the attendees of that meeting and to the members of the AMIGO project for the contributions they made.
12034#The cochlear implant 1
12035#Experimental model for the study of changes in the organization of human sensory information processing through the design and testing of non-invasive prosthetic devices for sensory impaired people
12036#This is the fifth in a series of articles reviewing the scientific literature on computers and the physically hadicapped. Please see the Spring, 1983 issue of the SIGCAPH newsletter (No. 32) for a description of this series. This article is a bibliography of articles appearing in the literature between January, 1975 and December, 1980 concerning the speech impaired and the hearing impaired. Note that Part IV, Vol. 35 was erroneously titled Part V. It should be Part IV. The literature 1975-1090 is large enough to be listed in two parts, V-A and V-B. Articles are backordered and the publishing schedule will depend on their arrival.
12037#The school Time-Table Scheduling task is a very hard operations research and engineering problem, especially when-implemented in a conventional language. That is due to the imperative, deterministic nature of most conventional languages, such as BASIC and PASCAL and to the long series of constraints and goals inside the problem. The descriptive, logic-based and nondeterministic nature of Prolog language, and its ability to backtrack allows one to easily obtain a deductive data base, mixing the facts, rules, and constraints of the Time-table. Two systems, one nonmonotonic, and one monotonic with a non-monotonic reasoning structure are compared and their performances in a significant test are discussed. The approach may be easily generalized to other analogous engineering, scheduling and operations research problems.
12038#We have now been running Fredkin competitions designed to find out how good the best computer chess entities really are, since 1980. These have always taken the form of computer-human competition, as this seems to be the way to bring reality to the subject.
12039#In this survey, we will provide a short survey and classification on the current work in special purpose architectures to support AI applications. In spite of the growing importance of AI applications, work in the area of designing AI architectures are so diversified that articles were published in other areas besides Al, ranging from psychology, medicine, manufacturing, computer architecture, software engineering, and database management to industrial engineering, operations research, and the list grows. The literature search is also complicated by the fact that with the development of the Fifth-Generation Computer Systems, some work in this area is very recent and was published in many foreign countries. During our literature search to compile this survey, we systematically went through over sixty different journals published in various countries and proceedings from over fifty conferences in the last twenty years and over seventy books.
12040#Common Lisp, which is becoming THE Lisp standard, does not support call by text (FEXPR mechanism in Mac/Franz Lisp). This effect can be obtained using macros. Based on the experience of converting an OPS5 implementation from Franz Lisp to Common Lisp, it is argued that sometimes call by text is needed for efficiency, despite its negative aspects.In the case of languages embedded in a Lisp system, using the macro alternative for call by text can cause marco expansion at execution time. This leads to a some-what less efficient implementation of the embedded language.
12041#Modern Darwinian evolutionary theory is a robust set of concepts that must be transported as a whole if they are to be used paradigmatically in any other context than that of their origin. For Al, the most immediately relevant lessons of evolutionary theory and process are listed below. Their meaning for AI research is that evolution can provide a paradigm for and the outline of an evolving system beyond the metaphorical sense of "evolution," if the full Darwinian paradigm is adopted. This discussion outlines how AI research can make use of the full Darwinian evolutionary paradigm by constructing "learning systems" upon a simulated genetic basis. It also suggests how the Darwinian evolutionary process is already active in one non-biotic context, namely, large organizations (public and private) that extensively use data base management systems (DBMS).
12042#Management Analysis Company, located in San Diego, is a general consulting corporation dealing almost exclusively with nuclear power generation.
12043#This paper reports a system with unexpected features. Starting from scratch, it learns to synthesize the function between the input and the output of a black box, which receives N bits and produces one. After being trained with one pass of a random sample of inputs and outputs, the system reproduces the sample completely but, if the sample size is greater than, or equal to some minimum (that depends on the black box function), the system will forecast correctly outside of the learned sample. The system has been tested with functions that range from easy to difficult and it has survived (up to now) all the tests. One of them is here reported.
12044#AI and expert systems techniques have been used as part of a research project and found to be useful and to have great potential for aiding both the research and the management of such projects. The potential benefits to each of these areas go far beyond what has been realized in the present project. We discuss some of these benefits and the experience gained to this time.
12045#Remarks on the auto-correlation function of binary periodic sequences
12046#The automated cryptanalysis of substitution ciphers
12047#Foiling the known-plaintext attack
12048#Some design criteria for Feistel-Cipher key schedules
12049#The control of public cryptography and freedom of speech: A review
12050#Improving the machine recognititon of vowels in simple substitution ciphers
12051#A machine solution of the AMSCO cipher
12052#Controllability of piecewise linear systems
12053#Exponential convergence of a model reference adaptive controller for plants with known high frequency gain
12054#Persistence of excitation in linear systems
12055#Numerical aspects of the reduction of linear systems into orthogonal canonical form
12056#Orthogonal representations of non-linear systems and input-output maps
12057#A canonical form for regular pencils of matrices
12058#Matrices of rational numbers, state group realizations and straight bases of abelian groups
12059#Robust observers for systems with parameters
12060#New conic sectors for sampled-data feedback systems
12061#On controlled invariance in nonlinear systems
12062#A new approach to nonlinear optimal feedback law
12063#A new approach to the structure at infinity of nonlinear systems
12064#Nonlinear filtering problems with finite-dimensional matrix estimation algebras
12065#Artificial intelligence: An introduction
12066#Why scientists are speaking out against star wars
12067#A computer and an archaeologist in Egypt
12068#Payment systems without cash
12069#Artificial intelligence comes of age
12070#Silver bullet opportunities
12071#Conversation with a computer - Part 2
12072#Image processing and records management
12073#Interactive videodisks: A new technology and its application in serving the disabled
12074#Forward chaining in Prolog
12075#Understanding frame languages, part I
12076#Project costing with cocomoi
12077#Procedural programming vs. Prolog
12078#Another commercial software technology?
12079#A flexible knowledge representation scheme
12080#Knowledge + control = expert systems
12081#Horizontal,vertical and matrix companies
12082#Digitalk's smalltalk V
12083#Micro data base system's Guru
12084#Just when you thought it made sense to get rid of contrex
12085#LDI: A bright future, despite a few obstacles
12086#A blueprint for business architectures
12087#VTAM can be customized for file-sharing applications
12088#Information-the next trade problem
12089#Image processing may cause future problems with network loading
12090#Evaluating microcomputer communications software
12091#The planning and managing of packet-switching networks
12092#What makes a building intelligent
12093#Mixed operating systems coexist on local area networks
12094#The big blue token ring view-II
12095#Tuning large distributed SNA networks
12096#The Kaspar wire-forming machine: an application of physical simulation to the disign and implementation of an automated process control system
12097#An expert system for machining data selection
12098#Drawing a block plan from a REL chart with graph theory and a microcomputer
12099#Relative performance of micro and mainframe computers: two case studies
12100#Animating simulations using TESS
12101#Forecasting irregularly spaced data: an extension of double exponential smoothing
12102#Surviving the personal computer industry downturn
12103#Knowledge processing and conventional data processing: The differences
12104#Technological surveillance: 1985 in the U.S.A
12105#Military control of over half of computer science research is excessive
12106#Bar-code scanning for applications for patents
12107#The information industries: How are they changing
12108#Wind shear and computers
12109#Robots for the moon and mars
12110#A computerized newspaper route: Management by remote control
12111#The danger line that is never to be crossed
12112#The computer-driven screen: A new two-way medium for mass communications
12113#Microcomputers: From movement to industry
12114#Glass annealing and artificial intelligence
12115#Philosophy, artificial intelligence, and the Chinese-room argument
12116#Mathematical modeling with spreadsheets
12117#High-level string-processing languages: COMIT,SNOBOL4, and icon
12118#How far can copyright protection go?
12119#Alternatives for work organization in computer-aided manufacturing
12120#Home computer III: The Philips/Sony CD-I proposal
12121#Palindromes and other word games
12122#Integrating Europe's telecoms
12123#UNIX is a disk-based operating system, where only the system kernel is always memory-resident. A combination of small block size, limited read-ahead and numerous seeks can severely limit the file system throughput. This paper presents a tool to study the file access patterns. Information derived from the data collected can be used to determine the optimal disk block size and also to improve the block placement strategy. The tool is a software monitor, installed at the device driver level, and triggered by every physical request to the disk handler. The design approach used to measure the average number of logical records accessed sequentially is described. An evaluation of the tool is also presented.
12124#The author argues that systems performance evaluation, in the first twenty years of its existence, has developed in substantial isolation with respect to such disciplines as computer architecture, system organization, operating systems, and software engineering. The possible causes for this phenomenon, which seems to be unique in the history of engineering, are explored. Its positive and negative effects on computer science and technology, as well as on performance evaluation itself, are discussed. In the author's opinion, the drawbacks of isolated development outweigh its advantages. Thus, the author proposes instructional and research initiatives to foster the rapid integration of the performance evaluation viewpoint into the main stream of computer science and engineering.
12125#It is still too often the case that Computer-Based Information Systems (CIS) are developed behind schedule, overcost, do not do as much as promised, and do not satisfy their users. In the last few years, we have been bombarded by techniques, methods, "optimal ways" in which to approach system development. For example, techniques such as prototyping and data flow diagrams have been developed to make the requirements definition process more effective. These methods, provide direction and structure to the development process.
12126#The focus of system design and evaluation has shifted from increasing computer efficiency to improving human/computer effectiveness. The new emphasis is especially critical when the users of the system are not information systems specialists or clerical support personnel, but highly paid knowledge workers. This paper presents a framework for organizing experimental studies in human/computer interaction and suggesting new research opportunities. The framework is applied to a review of 39 experiments in the areas of database management, decision support, text processing, graphics processing, calculation, and operating systems. Studies are assessed for their coverage of experimental variables and organized according to their findings.
12127#On October 21-23, 1985, the Institute for Computer Sciences and Technology of the National Bureau of Standards (NBS), in cooperation with the Association for Computing Machinery Special Interest Group on Management of Data (ACM SIGMOD), the IEEE Computer Society Technical Committee on Database Engineering, and the Federal Data Management Users Group (FEDMUG), held the fourth in their series of Data Base Directions workshops. The purpose of this workshop was to assess the nature of current information resource management (IRM) practice and problems, and to explore solutions which have proven workable.
12128#I define a simple data model which is based on an object oriented approach and uses logic programming as a computational model. The query part of the data model is purely declarative and has a fixpoint semantics, while the update part is imperative and uses assignments.
12129#Data objects in engineering applications, especially computer aided design, show highly complex structures and a lot of intricate dependencies. Hence a large amount of variably composed consistency constraints have to be dealt with. Furthermore, long transactions which are typical for CAD result in the need to tolerate inconsistencies over unpredictably long periods of time. The demands on mechanisms to enforce consistency in design database systems thus differ from those in business and administrative applications. Comprehensive consistency of the design data can only be attained by degrees. The time and extent of checking have to be determined dynamically and under control by the user. In the case of consistency violations, flexible kinds of reaction are necessary. In this paper we propose an event/trigger mechanism to enforce consistency in design databases that complements the transaction-oriented mechanisms suitable for traditional applications. The underlying ideas are derived from exception handling in programming languages. We present in detail the requirements to meet and how our concept copes with them. We also present an implementation that provides reasonable performance.
12130#This paper surveys research work performed within the last five years in distributed deadlock detection. The last survey paper on this topic appeared in 1980; since that time a large number of interesting algorithms have been discribed in the literature. A new, more efficient scheme is the probe-based deadlock detection strategy used by many of the new algorithms. This paper will concentrate on distributed deadlock detection algorithms. Only detection of resource deadlocks will be reviewed here, though other types of deadlock handling strategies and environments are briefly mentioned.
12131#The proteus bibliography: Representation and interactive display in databases
12132#In 1983, teenagers used computers in their homes to look at and modify data in computers thousands of miles away. Reports of these incidents, television dramas, and the movie "WarGames" have all aroused interest in the subject of how and how effectively computing systems' defenses withstand attacks by unauthorized individuals. The subject is of more than passing concern.
12133#Security in networks is becoming increasingly important owing to the expanding role of distributed computation, distributed databases and telecommunications applications such as electronic mail and electronic funds transfer. This paper undertakes to study this hitherto neglected area of Computer Science. It is the result of research, discussions and a series of seminars attended and presented by the author.
12134#Most large business organizations have functions called" computer security" or "data security". Very often, these activities are organizationally located within the information systems department or data center.
12135#Electronic Funds Transfer Systems (EFTS) are facing a crisis that must soon be overcome. In order to achieve the maximum cost benefits of EFTS, it is necessary that automated banking transactions be accepted on a widespread basis. General acceptance has not yet occured because of problems with EFTS perceived by consumers and bankers. The potential for loss through any number of new exposures is too great in the minds of many. This attitude must change before widespread acceptance of EFTS is to be accomplished.
12136#A logical authentication test requires no special hardware. As a proof of identity, the accessor is required to know or to use secret information. In a generalized model of logical authentication, the user learns an encryption algorithm whose functional description is secret. This model includes new tests of secret knowledge which induce larger forgery costs in certain environments than methods currently in wide-spread use.
12137#Questions about computer abuse abound in the popular press and in the computer trade and professional journals. Frequently asked questions focus on the extent of the problem and the abusers themselves. Some typical, critical questions are:* Is computer abuse a serious problem today in the U.S.?* How are systems being abused?* Who are the abusers and what motivates them?* Are privileged system users more prone to abuse systems than other users?
12138#Envoys are electronic mail messages that make requests at remote electronic mailers. Envoys differ from conventional messages in that they might be routed to recipients that have not been specified, their requests can often be carried out with no human intervention, they can be modified as they move from mailer to mailer, and they return to the original sender to inform her what actions have been taken. An electronic mailer that supports envoys needs reasoning systems to determine the recipients of the envoy and handle the requests.
12139#When two or more organizations interconnect their internal computer networks they form an Inter-Organization Network (ION). This paper analyzes how this new medium changes the economics of inter-organization communication and interchange and can thereby support communications of greater intensity and scope. Furthermore, in the spirit of transaction cost theory [15], we analyze how the new communication patterns can in turn support changes in the organization of work and industrial activities; in particular, by allowing participants to carry out greater numbers of activities across their organization boundaries, and to do so with greater numbers of interchange partners. However, at the same time ION communications may be more penetrating and segmented and thereby encourage participants to impose restrictions on cross-boundary flows and interchange partners. To benefit from ION use organizations will have to balance these opportunities and risks. We demonstrate our model with examples of commercial buyer-supplier relationships and an investigation of peer relationships among research and development (R&D) laboratories. The model and study demonstrate that technical analysis can inform organizational analysis of new technologies without being technologically deterministic. Moreover, our organizational analysis has implications for the technical design of IONs as described in [4].
12140#Wherever we turn there is talk about the “impact” of new technology upon society. Some of this talk is optimistic — indeed wildly so. Thus Christopher Evans, in his book The Mighty Micro, suggests that the “computer revolution” will lead to the decline of communism, the transformation and rise of the third world, the increasing dominance of the home, the substantial modification of crudely exploitative capitalism and the probable ending of war — a catalogue of benefits which would suggest that the end of human suffering is at hand. On a less global scale, others talk of the arrival of the microcomputer as if it heralds the dawn of a new era of emancipation for secretaries and businesses alike — the boring routines of typing will be replaced by skilled and rewarding tasks while the efficiency of business will be multiplied many times over1.However, the optimists are counterbalanced by the pessimists. There are those — for instance Herbert Marcuse — who hold technology to be inherently totalitarian2. More moderately, there are many who believe that the impact of new office technologies is disadvantageous if not downright disastrous, especially for those who find themselves at the bottom end of the social scale. Unemployment, or so it is suggested, will increase as tasks are automated and skills become outdated, while the conditions of work of those who still have jobs will deteriorate. In short, the alternative view is that the arrival of microcomputers and word-processors in the office simply marks the latest episode in a continuing struggle by those in positions of power to exploit those who are under them3.Though we are skeptical whether the arrival of the microcomputer will lead to the ending of war, or indeed, whether new technologies are inherently dominatory, there is doubtless something to be said in favor of the views of both the optimists and the pessimists. In many offices the more routine tasks have been automated and the process of retraining has improved the productivity of the enterprise together with the life-chances of all concerned. In others it has led to unemployment and increased surveillance and the replacement of skilled personnel by poorly paid unskilled employees. Our problem with the literature on the “impact” of technology does not lie in the fact that consequences, sometimes good and sometimes bad, have followed from the introduction of new technologies in different offices. It lies, rather, in the vocabulary that is used to describe these consequences. This vocabulary is Newtonian in character. Microcomputers are treated as being like projectiles which arrive from outer space (or perhaps from the technical agents of the ruling class) and subsequently have an “impact” upon social arrangements. It is as if the social world were best seen as a set of craters, the passive target of bits and pieces that are lobbed at it. This is surely wrong.Though there are many things wrong with such a vocabulary the most basic is the way in which technology is treated as an object — usually a unitary and relatively unproblematic object — which differs in kind from the social structure to which it relates. Analysis is predicated on the assumption that technical objects inhabit one domain while social relations exist in another. Sometimes one influences the other — indeed, in the more sophisticated versions of the theory they are seen as having reciprocal relations — but whether or not they interact they are seen as being different in kind. The first major purpose of this paper is thus to argue against this assumption and to propose, by contrast, that if we want to understand the way in which office technologies interact with social relations then we need to find a unified and holistic vocabulary for talking about devices-and-social-relations. We should, in other words, study the office as a system of interrelated parts and transactions. Any such system has its own set of more or less stable dynamics — it may, to shift metaphors, be treated as a network of components and interactions between those components. Furthermore, and this is a crucial point, the components, and the interactions between the components, are heterogeneous in character. Some of them have to do with power, authority or duty — that is they are predominantly social in character — while others have to do with circuits and circuit boards — that is, they are primarily technical in character. In between, however, there are many which are “sociotechnical” in character — they run together or depend upon elements of both the social and the technical: the operation of a word-processing program would be a case in point4.Understanding the “impact” of new technologies therefore requires us to describe the important components and interactions that go to make up the dynamics of an office whether these be social, technical, or (as is very often the case) sociotechnical in character. We have, therefore, to minimize the conventional boundaries between the social and the technical (and for that matter, the economic, the political and the scientific) and map out the heterogeneous and interrelated commitments that keep the office or enterprise on the road if we want to understand how and why office information systems are adopted, assimilated, adapted or rejected. In short, we need to avoid the “impact” metaphor altogether, and treat the new technologies as sets of real or potential interrelations that may (or may not) be married with the other sociotechnical relations that make up the average office.One way of handling the complexity and heterogeneity of office systems is to adopt an ethnographic approach and to consider the empirical detail of the interacting processes that may be detected in the office5. If this is to be profitable, however, it must be systematically undertaken. We will, as E.C. Hughes put it, “fall far short of our intellectual duty if we simply record events unsystematically on a sea of change” (Hughes :1971:55). In other words, the most useful ethnographies will be those that rest upon agreement about what should be examined and how it should be analysed. In the present paper we cannot consider our theoretical approach in any detail. In general, however, we share Hughes' view that the study of what he called “going concerns” offers a plausible basis for organizing ethnography. Hughes wrote that going concerns are identifiable enterprises, institutions, organizations, associations or families that are subjected to contingencies that arise from their environmental context. Thus he pictured each educational institution as being “in the market for students, staff, ministers, whatever kinds of help and personnel it wants” (Hughes :1971:64). Such institutions might, he noted “occur in many forms, and may be in any stage of having, getting, or losing moral, social, legal, or simply customer approval” (Hughes :1971:54). They operate, he noted, in a variety of markets and need, if they are to survive, to satisfy a variety of demands.Consider what happens if we think of a university department — our chosen example of an office — as a going concern and look at the demands that are placed upon it, and which it places upon its environment. The first thing to note is that it draws students, staff, financial and various forms of material support from that environment. In return it feeds various kinds of products — instruction, assessments, graduates, degrees, research papers, salaries and the like — back to its environment. One way of looking at the department is thus as a productive enterprise, or perhaps more precisely, as complex set of heterogeneous transformational chains which converts what it takes from the environment into what it gives back. Little can be said a priori about these transformational chains. Rather their mode of operation, their assessed efficiency, and the alternatives available are all matters for empirical investigation6.The transformation of resources into accomplishments within the department is not the end of the story. Transformations that lie outside the department are (as a thought experiment will quickly show) just as crucial to its character as a going concern as those that occur within its walls. Thus, instruction may not be directly converted into financial support, but failure to instruct will be quite quickly transformed into failure to pay. Thus one way of looking at the productive output of the department, albeit one that is rather unusual, is to treat it as a set of resources that will (or so it is hoped) operate on outside individuals and institutions in order to transform these into or cause them to generate new resources for the department.This analysis of the relationship between a department and its environment may be sharpened up by noting a further point. This is that much, if not all, of its activities are routine and indeed cyclic in character. It is important to see that it is precisely this routine character of activities — the fact that they are repeated on a regular basis — that makes it possible to talk of the university department as a going concern7. The cycle of transformations, starting with resources which are converted in various complex ways within the department to outputs which are in turn, periodically transformed into new resources — a cycle which we will from time to time call the “internal economy” of a going concern — for all intents and purposes constitutes the department. In the absence of routine it would not be a university department, indeed it would not be an identifiable going concern at all.In what follows we use this holistic but informal “systems” vocabulary to describe the process by which the department in question decided that it needed a microcomputer, the considerations that led to the selection of a particular machine and the sequence of events that followed its introduction8. In the course of this description we move, indifferently, between the technical, the social, and the sociotechnical. Our aim is to consider the conditions under which the more technical components of offices such as microcomputers turn out to be more or less malleable when they are juxtaposed with the more social components of those systems. It is, in short, to consider the circumstances under which technologies are molded by the social or, alternatively, the social is molded by the technological — or, as is perhaps the more common case, the sociotechnical is molded by the sociotechnical. We contend, though this cannot be demonstrated in a single case-study, that what it is that is malleable, and what it is that is not, is always a contingent, empirical matter.
12141#The widespread adoption of personal computers (PCs) may be attributable to their apparent low purchase and operational costs. However, significant procedural costs arise in fitting a PC application into a work setting. Our investigation of the adoption and use of PCs in several departments of a complex organization reveals a large number of unanticipated costs. These indirect, deferred, and governance costs are chiefly borne by users not responsible for acquiring PCs. These costs represent additional demands for users' time, skill, expertise, and attention as well as money. We find that the distribution of deferred costs determines the viability of PC systems. We also find that the integration of PCs can alter the way people do their jobs. These changes in turn give rise to additional social and political costs within the organization. Subsequently, we find that the true costs of personal computing are typically underestimated and unaccounted.
12142#While several procedures designed to facilitate office analysis have achieved success with respect to describing what happens in the office, they have contributed far less with respect to prescribing how computer-based technologies can support the office. Here we present TEMO (TEchnological Mapping of Office-work), a procedure which aids the analyst in determining the feasibility of supporting a given office task and suggests which specific software packages might improve performance of that task. In order to illustrate the procedure's application, we present a case in which TEMO is applied, in step-by-step fashion, in order to assess the feasibility of automating a simple set of tasks and to assist in the selection of an appropriate software package. Directions of continuing work in the procedure's extension, enhancement, and evaluation are also described.
12143#The knowledge stored in the information networks of the near future will not resemble that in today's conventional database systems. Instead, systems will look more like electronic libraries, with millions of items in many different media and with widely varying formats and levels of detail. Using foreseeable searching mechanisms, the results of queries will often be very coarse, containing a large fraction of all the items in storage. To make up for this coarseness, users must be able to browse the database, discarding unneeded items rapidly—but the sheer size of the result sets will make textual presentation useless. As an alternative, we have investigated ways to arrange the data into information spaces that can be presented graphically. Users browse the space simply by moving their viewpoints within it, selecting interesting features of the “information landscape” for closer examination.
12144#Adaptation in the user-system interface can be designed to benefit either the system or the user. This paper presents a general model to portray that symmetry and to describe the essential components of the user-oriented version of an adaptive interface system. A function-based interpretation of the process is also characterized. Finally, the types of knowledge bases upon which the adaptation is dependent are described with reference to a prototype system being implemented. Especially those users who have limited understanding of computer technology, such as the numerous workers in offices, are expected to be future beneficiaries of adaptive interface research.
12145#A major challenge in Office Automation is one of automating routine jobs that involve large-scale processing of ill-formed natural language data. Such data are often present in documents such as forms where it is necessary and/or practical to allow latitude in how the forms may be filled. In this paper, we describe a computational model designed to process free-form textual data in application forms for Letters of Credit (LC), which represent a common vehicle for initiating international trade transactions. The model is based on a variation of the case-frame or thematic-role frame instantiation methods. We describe the implementation of the model, report empirical results with real LC applications, and indicate directions we are currently pursuing to improve its performance.
12146#Analyzing due process in the workplace
12147#An important component of planning involves keeping track of what various agents intend to do and recognizing situations in which certain planned-for activities are likely to interfere with one another. In planning situations involving several agents participating in a cooperative endeavor, this process can be automated to a high degree thereby facilitating coordination between agents. The more difficult aspects of planning, how to choose what activities to perform and what to do when those choices lead to problems, are left to the agents themselves. This paper demonstrates how the use of an interactive temporal data base management system can direct the inter-agent communication necessary to coordinate the use of shared resources and deal with complex scheduling problems. It is argued that much of the paper work normally associated with routine office transactions can be eliminated through the use of this temporal data base.
12148#Systems for programming by example permit the specification of algorithms through the use of demonstrations that manipulate examples. This paper analyzes systems for programming by example from a language point of view. Examples are analyzed as data abstractions, and demonstrations as abstractions for evaluation and control. Criteria are introduced for evaluating both the computational power and the expressiveness of the abstractions. The analysis demonstrates the existence of several previously unconsidered approaches to the more difficult problems associated with programming by example.
12149#We argue that a task-centered, an agent-centered and a cognition-oriented perspective are all needed for providing intelligent assistance in distributed office environments. We present the architecture for a system called OFFICE that combines these three perspectives. We illustrate this architecture through an example.
12150#Detection of control deterioration using decision support systems
12151#A survey of issues in computer network security
12152#Computer crime investigation and investigators
12153#Authentication and discretionary access control in computer networks
12154#Data security in terminalised system
12155#A human approach to the technological challenges in data security
12156#Secure software's impact on reliability
12157#How to modify a microcomputer operating system for added security
12158#Host cryptographic operations: A software implementation
12159#Privacy and progress
12160#The real-time shaded display of a solid model being milled by a cutting tool following an NC path is attained by the image-space Boolean subtraction of solid objects. The technique is suitable for implementation in microcode in a raster graphic display processor. Update rates of 10 cutting operations per second are typical.
12161#A program for the real-time display of computer animation on a bit-mapped raster display is presented. The differential compiler performs temporal domain image data compression using frame replenishment coding on successive frames of animation stored in memory as bitmaps and saves only the differences. A small run-time interpreter then retrieves and displays the differences in real-time to create the animated effect. This results in a significant reduction in storage requirements, and allows animation on general purpose computers which would otherwise be too slow or have insufficient memory. Frame creation is both device and method independent. An animation environment supports interactive editing capabilities, reconstructing any arbitrary desired frame for later modification. Frames can be added, modified, or deleted, and the animated sequence can be viewed at any point during the session. The compiler is automatically called as needed; its operation is transparent to the user. The compiler is described in detail, both in terms of data compression and the requirements of interactive animation editing.
12162#This paper describes techniques for improving the performance of image rendering on personal workstations by using CPU cycles going idle while the user is examining a static image on the screen. In that spirit, we believe that a renderer's work is never done. Our goal is to convey the most information to the user as early as possible, with image quality constantly improving with time. We do this by first generating a crude image rapidly and then adaptively refining it where necessary as long as the user does not change viewing parameters. The renderer operates in a succession of phases, first displaying only vertices of polygons, next polygon edges, then flat shading polygons, then shadowing polygons, then Gouraud shading polygons, then Phong shading polygons, and finally anti-aliasing. Performance is enhanced by each phase using results from previous phases and trimming the amount of data needed by the next phase. In this way, only a fraction of the pixels in an image may be Phong shaded while the rest may be Gouraud or flat shaded. Similarly anti-aliasing is performed only on pixels around which there is significant color change. The system features fast response to user intervention, encourages user intervention at any moment, and makes useful the idle cycles in a personal computer.
12163#This paper examines three methods, two existing and one new, for the generation of fractals based on recursive subdivision. Both existing methods are found to have defects, which are not present in the new method. A parallel processing algorithm is proposed for the rendering of height fields which is exact and distributes the load evenly between the processors. A method is described for the 'fan-tracing' of height fields to allow the realistic simulation of water reflections.
12164#In image synthesis, cloth objects such as clothes are most often modelled as textures mapped onto rigid surfaces. However, in order to represent such objects more realistically, their physical properties must be examined. This paper describes a method for modelling cloth material hanging in three dimensions when supported by any number of constraint points. The cloth synthesized with this model contains folds and appears more realistic than simple texture mapping. This paper also describes a method for rendering the cloth once its free-hanging shape has been determined.The computation of the surface of a free-hanging cloth is performed in two stages. The first stage approximates the shape of the surface which is interior to the constraint points, and the second stage performs a relaxation process on all points on the surface to arrive at a close approximation to its shape. The rendering of the surfaces is done using a ray-tracer which treats the surface as a mesh of line segments.
12165#The goal of science is to understand why things are the way they are. By emulating the logic of nature, computer simulation programs capture the essence of natural objects, thereby serving as a tool of science. When these programs express this essence visually, they serve as an instrument of art as well.This paper presents a fractal computer model of branching objects. This program generates pictures of simple orderly plants, complex gnarled trees, leaves, vein systems, as well as inorganic structures such as river deltas, snow flakes, etc. The geometry and topology of the model are controlled by numerical parameters which are analogous to the organism's DNA. By manipulating the genetic parameters, one can modify the geometry of the object in real time, using tree based graphics hardware. The random effects of the environment are taken into account, to produce greater diversity and realism. Increasing the number of significant parameters yields more complex and evolved species.The program provides a study in the structure of branching objects that is both scientific and artistic. The results suggest that organisms and computers deal with complexity in similar ways.
12166#Although modeling natural phenomena is recognized as one of the greatest challenges of computer graphics, relatively little time has been spent on modeling ocean waves. The model presented in this paper is suitable for the rendering and animation of waves approaching and breaking on a sloping beach. Waveforms consist of a phase function which correctly produces wave refraction and other depth effects, and a wave profile which changes according to wave steepness and water depth. Particle systems are used to model the spray produced by wave breaking and collisions with obstacles. A scanline algorithm for displaying the wave surface is presented, along with a method of integrating separately rendered particle systems with other surfaces. Hidden surface removal for both waves and particles is done using a novel variation of the A-buffer technique. Methods of implementing the model are presented and compared with previous rendering techniques.
12167#We present a simple model for the surface of the ocean, suitable for the modeling and rendering of most common waves where the disturbing force is from the wind and the restoring force from gravity.It is based on the Gerstner, or Rankine, model where particles of water describe circular or elliptical stationary orbits. The model can easily produce realistic waves shapes which are varied according to the parameters of the orbits. The surface of the ocean floor affects the refraction and the breaking of waves on the shore. The model can also determine the position, direction, and speed of breakers.The ocean surface is modeled as a parametric surface, permitting the use of traditional rendering methods, including ray-tracing and adaptive subdivision. Animation is easy, since time is built into the model. The foam generated by the breakers is modeled by particle systems whose direction, speed and life expectancy is given by the surface model.To give designers control over the shape of the ocean, the model of the overall surface includes multiple trains of waves, each with its own set of parameters and optional stochastic elements. The overall "randomness" and "short-crestedness" of the ocean is achieved by a combination of small variations within a train and large variations between trains.Rendered examples of oceans waves generated by the model are given and a 10 second animation is described.
12168#By integrating physical simulation, in the form of numerical fluid dynamics, with visual simulation, in the form of particle rendering, texture mapping and traditional polygonal modeling techniques, we have achieved a uniquely realistic and organic special effects sequence of a planetary atmospheric flow. This paper examines the selection, implementation, and application of these techniques, know collectively as VORTEX, to produce the moving images of the planet Jupiter in the film "2010." Details of the generation of the flow field and the fluid dynamic algorithms employed are presented, along with issues relating to the generation and updating of the atmospheric images. We also describe the integration of these techniques with an advanced computer graphics imaging system. The VORTEX system provides a fairly general solution to a class of imaging problems involving two-dimensional fluid flows, and we remark upon its application to other projects. VORTEX, as an example of the marriage of physical simulation to visual simulation, demonstrates the importance of computer graphics to the computational sciences and of the physical sciences to the field of computer graphics.
12169#Image rendering is the performance bottleneck in many computer-graphics systems today because of its computation-intensive nature. Described here is a one-chip VLSI implementation of a shaded-polygon renderer which provides an affordable solution to the bottleneck. The chip takes advantage of a unique extension to Bresenham's vector drawing algorithm [1] to interpolate four axes (for Red, Green, Blue and Z) across a polygon, in addition to the X and Y values. Its inherent accuracy and ease of high-speed hardware implementation distinguish this new algorithm from interpolation with incrementing fractions (DDA).This chip was designed as part of a workstation primarily for mechanical engineering CAD applications. The pipelining and internal bandwidth possible on the chip allows rendering speeds of over twelve-thousand, 1000-pixel, shaded polygons per second, suitable for interactive manipulation of solids. Described in this paper is the derivation of the new algorithm and its implementation in a pipelined, polygon-rendering chip.
12170#Computer image generation systems often represent curved surfaces as a mesh of planar polygons that are shaded to restore a smooth appearance. Phong shading is a well known algorithm for producing a realistic shading but it has not been used by real-time systems because of the 3 additions, 1 division, and 1 square-root required per pixel for its evaluation. We describe a new formulation for Phong shading that reduces the amount of computation per pixel to only 2 additions for simple Lambertian reflection and 5 additions and 1 memory reference for Phong's complete reflection model. We also show how to extend our method to compute the specular component with the eye at a finite distance from the scene rather than at infinity as is usually assumed. The method can be implemented in hardware for real-time applications or in software to speed image generation for almost any system.
12171#We present two algorithms for the display of CSG-defined objects on Pixel-Powers, an extension of the Pixel-Planes logic-enhanced memory architecture, which calculates for each and every pixel on the screen (in parallel) the value of any quadratic function in the screen coordinates (x,y). The first algorithm restructures any CSG tree into an equivalent, but possibly larger, tree whose display can be achieved by the second algorithm. The second algorithm traverses the restructured tree and generates quadratic coefficients and opcodes for Pixel-Powers. These opcodes instruct Pixel-Powers to generate the boundaries of primitives and perform set operations using the standard Z-buffer algorithm.Several externally-supplied CSG data sets have been processed with the new tree-traversal algorithm and an associated Pixel-Powers simulator. The resulting images indicate that good results can be obtained very rapidly with the new system. For example, the commonly used MBB test part (at right) with 24 primitives is translated into approximately 1900 quadratic equations. On a Pixel-Powers system running at 10MHz (the speed at which our current Pixel-Planes memories run), the image should be rendered in about 7.5 milliseconds.
12172#The shadow volume algorithm of Frank Crow was reorganized to provide information on the regions of illuminated space in front of each visible surface. This information is used to calculate the extra intensity due to atmospheric scattering, so when the atmosphere is partly in shadow, columns of scattered light will be visible. For efficiency in sorting the shadow edges, the image is computed in polar coordinates.
12173#Natural lighting models to date have been limited to calculation of direct sunlight. However, this paper proposes an improved model for natural lighting calculations that adequately considers both direct sunlight and scattered light caused by clouds and other forms of water vapor in the air. Such indirect natural light is termed skylight and can be an important factor when attempting to render realistic looking images as they might appear under overcast skies.In the proposed natural lighting model, the sky is considered to be a hemisphere with a large radius (called the sky dome) that acts as a source of diffuse light with nonuniform intensity. In order to adequately take into account the nonuniform intensity of such skylight, the sky dome is subdivided into bands. The light intensity within individual bands can be assumed to be transversely uniform and longitudinally nonuniform and therefore the total luminance emanating from each band can be calculated more accurately.The proposed method significantly improves the realism of natural lighting effects. Its advantages are particularly apparent when simulating lighting under an overcast sky or when rendering surfaces that fall within a shadow cast by an obstruction lit by direct sunlight.
12174#A general radiosity method accounting for all interreflections of light between diffuse and nondiffuse surfaces in complex environments is introduced. As contrasted with previous radiosity methods, surfaces are no longer required to be perfectly diffuse reflectors and emitters. A complete, viewer independent description of the light leaving each surface in each direction is computed, allowing dynamic sequences of images to be rendered with little additional computation per image. Phenomena such as "reflection tracking", reflections following a moving observer across a specular surface are produced. Secondary light sources, such as the light from a spotlight reflecting off a mirror onto a wall are also accounted for.
12175#We present an integral equation which generalizes a variety of known rendering algorithms. In the course of discussing a monte carlo solution we also present a new form of variance reduction, called Hierarchical sampling and give a number of elaborations shows that it may be an efficient new technique for a wide variety of monte carlo procedures. The resulting rendering algorithm extends the range of optical phenomena which can be effectively simulated.
12176#A technique is presented for deforming solid geometric models in a free-form manner. The technique can be used with any solid modeling system, such as CSG or B-rep. It can deform surface primitives of any type or degree: planes, quadrics, parametric surface patches, or implicitly defined surfaces, for example. The deformation can be applied either globally or locally. Local deformations can be imposed with any desired degree of derivative continuity. It is also possible to deform a solid model in such a way that its volume is preserved.The scheme is based on trivariate Bernstein polynomials, and provides the designer with an intuitive appreciation for its effects.
12177#Constructive Solid Geometry (CSG) is a powerful way of describing solid objects for computer graphics and modeling. The surfaces of any primitive object (such as a cube, sphere or cylinder) can be approximated by polygons. Being abile to find the union, intersection or difference of these objects allows more interesting and complicated polygonal objects to be created. The algorithm presented here performs these set operations on objects constructed from convex polygons. These objects must bound a finite volume, but need not be convex. An object that results from one of these operations also contains only convex polygons, and bounds a finite volume; thus, it can be used in later combinations, allowing the generation of quite complicated objects. Our algorithm is robust and is presented in enough detail to be implemented.
12178#An algorithm is presented for automatically converting data representing unambiguous, three-dimensional objects in wire-frame form with curvilinear edges into a boundary representation. The method is an important extension to a previously published algorithm based on graph theory and topology. The new method automatically detects and resolves anomalies, such as necks which may appear to be faces, that formerly required human intervention. The topological basis for the solution to this problem is given along with a description of what topological properties a well defined three-dimensional object should have. An implementation has been coded and examples of results are included.
12179#A method is developed for surface-fitting from sampled data. Surface-fitting is the process of constructing a compact representation to model the surface of an object based on a fairly large number of given data points. In our case, the data is obtained from a real object using an automatic three-dimensional digitizing system. The method is based on an adaptive subdivision approach, a technique previously used for the design and display of free-form curved surface objects. Our approach begins with a rough approximating surface and progressively refines it in successive steps in regions where the data is poorly approximated. The method has been implemented using a parametric piecewise bicubic Bernstein-Bézier surface possessing G1 geometric continuity. An advantage of this approach is that the refinement is essentially local reducing the computational requirements which permits the processing of large databases. Furthermore, the method is simple in concept, yet realizes efficient data compression. Some experimental results are given which show that the representation constructed by this method is faithful to the original database.
12180#We illustrate two enhancements to procedural geometric models which allow autonomous procedures to jointly satisfy mutual constraints. One of the techniques adds communications paths between procedures which may affect one another. Conflicts are resolved by modifying communicating procedures as they execute.The second technique is a generalization of widely used subdivision procedures. The termination test of typical subdivision methods is replaced with a "transition" test. The subdivision procedure is augmented with a "script" in the form of a state transition table which controls the procedures' response to external events as well as to the normal termination conditions.In the examples we show how effective these techniques are building complex geometric models with very sparse input.
12181#A consistent hierarchical data structure for the representation of vector data is presented. It makes use of a concept termed a line segment fragment to prevent data degradation under splitting or clipping of vector primitives. This means that the insertion and subsequent deletion (and vice versa) of a vector leaves the data unchanged. Vectors are represented exactly and not as digital approximations. The data is dynamically organized by use of simple probabilistic splitting and merging rules. The use of the structure for implementing a geographic information system is described. Algorithms for constructing and manipulating the structure are provided. Results of empirical tests comparing the structure to other representations in the literature are given.
12182#A system of computer programs has been established to generate high quality montage image of considerable usefulness in architectural simulation which combine computer-generated images and photographed background pictures.Traditionally, there are two methods of creating architectural montages: (1) an artist paints new buildings onto a background scene usually generated photographically, and (2) a three-dimensional scale model is created to simulate the whole landscape, and this model is then photographed. The montage method described here combines aspects of both traditional montage methods with significant improvement in accuracy and reduction of time and cost of preparation. Specifically, a digitized photograph is used as a background scene onto which is superimposed a 3D computer-generated image of a new building. The outstanding points of the new method are:(i) The shading and shadows of each computer generated image are calculated with higher accuracy, (ii) the fog effect is taken into account, and (iii) a new anti-aliasing technique improves the quality of the final montage image.
12183#Realism in computer graphics typically requires using 24 or more bits/pixel to generate an image. This paper describes a method developed by the authors called "Color Cell Compression" or "CCC" that preserves at least a limited animation and local update capability yet yields extraordinary-looking color images in approximately two bits/pixel independent of image complexity. Three intermediate methods of compressing images to six, four and three bits/pixel respectively are also described. The CCC encoding process for a 640 × 480 image averages 11 seconds on a VAX 11/750, however, the CCC method does permit real-time decoding of these images using software look-up tables and conventional display hardware. The three intermediate methods may also be decoded in real time but have the added advantage of requiring only 3-4 seconds for encoding on a VAX 11/750.
12184#Paint brushes are modeled as a collection of bristles which evolve over the course of the stroke, leaving a realistic image of a sumi brush stroke. The major representational units are (1) Brush: a compound object composed of bristles, (2) Stroke: a trajectory of position and pressure, (3) Dip: a description of the application of paint to a class of brushes, and (4) Paper: a mapping onto the display device. This modular system allows experimentation with various stochastic models of ink flow and color change. By selecting from a library of brushes, dips, and papers, the stroke can take on a wide variety of expressive textures.
12185#We are interested in the problem of making precise line drawings using interactive computer graphics. In precise line drawings, specific relationships are expected to hold between points and lines. In published interactive drawing systems, precise relationships have been achieved by using rectangular grids or by solving simultaneous equations (constraints). The availability of fast display hardware and plentiful computational power suggest that we should take another look at the ruler and compass techniques traditionally used by draftsmen. Snap-dragging uses the ruler and compass metaphor to help the user place his next point with precision, and uses heuristics to automatically place guiding lines and circles that are likely to help the user construct each shape. Snap-dragging also provides translation, rotation, and scaling operations that take advantage of the precision placement capability. We show that snap-dragging compares favorably in power and ease of use with grid or constraint techniques.
12186#A Switchboard model of user input management is presented which takes advantage of opportunities afforded by a multitasking multiprocessor programming environment. This model further separates application programming from the programming of the interaction dialogues as compared with conventional user interface management systems. It also provides powerful tools for implementing parallel forms of input, is suitable for managing interaction in window-based systems, and is very flexible.The paper describes this Switchboard model and its implementation on top of the Harmony operating system, as well as discussing some of the graphics support needed for the model.
12187#It is very time-consuming and expensive to create the graphical, highly-interactive styles of user interfaces that are increasingly common. User Interface Management Systems (UIMSs) attempt to make the creation of user interfaces easier, but most existing UIMSs cannot create the low-level interaction techniques (pop-up pull-down and fixed menus, on-screen "light buttons", scroll-bars, elaborate feedback mechanisms and animations, etc.) that are frequently used. This paper describes Peridot, a system that automatically creates the code for these user interfaces while the designer demonstrates to the system how the interface should look and work. Peridot uses rule-based inferencing so no programming by the designer is required, and Direct Manipulation techniques are used to create Direct Manipulation interfaces, which can make full use of a mouse and other input devices. This allows extremely rapid prototyping of user interfaces.
12188#The George Washington User Interface Management System (GWUIMS) has been designed as a test bed for comparing user interface models, as a tool for rapidly prototyping highly interactive graphic user interfaces, and as a vehicle for investigating the applicability of knowledge-based technology to user interface design. The GWUIMS was designed and implemented using the object-oriented programming paradigm and consists of a variety of object classes representing different levels of abstraction, Responsibility for lexical, syntactic, and semantic levels of both input parsing and feedback are distributed throughout these classes. We include a description of the GWUIMS and a brief scenario to demonstrate its capabilities. A description of the implementation is followed by a discussion of the future application of knowledge representation techniques and the evolution towards an intelligent assistant for the user interface designer.
12189#A new algorithm for speeding up ray-object intersection calculations is presented. Objects are bounded by a new type of extent, which can be made to fit convex hulls arbitrarily tightly. The objects are placed into a hierarchy. A new hierarchy traversal algorithm is presented which is efficient in the sense that objects along the ray are queried in an efficient order.Results are presented which demonstrate that our technique is several times faster than other published algorithms. Furthermore, we demonstrate that it is currently possible to ray trace scenes containing hundreds of thousands of objects.
12190#A new algorithm for ray tracing parametric surface patches is presented. The method uses quasi-Newton iteration to solve for the ray/surface intersection and utilizes ray-to-ray coherence by using numerical information from adjoining rays as initial approximations to the quasi-Newton algorithm. Techniques based upon object space subdivision are used to insure convergence to the correct interesection point. Examples are given of the use of the algorithm in scenes containing Bézier surface patches. Results show that a significant number of ray/surface intersections on these parametric surface patches can be found using very few iterations, giving a significant computational savings.
12191#A collection of new methods for ray tracing differentiable surfaces is developed. The methods are general, and extend the set of "ray-traceable" surfaces suitable for use in geometric modeling. We intersect a ray l = at + b, t > 0 with a parametric surface x = f(u, v), and with implicit surfaces f(x,y,z) = 0. A smooth surface is treated as a deformation of a flat sheet; the intersection problem is converted to a new coordinate system in which the surfaces are flat, and the rays are bent. We develop methods for providing good initial estimates of the parametric intersection values, and a "closeness criterion," to reduce computation. These same criteria help us substitute a set of simpler surfaces for the more complex surface. The parametric method produces the intersection values of u, v, and t. These are suitable for shading calculations and for mapping textures onto the surface; they can also produce the local coordinate frame values, suitable for anisotropic lighting models.
12192#We introduce an adaptive, iterative technique for obtaining texture samples of arbitrary precision when synthesizing a computer-generated image. The technique is an improvement on the sum table texturing method. To motivate the technique we analyze the error properties of the sum-table method. Based on that analysis we propose using a combination of tables independently or together to obtain a better estimate, and analyze the error properties of such methods. We then propose a new technique for obtaining texture samples whose accuracy is a function of the texture and the image. As part of this technique we propose the use of an auxiliary table which contains local estimates of the texture variance. We show how the iteration of a given sample may be controlled by values from this table. We then analyze the error in this method, and present images which demonstrate the improvement.
12193#The power of a color space to perform well in interpolation problems such as anti-aliasing and smooth-shading is dependent on the topology of the color space as well as the number of elements it contains.We develop the Major-minor color space, which has a topology and representation that lends itself to simple anti-aliasing computations between elements of an arbitrary set of colors in an inexpensive frame store.
12194#Many applications of digital filtering require a space variant filter - one whose shape or size varies with position. The usual algorithm for such filters, direct convolution, is very costly for wide kernels. Image prefiltering provides an efficient alternative. We explore one prefiltering technique, repeated integration, which is a generalization of Crow's summed area table.We find that convolution of a signal with any piecewise polynomial kernel of degree n--1 can be computed by integrating the signal n times and point sampling it several times for each output sample. The use of second or higher order integration permits relatively high quality filtering. The advantage over direct convolution is that the cost of repeated integration filtering does not increase with filter width. Generalization to two-dimensional image filtering is straightforward. Implementations of the simple technique are presented in both preprocessing and stream processing styles.
12195#Proceedings of the 13th annual conference on Computer graphics and interactive techniques
12196#Several articles have appeared in SIGART Newsletter on the game of Mastermind during the recent three to four years (1 - 8). In particular, P. Norvig described a heuristic for obtaining an approximation to the optimal solution(1). In this article, several simple heuristics to play Mastermind are analyzed.
12197#An interactive generation of a solution to a 3 × 3 × 2 cube-like problem is presented.
12198#We introduce the "model-driven reasoning" as an approach to diagnosing. Lucidness and explicitness of knowledge representation are emphasized. Good partitioning of diagnosis knowledge in the structure results in the attention focusing of interpretation and gives efficient reasoning power. The approach has been used in the design of a knowledge-based system for identifying paleo-depositional environments in oil prospecting.
12199#1. INTRODUCTION. In this investigation we attempt to quantify expert reasoning to process boolean values 0 (FALSE) and 1 (TRUE) instead of large lists of atoms that form conditions. The human brain reasons by processing demodulated signals through axons and across synapses, which either fire or don't fire in a boolean fashion. Our approach bridges the current expert systems approach (see, e.g., Hayes-Roth et al.[3]) and the old approaches, e.g., neural nets (McCulloch and Pitts[6]) and associations (Nakano[9]). It simplifies knowledge representation by reducing much of symbolic processing to efficient ANDing and ORing. An ultimate application of our approach would be an expert systems on a chip. A side effect of this would be the demise of inefficient, memory cluttering, list processing languages.
12200#The science of computing—expert systems
12201#Proceedings of the NATO Advanced Study Institute on Learning Physics and Mathematics via computers on Designing computer-based learning materials
12202#Current research in the psychology of learning and teaching
12203#Overcoming conceptual difficulties in physical science through computer-based Socratic dialogs
12204#Pedagogical development of computer-based learning material
12205#Modelling as a method of learning physical science and mathematics
12206#Toward an industrial approach to educational software development
12207#The computer in the evaluation of learning
12208#Integrating physics and computer education in a single process
12209#Integrating computers and tutors into cost-effective physics and mathematics instruction
12210#The computer as an integral part of the laboratory
12211#Measurement of protein surface shape by solid angles
12212#Conformational studies on histamine H20-receptor antagonists: deduction of a simple structure activity relationship
12213#Pharmacophoric pattern matching in files of 3-D chemical structures: election of interatomic distance screens
12214#Computer-aided structural comparisons of clonidine and guanfacine with cyclazocine
12215#Electrostatic potentials of the alpha helix dipole and of elastase
12216#The central nervous system drug design
12217#Statistical method for surface pattern-making between dissimilar molecules: electrostatic potentials and accessible surfaces
12218#Similarities of pharmacophoric patterns revealed by the MEP of metoclopramide, molindone and piquindone, a subgroup of dopamine D-2 receptor antagonists
12219#Analysis of the pharmacological properties of clozapine analogues using molecular electrostatic potential surfaces
12220#Approach to modeling specificity determinants in receptor-ligand complexes: congeners of serotonin
12221#Computer graphic modelling in drug design: conformational analysis of dihydrofolate reductase inhibitors
12222#Second European seminar and exhibition on computer-aided molecular design
12223#The American (information) revolution: Electronic collection and dissemination of information by federal agencies
12224#Artificial intelligence for the layman
12225#A science of information for the information age
12226#Medical information systems
12227#Some thoughts on professional ethics codes
12228#Teaching about computers and technology
12229#Which monoids are syntactic monoids of &ohgr;-Languages
12230#On szilard languages of pure context-free grammars
12231#Classification of a maximal clone of three-valued logical functions
12232#Small nonplanar subgraphs of the cube
12233#A watershed algorithm adapted to functions on grids
12234#On a robustness problem for the GI/GI/s queue
12235#Applied Mathematical Modelling
12236#Field validation of the contaminant transport model,FEMA
12237#Optimizing the number of tools and cutting parameters in multi-tool turning for multiple objectives through geometric programming
12238#On mixed boundary element solutions of convection-diffusion problems in three dimensions
12239#Flow behaviour in rearward-facing cavities
12240#Computation of fundamental solutions of the boundary element method for shallow shells
12241#The mathematical modelling of turbulent flows
12242#Temperature and velocity distributions in a square duct
12243#The importance of mixed language programming, and some of the associated problems, are summarized. The paper presents a structured view on the major ways to realize mixed language programming and how to provide the necessary data types.
12244#A novel introduction in fracture mechanics of pseudo-ordinary differential equations (ODEs) corresponding to the stress intensity factors (SIFs), augments the under-determined system of ODEs produced by the method of lines (MOL) solution of the equations of elasticity, in the presence of cracks. With this modelling "trick", which is natural to MOL, the SIFs are obtained directly, as part of the solution unknowns, thus avoiding the uncertainties associated with other indirect methods.
12245#Myopia vs. computopia: power to the users?
12246#Technology transfer and the computerization of South Korea and Taiwan Part I: Developments in the private sector
12247#Impact of transborder data flow restrictions on cash-management services
12248#Effective legal transactions in open telecommunications systems in accordance with German law
12249#Software escrow: a practical primer
12250#Combatting computer crime
12251#National health care information system for Greece
12252#Office systems: their role
12253#Expert systems and knowledge engineering: artificial intelligence applications
12254#Methodus: an informatics application to law
12255#Technological changes during the eighties and fourth generation languages
12256#Experiments and analysis of information use and value in a decision-making context
12257#Online search patterns: NLM CATLINE database
12258#Information-seeking behavior in an applied research/service delivery setting
12259#Person-to-person communication in an applied research/service delivery setting
12260#The five-axiom theory of indexing and information supply
12261#The research method used in subfields and the growth of published literature in those subfields: Vertebrate paleontology and geochemistry
12262#This paper shows that synthesizing binary decision programs (formed by means of decision instructions of the type if then else and of execution instructions of the type do) and proving theorems can be carried out by using the same approach. It is proved that the same transformations acting on P-functions can be interpreted in terms of binary program synthesis and of theorem proving. Since binary program leads to algorithmic state machine design while theorem proving leads to declarative programming, this allows us to lay a bridge between logic design and declarative languages such as Prolog.
12263#In this paper we study the problem of testing RAM. A new fault model, which encompasses the existing fault models, is proposed. We then propose a scheme of testing faults from the new fault model using built-in testing techniques. We introduce concept of p-hard and determine the complexity of the extra hardware required for built-in self-testing on our hardness scale. A novel approach using microcoded ROM for implementation of built-in testing is also proposed and its complexity is determined.
12264#A methodology for characterizing dynamic distributed recovery in fault-tolerant multiprocessor systems is developed using graph theory. Distributed recovery, which is intended for systems with no central supervisor, depends on the cooperation of a set of processors to execute the recovery function, since each processor is assumed to have only a limited amount of information about the system as a whole. Facility graphs, whose nodes denote the system components (processors), and whose edges denote interconnection between components, are used to represent multiprocessor systems, and error conditions. A general distributed recovery strategy R, which allows global recovery to be achieved via a sequence of local actions, is given. R recovers the system in several steps in which different nodes successively act as the local supervisor. R is specialized for two important classes of systems: loop networks and tree networks. For each of these cases, fault-tolerant designs and their associated distributed recovery strategies, which allow recovery from up to k faults within a specified number of steps, are presented.
12265#A key element (one is tempted to say the heart) of most digital systems is the clock. Its period determines the rate at which data are processed, and so should be made as small as possible, consistent with reliable operation.
12266#Bit-sequential algorithms for arithmetic processing are good candidates for VLSI signal processing circuits because of their canonical structure and minimal interconnection requirements. Several recent papers have dealt with algorithms that accept unsigned binary inputs, one bit at a time, least significant bit first, and produce an unsigned binary product in a bit-serial fashion.
12267#Performability, a composite measure for the performance and reliability, may be interpreted as the probability density function of the aggregate reward obtained from a system during its mission time. For large mission times we show that known limit theorems lead to an asymptotic normal distribution for the aggregate reward. For finite mission times and Markovian models we obtain the expressions for all moments of performability and give recursions to compute coefficients involved in the expressions. We illustrate the use of the results through an example of a multiple processor computer system.
12268#Garcia-Molina, Lipton, and Valdes [1] introduced a new machine architecture called "massive memory machines" (MMM). The primary application of their proposed architecture was for so-called memory bound computations. In this correspondence we argue: 1) that massive memories will likely become feasible, but will be most effective with much more powerful processors, and 2) that a massive memory on the proposed machine will perform poorly in the same cases that virtual memory performs poorly: whenever there is poor locality of memory reference. Other problems with the architecture are also discussed. These related issues include: 1) the infeasibility of large on-chip dual port memory, 2) the support of multiprocessing on an ESP, 3) the possibility of memory prerequest, 4) the potential of trading program size for execution time, and 5) the time required for clearing the entire memory.
12269#This correspondence presents a collection of reconfiguration procedures for a multiprocessor which employs multistage interconnection networks. These procedures are used to dynamically partitipn the multiprocessor into many subsystems, and reconfigure them to form a variety commonly used topologies to match task graphs. By examining the switching capability of the interconnection network, design rules for avoiding connection conflicts are exploited. Then, on the basis of these rules, parallel procedures are designed. With the procedures, a subsystem can be reconfigured in the form of the desired topologies without interfering with other subsystems. In addition, the reconfiguration of a subsystem can be accomplished in constant time, independently of subsystem size.
12270#This correspondence presents a linear systolic array for the implementation pf digital signal processing systems based upon matrix- vector multiplication algorithms where the matrix elements can be computed from their row and column indexes. Haar, Walsh, and the discrete Fourier transforms are solved using this approach. The method presented enables the n2 matrix elements to be computed in situ directly from the 2n matrix indexes. Thus, performance comparable to known systolic matrix-vector multipliers is achieved using only constant I/O bandwidth, rather than O(n) bandwidth required in the more general case. A generalized method is given for the development of recursively formed matrices and specifically the VLSI implementation of the Haar and Walsh transforms.
12271#We present a parallel algorithm to solve the visibility problem among n vertical segments in a plane, which can be implemented on a VLSI chip arranged as a mesh of trees. Our algorithm determines all the pairs of segments that "see" each other in time O(log n); while the fastest sequential algorithm requires O(n log n). A lower bound to the area-time complexity of this problem of O(n2 log2 n) is also derived.
12272#The addition and multiplication algorithms of two Hensel codes were presented in two earlier papers [1], [2] on p-adic arithmetic. It is shown here that these algorithms do not always generate a correct result having the same code word length as the two operands and the correct algorithms are given.
12273#This correspondence shows two counter examples which contradict the Theorems 4 and 5 in [1].
12274#COMPUTER DATABASES: A survey Part I: General and news databases
12275#A laserdisk for law students-IAC's legaltrac
12276#INMAGIC In practice-Version 7 in a law library
12277#Starting a software user's group
12278#INMAGIC...Kudos and Caveats
12279#Inside tips to searching Rapra abstracts
12280#Laserdisk directory-Part 5
12281#Washington Press Text
12282#AGRIBUSINESS U.S.A
12283#Search Works: Does it really work?
12284#“Hello,central? Give me everything on...”Or, telecommunications information in the age of divestiture
12285#Accessing tax information online
12286#Laserdisk directory-Part 3
12287#Silverplatter brings CDROM to the reference desk
12288#A-V Online: Now on compact laserdisk (CDROM)
12289#Do it for less] A comparison of low-cost communications software for the IBM PC
12290#MEDLINE subheadings: Review and update
12291#The silver disk-Access software for optical/laser information packages
12292#Full-text newspapers online
12293#Experiments in search and knowledge
12294#Recursions and rule selections on a high level relation processor for knowledge-base machine
12295#A systems model of cognition for improving human factors of computing environments
12296#Design and analysis of reliable interconnection networks
12297#Fault identification and isolation in multiprocessor systems
12298#Complexity results for automatic layout design
12299#International Colloquium on Automata, Languages and Programming on Automata, languages and programming
12300#Characterizations of PUNC and precomputation
12301#Comparison of algorithms controlling concurrent access to a database: a combinational approach
12302#A new duality result concerning Voronoi diagrams
12303#Classification of all the minimal bilinear algorithms for computing the coefficients of the products of two polynomials modulo a polynomial
12304#On exponential lowness
12305#A tradeoff between search and update time for the implicit dictionary problem
12306#Intersections of some families of languages
12307#Correspondence between ternary simulation and binary race analysis in gate networks
12308#Counting with rational functions
12309#Finite biprefix sets of paths in a graph
12310#Parallel RAMs with owned global memory and deterministic contex-free language recognition
12311#A strong restriction of the inductive completion procedure
12312#On discerning words by automata
12313#Complexity classes without machines: on complete languages for UP
12314#Containment, separation, complete sets, and immunity of complexity
12315#On nontermination of Knuth-Bendix algorithm
12316#Tradeoffs for language recognition on parallel computing models
12317#Rational equivalence relations
12318#Some further results on digital search trees
12319#Knowledge, belief and time
12320#A termination detector for static and dynamic distributed systems with asynchronous non-first-in-first-out communication
12321#Decompositions of nondeterministic reductions
12322#Hierarchical planarity testing algorithms
12323#Synthesis and equivalence of concurrent systems
12324#The set union problem with backtracking
12325#Torsion matrix semigroups and recognizable transductions
12326#On recognizable subsets of free partially commutative monoids
12327#Min Cut is NP-complete for edge weighted trees
12328#Alternating automata, the weak monadic theory of the tree, and its complexity
12329#Subpolynomial complexity classes of real functions and real numbers
12330#Syntactic study of recognizable parts of infinite words
12331#Refusal testing
12332#A timed model for communicating sequential processes
12333#A uniform reduction theorem extending a result of J. Grollmann and A. Selman
12334#On the complexity of deciding fair termination of probabilistic concurrent finite-state programs
12335#A new approach to detection of locally indicative stability
12336#A more efficient algorithm for lattice basis reduction
12337#Lower bounds by recursion theoretic arguments
12338#An improved algorithm for transitive closure on acyclic digraphs
12339#An algorithm determining the shuffle of two words
12340#A very fast, practical algorithm for finding a negative cycle in a diagraph
12341#A compositional reformulation of Owicki-Grier's partial correctness logic for a concurrent while language
12342#Semigroups and languages of dot-depth 2
12343#A parallel vertex insertion algorithm for minimum spanning trees
12344#More complicated questions about maxima and minima, and some closures of NP
12345#Lower bounds for dynamic range query problems that permit subtraction
12346#E-unification algorithms for a class of confluent term rewriting systems
12347#On fixed-point clones
12348#A natural language interface for computer-aided design
12349#Document databases
12350#Computers and communications: a vision of C & C
12351#The professional user's guide to acquiring software
12352#Pebbles to computers: the thread
12353#Software engineering: the production of quality software
12354#Op amp network design
12355#Oxford surveys in information technology; vol. 2, 1985
12356#The validation, verification and testing of software
12357#High-level information technology developments in Eastern Europe
12358#User interfaces for office systems
12359#The social impact of information technology
12360#Videotex USA
12361#Personal computing for decision support
12362#International standards for the interchange of text
12363#The evolution of integrated services digital networks
12364#Object oriented programming: an evolutionary approach
12365#Structured data flow: a quasi-synchronous interpretation of data driven computations
12366#An :20Anaylsis” of analytical chemistry
12367#The NCI drug information system. 1. System overview
12368#The NCI drug information system. 2. DIS pre-registry
12369#The NCI drug information system. 3. The DIS chemistry module
12370#The NCI drug information system. 4. Inventory and shipping modules
12371#The NCI drug information system. 5. DIS biology module
12372#The NCI drug information system. 6. System maintenance
12373#Integrated chemical-biological-spectroscopy-inventory-reactions preclinical database
12374#Description of organic reactions based on imaginary transition structures. 1. Introduction of new concepts
12375#Description of organic reactions based on imaginary transition structures. 2. Classification of one-string reactions having an even-membered cyclic reaction graph
12376#Description of organic reactions based on imaginary transition structures. 3. Classification of one-string reactions having an odd-membered cyclic reaction grap
12377#Description of organic reactions based on imaginary transition structures. 4. Three-nodal and four-nodal subgraphs for a systematic characterization of reaction
12378#Description of organic reactions based on imaginary transition structures. 5. Recombination of reaction strings in a synthesis space and its application to the
12379#Coding of relational descriptions of molecular structures
12380#Essential framework: a self-teaching guide
12381#The William Lowell Putnam mathematical competition: problems and solutions: 1965-1984
12382#Stiff computation
12383#Metamodeling: a study of approximations in queueing models
12384#Animated algorithms: a self-teaching course in data structures and fundamental algorithms
12385#Introducing dBase II
12386#Analytic methods in the analysis and design of number-theoretic algorithms
12387#WordStar and WordStar 2000: advanced tips and techniques
12388#KBEmacs: Where's the AI?
12389#I had a dream: AAAI presidential address
12390#Qualitative reasining for financial assessments
12391#Artificial intellignece research at the center for automation and intelligence systems research, case Western Reserve University
12392#Artificial intelligence research at the advanced computational methods center, University of Georgia
12393#Artificial intelligence research at East Texas State University
12394#Essential LISP
12395#Computer organization and assembly language programming for the VAX
12396#32-bit microprocessors
12397#68000 assembly language programming
12398#Adaptive signal processing: theory and applications
12399#The UNIX System user's manual
12400#The UNIX System user's guide
12401#The Motorola MC68000: an introduction to processor, memory and interfacing
12402#The PICK operating system
12403#UNIX for people
12404#The VI user's handbook
12405#DOS to OS conversion
12406#Lisp lore: a guide to programming the Lisp machine
12407#CP/M 80 systems programming
12408#Preparing documents with UNIX
12409#PORTAL language description
12410#Crafting C tools for the IBM PCs
12411#A guide to Modula-2
12412#PC-Portable Fortran
12413#Microcomputers: software and applications
12414#VAX-11 BASIC: a structured approach
12415#ProDOS inside and out
12416#Probability, signals, noise
12417#The students' FORTH
12418#The geometry of fractal sets
12419#The C trainer
12420#C for personal computers: IBM PC, AT&T PC 6300, and compatibles
12421#Hands-on-Excel: shortcuts, strategies, and techniques for your Macintosh
12422#Adaptive filter theory
12423#Foundations and applications of Montague grammar: 8M part 1: philosophy, framework, computer science
12424#Systematic software development using VDM
12425#Problem solving using Turbo Pascal
12426#DEC microcomputer directory
12427#PICK—your system
12428#Modern antenna design
12429#Programming in C with a bit of UNIX
12430#Introducing UNIX System V
12431#Programming using VAX BASIC
12432#Assembler language with ASSIST and ASSIST/I (3rd ed.)
12433#Beginning COBOL: 8M an interactive and structured approach
12434#The problem considered in this paper is the deterministic scheduling of tasks on a set of identical processors. However, the model presented differs from the classical one by the requirement that certain tasks need more than one processor at a time for their processing. This assumption is especially justified in some microprocessor applications and its impact on the complexity of minimizing schedule length is studied. First we concentrate on the problem of nonpreemptive scheduling. In this case, polynomial-time algorithms exist only for unit processing times. We present two such algorithms of complexity O(n) for scheduling tasks requiring an arbitrary number of processors between 1 and k at a time where k is a fixed integer. The case for which k is not fixed is shown to be NP-complete. Next, the problem of preemptive scheduling of tasks of arbitrary length is studied. First an algorithm for scheduling tasks requiring one or k processors is presented. Its complexity depends linearly on the number of tasks. Then, the possibility of a linear programming formulation for the general case is analyzed.
12435#In this paper we give methods for the construction of systematic t-random error correcting and all unidirectional error detecting codes. Also we give the encoding/decoding algorithms and discuss their implementation.
12436#Previous theoretical work in computational complexity has suggested that any problem which is log-space complete for P is not likely in NC, and thus not parallelizable. In practice, this is not the case. To resolve this paradox, we introduce new complexity classes PC and PC* that capture the practical notion of parallelizability we discuss in this paper. We show that foqur complete problems for P (nonsparse versions of unification, path system accessibility, monotone circuit value, and ordered depth-first search) are parallelizable. That is, their running times are O(E + V) on a sequential RAM and O(E/P + V log P) on an EXCLUSIVE-READ EXCLUSIVE-WRITE Parallel RAM with P processors where V and E are the numbers of vertices and edges in the inputed instance of the problem. These problems are in PC and PC*, since an appropriate choice of P can speed up their sequential running times by a factor of µ(P). Several interesting open questions are raised regarding these new parallel complexity classes PC and PC*. Unification is particularly important because it is a basic operation in theorem proving, in type inference algorithms, and in logic programming languages such as Prolog. A fast parallel implementation of Prolog is needed for software development in the Fifth Generation project.
12437#The past few years have witnessed an increasing number of large distributed computer system implementations based on local area networks. In these systems a number of resources (CPU's, file servers, disks, etc.) are shared among jobs originating at different sites. Evaluating the performance of such large systems typically requires the solution of a queueing network model with a large number of closed chains, which precludes the use of exact solution techniques. Therefore, it is important to develop accurate and cost-effective methods for the approximate analysis of closed queueing networks with many chains. In this paper, we present an approach based on the clustering of chains and service centers. The method is applicable to queueing networks with single server fixed rate, infimite server and multiple server service centers. We present the results obtained when the method is used to solve large queueing network models. Extensive comparison of this method to existing approximation techniques indicates that the approach has better accuracy/cost characteristics.
12438#In this paper, we take a hard look at scheduling considerations in computing arrays. A simple sufficient condition is developed for determining whether a computing array can be pipelined. If the array cannot be pipelined in the form given, the condition also indicates the direction in which to proceed to make it pipelineable. The overall framework and methodology take a good part of the load off the logical architect of the array, and make the translation from the logical to the physical architecture a mechanical process.
12439#This paper discusses ways of reducing fragmentation ion in buddy systems. Although internal fragmentation may be estimated for any buddy system, external fragmentation cannot be determined theoretically. It is suggested here that mean external fragmentation for any buddy system is directly related to the height of the associated binary tree. Simulation studies with a new buddy system support this conjecture. Attempts at reducing internal fragmentation have, in the past, increased the tree height covering the range of request sizes and given rise to a commensurate increase in external fragmentation. A new buddy system is described which supports a large number of buddy sizes without requiring a large tree height. The new scheme is a modified form of the weighted buddy method, entitled the dual buddy system. It provides the same set of block sizes as the weighted scheme but has the same tree height as the binary buddy system. Simulation results show that mean external fragmentation is within four percent of that of the binary system and much lower than that of the weighted scheme. The new system has better overall storage utilization han others for uniform random request sizes.
12440#Multiprocessors used in life-critical real-time systems must recover quickly from failure. Part of this recovery consists of switching to a new task schedule that ensures that hard deadlines for critical tasks continue to be met. We present a dynamic programming algorithm that ensures that backup, or contingency, schedules can be efficiently embedded within the original, "primary" schedule to ensure that hard deadlines continue to be met in the face of up to a given maximum number of processor failures. Several illustrative examples are included.
12441#A new scheme for constructing search algorithms for bit-parallel associative memories of m n-bit words is described. The resulting equivalence searches, threshold searches, and double-limit searches achieve the time bound of O(log n), compared to O(n), the recent result of Ramamoorthy et al. [12]. The extremum search algorithm by Frei and Goldberg [2] is modified and generalized so that the number of memory interrogations is reduced by 30 percent over the initial algorithm in the average case.
12442#We present algorithms and time complexity results for MOS switch-level simulation with particular reference to race detection. Under the switching model used in classical (Boolean) switching theory, we derive a linear-time race detection algorithm for switch-level circuits that have no feedback within a clock phase, and have unit fan-out. We show that the problem becomes NP-complete if fan-out of two or more is allowed. We Also relate this result to others that have recently been reported, using a different switching model.
12443#Programmed logic arrays [1], [2] are common in computer design. A form of this method of design has been used since the beginnings of computers, in telephone relay networks [3]. Optimization of such realizations of functions were begun by Karnaugh [4], Quine [5], McCluskey [6], and Roth [7]. Substantial use was mnade of such programs by Preiss [8] and Perlman [9]. Despite the existence of exact procedures, "fast," "approximate" procedures have been widely used. A new approximate procedure, using the D algorithm [1], [10], [11] is introduced here. It gets around a large computation, in complementation, using prior methods. Running programs "verify" this expectation.
12444#The extended Euclidean algorithm is typically used to calculate multiplicative inverses over finite fields and rings of integers. The algorithm presented here has approximately the same number of average iterations and maximum number of iterations. It is shown, when P is a Mersenne prime, implementation of this algorithm on a processor, designed especially for mod P arithmetic operations, produces a more efficient algorithm with respect to the amount of program statements and number of operations. It is then shown heuristically, when the division and multiplications are performed simultaneously, the Euclidean algorithm has fewer subiterations.
12445#This note points out several errors in the paper [1] by E. E. Swartzlander, Jr. et al. Corrected results are presented including detailed reasons and derivations.
12446#A parallel approach to the picture restoration algorithm of Geman and Geman on an SIMD machine
12447#Application of an optimized digital correlation method to planar deformation analysis
12448#Hardware implementation of image registration algorithms
12449#Three-dimensional surface measurement by microcomputer
12450#Efficient algorithm for polygon overlay for dense map image data set
12451#Critical success factors of decision support systems: An experimental study
12452#End-user satisfaction of data base management systems: An empirical assessment of mainframe, mini and micro computer-based systems using an interactive model
12453#Don't shoot, they are your children
12454#Programming computer games
12455#Spreadsheet solutions for mathematical modeling problems
12456#Alphamagic squares
12457#The evolution of computer law in Indiana
12458#Surveillance: A dangerous game played with matches
12459#Jumping frogs and the dutch national flag
12460#The virgin Atlantic affair
12461#What crisis in computer science?
12462#The star wars computer system
12463#Misconception in human factors
12464#A quarter century of IFIP
12465#The origin of IFIP
12466#Japanese word processing: Interfacing with the inscrutable
12467#How much computer crime is there?
12468#Recording, sorting, an retrieving brainstorms
12469#Highly composite integers and an undergraduate exam
12470#France's information needs: reality or alibi?
12471#From Guidon to Neomycin and Heracles in twenty short lessons
12472#Blackboard systems part two: Blackboard application systems
12473#CRSL: A language for classificatory problem solving and uncertainty handling
12474#Strategy and business planning for artificial intelligence companies: A guide for entrepreneurs
12475#The wager
12476#Research in artificial intelligence at the university of Pennsylvania
12477#Artificial intelligence research and applications at the NASA Johnson space center, part two
12478#Inside an expert systems shell
12479#Object-oriented programming in Prolog
12480#A lisp structure editor
12481#Writing expert systems with small-X
12482#What's so special about artificial intelligence
12483#Constructing a (better) theorem-prover in PROLOG
12484#Programming structures in PROLOG
12485#Selecting an expert system shell
12486#Apollo domain series 3000
12487#A programming approach to mathematics
12488#Computer text access
12489#A computer based tutorial to teach the phonetic alphabet
12490#Course design using software engineering methods
12491#The electronic spreadsheet as a didactic learning enhancement
12492#Computer education in Bahrain's secondary schools (a pilot project)
12493#Callisto: An intelligent project management system
12494#AI in manufacturing at digital
12495#OPGEN: The evolution of an expert system for process planning
12496#A knowledge-based consultant for financial marketing
12497#AI Research in progress at the courant institute, New York University
12498#Construction and maintaining detailed production plans: Investigations into the development of knowledge-based factory scheduling systems
12499#PIES: An engineer's Do-It-Yourself knowledge system for interpretation of parametric test data
12500#An AI-Based methodology for factory design
12501#CML: A meta-interpreter for manufacturing
12502#Online, artificial intelligence-based turbine generator diagnostics
12503#Writing to be searched: A workshop on document creation principles
12504#Information retrieval research at the national library of medicine
12505#Which way for a classification scheme for computers and medicine
12506#Computers and education
12507#Time in clinical decision support systems: Temporal reasoning in ONCOCIN and ONYX
12508#The acid-base physiology program
12509#Information retrieval and the structure of the biomedical lexicon
12510#New methods for automated construction of knowledge bases for expert classification systems are being developed using a logic-based language and inductive inference techniques. This research addresses deficiencies of currently available methods for deriving classification rules from empiric data. Unate boolean functions are proposed as a useful language for logical classification rules. An example is given showing the use of an algorithm for converting unate functions to a "criteria table" knowledge representation.
12511#Emergency psychiatric service patient information system
12512#As a comprehensive center for pacemaker study, the VA Eastern Pacemaker Surveillance Center (EPSC) combines three responsibilities. First, EPSC actively monitors more than 3,500 persons in 28 states by telephone. EPSC also maintains the national VA Pacemaker Registry of over 20,000 patients. Additionally, EPSC is the VA national center for testing explanted pacemakers. The EPSC database is implemented in MUMPS on a PDP 11/44 mini-computer, using the public domain FileMan DBMS. Designed after development of multi-programmable pulse generators and dual chamber pacing, the EPSC database incorporates the expanding range of new pacing parameters. Data is entered interactively by pacemaker technicians. EPSC capabilities include a linked on-site Marquette MUSE D-300 computer system which analyzes and stores standard-lead ECGs, clinically-recorded pacemaker pulse waveforms and telephoned rhythm tracings. Comprehensive EPSC services include augmented monitoring of veterans with pacemakers and leads involved in advisory bulletins or recalls.
12513#Design for a distributed hospital information system based on local area network technology
12514#Third normal form is defined in different inequivalent ways in elementary data base textbooks. The method given in many of these books for decomposing a file into third normal form is non-algorithmic, depends on human recognition of a pattern, and has severe limitations and unexplained complexities. This is not necessary. There is an excellent algorithmic method available which is easy to learn, and which can be programmed.The objective of this paper is to examine the differences concerning how third normal form is presented in various textbooks, and to present an easy way of introducing it to students.This article appeared previously in the June 1986 issue of SIGCSE BULLETIN.
12515#There has been some technical and justified criticism of the treatment of missing information in the data sublanguage SQL and in IBM's Database 2 system (a relational database management system). Some of this criticism has been directed (by mistake) at the relational model. The purpose of this paper is to clarify and extend the treatment of missing information by the relational model.The clarification places heavy emphasis on the semantic aspects of missing information. The extension, which is relatively minor, provides a systematic approach (independent of data type) to dealing with the inapplicability of certain properties to some objects. This extension does not invalidate any part of the present version of the relational model.
12516#This article gives three viewing-transformation algorithms for displaying on a screen 3D pictures represented by linear octrees. All the procedures take advantage of the recursive labeling used to identify the successive decomposition of an object into octants. The first algorithm performs transformations directly on the linear octree, while the second and third algorithms determine the 3D border of the given object first and then project onto the screen the surface voxels thus found. All the algorithms perform the viewing transformations in O(RN) time, where R is the resolution of the picture and N is the number of elements in the linear octree. One of the algorithms provides views of the object at different layers of gray level, while another allows internal views.
12517#The 34010 Graphics System Processor is a 32-bit graphics microprocessor capable of executing high-level languages. It combines a full general-purpose instruction set with a powerful set of graphics instructions that includes arithmetic as well as Boolean pixbits (pixel block transfers). Because it is completely programmable, the 34010 can be used in many different graphics and nongraphics applications. it was designed to support a wide range of display resolutions and pixel sizes, as well as applications such as page (laser) printers, ink jet printers, data compression, and facsimile transmission. The 34010 includes such system features as an on-board instruction cache, full interrupt capability, wait and hold functions, and display timing control, as well as test and emulation support. Unique among today's microprocessors, the 34010 addresses all memory down to the bit level with variably sized fields rather than the common byte or word addressing. For example, the 34010 can push a 5-bit quantity onto a stack. This field-processing capability is an integral part of the basic architecture.
12518#To reinforce the growth of computer graphics, hardware architectures must be developed to support the rapid growth in display resolution that will occur in the next few years. The architectures must allow a high degree of application independence without requiring significant changes in the overhead software interface. The hardware architecture must be expandable, again avoiding significant software changes. Finally, the architecture must be implemented in VLSI for reasons of cost and speed. This article will describe a graphics hardware architecture that meets these criteria.
12519#Most graphics systems available today suffer from low performance, minimal flecibility, or high cost and high component count. Intel carefully looked at these problems and designed the 82786 chip to address them. The 82786 combines into a single of supporting today's graphics standards and a powerful display processor that supports windowing in hardware.
12520#On describing complex surface shapes
12521#Optic flow segmentation as an illposed and maximum likelihood problem
12522#Direct surface reconstruction from a moving sensor
12523#Binocular stereo algorithm based on the disparity-gradient limit and using optimization theory
12524#Surface descriptions from stereo and shading
12525#Use of multiple difference-of-gaussian filters to verify geometric models
12526#An approach to knowledge-driven segmentation
12527#Relaxation labelling algorithms-a review
12528#Knowledge-based analysis of carotid angiograms
12529#Knowledge-based interpretation of remotely sensed images
12530#Multiconstraint shape analysis
12531#Automated reasoning about image motion using a rule-based deduction system
12532#Curvature-based representation of objects from range data
12533#`Model': a POPLOG package to support model-based vision
12534#Using the computer in business communication courses
12535#Draft international standard (ISO/DIS 2382/ 8) data processing vocabulary control, integrity and security
12536#This report proposes a Reference Model (RM) for database management system (DBMS) standardization. A Reference Model is a conceptual framework whose purpose is to divide standardization work into manageable pieces and to show at a general level how these pieces are related with each other. The proposed RM comprises a Data Mapping Control System (DMCS) that retrieves and stores application data, application schemas, and data dictionary schemas. This DMCS is bounded by two interfaces: the Data Language (DL) interface which defines the services offered by the DMCS to various Data Management Tools (DMT), and the internal Data Language (i-DL) interface which defines the services required by the DMCS from the host operating system. This report suggests two candidates for standardization: the DL and the i-DL.
12537#Laserdisk directory-Part I
12538#Online sources of competitive intelligence
12539#A practical guide to establishing a business intelligence clearinghouse
12540#Searching LEXIS and WESTLAW-Part III
12541#Westmate and the LEXIS communications package. Dueling dial-ups
12542#First look-Info Trac vs. the confounding of technology and its applications
12543#Use of InfoTrac in a university library
12544#FINIS
12545#Laboratory test modifications
12546#CDROM Standards update
12547#Quality control and your database
12548#Most of the firmware engineering research currently under investigation at CSU is focused on methods of automated microcode generation and compaction, particularly retargetable methods. We have developed a prototype for a retargetable microcode compiler, which is depicted in Figure 1. Ideally, the system shown is retargeted by supplying a flow graph machine model for the target machine, and the remainder of the system is invariant.
12549#mcASM is a second generation Structured Microcode Assembler that is a, product of a joint effort between Advanced Micro Devices and Microtec Research. Years of bit-slice and microcode assembler experience by both companies has been combined with the latest in software technology to produce this advanced implementation of a relocatable microcode assembler. New features make mcASM faster and easier to use than conventional microcode assemblers so that the assembler package does more of the detail work. This allows the programmer to concentrate on the target system algorithm thereby achieving a more intelligent and more competeitve target system sooner.
12550#A Prolog machine design and its control are described. The machine features two-stage pipelining, a triple bus interconnection data path and support for concurrent control of micro-operations. The objective of this design is to improve execution of a Prolog processor by simultaneously performing multiple micro-operations. Capabilities of concurrent operation support are described in detail and demonstrated using some example Prolog functions. Two-stage pipeline technique as applied to non-deterministic control of Prolog program execution will be presented.
12551#Computer aided antibiotic therapy
12552#The behavior of a VLSI device can be expressed in occam, a language based on communicating processes. It is then possible to establish that the design behaves as intended, by simulation and by proof techniques using the formal semantics of occam. Finally, the occam source can be directly compiled into correct silicon layout.
12553#On robust partial discriminant analysis as a decision-making tool with clinical and analytical chemical data
12554#ANEMIA: An expert consultation system
12555#Multilead ECG analysis
12556#Three-dimensional graphics display of x-ray angiography data
12557#Rank order scaling in taste evaluation
12558#Representation and semiautomatic acquisition of medical knowledge in CADIAG-1 and CADIAG-2
12559#A hand-held decision-aid system designed for rural health workers
12560#A statistical analysis of spot variation using the two-dimensional polyacrylamide gel electrophoresis
12561#Computer-assisted diagnosis of acute azotemia
12562#Applications of clustering theory to cancer mortality data
12563#Logistic curve fitting and parameter estimation using nonlinear noniterative least-squares regression analysis
12564#Compartment model approaches for estimating the parameters of a chronic disease process under changing risk factor exposures
12565#Detection and characterization of peaks and estimation of instantaneous secretory rate for episodic pulsatile hormone secretion
12566#An improved method for on-line averaging and detection of ECG waveforms
12567#Spectral estimation of temporal series at unequal intervals
12568#A new ECG classifier based on linear prediction techniques
12569#An algorithm to manage variable-length records for highly portable clinical data base systems
12570#Computer simulation of cardiac rhythm and artificial pacemakers using a ten-element heart model
12571#Probabilistic sensitivity analysis methods for general decision models
12572#Frequency and time domain analysis of airflow breath patterns in patients with chronic obstructive airway disease
12573#Self-help computer conferencing
12574#Knowledge-based landmarking of cephalograms
12575#Prediction of lithogenic character of human bile by a quaternary system
12576#The determination of peaks in biological waveforms
12577#Evaluation of scientigraphic data of renal transplants
12578#Classification of malnutrition by statistical analysis of quantitative two-dimensional gel electrophoresis of plasma proteins
12579#Three-dimensional reconstruction from serial sections. IV. The reassembly problem
12580#Markov chain model and its application
12581#Constrained poststratification
12582#Recursive complementarity in the cybernetics of education
12583#The cybernetic mechanisms of stress
12584#Computers for self-help with behavior: systems and cybernetics can support persons and families uniquely
12585#Partial autoreference in models of natural systems and inadequacy of space-time references of physicians
12586#Some aspects of high technology and economic development
12587#Communicating with online catalogs and other retrieval systems: the need for a standard command language
12588#Full-text access and laser videodiscs: the National Agricultural Library System
12589#CD-ROM: a revolution in the making
12590#Designing user manuals for the online public access catalog
12591#The objective request-for-proposal
12592#The LSP/SNI test facility
12593#Mapping information delivery networks: the objectives, the methods, the benefits, and the model
12594#Electronic document delivery: OCLC's prototype system
12595#Common sense wordworking: writing with a personal computer
12596#Quality control in developing an interinstitutional database
12597#Auto-Graphics' AGILE II
12598#Research project on nanometer structure electronics
12599#Molecular level fabrication techniques and molecular electronics devices
12600#Nanometer-scale silicon MOSFETs
12601#Physics of nanometer structure devices
12602#Optical properties of superlattice and MQW laser diode
12603#Nanostructure fabrication methods
12604#Nanometer structure fabrication using electron beam lithography
12605#A field emission E-beam system for nanometer lithography
12606#Ion beam microfabrication
12607#Nanometer structure and device fabrication
12608#Resolution limit of E-beam direct writing technology
12609#Dry development and fine pattern fabrication PMIPK-AZIDE dry-developable resist in electron beam lithography
12610#Ion Beam deposition
12611#Investigation on solid phase epitaxy and its application
12612#Fabrication and characterization of heterostructures with subnanometer thickness
12613#Mid-gap electron traps (EL2 family) om GaAs
12614#Integrated optical devices for high-speed signal processing
12615#An approach to optically integrated digital logic devices
12616#Proposal of a distributed feedback laser with nonuniform stripe width for complete single-mode oscillation
12617#Surface emitting injection lasers
12618#Bridge type Josephson junctions as high speed digital devices
12619#Critical current adjustment of superconducting microbridge in liquid helium
12620#Microwave applications of Josephson junction diode and triode
12621#InP double-layer gate MISFET technology for VLSIs
12622#Fine lithography and SAW devices
12623#The Monte Carlo method provides a means of introducing natural variability in data, uncertainty of parameter estimation, chance occurrences and model reliability, into the process of simulation modeling for resource management. The technique is described and demonstrated for a hypothetical application of a Gaussian Plume Dispersion Model to a case of atmospheric pollution. It is concluded that the utility of the Monte Carlo approach lies mainly in providing decision makers with information on the likelihood of extreme occurrences and the inherent reliability of simulation modeling.
12624#The high cost of simulation has been well documented, and is a significant problem in many applications. In this paper, several existing methods for cost control and reduction are mentioned, and a modest proposal for drastically reducing simulation cost is presented.
12625#Advanced BASIC for the IBM PC
12626#COBOL: the language of business
12627#Structured BASIC programming with technical applications for the IBM PC
12628#Strictly structured BASIC
12629#It is shown that the worst case height of a k- dimensional height-balanced tree, k = 2, is the same as that of an AVL-tree, to within an additive factor of 2k - 2.
12630#In this paper a recursive algorithm using the error-trellis decoding technique is developed to decode certain convolutional codes (CC's). An example, illustrating the VLSI architecture of such a decoder, is given for a dual-k CC. It is demonstrated that such a decoder can be realized readily on a single chip with NMOS technology.
12631#The architecture of a multicomputer system with switchable main memory modules (SM3) is presented. This architecture supports the efficient execution of parallel algorithms for nonnumeric processing by 1) allowing the sharing of switchable main memory modules between computers, 2) supporting dynamic partitioning of the system, and 3) employing global control lines to efficiently support interprocessor communication. Data transfer time is reduced to memory switching time by allowing some main memory modules to be switched between processors. Dynamic partitioning gives a common bus system the capability of an MIMD machine while performing global operations. The global control lines establish a quick and efficient high-level protocol in the system. The network is supervised by a control computer which oversees network partitioning and other global functions. The hardware involved is quite simple and the network is easily extensible. A simulation study using discrete event simulation techniques has been carried out and the results of the study are presented. The architecture of this system is compared to those of conventional local area networks and shared-memory systems in order to establish the distinct nature and characteristics of a multicomputer system based on the SM3 concept.
12632#An approximation algorithm for systematically converting a stiff Markov chain into a nonstiff chain with a smaller state space is discussed in this paper. After classifying the set of all states into fast and slow states, the algorithm proceeds by further classifying fast states into fast recurrent subsets and a fast transient subset. A separate analysis of each of these fast subsets is done and each fast recurrent subset is replaced by a single slow state while the fast transient subset is replaced by a probabilistic switch. After this reduction, the remaining small and nonstiff Markov chain is analyzed by a conventional technique.
12633#Processors with multiple functional units, such as CRAY-1, Cyber 205, and FPS 164, have been used for high-end scientific computation tasks. Much effort has been put into increasing the throughput of such systems. One critical consideration in their design is the identification and implementation of a suitable instruction issuing scheme. Existing approaches do not issue enough instructions per machine cycle to fully utilize the functional units and realize the high-performance level achievable with these powerful execution resources.
12634#An analytic expression for the lower bound on the complexity of residue multiplication is developed. Significant reduction of the required stored logic in a content-addressable memory is noted. Errors in Figs. 5(a), 7, and 8 of the above paper1 are corrected.
12635#A scheme of a good signature analysis by a linear feedback shift register (LFSR) is presented. It works for k-output circuits, even if k is greater than the register length. It is built according to rules which are presented in the correspondence, taking into account error models which are introduced. The rules are derived from a property which is formally shown for one kind of LFSR. However, some of them apply to other LFSR schemes too.
12636#In the literature on diagnosable multiprocessor systems, regular testing structures which isolate up to t1 faulty processors to within a set of t1 processors have been studied. These structures are called D(n, t0, X) systems and are said to be t1/t1-diagnosable. In this correspondence, the problem of designing regular testing structures which isolate the largest number of faulty processors is shown to be equivalent to determining full-difference triangles. These triangles have been used to design error-correcting convolutional codes and transmission systems without third-order intermodulation interference, and have been studied extensively. Recognizing this relationship allows results from these areas to be applied directly to the design of diagnosable systems. A list of the best-known systems is given.
12637#In the channel routing problem, a problem arising in the design of layout systems, two rows of terminals which are opposite each other, have to be connected. We study what effect the rotation of one row of terminals has on the cost measures of the routing phase. The cost measures we consider are the density, which is proportional to the width of the channel, the crossing number, which is closely related to the number of crossings between two wires in the channel, and the length of nets, which is related to the wire length needed in the routing. We present algorithms for determining the rotations which minimize each of these cost measures. The algorithms can also be used for solving optimal offset problems.
12638#Database systems normally have been designed with the assumption that main memory is too small to hold the entire database. With the decreasing cost and increasing performance of semiconductor memories, future database systems may be constructed that keep most or all of the data for the database in main memory. The challenge in the design of these systems is to provide fast transaction processing, to effectively use multiple processors, and to perform a fast restart after a crash. This correspondence presents a method of performing crash recovery for these systems.
12639#A faster algorithm for finding a maximum independent set in a graph is presented. The algorithm is an improved version of the one by Tarjan and Trojanowski [7]. A technique to further accelerate this algorithm is also described.
12640#Programming teams
12641#Fortelling the future by adaptive modeling
12642#Living with a new mathematical species
12643#The problems of coping without cash
12644#Electronic reading from optical disks
12645#French information needs
12646#A set of output utility functions is described that allows the programmer to direct output to four different output devices (array, file, printer, and terminal) in a device-independent manner. These output functions provide the programmer with the ability to switch output devices without recoding application programs, and the ability to control particular device characteristics. The functions include logic for line counting and (optional) page headings, and are easy to learn and use. Technical notes, examples, function listings, and a discussion of potential extensions are also included. These output functions may usefully be included in the utility library of every micro and mainframe APL installation.
12647#A set of output functions for a utility library
12648#An ability to detect faults in digital circuitry is of increasing importance as a result of the current trend towards ever-greater levels of circuit complexity in VLSI design. This paper describes a system of APL routines that permits the interactive specification of combinational circuits and the discovery of spectra for lines of the (fault-free) circuits. The system can also simulate the spectral behavior of a specified circuit under the condition of "stuck-at" faults on any combination of circuit lines, or under the condition of some internal line considered as if it were another circuit input.
12649#Model reduction via Chebyshev polynomials
12650#Iterative construction of binary lookahead addition trees
12651#The single board computer: a practical alternative to a custom designed microsystem
12652#Comparative implementations of the LMS algorithm
12653#Statistical distributions of image DCT coefficients
12654#Design of optimal quantizers with an entropy constraint
12655#Parameter identification of discrete systems via discrete Lengendre polynomials
12656#Further studies on the matrix approach to the measurement and control problems of synchronous sequential machines—performance evaluation by computer simulation and application of specific heuristics
12657#A similarity-based reasoning model for intelligent interfaces
12658#A fast algorithm for exact convolution of rational sequences by using integer arithmetic only
12659#Remarks and experiments on the construction of respiratory waveforms froms electrocardiographic tracings
12660#Assessment of the maximum frequency components and digital sampling of cardiac Purkinje fiber action potentials
12661#ECG baseline wander reduction using linear phase filters
12662#Computing the skeleton of coronary arteries in cineangiograms
12663#An expert system for postoperative breast cancer therapy
12664#Expert system detection of drug interactions: Results in consecutive inpatients
12665#Multicompartmental analysis of tracer clearance and its application to cerebral blood flow measurement
12666#Computerized estimation of lactate threshold
12667#The use of microcomputers for data management in a large epidemiological survey
12668#Computation of the thermodynamic properties of reactions involving minerals and queous solutions with the aid of the personal computer
12669#A program package for major element data handling and CIPW norm calculation
12670#Quadree: A FORTRAN program to extract the quadtree structure of a raster format multicolored image
12671#Decoding IGBADAT, a world data base for igneous petrology
12672#A new algorithm for object oriented ray tracing
12673#Finding axes of skewed symmetry
12674#Locating neuron boundaries in electron micrograph images using “primal sketch” primitives
12675#Determining motion of image curves from local pattern changes
12676#Efficient planar embedding of trees for VLSI layouts
12677#Picture processing: 1985
12678#A theoretical basis for diffrequency stereo
12679#The image flow constraint equation
12680#Object recognition using oriented model points
12681#Segmentation of textured images using Gibbs random fields
12682#A linear time algorithm with minimum link paths inside a simple polygon
12683#A vectorizer and feature extractor for document recognition
12684#Neighborhood-uniform NLC grammars
12685#Efficient two-dimensional filters using B-spline functions
12686#Theoretical error assessments of curved line digitization schemes on graphic displays
12687#Structure and motion from optical flow under orthographic projection
12688#Calibration of a camera and light source by fitting to a physical model
12689#Algorithms for subpixel registration
12690#Rank algorithms for picture processing
12691#A strong chord property for 4-connected convex digital sets
12692#Introduction to mathematical morphology
12693#Application of morphological transformations to the analysis of two-dimensional electrophoretic gels of biological materials
12694#Grayscale morphology
12695#Automatic screening of cytological specimens
12696#Morphological structuring element decomposition
12697#Iconic indexing using generalized pattern matching techniques
12698#An analytical approach to the determination of planar surface orientation using active-passive image pairs
12699#Edge extraction using entropy operator
12700#Digital straight segments
12701#Computational-geometric methods for polygonal approximations of a curve
12702#On translating a set of objects in 2- and 3-dimensional space
12703#On the application of massively parallel SIMD tree machines to certain intermediate-level vision tasks
12704#Recognition and recovery of the three-dimensional orientation of planar point patterns
12705#Volume/surface octrees for the representation of three-dimensional objects
12706#Digital color reproduction on color television monitors
12707#Analysis of residual stresses in hot-rolled complex beams
12708#Fixed-point algorithms for stationary flow in porous media
12709#A cylindrical tank-foundation-halfspace interaction using an energy approach
12710#Probabilistic finite elements for nonlinear structural dynamics
12711#The variational inequality formulation of a unidirectional gravity-driven free-boundary flow
12712#Dynamic response of 3-D embedded foundations by the boundary element method
12713#Extreme eigenvalues of large sparse matrices by Rayleigh quotient and modified conjugate gradients
12714#Tau-lines: A new hybrid approach to the numerical treatment of crack problems based on the Tau method
12715#Minimal-degree thin triangular plate and shell bending finite elements of order two and four
12716#Natural coordinates for the computer analysis of multibody systems
12717#A digital simulation method for flutter analysis
12718#Hybrid-stress isoparametric elements for moderately thick and thin multilayer plates
12719#A domain method for shape design sensitivity analysis of built-up structures
12720#The development and application of the Gauss nonlinearly constrained optimization method
12721#Automated structural synthesis for nondeterministic loads
12722#An optimal control approach to the design of vibrating elastic-viscoelastic sandwich beams
12723#An active set RQP algorithm for engineering design optimization
12724#Adaptive finite element methods for shape optimization of linearly elastic structures
12725#Structural shape optimization — a survey
12726#Numerical study of a relaxed variational problem from optimal design
12727#Anisotropic continuum models for beamlike lattice trusses
12728#Generation of solution-adaptive computational grids using optimization
12729#On the general rolling contact problem for finite deformations of a viscoelastic cylinder
12730#Proceedings on Graphics Interface '86/Vision Interface '86
12731#Computer graphics and the fashion industry
12732#Some implications of dynamic structural analysis
12733#An encoding scheme for presentation graphics with animation
12734#Kinematic and geometric modelling and animation of robots
12735#Semantic network reasoning for picture composition
12736#Experiences with using Prolog for geometry
12737#The Inference Machine Laboratory: graphic tools for knowledge management
12738#PORTRAY—an image synthesis system
12739#An adaptive subdivision by sliding boundary surfaces for fast ray tracing
12740#Profiling graphic display systems
12741#Using caching and breadth-first search to speed up ray-tracing
12742#What are visual programming, programming by example, and program visualization?
12743#An editing model for generating graphical user interfaces
12744#Automatic generation of graphical user interfaces
12745#A fast algorithm for general raster rotation
12746#A cel-based model for paint systems
12747#Design and experience with a generalized raster toolkit
12748#Graphics tools in Adagio, a robotics multitasking multiprocessor workstation
12749#Exploiting classes in modeling and display software
12750#Applications of world projections
12751#Animating human figures: perspectives and directions
12752#The interactive specification of human animation
12753#Goal directed animation using English motion commands
12754#Speech and expression: a computer solution to face animation
12755#Virya—a motion control editor for kinematic and dynamic animation
12756#Near-real-time control of human figure models
12757#Modeling and animating three-dimensional articulate figures
12758#Constraint-based modeling of three-dimensional shapes
12759#The stochastic modelling of trees
12760#Methods for stochastic spectral synthesis
12761#Interactive 3-D modeling with personal computers
12762#Psychology and the user interface: science is soft at the frontier
12763#Learning graphics programming by direct communication
12764#VLSI and graphics at the pixel level
12765#Hardware assistance for Z-buffer visible surface algorithms
12766#Eliminating the dichotomy between scripting and interaction
12767#Survey of texture mapping
12768#Keyframe-based subactors
12769#The representation of water
12770#Part structure for 3-D sketching
12771#Interfacing image processing and computer graphics systems using an artificial visual system
12772#Connected component labeling using modified linear quadtrees
12773#Asterisk*: an extensible testbed for spline development
12774#Graphical applications of L-systems
12775#Fractals, computers and DNA
12776#A knowledge-based approach to computer vision systems
12777#Integration of remotely sensed data and geographic information systems
12778#Image segmentation based on color and texture gradient
12779#Map/image congruency evaluation knowledge based system
12780#A context based technique for smoothing of digital thematic maps
12781#Principle of visual color coding applied to satellite images
12782#A file organization scheme for polygon data
12783#Mathematical morphology applied to range image processing
12784#Incremental construction of 3-D models from a sequence of framed views: matching partial objects
12785#Image techniques for the identification of depressions and other obstacles in automated guidance of roving robots
12786#A computational theory of 3D shape reconstruction from image contours
12787#Selection and use of image features for segmentation of boundary images
12788#Cortical representation of texture primitives
12789#Speeded phase discrimination: evidence for global to local processing
12790#Correspondence in apparent motion: defining the heuristics
12791#Three processing characteristics of texture discrimination
12792#Parallel architectures for machine vision
12793#Determining displacement fields along contours from image sequences
12794#Edge-only matching techniques in robot vision
12795#A method of learning rules from uncertain data applied to the computer vision problem
12796#Sequential estimation of boundaries in texture images
12797#Detection of pecularities in colour images using local operators
12798#Coupling visual and dynamic features to study handwritten signatures
12799#Detecting glass fibers using computer vision
12800#Reconstruction and display of the retina
12801#Optical character recognition of touching characters
12802#Contour line region segmentation
12803#Canadian information issues
12804#Fifth-generation computers and information processing
12805#A relational bibliographic database
12806#Universal relation theory applied to bibliographic data
12807#The hyperterm model of a bibliographic database
12808#In search of a definition of library and information science
12809#SIGIRD: an integrated bibliographic system
12810#Technological development and the integrated workstation
12811#The integration of an automated office assistant with an extensible relational database
12812#Structured information in the distributed computer environment
12813#FORMAT: connecting Canada's audiovisual information
12814#Proceedings on Office workstations in the home
12815#American Express Company: Project Homebound
12816#Blue Cross/Blue Shield of South Carolina: program for clerical workers
12817#U.S. Army: prototype program for professionals
12818#Mountain Bell: program for managers
12819#Control Data Corporation: alternate work site programs
12820#F International: twenty years' experience in homeworking
12821#Legalities
12822#Effects of work location on motivation
12823#Use and misuse of workstations at home
12824#Technology forecast
12825#Clerical workers and new office technologies
12826#The potential of remote work for professionals
12827#Commentary on office workstations in the home
12828#Proceedings of the International Spring School on Mathematical method of specification and synthesis of software systems '85
12829#Verification of an alternating bit protocol by means of process algebra
12830#Predicative programming revisited
12831#Some problems on inductive inference from positive data
12832#Language and example of knowledge-based programming
12833#Inductive inference hierarchies: probabilistic vs pluralistic strategies
12834#Natural mathematical texts vs. programs
12835#An algebraic framework for inductive program synthesis
12836#Approximation logic
12837#Learning on the basis of a polynomial pattern synthesis algorithm
12838#The proof-checking component for the PLEATS programming system enabling specification of theories
12839#The METANET, a knowledge representation tool based on abstract data types
12840#One more property of array languages
12841#Theoretical aspects of &Sgr;-programming
12842#Decidability in Pratt's process logics
12843#A program synthesis algorithm exemplified
12844#The algorithmic specification method of abstract data types: an overview
12845#Orientation problems on sequences by recursive functions
12846#The solution of discrete problems by means of ternary representation
12847#Formalizing analogical reasoning
12848#Some results in the theory of effective program synthesis: learning by defective information
12849#Deductive normal forms of relations
12850#How fast is program synthesis from examples
12851#On recursive optimizers
12852#Proceedings of the twenty-first annual conference on Computer personnel research
12853#The traditional approaches to system development are being challenged by the improved end-user software that is becoming available for traditional users and systems professionals in their roles as system developers. To meet these challenges there might need to be a fundamental rethink of the traditional approaches at a step back from the ongoing methodological debate that is presently evidencing the profession's response to these challenges. This paper proposes one solution which is the result of an in depth study of methodologies. It proposes an approach that utilises a comprehensive but highly adaptable system development model — which is based on human activities, development roles, a comprehensive set of potential development tasks and a means of establishing and supporting the relationship between all three by software. It is claimed that the approach can be effectively applied in order to respond positively to the changing system development environment.
12854#With the actual penetration of expert systems into the business world, the question is, how can expert systems be used to enhance the existing information systems with more intelligence in usage and operation. This interest is not surprising due to the advancement of the fifth generation of computer technology and avid interest in the field of Artificial Intelligence.This paper presents a conceptual model for analysing complex real world problems. The model, known as the Conceptual Knowledge Model (CKM), is represented by a Graphical — and Formal — Representation. The Graphical Representation consists of three graphs: Conceptual Requirements Graph, Conceptual Behavior Graph, and Conceptual Structure Graph. These graphs are developed by involving the expert in the design process. The graphs are then transformed into first-order predicate logic to represent the logical axioms of a theory, which constitutes the knowledge base of the Expert System.
12855#An exciting new concept is emerging in the area of decision support. This involves the development of computer-based systems for use by groups of people who are jointly responsible for making decisions. Known as “Group Decision Support Systems” (GDSS) they can be useful to committees, review panels, executive board meetings, task forces, and groups of managers who work together on either a regular or one-time basis. The precise design of a GDSS will vary depending on the proximity of group members to one another and the duration of the decision-making session. This paper presents an overview of the GDSS concept.
12856#This paper reports the results of a study of the impact of end user computing strategies, and in particular organizational Information Centre activities, upon an organization's information technology assessment and adoption process. Over 40 managers in ten organizations were interviewed using a discussion questionnaire. The purpose of the interviews was to probe, in a semi-structured way, various aspects of the roles played by these firms' Information Centres in identifying, assessing and absorbing new information technology into the firm. It was found that the impact of Information Centres on technology absorption could be broadly characterized using two constructs: Acceleration (the rate at which new technology is introduced) and Control (the variety of choices made possible to users of the technology). By considering Acceleration and Control together, four different states are identified and characterized. Typical growth patterns through the different states are described, based on actual histories from the companies studied. Also, the major factors that influence end user computing strategies, and the various tactics available for implementing user computing as a function of the various states, are delineated.
12857#This paper provides case studies of thirteen St. Louis based information centers. The objectives of the paper are to describe the responsibilities of information center professionals, to identify tools and resources for end user computing, to describe users and user-developed applications, and to identify policies relating to end user application development. The findings reflect the growth of information center resources and staff in response to rising demand for support of end user computing . Most user-developed applications were queries, reports, and analyses of production data extracts, as well as microcomputer based applications involving personal and departmental data. Informal policies and guidelines for user applications have been defined, but as yet most of these applications have not impacted the application development backlog.
12858#Certification comes of age: end users are now eligible
12859#The growth of end-user computing is one of the most important trends in information systems today. Organizations are increasingly turning to information centers to facilitate and coordinate these activities. This paper reports the results of a field survey of information center managers. It attempts to identify major successes and problems that are faced by these managers. It also aims to define critical success factors for such centers. The paper concludes with recommendations on how firms can apply the results of the study to their own situations.
12860#This paper compares use of mainframe-based, microcomputer-based, and mixed computer-based business graphics in 200 organizations. It compares organizational, and technological environment, motivation for selection and use, functional area use, end users, organizational responsibility and support, application profiles, impediments to increased use, and forecasts for the future. It presents profiles of typical end users for both mainframe and micro computer groups with organizational environments and culture. In so doing, it provides empirical evidence for differing strategies of MIS involvement in the development of business graphics.
12861#It is proposed that organizations better able to exploit information-related opportunities do so because their information systems groups provide a greater number of linking mechanisms through which end-user computing is motivated and facilitated. This study examines this notion. Interviews were held in 21 organizations to determine the extent to which 12 linking mechanisms were being used to facilitate 19 issues. An examination of the findings suggests that while the linking mechanisms are being used, this usage (1) is not yet that extensive and (2) the apparently more effective links are not always those most used.
12862#Development of computer-based applications by end users themselves is a new phenomenon that is gaining rapid acceptance today. A field study of user development of computer-based applications (UDA) was carried out in ten large Canadian business enterprises. A research model representing the key success factors for UDA activities was developed from the available literature. In-depth interviews of users and DP managers in the firms were carried out to evaluate the model. A revised, improved version of the model emerged from those interviews. This paper presents and discusses the two versions of the model.
12863#The use of a usability test laboratory for software products can directly affect products. Error messages, instructions, panel design, and system flow can all be improved when system developers are able to observe users interacting with software products, attempting to solve real-world problems with a system in the process of development. Furthermore, the use of a usability laboratory can have, in addition to this direct effect on the quality of a particular software system, can have a less direct (but perhaps more powerful) impact on procedures within the development organization. Usability testing can raise the level of human factors awareness among developers, while providing an objective arena in which programmers, writers, human factors specialists, and other support personnel can evaluate the usability of application software.
12864#Much of the discussion about the use of personal computers within organizations arises from viewing personal computers and personal computing as the same thing. The focus is on a peripheral issue: the choice between distributed computer hardware and central computer hardware. It is more useful to focus on a very different issue: the difference between organizational computing and personal computing in organizational information systems. The primary problem is that of control; how can centralized information processing organizations ensure that the correct data is used, that it is protected, that the systems developed are what end users need, and that such development represents productive use of computing resources without getting in the way of productive use of computing resources to solve individual users' problems?
12865#Information Requirements Determination (IRD) is presented as a process with obstacles WITHIN individual “users”, AMONG “users”, and BETWEEN “users” and systems developers. A distinction is made between IRD and Information Requirements Analysis (IRA), two labels which are often used interchangeably. The triple-obstacle view of IRD/IRA problems and the distinction between IRD and IRA is suggested as an approach for research into the requirements determination process. A user-oriented IRD tool designed to attack the “within” obstacles is identified as the basis for the authors' current research into how to improve the user's lot in the development of information systems.
12866#A theoretical model is suggested for designing information systems task teams based on a contingency approach using characteristics of the task, the environment and types of people as contingency variables. A fourth variable, systems design phase, is also considered for suggesting differences in the staffing and operations of task teams. The basic assumption is that staffing, ways of operating, ways of reaching decisions, and measures of task team effectiveness will vary during the systems development process.
12867#This study analyzes the influence of sources of applications programs (SAP) on overall computer user satisfaction as determined by multiple regression. The variables, proprietary software packages, vendor customized application programs, and average system, life in months are found to be the most significant variables affecting overall satisfaction whereas, the variables, ready made vendor programs, minicomputer systems, and in house personnel applications have the least significant effect on user satisfaction. An interactive expert system (ES) for SAP is designed, developed and demonstrated in this study.
12868#This study investigates whether work-unit environments differ for information systems (IS) and non-information systems (non-IS) employees. Within the same occupational level, i.e., within clerical, technical-professional, and managerial level personnel, no differences are discovered in the overall work-unit environments of IS and non-IS employees. Speculation is presented suggesting that (1) the management of end-user personnel need not change as they become more involved in performing information systems tasks and (2) IS and non-IS personnel in distributed processing environments should be managed similarly.
12869#User satisfaction has increasingly played an important role in information systems (IS) organizations' effectiveness. Does an IS organization's ability to design and develop increasingly effective systems depend on its maturity? Does maturity depend on bringing in state-of-the-art technology? Is maturity related to the organizational structure of the Data Processing/Management Information Systems (DP/MIS) Unit? Is maturity related to spending increasing amounts of money on IS organizations? The importance of these questions and their answers to DP/MIS managers and users cannot be overemphasized. The research uses a field study of IS users and managers to answer these questions and other related issues. The study shows a weak but significant overall relationship between user satisfaction variables and maturity criteria defined by Nolan [25]. Further research based on the findings of the study is suggested as a means of improving the degree of relationship between maturity criteria and user satisfaction variables.
12870#User Information Satisfaction (UIS) has emerged as the major surrogate for the effectiveness of Management Information Systems (MIS) in organizations. While the concepts of “information” and “satisfaction” have been researched extensively, we argue that our understanding of the MIS user is inadequate. This inadequacy is compounded by the rapidly changing information technology which has tended to blur the traditional distinctions between users and non-users and is rendering obsolete the implicit assumption of the functionally homogeneous user underlying a wide spectrum of studies. Based on a detailed survey of the literature, we propose a typology of users consisting of three categories: direct user, autonomous user, and indirect user. Direct user is someone who interfaces directly with the computer-based information systems, working with one or more systems, largely designed, implemented, and maintained by the MIS/Data Processing (DP) department or receives periodic computer reports. Autonomous user develops and uses simple systems and/or application programs he or she needs, either individually or in small groups of users. This class of users possesses some amount of computing skills and makes use of a variety of tools such as general purpose, commercial software, user-friendly operating systems, personal computers (PCs), workstations and higher level programming languages. The third category of users—indirect users—are typically managers in the higher levels of the organizational hierarchy whose interface with the computer is mediated by staff analysts or assistants. A certain degree of overlap across the categories is to be expected. The implications of the typology for UIS research in particular and MIS research and practice in general are discussed.
12871#Office automation may be the ultimate example of end-user computing in action. It represents the usage of information systems by the principal users of the system's outputs or by their immediate support staffs. The purpose of this paper is to present a model of office automation with a focus on its impact on the end-user. Consideration is given to both macro and micro organizational perspectives. Results of a validation process of the model with focus group of experienced end-users representing twelve large organizations are presented and discussed. Organizational and societal implications are drawn.
12872#This paper presents a program development system that enables casual, non-professional programmers to be literate in programming. The system combines the features of several existing tools into one unifying environment, enabling the production of programs to be constructed in one pass. This eliminates the design-code-edit-compile-run cycles and their resulting environment changes.
12873#Nolan's stage hypothesis on the growth of data processing provides a popular framework for describing the typical development patterns of organizational information systems. Up until now, a few limited tests have been published to ensure formally the reliability of the stage model. We report on an empirical study of 130 major Finnish edp user organizations where the aim was to test the power of Nolan's stage model. Several of Nolan's benchmarks were used as measures of the stage of development but special attention was given to the role of end-users in systems development. Not only were the actual stages of development measured but also estimates of the future changes in the major benchmarks were compared for typical groups of organizations.Our tests show that there are significant differences both in the stage and speed of development between organizations even with the same experience in computing. We have been able to assure that Nolan's model is a good descriptor of the average patterns of changes in data processing but it is not able to predict the development. The Nolan model seems to be confined within the limits of its own historical background.
12874#This paper examines methodologies for large scale system development. By “large scale” we mean system projects carried out by teams as compared to a single person. System development is taken to mean the whole range of activities from (some one, some how) deciding a system is needed to eventually (some one, some how) deciding to scrap the system. The typical organizational setting we are concerned with would be a large corporation or government agency with a systems staff numbering in the hundreds or thousands. Existing life cycle methodologies have a number of commonalities. The rather poor results from use of these methods is traced to a basic flaw in all of the methods. A number of common results stemming from this flaw are discussed. The solution to the problem is conceptually simple but somewhat more difficult to implement. Implementation schemes for the solution are discussed and our particular incarnation of a solution is briefly presented.
12875#A growing number of end-users are developing their own application systems. The potential benefits of application development by end-users include: enhanced productivity of professionals and white-collar workers, creating user-friendly applications and overcoming the implementation problems by transferring the process to the end-users. In the enthusiasm to take advantage of these benefits, it is important not to overlook the costs and risks of low quality end-user developed applications. This paper focuses on quality issues of end-user created applications and makes specific recommendations for quality control.
12876#The contribution of the European information technology industry to the evolution of standardization policy in Europe—a brief history
12877#Putting standards to work
12878#The upper layers of the ISO/OSI reference model (part I)
12879#A circuit for sharing peripherals and instruments with the IEEE-488 interface between two or more microcomputers
12880#Integrated services digital networks—a major challenge for international standardization
12881#The complete Commodore machine code programming course
12882#PDP-11 software source book (3rd ed.)
12883#Programming in VAX-BASIC
12884#IEEE trial-use standard specifications for microprocessor operating systems interfaces
12885#Creative modelling with Lotus 1-2-3
12886#MC68851: paged memory management unit user's manual
12887#M68000: 8-/16-/32-bit microprocessors: programmer's reference manual (5th ed.)
12888#M68000: 16/32-bit microprocessor: programmer's reference manual (4th ed.)
12889#ACM Turing Award lectures: the first twenty years (1966-1985)
12890#Actuarial science
12891#The bilateral Bergman shift
12892#Hadamard matrices and their applications
12893#Essentials of structured BASIC
12894#Mastering Microsoft works
12895#Computerized numerical analysis
12896#A unified theory of nonlinear operator and evolution equations with applications new approach to nonlinear partial differential equations
12897#Amiga ROM kernel reference manual: libraries and devices
12898#Characterizations of inner product spaces
12899#Abbreviations of data processing terms: A-Z, covering all areas of data and information processing: German, English, French, Spanish and Italian abbreviations
12900#C for programmers
12901#Analysis and algorithms of optimization problems
12902#dBase III tips and traps
12903#Essential LISP
12904#Windows: the official guide to Microsoft's operating environment
12905#Quadratic forms and Hecke operators
12906#High resolution computer graphics in FORTRAN 77
12907#MS-DOS developer's guide (1st ed.)
12908#State space modeling of time series
12909#Symposium sponsored by IBM Deutschland on Accurate scientific computations
12910#Proceedings of the symposium on order restricted statistical inference on Advances in order restricted statistical inferences
12911#Symposia held at the Univ. of Western Ontario on Advances in the statistical sciences: festschrift in honor of Professor V. M. Jo
12912#Psychology and the user interface: science is soft at the frontier
12913#Knowledge engineering technology and its application to factory automation
12914#Knowledge-based process diagnosis system for semiconductor manufacturing
12915#Knowledge processing for mobile robots
12916#Development of knowledge-based method for three-dimensional pipe route planning
12917#Design of an expert system for computer room layout
12918#FA System for automatic component insertion on printed circuit boards
12919#A laser-applied three-dimensional profile measuring system
12920#Recent advanced FA controllers
12921#“FA-BASIC”: A universal language for controlling factory automation cells
12922#LAN-Based real-time shop floor control system
12923#Integrated and distributed production control system for daily part manufacturing
12924#Factory automation system for elevator design structure parts
12925#Hitachi-IP High speed image processor
12926#Spectral methods for principal components analysis of event-related brain potentials
12927#Programs to produce high quality dichotic tapes for central auditory testing
12928#Spectral and cross-spectral analysis of heart rate and arterial blood pressure variability signals
12929#Anatomical modeling with computer-aided design
12930#An investigation of data entry methods with a personal computer
12931#Appraisal of computerized medical histories: Comparisons between computerized and conventional records
12932#Parallel algorithms for the analysis of two-dimensional electrophoresis gels
12933#Estimation of growth curves from longitudinal data collected at irregular time intervals
12934#Small sample properties of some parametric bioassay estimators of the LD90
12935#Computerized history taking for training medical students
12936#Some methods of information evaluation of scientific results
12937#Semantic manipulations in expert systems
12938#Belief structures, possibility theory and decomposable confidence measures on finite sets
12939#Heuristic search with global and local heuristics
12940#Automatic program synthesis using heuristics and interaction
12941#An efficient synthesis of image matching algorithms
12942#The computation of the convex hull of a simple polygon in linear time
12943#Wire routing on a parallel computer
12944#Proceedings on International conference on database theory
12945#Logic programming and parallel complexity
12946#The generalized counting method for recursive logic queries
12947#Restructuring of complex objects and office forms
12948#Set containment inference
12949#A domain theoretic approach to higher-order relations
12950#On the desirability of gamma-acyclic BCNF database schemes
12951#Update semantics under the domain closure assumption
12952#Unsolvable problems related to the view integration approach
12953#Horizontal decompositions based on functional-dependency-set-implications
12954#Update serializability in locking
12955#Filtering data flow in deductive databases
12956#Multidimensional order preserving linear hashing with partial expansions
12957#Split-freedom and MVD-intersection: a new characterization of multivalued dependencies having conflict-free covers
12958#Towards online schedulers based on pre-analysis locking
12959#Query processing in incomplete logical databases
12960#Introduction to the theory of nested transactions
12961#Entity-relationship consistency for relational schemas
12962#Modelling large bases of categorical data with acyclic schemes
12963#Some extensions to the closed world assumption in databases
12964#Expedient stochastic move-to-front and optimal stochastic move-to-rear list organizing strategies
12965#The cost of locking
12966#Theoretical foundation of algebraic optimization utilizing unnormalized relations
12967#A polynomial-time join dependency implication algorithm for unary multi-valued dependencies
12968#Updating logical databases containing null values
12969#A new characterization of distributed deadlock in databases
12970#Proceedings of the 2nd international conference, AAECC-2 on Applied algebra, algorithmics and error-correcting codes
12971#On associative algebras of minimal rank
12972#Construction of primitive idempotents for n variable codes
12973#Multivariate polynomials in coding theory
12974#Enumeration of self dual 2k circulant codes
12975#Codes, groups and invariants
12976#On a conjecture concerning coverings of Hamming space
12977#An improved upper bound on covering radius
12978#Association schemes and difference sets derived on two weight codes
12979#Automorphisms of two families of extended non binary cyclic Goppa codes
12980#Some quasi-perfect cyclic codes
12981#Explicit Kerdock codes over GF(2)
12982#A class of adapted 2-corrector codes for information systems
12983#LOUSTICC simulation software: experimental results of coding systems
12984#An algorithm of complete decoding of double-error-correcting Goppa codes
12985#On the number of divisors of a polynomial over GF(2)
12986#Multivariate polynomial factoring and detection of true factors
12987#Discriminants and the irreducibility of a class of polynomials
12988#Computational aspects of reduction strategies to construct resolutions of monomial ideals
12989#Designs arising from symplectic geometry
12990#Distance-transitive graphs and the problem of maximal subgroups of symmetric groups
12991#Can a fast signature scheme without secret key be secure?
12992#Manipulation of recurrence relations in computer algebra
12993#Some design principles for a mathematical knowledge representation system: a new approach to scientific calculation
12994#The evolution of computer based learning software design: computer assisted teaching unit experience
12995#Learner control and educational advice in computer based learning: the study-station concept
12996#Computer-based teaching for undergraduates: old problems and new possibilities
12997#A computer auditing course
12998#Student opinion of tutorial CAL
12999#A sample survey of attitudes to computer studies
13000#Predicting computer programming skill
13001#A microcomputer application for student flows and records in a college of business
13002#Compulab—computing for the physical sciences teaching laboratory
13003#On counting in the game of life
13004#Signal processing via COSHAD transform
13005#Solution of a scaled system by shifted Legendre series representation
13006#Comments on “On the computation and the effectiveness of discrete sine transform”
13007#The area-time complexity of a VLSI digital filter using residue number systems
13008#Terminal buffer memory analysis in resource sharing local computer networks
13009#Test generation for combinational logic circuits using information theory
13010#Sign detection in residue code
13011#Performance evaluation of a distributed concurrency control algorithm
13012#Engineering information systems (Panel session): builders and designers perspective
13013#In order to represent inheritance, several recent designs for database programming languages have made use of class construct, which can be thought of as a restricted data type with an associated set of instances. Moreover, these classes are persistent they survive from one program invocation to another. This paper examines whether it is necessary to the together type, extent and persistence in order to model inheritance and suggests that they may be separated to provide more general database programming languages. In particular we shall see that it is possible to assign a generic data type to a function that extracts all the objects of a given type in the database so that the class hierarchy can be derived from the type hierarchy. We shall also examine object-level inheritance and its relationship to data types for relational databases. A final section examines how the various forms of persistence interact with inheritance at both object and type level.
13014#This paper surveys and compares various strategies for processing logic queries in relational databases. The survey and comparison is limited to the case of Horn Clauses with evaluable predicates but without function symbols. The paper is organized in three parts. In the first part, we introduce the main concepts and definitions. In the second, we describe the various strategies. For each strategy, we give its main characteristics, its application range and a detailed description. We also give an example of a query evaluation. The third part of the paper compares the strategies on performance grounds. We first present a set of sample rules and queries which are used for the performance comparisons, and then we characterize the data. Finally, we give an analytical solution for each query/rule system. Cost curves are plotted for specific configurations of the data.
13015#This article presents an algorithm to refresh the contents of database snapshots. A database snapshot is a read-only table whose contents are extracted from other tables in the database. The snapshot contents can be periodically refreshed to reflect the current state of the database. Snapshots are useful in many applications as a cost effective substitute for replicated data in a distributed database system.When the snapshot contents are a simple restriction and projection of a single base table, differential refresh techniques can reduce the message and update costs of the snapshot refresh operation. The algorithm presented annotates the base table to detect the changes which must be applied to the snapshot table during snapshot refresh. The cost of maintaining the base table annotations is minimal and the amount of data transmitted during snapshot refresh is close to optimal in most circumstances.
13016#Query processing can be sped up by keeping frequently accessed users' views materialized. However, the need to access base relations in response to queries can be avoided only if the materialized view is adequately maintained. We propose a method in which all database updates to base relations are first filtered to remove from consideration those that cannot possibly affect the view. The conditions given for the detection of updates of this type, called irrelevant updates, are necessary and sufficient and are independent of the database state. For the remaining database updates, a differential algorithm can be applied to re-evaluate the view expression. The algorithm proposed exploits the knowledge provided by both the view definition expression and the database update operations.
13017#There are many examples of actions on abstract data types which can be correctly implemented with nonserializable and nonrecoverable schedules of reads and writes. We examine a model of multiple layers of abstraction that explains this phenomenon and suggests an approach to building layered systems with transaction oriented synchronization and roll back. Our model may make it easier to provide the high data integrity of reliable database transaction processing in a broader class of information systems. We concentrate on the recovery aspects here, a technical report [Moss et al 85] has a more complete discussion of concurrency control.
13018#Few database query optimizer models have been validated against actual performance. This paper presents the methodology and results of a thorough validation of the optimizer and evaluation of the performance of the experimental distributed relational database management system R*, which inherited and extended to a distributed environment the optimization algorithms of System R. Optimizer estimated costs and actual R* resources consumed were written to database tables using new SQL commands, permitting automated control from SQL application programs of test data collection and reduction. A number of tests were run over a wide variety of dynamically-created test databases, SQL queries, and system parameters. The results for single-table access, sorting, and local 2-table joins are reported here. The tests confirmed the accuracy of the majority of the I/O cost model, the significant contribution of CPU cost to total cost, and the need to model CPU cost in more detail than was done in System R. The R* optimizer now retains cost components separately and estimates the number of CPU instructions, including those for applying different kinds of predicates. The sensitivity of I/O cost to buffer space motivated the development of more detailed models of buffer utilization unclustered index scans and nested-loop joins often benefit from pages remaining in the buffers, whereas concurrent scans of the data pages and the index pages for multiple tables during joins compete for buffer share. Without an index on the join column of the inner table, the optimizer correctly avoids the nested-loop join, confirming the need for merge-scan joins. When the join column of the inner is indexed, the optimizer overestimates the cost of the nested-loop join, whose actual performance is very sensitive to three parameters that are extremely difficult to estimate (1) the join (result) cardinality, (2) the outer table's cardinality, and (3) the number of buffer pages available to store the inner table. Suggestions are given for improved database statistics, prefetch and page replacement strategies for the buffer manager, and the use of temporary indexes and Bloom filters (hashed semijoins) to reduce access of unneeded data.
13019#A prototype of a temporal database management system was built by extending Ingres. It supports the temporal query language TQuel, a superset of Quel, handling four types of database static, rollback, historical and temporal. A benchmark set of queries was run to study the performance of the prototype on the four types of databases. We analyze the results of the benchmark, and identify major factors that have the greatest impact on the performance of the system. We also discuss several mechanisms to address the performance bottlenecks we encountered.
13020#Most previous work on query optimization in distributed database systems has focused on finding optimal or near-optimal processing plans based solely on static system characteristics, and few researchers have addressed the problem of copy selection when data is replicated. This paper describes a new approach to query processing for locally distributed database systems. Our approach uses load information to select the processing site(s) for a query, dynamically choosing from among those sites that have copies of relations referenced by the query. Query compilation is used to produce a statically-optimized logical plan for the query, and then a dynamic optimization phase converts this logical plan into an executable physical plan at runtime. This paper motivates the separation of static and dynamic optimization, presents algorithms for the various phases of the optimization process, and describes a simulation study that was undertaken to investigate the performance of this approach. Our simulation results indicate that load-balanced query processing can provide improvements in both query response times and overall system throughput as compared to schemes where execution sites are either statistically or randomly selected.
13021#A database token is a value of either the data or the metadata. Usually, such tokens are combined with formal language constructs to form queries. In this paper we show how a given set of tokens may be completed to a proper query. This process provides a useful means of communication between naive users and databases, allowing them to express simple requests by listing several tokens. As the inferred query is always shown to the user, this process has a side effect of instructing the user in the proper use of the query language. The method is described and demonstrated with relational databases, but its principles may be implemented with other databases as well.
13022#Even though many of the essential notions of hypertext were first contained in the description of a “memex,” written by Vannevar Bush in 1945 [Bus45], there are today only a few scattered implementations of hypertext, let alone any serious use of it in a CAD environment. In what follows, we describe what hypertext is all about. We describe a prototype hypertext system, named Neptune, that we have built. We show how it is useful, especially its broad applicability to CAD.
13023#Improvements both in technology and in user-oriented software have shown the feasibility of new kinds of non-procedural languages. However, interaction between end-user and data should rely more and more on graphical languages and, particularly, on 'iconic” languages. In the following we review and analyze the forces which are at the origin of changes in the user environment. We give the main specifications of an iconic interface and a command language based on icons. Examples are given in a medical environment.
13024#In the past few years we have seen in the literature a number of proposals for benchmarks to be used in measuring the performance of database management and transaction processing systems. The TP1 benchmark [Anon et al 1985] and the Wisconsin benchmark [Bitton et al 1983], [Boral and DeWitt 1984], and [Bitton and Turbyfill 1985] have been used to benchmark several systems. Other benchmarks have also been proposed.The TP1 benchmark actually consists of three different benchmarks Debit-Credit, Scan, and Sort. It is oriented towards transaction processing systems. Each of the benchmarks consists of a single transaction type and operates on a large database — around 10 GBytes. The database consists of artificial data but is modeled around data maintained by a large bank.The Debit-Credit benchmark consists of a transaction that reads and updates a small number (about 4) of random records. It imposes stringent response time and throughput requirements on the system.The Scan benchmark consists of a COBOL program that exercises the system by executing 1,000 scan transactions each of which accesses and updates 1,000 records in a sequentially organized file.Finally, the Sort benchmark sorts 1M records of 100 bytes each.Each of the benchmarks stresses different aspects of the system. Each requires different amount of CPU, communication, and I/O cycles. In addition to the diversity of system resource requirements the benchmark methodology described in [Anon et al 1985] also requires that the cost of the system be calculated. Thus, the final measure one obtains from running the TP1 benchmark is $K/TPS.Whereas TP1 is oriented towards transaction processing the Wisconsin benchmark was conceived for the purpose of measuring the performance of relational database systems. It consists of two parts a single user benchmark in which a suite of approximately 30 different queries are used to obtain response time measures in standalone mode (described in [Bitton et al 1983], and a multi-user benchmark in which several queries of varying complexity are used to determine the response time and throughput behavior under a variety of conditions (one version of the multi-user benchmark is described in [Boral and DeWitt 1984] and a second version in [Bitton and Turbyfill 1985]).The test database consists of a number of relations of varying sizes. The relations are generated according to statistical distributions and do not model any real world data. Users of the benchmark can modify the database generator routines to adapt the database characteristics so that they are more representative of their application.It appears as though both the TP1 and the Wisconsin benchmark have the potential of becoming de facto standard benchmarks, in their respective areas, to be used in a variety of ways. For example, a vendor could use the benchmarks to stress test a system under development. Another use for a vendor is in establishing a particular rating for a system (equivalent MIPS Whetstones, etc. for mainframes). Finally, a user can use a benchmark to compare several systems before purchasing one.The purpose of this panel is to discuss the use of benchmarking for measuring the performance of transaction processing systems and database management systems in general and the use of the TP1 and Wisconsin benchmarks in particular.The panelists have been chosen so that we have a representation of experts in the particular benchmarks (Gawlick) and DeWitt), a benchmark “consumer” (Hawthorn), and a “performance expert” — someone who understands benchmarking as a science/art (Brice).The panelists will address the following issues (as well as others raised by the audience)What are the strengths and weaknesses of the TP1 and Wisconsin benchmarks?Is benchmarking a good technique for measuring the performance of data management and transaction processing systems?What can these benchmarks tell us about a system and what can they not tell us about it?
13025#A message passing framework for logical query evaluation
13026#Many capabilities that are needed for recursive applications in engineering and project management are not well supported by the usual formulations of recursion. We identify a class of recursions called “traversal recursions” (which model traversals of a directed graph) that have two important properties they can supply the necessary capabilities and efficient processing algorithms have been defined for them. First we present a taxonomy of traversal recursions based on properties of the recursion on graph structure and on unusual types of metadata. This taxonomy is exploited to identify solvable recursions and to select an execution algorithm. We show how graph traversal can sometimes outperform the more general iteration algorithm. Finally we show how a conventional query optimizer architecture can be extended to handle recursive queries and views.
13027#The authors introduce a new method to compile queries referencing recursively defined predicates. This method is based on an interpretation of the query and the relations as functions which map one column of a relation to another column. It is shown that a large class of queries with associated recursive rules, including mutually recursive rules, can be computed as the limit of a series of functions. Typical cases of series of functions are given and solved. The solutions lend themselves towards either extended relational algebra or SQL optimized programs to compute the recursive query answers. Examples of applications are given.
13028#New implementation techniques and new capabilities for database systems are being developed and proposed at a rapid rate. Novel file structures and improved algorithms for query optimization, buffer and recovery management, and transaction management have the potential of realizing significant gains in DBMS performance. The proposed integration of design objects, voice, text, rules, vector graphics, and images into databases promises exciting new capabilities for DBMSs. To accommodate advances in database technology and to support new classes of database applications, DBMSs must be extensible (i.e., customizable).To achieve extensibility forces a fundamental rethinking about how DBMSs are built, and how special-purpose features can be integrated into a DBMS with little effort and expense. Customizing DBMSs implies the availability of extensible data models, to allow for the introduction of new object types and operations, and extensible storage structures, to take advantage of special properties of stored data or operations to enhance performance.Although research on extensible DBMSs is still in its infancy, a fundamental concept underlying their construction is now evident. This is the standardization of interfaces and the plug-compatibility of modules. An extensible DBMS will be a 'software bus' whereby new modules (and hence new DBMS capabilities) can be added, exchanged, or removed by plugging or unplugging modules. Extensible DBMSs will thus rely on extensive software libraries, where new modules can be added as needed. Furthermore, changes to DBMSs can be made in months rather than years, and the reinvention of established technology is kept to a minimum because of the reusability of modules.The perception of DBMSs as monolithic entities that are difficult to modify will change as extensible DBMS technology becomes better understood. The use of database systems will not change, the ANSI/SPARC roles of database users, who write and execute transactions, and the database administrator (DBA), who designs and writes database schemas, will remain. Extensible DBMSs will require the introduction of an additional party, the database architecture administrator (DDA), who is responsible for the construction and customization of a DBMS.A growing number of researchers are developing extensible DBMSs. The purpose of this panel is to explain and discuss some of the approaches that are now being taken (and those that can be taken), and to survey the problems that confront extensible database technology. Descriptions of the systems and research represented at this panel are given in the following sections.
13029#In some recently proposed extensions to relational database systems as well as in deductive databases, a database system is presented with a collection of queries to process instead of just one. It is an interesting problem then, to come up with algorithms that process these queries together instead of one query at a time. We examine the problem of multiple (global) query optimization in this paper. A hierarchy of algorithms that can be used for global query optimization is exhibited and analyzed. These algorithms range from an arbitrary serial execution without any sharing of common results among the queries to an exhaustive search of all possible ways to process all queries.
13030#Over the last decade many techniques for optimizing relational queries have been developed. However, the problem of translating these set-oriented query specifications into other forms for efficient execution has received little attention.This paper presents an algorithm that translates algebra-based query specifications into iterative programs for an efficient execution. While the source level operates on sets of tuples, the generated programs manipulate tuples as their basic objects. The algorithm incorporates techniques which have been developed in the areas of functional programming and program transformation.
13031#In this paper a method is proposed how to achieve response times of main memory database systems without keeping the whole database in main memory. The method was originally developed for real-time systems in manufacturing automation, but it is applicable in environments where canned transactions interact with databases rather than people performing free transactions. The main idea is to preanalyse canned transactions in order to extract knowledge about their local access behaviour. This knowledge is used by the runtime system of the database when the transaction is started. Concepts for modules doing the preanalysis and the runtime tasks are described in detail. Furthermore a database architecture is developed incorporating these new components.
13032#Multiattribute hashing and its variations have been proposed for partial match and range queries in the past. The main idea is that each record yields a bitstring @@@@ (“record signature”), according to the values of its attributes. The binary value (@@@@)2 of this string decides the bucket that the record is stored. In this paper we propose to use Gray codes instead of binary codes, in order to map record signatures to buckets. In Gray codes, successive codewords differ in the value of exactly one bit position, thus, successive buckets hold records with similar record signatures. The proposed method achieves better clustering of similar records and avoids some of the (expensive) random disk accesses, replacing them with sequential ones. We develop a mathematical model, derive formulas giving the average performance of both methods and show that the proposed method achieves 0% - 50% relative savings over the binary codes. We also discuss how Gray codes could be applied to some retrieval methods designed for range queries, such as the grid file [Nievergelt84a] and the approach based on the so-called z-ordering [Orenstein84a].
13033#Most previous work in the area of main memory database systems has focused on the problem of developing query processing techniques that work well with a very large buffer pool. In this paper, we address query processing issues for memory resident relational databases, an environment with a very different set of costs and priorities. We present an architecture for a main memory DBMS, discussing the ways in which a memory resident database differs from a disk-based database. We then address the problem of processing relational queries in this architecture, considering alternative algorithms for selection, projection, and join operations and studying their performance. We show that a new index structure, the T Tree, works well for selection and join processing in memory resident databases. We also show that hashing methods work well for processing projections and joins, and that an old join method, sort-merge, still has a place in main memory.
13034#Consider a file which arranges records in sequential order, and stores them with possible empty spaces in M consecutive pages of memory. We develop an insertion-deletion algorithm which runs in a worst-case time approximately proportional to log2M divided by the page-size when the set of manipulated records has cardinality O(M).
13035#This paper describes the rule base management strategy of an expert system environment. The environment includes a set of integrated tools which facilitate acquisition, manipulation and maintenance of knowledge. The rule base management component of the system, called RBM, assists these tasks by organizing global semantic information within the rule base. RBM extracts this semantic information from the texts included in “rule structures” and builds a semantic network of the concepts found in the rule base. The rule base is then divided into rulesets which are clusters of rules that refer to the same atomic concept. Construction of this meta knowledge is achieved through a keyword matching mechanism. The paper includes a brief description of the RBM system, the dictionary it uses for building meta-level knowledge, and its keyword matching technique.
13036#We study here automated deduction in databases in the presence of various types of inference rules of the form of Horn Clauses with Skolem functions. These inference rules are typical for databases with incomplete information. We demonstrate a number of results related to processing of conjunctive queries for different types of database intensions. In particular, we show that when a database intension is built from possibly cyclic inclusion dependencies and view definitions any conjunctive query can be translated to the an equivalent form which can be evaluated directly over the database extension (disregarding inference rules). We also demonstrate that the complexity of query processing significantly grows when we mix incomplete information with recursive rules. In particular, we demonstrate here that even the power of least fixpoint extension of first order logic may be not sufficient to process queries in the presence of incomplete data and recursive rules. The same is demonstrated in case disjunctive information is allowed in the database.
13037#A rule-based object/task modelling approach is proposed which is characterized by specifying object behaviors and domain rules in terms of object-oriented logic programming, and specifying tasks and meta-rules in terms of network-oriented formalism. In addition the concepts of associations, virtual objects, multiple level integrity control and net expressions are introduced. The object-oriented logic programming system is extended for supporting the semantic modelling, and an explicit control knowledge representation mechanism is developed. This approach may be viewed as a step to the integration of object-oriented programming, logic programming, semantic modelling and event modelling, and to the combination of forward chaining and backward chaining techniques. Therefore, it can provide complementary benefits in deductive query support, integrity control, explicit control knowledge representation and intelligent user interface, and enhance the flexibility and extendibility of knowledge based systems to accommodate applications in multiple domains, towards a generalized, rule-based management of data, action and operational schemes. This approach is being designed and partially implemented on top of System C [Chen 85b] on a VAX computer.
13038#Panel: user interfaces and database management systems
13039#Large multimedia data bases become feasible due to recent advances in hardware technology. A very important component of multimedia data base management systems will be the presentation manager which will be responsible for effective multimedia presentation and browsing on the screen of workstations.In this paper we present the functions provided for multimedia presentation and browsing in MINOS, a multimedia information system. The presentation and browsing capabilities provided make effective use of the capabilities of a modern workstation to increase the man-machine communication bandwidth. We regard voice as an important means of communication. Symmetric capabilities for text and voice browsing are provided.
13040#This paper identifies data modelling and data access and sharing requirements which multimedia applications impose on a database system. It shows the capabilities of an object-based data model and indicates extensions which are needed to meet the data modelling aspects of these requirements. A logical implementation of the operations on the model is described. The model generalizes the notions of instantiation and generalization in the standard object-oriented paradigm, and augments it with the notions of aggregation and relationships which are specialized for a multimedia application environment. Objects may exist in aggregation hierarchies which provide the capability to integrate diverse types of multimedia information such as text, sound, bit-mapped images, and complex graphics drawings. Objects may also be linked through other user-defined relationships to capture such application functions as voice annotation and referencing of one document by another. Using this model, the semantics of aggregation and relationships in a multimedia application environment can be understood and efficiently supported by a database system.
13041#DBMSs must offer spatial query processing capabilities to meet the needs of applications such as cartography, geographic information processing and CAD. Many data structures and algorithms that process grid representations of spatial data have appeared in the literature. We unify much of this work by identifying common principles and distilling them into a small set of constructs. (Published data structures and algorithms can be derived as special cases.) We show how these constructs can be supported with only minor modifications to current DBMS implementations. The ideas are demonstrated in the context of the range query problem. Analytical and experimental evidence indicates that performance of the derived solution is very good (e.g., comparable to performance of the kd tree.)
13042#Panel: The effect of large main memory on database systems
13043#This paper presents the preliminary design of a new database management system, called POSTGRES, that is the successor to the INGRES relational database system. The main design goals of the new system are toprovide better support for complex objects,provide user extendibility for data types, operators and access methods,provide facilities for active databases (i.e., alerters and triggers) and inferencing including forward- and backward-chaining,simplify the DBMS code for crash recovery,produce a design that can take advantage of optical disks, workstations composed of multiple tightly-coupled processors, and custom designed VLSI chips, andmake as few changes as possible (preferably none) to the relational model.The paper describes the query language, programming language interface, system architecture, query processing strategy, and storage system for the new system.
13044#Recently, extensions for relational database management systems (DBMS) have been proposed to support also hierarchical structures (complex objects). These extensions have been mainly implemented on top of an existing DBMS. Such an approach leads to many disadvantages not only from the conceptual point of view but also from performance aspects. Thus paper reports on a 3-year effort to design and prototype a DBMS to support a generalized relational data model, called extended NF2 (Non First Normal Form) data model which treats flat relations, lists, and hierarchical structures in a uniform way. The logical data model, a language for this model, and alternatives for storage structures to implement generalized relations are presented and discussed.
13045#Educe is a logic programming system for handling large knowledge bases. It was constructed by fully integrating the logic programming language Prolog and the relational data base management system Ingres. Educe uses a hybrid strategy for the evaluation of queries. This strategy is based on two contrasting strategies. The strategy known as sets retrieval, transforms recursive and non-recursive queries into a form suitable for evaluation by a relational data base management system. The other strategy, known as one-tuple-at-a time, evaluates queries by imitating the evaluation strategy of the programming language Prolog. In earlier versions of Educe, users selected the strategy by using two different query languages. In order to remove this responsibility from the user, algorithms to map expressions from either of the languages into the other were implemented and added to Educe. This paper briefly reviews the implementation of both evaluators and the mappings compares the basic strategies of evaluation, and then proceeds to explain Educe's own strategy.
13046#We describe a semantic object-oriented data model for representing how a complex design database evolves over time. Structural relationships, introduced by the data management system, are imposed on the objects created by existing CAD tools. The relationships supported by the model are (1) version histories, (2) time-varying configurations, and (3) equivalences among objects of different types. We describe mechanisms for (1) identifying current versions, (2) supporting dynamic configuration binding, and (3) verifying equivalence relationships. The data model is being implemented in a Version Server, under development at the University of California, Berkeley.
13047#This paper presents a methodology for the stepwise specification of dynamic database behaviour. A conceptual schema is described in three levels: data, objects and transactions. To determine which sequences of database states are “admissible”, integrity constraints on objects are given in temporal logic. Transactions are specified by pre/postconditions to produce “executable” state sequences. In order to guarantee that executable state sequences already become admissible, integrity constraints are completely transformed into additional pre/postconditions. We introduce general rules for these transformations. Thus, schema specifications can be refined and simplified systematically.
13048#The design of an appropriate conceptual database scheme is one of the most difficult tasks in usual database applications. Especially, the design of a common global database scheme for many different user groups requires a great amount of effort and skill, because the desired scheme should fit a great variety of requirements and expectations. Here, view integration is a natural method that should help to manage the complexity of such a design problem. For each user group the requirements and expectations are separately collected and specified as views, that are subsequently integrated into a global scheme supporting all those different views.In this paper, we carefully develop a formal model, clarifying many notions and concepts, related to the view integration method. This formal model serves as a theoretical basis of our integration approach that uses equivalence preserving, local scheme transformations as the main integration operations.
13049#Proceedings of the 1986 ACM SIGMOD international conference on Management of data
13050#Computer on guard]
13051#A simple windowing system, part 2: implementation
13052#Build the Emulo-8
13053#Making UNIX secure
13054#Data design
13055#Programming insight: DRAGON
13056#A micro-based supercomputer
13057#Computer approximations
13058#The inversion of large matrices
13059#The Runge-Kutta methods
13060#The ATOMCC toolbox
13061#Semiconductor memory
13062#Jumping on the MAP bandwagon: how soon and how far
13063#Floppy disk controllers feature some important extras
13064#GaAs pushes bit slice to new performance levels
13065#Hardware advances fuel graphics standards controversy
13066#Testability system reduces scan path penalty
13067#Personal computers expand in functionality and applications
13068#DSP tackles floating-point arithmetic
13069#Single chip combines bit slice and EPROM
13070#Prototype verification completes ASIC design
13071#Proceedings of the conference on Computing in high energy physics
13072#Trends in computing for HEP
13073#New architectures
13074#Research issues in distributed operating systems
13075#Trends in languages for embedded systems
13076#Real-time systems architectures
13077#Trends in wide area networks
13078#Barriers in HEP networking
13079#Two recent supercomputers, the CRAY-2 and the SX-2
13080#Alternatives in high volume HEP computing
13081#Data storage—where do we store terabytes of data?
13082#Requirements for databases in HEP
13083#Future plans for HEP computing in the U.S.
13084#Status of networking for high energy physics in the United States
13085#Possible solutions for HEP networking in Europe
13086#Satellite communications: possibilities and problems
13087#Computer communications at CERN
13088#GIFT: an HEP project for file transfer
13089#Wide-area networking for high energy physics in Brussels and Antwerp
13090#“Y” a distributed resource sharing system in a nuclear research environment
13091#Overview of networking at Daresbury Laboratory
13092#A LAN with real-time facilities based on OSI concepts
13093#The equipment bus: a very simple network to interconnect control and monitor equipment
13094#A LAN with an experiment command interpreter and 2.5 Mbaud interfaces
13095#Resume´: networking in high energy physics
13096#The intelligent FASTBUS—168/E data acquisition interface system for the NA31 experiment
13097#VIRTUS: a multiprocessor system in FASTBUS
13098#Online fastbus processor for LEP
13099#Status of the development of a parallel-pipelined data driven processor capable of analyzing up to 105 events per second on-line
13100#A multiprocessor system for parallel proton tracking
13101#The summer VME trigger processor
13102#A VME/VMX parallel multiprocessor system for the data acquisition of the UA1 streamer tubes
13103#MacVEE—the intimate Macintosh-VME system
13104#The design of a real-time distributed system
13105#Portability aspects of Modula-2
13106#DRM system—a distributed realtime multiprocessor system
13107#XOP, a fast versatile processor, as a building block for parallel processing in high energy physics experiments
13108#Data acquisition for the D0 experiment
13109#The ALEPH event builder
13110#IKONET: distributed accelerator and experiment control
13111#A survey of Tumult, a real-time multi-processor system
13112#Resume´ of embedded systems presentations
13113#The new MAD: a software tool kit for designing accelerators
13114#Computational needs for modelling accelerator components
13115#The 3081/E emulator, a processor for use in on-line and off-line arrays
13116#Using the 3081/E as a VAX emulator
13117#The APE project: a gigaflop parallel processor for lattice calculations
13118#The space time array computer
13119#Software development and code migration strategies for parallel processing
13120#The effect of processor topology and communication mechanisms on the performance in a multiprocessor system
13121#Use of SIMD-SPMD machine for simulation in particle physics
13122#High performance simulation of lattice physics using enhanced transputer arrays
13123#The ANL/Star project: a new architecture for large scale theoretical physics computations
13124#The Fermilab advanced computer program multi-microprocessor project
13125#Resume´ on vector and parallel processing in HEP
13126#Practical parallel processing
13127#Vectorization of phase space Monte Carlo code in FACOM vector processor VP-200
13128#The CYBERPLUS parallel processing system—a supercomputer alternative
13129#SCI-Clone/32—a distributed real time simulation system
13130#Proceedings of the first IFCEB World Conference on Computer Based Education on Computer based education in banking and finance
13131#CBT in banking today
13132#Panorama of computer based education in banking in Europe
13133#A panorama of computer based education in banking: U.S.A.
13134#Use of video in the German banking industry
13135#The Credit Agricole computer assistant learning project
13136#Getting started with CBT: how to build your own system
13137#Seven years of CBT at Barclaycard
13138#CBT in the banking sector
13139#Computer assisted learning at Generale Bankmaatschappij
13140#Future of CBT
13141#Five generations of courseware authoring tools
13142#A perspective on the future of computer based education author systems
13143#Seven statements on interactive video
13144#Why should banking organizations produce their own interactive video?
13145#Interactive videodiscs: database-driven courseware
13146#Panel of the future
13147#Why artificial intelligence?
13148#C.I.F.P.B.'s methods in the use of educational technology
13149#Difficult speech-recognition technology shows signs of maturity
13150#Application-specific processor brings high performance to DSP
13151#No longer novelties, expert systems find practical applications
13152#Access control plus data encryption adds up to system security
13153#Fiber optics points way to speed divergent networks
13154#Optical disk drives promise to revolutionize computer use
13155#Special report on PCs in engineering
13156#Spice improvements ease analog simulation
13157#FIFO RAM controller tackles deep data buffering
13158#Packaging supermicros for office applications
13159#32-bit micros advance art of memory management
13160#ECL gate arrays emerge as speed and density contenders
13161#Hard disk controllers marked by bewildering variety
13162#PC-based compilers offer low-cost Ada
13163#Protocol analyzers tackle SNA and ISDN
13164#Special report on prototype verification
13165#Documentation tools provide design cycle management
13166#Forth takes aim at real-time applications
13167#The flooding sink-A new approach to local area networking
13168#Simulation of distributed processing networks
13169#A survey of multi-connected loop topologies for local computer networks
13170#A congestion-control policy on the internetwork gateway
13171#International seminar on computer networks and performance evaluation
13172#Ninth data communications symposium
13173#The second international symposium on computer message systems
13174#Carrier sense access in an enviornment of two interfering channels
13175#Establishing virtual circuits in large computer networks
13176#Performance evaluation of channel access schemes in multihop packet radio networks with regular structure by simulation
13177#Local digital telephone system on two-way cable television
13178#Teletraffic analysis and computer performance evaluation
13179#Optimal design parameters in a multishop packet radio network using random access techniques
13180#Software development and implementation of NBS class-4 transport protocol
13181#Protocol analysis and synthesis by structured partitions
13182#A simple file server for a terminal support network environment
13183#Ninth international Zurich seminar on digital communications-New directions in switching and networks
13184#Report on the INS experiment
13185#The design of a small packet-switching
13186#Testing to assure interworking of implementations of ISO/OSI protocols
13187#Authentication protocols for computer networks: I
13188#COST Project 214: Methods for the planning and evaluation of multiservice networks
13189#COMNET '85
13190#Contradictions in the control of large systems
13191#An approach to building technical diagnostic expert systems
13192#The complexity of finding compact well-separated clusters
13193#The growth functions of stochastic TOL languages
13194#Determination of computer system sensitivity to the change of parameters by means of linear regression
13195#Threshold and histogram algorithms for parallel associative computer
13196#An information-control technical vision system for the adjustment and check of the measuring needle instruments
13197#GENERA- An advanced control system for industrial robots
13198#A wave language for parallel processing of semantic networks
13199#How can cognitive psychology help solve an artificial intelligence problem?
13200#On the minimization of random Boolean functions
13201#Expected number of comparisons in the Hwang-Lin merging algorithm
13202#The efficiency of the depth first algorithms
13203#A new texture recognition method
13204#Cluster analysis in knowledge identification
13205#The optimum placement based on a method of limited cuts
13206#Conceptual knowledge operations
13207#Growing semantic networks in adaptive problem solving systems
13208#Towards meta-expert systems
13209#Two notes concerning the society theory of thinking
13210#Syntactic-semantic analysis of natural language by new word-class controlled functional analysis
13211#A fast digital image processor
13212#Nonlinear lower bound on synchronous combinational complexity of binary addition
13213#How to assemble Trellis machines
13214#Boltzmann machines for speech recognition
13215#Continuously variable duration hidden Markov models for automatic speech recognition
13216#Lexical access using broad acoustic-phonetic classifications
13217#Improving speaker consistency in an automatic speech recognition framework
13218#The alternation number and a dot hierarchy of regular sets
13219#The minimal keys and antikeys
13220#On the index of concavity of neighbourhood templates
13221#Optimization of multi valued logical functions based on evaluation graphs
13222#An Erdo¨s-Ko-Rado Type theorem II
13223#Giving mathematical semantics of nondeterministic and parallel programming structures by means of attribute grammars
13224#A new programming methodology using attribute grammars
13225#Problem solving based on knowledge representation and program synthesis
13226#On the compositions of root-to-frontier tree transformations
13227#The probabalistic behaviour of the NFD Bin packing algorithm
13228#Languages written by an infinitary code: theorem of defect
13229#On the congruences of finite autonomous Moore automata
13230#On the complexity of finite Moore Automata
13231#Varieties and general products of top-down algebras
13232#On products of automata with identity
13233#Properties of the fuzzy connectives in the light of the general representations theorem
13234#On the optimization of library information retrieval systems
13235#A probability model for priority processor-shared multiprogrammed computer systems
13236#An iterative method for solving M/G/1//N-type loops with priority queues
13237#Computing aspects of interactive video
13238#Local viewdata—an international CAL resource
13239#Software and television—a new approach
13240#Laboratory equipment training utilizing CAL and interactive videocassettes
13241#Computer assisted communication in the education of the visually impaired
13242#Designing microcomputer programs for disabled students
13243#The coventry computer based learning project
13244#QUEST—two curriculum projects: perspectives, practice and evidence
13245#Using Logo in the mathematics classroom. What are the implications of pupil devised goals?
13246#The TOPIC-cal project
13247#A heuristic problem solver: GEORGE
13248#Teaching about the electricity supply industry—the development and evaluation of a computer based teaching package for schools
13249#Designing an interactive modelling environment
13250#ENGOL—Engineering-Graphics-Oriented Language: the core of a “computational engineering graphics” implementation
13251#CAL: improved learning and improved teaching
13252#Teaching electronics with the aid of a microcomputer
13253#Using CAL to broaden design experience for undergraduate engineers
13254#An attempt to optimize teachers' and learners' contributions—and the computer's
13255#Teacher training in computers and education: a two-year experience
13256#A strategy for the eighties
13257#Relating research to curriculum and course development
13258#Extended muSIMP/muMATH for teaching and learning mathematics
13259#Theoretical considerations in selecting language arts software
13260#The computer and the pre-school child; the written language and play
13261#The role of the computer in developing childrens' classificatory abilities
13262#Generating language learning with CAL
13263#CONFLICT: the establishment of a teacher-friendly database for the computerorganisation of role playing in the classroom
13264#Interactive databases for leisure learning
13265#Computer aided training in a renal dialysis ward—a unique approach
13266#Use of computer assisted teaching in clinical dentistry
13267#Social responsibility in technological environments
13268#CAL in Canada: innovations and their sources in teaching and learning
13269#A decade of CAL at a Dutch university
13270#Computers and religious education
13271#The introduction of computers into a school
13272#PTPATH: a FORTRAN program to calculate pressure:80temperature paths from zoned metamorphic garnets
13273#Complete subcompositional independence testing of closed arrays
13274#A disjunctive kriging program for two dimensions
13275#A FORTRAN 77 program for analyzing broad-scale spatial trends of streamline glacial features
13276#A FORTRAN 77 computer program for the least-squares analysis of chemical data in Pearce variation diagrams
13277#RPHIN:80a FORTRAN 77 program for acquiring axial ratios, long axis orientations and centroid positions of elliptical strain markers
13278#REFOLD: a FORTRAN 77 program to construct model block diagrams of multiply folded rocks
13279#On compatibility and support functions in probabilistic relaxation
13280#A robust method for picture segmentation based on split-and-merge procedure
13281#A fast shape descriptor
13282#An adaptive asteroid zonal filter for data compression
13283#Toward the derivation of three-dimensional descriptions from image sequences for nonconvex moving objects
13284#Pulse and staircase edge models
13285#Distance transformations in digital images
13286#A note on “rigid body motion from depth and optical flow”
13287#Some questions concerning the initial fields in finite difference computation of two-dimensional steady transonic flows
13288#Instability analysis of thin plates and arbitrary shells using a faceted shell element with Loof nodes
13289#On the lack of convergence of unconditionally stable explicit rational Runge-Rutta schemes
13290#About the choice of uniformly distributed sequences to be used in the random choice method
13291#Construction of models of dispersive elastodynamic behavior of periodic composites: A computational approach
13292#A numerical simulation of inertial waves in a rotating fluid
13293#A segregated formulation of Navier-Stokes equations with finite elements
13294#A mixed finite element method for boundary flux computation
13295#Round-off errors in the stiffness equation
13296#The PC-SIG library
13297#C: a programming workshop
13298#Satellite communication systems engineering
13299#Programming with R:base 5000
13300#Strategies for electronics test
13301#LISP
13302#The COBOL programmer's design book
13303#An introduction to the art and science of programming: Turbo Pascal edition
13304#1001 things to do with your Amiga
13305#1001 things to do with your Atari ST.
13306#Assembly language subroutines for MS-DOS computers
13307#UNIX V and XENIX System V programmer's tool kit
13308#Build a remote-controlled robot for under $300
13309#Circuits,signals,and systems
13310#Atari ST graphics and sound programming
13311#A practical guide to UNIX System V
13312#Assembler language programming for IBM and IBM-compatible computers
13313#C development tools for the IBM PC
13314#PICK for users
13315#Microtechnology: the M6809
13316#VAX BASIC
13317#Automated performance optimization of custom integrated circuits
13318#Feedback control systems
13319#C language user's handbook
13320#Linear systems and digital signal processing
13321#Stabilization of control systems
13322#Multi-level simulation for VLSI design
13323#Modula-2: constructive program development
13324#Laboratory virtual instrument engineering workbench
13325#Build a hardware data encryptor
13326#Calculating CRCs by bits and bytes
13327#Breaking out
13328#Keyed file access in Basic
13329#Real time under real pascal
13330#68000 trips and traps
13331#UNIX and the MC68000
13332#A comparison of MC68000 family processors
13333#Atari ST software development
13334#Amiga animation
13335#Amiga vs. Macintosh
13336#Build the GT180 color graphics board part 2: hartware
13337#Using DOS functions from Turbo Pascal
13338#A program for approximating integrals
13339#Debugging macintosh applications
13340#Local effects of nuclear weapons
13341#Henon mapping with Pascal
13342#Abstract mathematical art
13343#The TMS34010 graphics system processor
13344#Plotting the mandelbrot set
13345#Graphing quadric surfaces
13346#Free-form curves on your micro
13347#The Apple II GS
13348#Build an intelligent serial EPROM programmer
13349#Safe storage allocation
13350#Sound and the Amiga
13351#A useful property of 2n
13352#PD Prolog
13353#An Icon tutorial
13354#Enhanced console driver
13355#Abundance
13356#Z80MU
13357#CP/M hall of fame
13358#Legal protection of semiconductor mask works in the United States
13359#Requiring an election of protection for patentable/copyrightable computer programs
13360#Data accuracy in Criminal Justice information systems: The need for legislation to minimize constitutional harm
13361#Defamation and the public official: The big chill
13362#Searching for strings with Boyer-Moore
13363#Wordz that almost match
13364#The unshuffle algorithm
13365#Decision tables and logic processing
13366#Simple algorithms for lines and circles
13367#Machine-independent assembly: A universal approach
13368#A programmer's view of IBM's PC RT chip
13369#Assembly and high-level control constructs
13370#Beefing up BASIC with assembly
13371#Finite-state machines
13372#On the bathtub algorithm for dot-matrix holograms
13373#Concurrent programming in co-pascal
13374#Ce´page: A software design tool
13375#Interpreter design and construction, Part II
13376#The graphics cursor
13377#Exponentiation in C and pascal
13378#Generating data
13379#Match redux
13380#Structured editing with RPDE
13381#Fast operations on raster images with SIMD machine architectures
13382#Image generation by space sweep
13383#Two algorithms for decomposing a polyhedron into convex parts
13384#A Monte Carlo approach for &egr; placement in fractal-dimension calculations in waveform graphs
13385#Displaying relevant features of protein molecules
13386#First time classroom computer graphics
13387#EUROGRAPHICS UK 1986 Glasgow conference
13388#Computer graphics and CAD literature—A keyword-indexed bibliography
13389#A geometric modeller based on the exact octtree representation of polyhedra
13390#Algorithms for handling the fill area primitive of GKS
13391#A method of displaying transformed picture rectangles using GKS raster functions
13392#Anti-aliasing of computer-generated images: A picture-independent approach
13393#Shading of solid voxel models
13394#A token based graphics system
13395#An integrated graphics programming environment
13396#Illustrating super-BASIC on the Sinclair QL
13397#T/S 2068 basics and beyond
13398#Advanced computer architecture
13399#The statistical analysis of compositional data
13400#A practical introduction to denotational semantics
13401#Algebra, combinatorics, and logic in computer science
13402#Seminar on higher mathematics on Analysis of categorical data
13403#Applied probability, stochastic processes, and sampling theory
13404#Proceedings of symposia in applied mathematics on Approximation theory
13405#Computers and end-user software
13406#Computers and end-user software with BASIC
13407#Data processing project management
13408#The spine of software: designing provalby correct software-theory and practice, or, a mathematical introduction to the semantics of computer programs
13409#dBase III plus: advanced applications for nonprogrammers
13410#VAX/VMS user's guide
13411#Programmer's guide to GEM
13412#Double Agent: a cipherbase program for electronic self-defense
13413#Using graphics to learn BASIC programming
13414#dBASE demystified. dBASE II/III/III PLUS: applications and solutions to real problems
13415#Essentials of BASIC with structure
13416#Power painting: computer graphics on the Macintosh
13417#Information technology in the third world: a critical analysis of theoretical and empirical studies
13418#Essential skills for arithmetic
13419#Methods in approximation: techniques for mathematical modelling
13420#The FOCUS developer's handbook
13421#68000 assembly language programming: a structured approach
13422#BASIC: an introduction to computer programming with the Apple (2nd ed.)
13423#BASIC programming: a problem-solving approach
13424#Microcomputers in development: a manager's guide (2nd ed.)
13425#Programming from first principles
13426#Concurrency control and recovery in database systems
13427#Design theory
13428#dBASE III PLUS a comprehensive user's manual
13429#Biostatistics
13430#Spectral theory of self-adjoint operators in Hilbert space
13431#Data abstraction in programming languages
13432#Structured BASIC programming with technical applications for the IBM PC
13433#Crunch mode: building effective systems on a tight schedule
13434#Understanding FORTRAN 77 with structured problem solving (2nd ed.)
13435#The book of Commodore 64 software 1985
13436#The Amiga: images, sounds, and animation on the Commodore Amiga
13437#Under the Apple
13438#The higher calculus: a history of real and complex analysis from Euler to Weier strass
13439#The PICK operating system: a practical guide
13440#Free software
13441#The users guide to CP/M systems
13442#How to get the most out of The Source
13443#Time series forecasting: unified concepts and computer implementation
13444#Empirical model-building and response surface
13445#Nonlinear approximation theory
13446#WATFIV-S fundamentals and style
13447#A guide to simulation (2nd ed.)
13448#Introduction to computers and BASIC programming (2nd ed.)
13449#Selecting and installing software packages: new methodology for corporate implementation
13450#Computer architecture and VAX assembly language programming
13451#Proceedings of the Second Conference of the British Computer Society, human computer interaction specialist group on People and computers: designing for usability
13452#Proceedings of the sixth technical conference of the British Computer Society specialist group on expert systems on Research and development in expert systems III
13453#Time series: theory and methods
13454#MVS, JCL, and utilities
13455#CICS: mastering command level coding using COBOL
13456#A little Smalltalk
13457#Making use of UNIX
13458#The Pick operating system
13459#Logo, a learner's guide
13460#Statistics today: a comprehensive introduction
13461#Advanced Macintosh BASIC programming
13462#Casebook for systems analysis and design
13463#COBOL: a practical approach
13464#Principles of computer science: concepts, algorithms, data structures and applications
13465#Compute]'s kids and the Commodore 128
13466#Simulation using personal computers
13467#Linear dynamical systems
13468#Standard BASIC programming with true BASIC
13469#CDP exam guide
13470#Expert systems for microcomputers: an introduction to artificial intelligence
13471#Chaos
13472#Report on the international workshop on high-performance transaction systems
13473#TI's pinout scheme for ACL devices still under attack
13474#Programmable devices tailored to state machine needs
13475#ISDN gains ground as needed ICs emerge
13476#Approaches to software testing embroiled in debate
13477#Special report on digital signal processing
13478#EDIF Version 200 takes on production environment
13479#Unix environment permits flexible I/O design
13480#Analog simulator models multitechnology systems
13481#A relational knowledge base model and an architecture which manipulates the model are presented. An item stored in the relational knowledge base is called a term. A unification operation on terms in the relational knowledge base is used as the retrieval mechanism. The relational knowledge base architecture we propose consists of a number of unification engines, several disk systems, a control processor, and a multiport page-memory. The system has a knowledge compiler to support a variety of knowledge representations.
13482#The architecture of a data flow machine, called DFM, is developed for parallel list processing. The DFM can maximally exploit parallelism inherent in list processing, due to its ultra-multi-processing mechanism, packet communication-based parallel and pipeline execution mechanism, and lenient cons mechanism. A practical DFM implementation is described. A DFM prototype machine is implemented and DFM performance is evaluated in a simulation on the register transfer level using several benchmark programs. The DFM single processor system is shown to be about five times faster than conventional machines which use the same device technology, while a multi-processor DFM system is shown to achieve a linear speed-up ratio of 0.6 ~ 0.9.
13483#This paper presents a new architecture for practical string search hardware design. This architecture is based on the finite state automaton design concept using a character control charge transfer model. The resultant hardware is a set of programmable sequential logic (PSL) circuits, each of which consists of a sequential logic and memory parts. The logic part is an array of logical gates, each of which is controlled by the read-out signal from the memory part, to connect the flip-flops. The memory part stores each variable-length pattern string character on a bit line by bit line basis. Then, several pattern strings in the memory part can be compared with the serial input data string in parallel, even at a non-anchor mode and an approximate matching mode. This new hardware can be easily implemented in an LSI chip, which allows 8192 pattern string storage using 1 Mb RAM cells.
13484#Rule-based systems, on the surface, appear to be capable of exploiting large amounts of parallelism—it is possible to match each rule to the data memory in parallel. In practice, however, we show that the speed-up from parallelism is quite limited, less than 10-fold. The reasons for the small speed-up are: (1) the small number of rules relevant to each change to data memory; (2) the large variation in the processing required by the relevant rules; and (3) the small number of changes made to data memory between synchronization steps. Furthermore, we observe that to obtain this limited factor of 10-fold speed-up, it is necessary to exploit parallelism at a very fine granularity. We propose that a suitable architecture to exploit such fine-grain parallelism is a bus-based shared-memory multiprocessor with 32-64 processors. Using such a multiprocessor (with individual processors working at 2 MIPS), it is possible to obtain execution speeds of about 3800 rule-firings/sec. This speed is significantly higher than that obtained by other proposed parallel implementations of rule-based systems.
13485#Concert is a shared-memory multiprocessor testbed intended to facilitate experimentation with parallel programs and programming languages. It consists of up to eight clusters, with 4-8 processors in each cluster. The processors in each cluster communicate using a shared bus, but each processor also has a private path to some memory. The novel feature of Concert is the RingBus, a segmented bus in the shape of a ring that permits communication between clusters at relatively low cost. Efficient arbitration among requests to use the RingBus is a major challenge, which is met by a novel hardware organization, the criss-cross arbiter. Simulation of the Concert RingBus and arbiter show their performance to lie between that of a crossbar switch and a simple shared intercluster bus.
13486#One particular result is that to balance an array of p linearly connected PEs for performing matrix computations such as matrix multiplication and matrix triangularization, the size of each PE's local memory must grow linearly with p. Thus, the larger the array is, the larger each PE's local memory must be.
13487#One of the most important considerations for a dataflow multiprocessor is the algorithm by which the nodes of a program graph are allocated for execution to its processors. In the case of the static type of architecture one must consider pipelining as well as spatial concurrency. This paper uses a graph partitioning scheme to aid in the design of such algorithms and selection of the associated interconnection topology. The scheme first refines the usual dataflow program graph and then partitions it into “trees.” Our study shows that the hypercube interconnection accommodates these trees in a way that allows as to develop an algorithm that places producer nodes (of a dataflow graph) nears their consumers to keep the message path very short. The algorithm achieves concurrency in simultaneous execution of subgraphs that involve parallel operations, e.g., array operations, and subgraphs that are highly iterative or recursive. An analytical model is given to evaluate the performance of the algorithm.
13488#RAFT is a recursive algorithm for fault tolerance that uses a combination of dynamic space and time redundancy techniques for detecting faulty processors and recovering from errors. U* is a multicomputer testbed consisting of a network of AT&T 3B2 computers running a network operating system based on the UNIX system. This paper describes a software implementation of RAFT on U*, and demonstrates the effectiveness of a RAFT-like scheme for designing fault-tolerant multicomputer systems. Results of Monte Carlo experiments, conducted on this system that validated the theoretical basis of RAFT, are presented. Experimentally observed performance penalty, incurred due to fault tolerance, is also presented.
13489#An advanced microprocessor has been developed for the high performance execution of object oriented language programs. In object oriented languages, improvement of frequent or complex operations such as dynamic type checking, procedure calls, and storage management, contributes toward the increase of overall performance. In order to improve their performance, the microprocessor adopts large on-chip register files, a large EPROM for microstore, and ingenious instruction dispatching and tag-handling mechanisms. By specially treating frequently accessed data, i.e., allocating activation records in register files, much of the data traffic can be effectively localized within the chip, and the complexity of procedure calls as well as the burden imposed on storage management can be alleviated. The tag-handling mechanisms efficiently perform dynamic type checking. As the result, the microprocessor, together with an efficient microprogram, executes object oriented language programs much faster than existing computers. Furthermore, it can efficiently execute other high-level languages by using corresponding microprograms, especially AI-languages.
13490#The G-machine provides architecture support for the evaluation of functional programming languages by graph reduction. This paper describes an instruction fetch unit for such an architecture that provides a high throughput of instructions, low latency and adequate elasticity in the instruction pipeline. This performance is achieved by a hybrid instruction set and a decoupled RISC architecture. The hybrid instruction set consists of complex instructions that reflect the abstract architecture and simple instructions that reflect the hardware implementation. The instruction fetch unit performs translation from complex instruction to a sequence of simple instructions which can be executed rapidly. A suitable mix of techniques, including cache, buffers and the translation scheme, provide the memory bandwidth required to feed a RISC execution unit. The simulation results identify the performance gains, maximum throughput and minimum latency achieved by various techniques. Results achieved here are in general applicable to von Neumann architectures.
13491#As modular programming grows in importance, the efficiency of procedure calls assumes an ever more critical role in system performance. Meanwhile, software designers are becoming more aware of the benefits of object-oriented programming in structuring large software systems. But object-oriented programming requires a good deal of support, which can best be distributed between the compiler and architectural levels. A major part of this support relates to the execution of procedure calls. Must such support exact an unacceptable performance penalty? By considering the case of the Intel 432, a prominent object-oriented architecture, we argue that it need not. The 432 provided all the facilities needed to support object orientation. Though its procedure call was slow, the reasons were only tenuously related to object orientation. Most of the inefficiency could be removed in future designs by the adoption of a few new mechanisms: stack-based allocation of contexts, a memory-clearing coprocessor, and the use of multiple register sets to hold addressing information. These proposals offer the prospect of an object-oriented procedure call that can, on average, be performed nearly as fast as an ordinary unprotected procedure call.
13492#The prospect of coupling a large number of small inexpensive microprocessor based systems to deliver the performance of a large transaction processing system at lower cost has not been realized, to date. Inter-system interference, multi-system coupling protocol overhead and the increased processing time for smaller systems can cause considerable degradation. A methodology is developed to determine the number of processors needed to satisfy transaction throughput and response time requirements for processors of different MIPS (sizes). The minimum MIPS per processor required to satisfy response time, throughput and utilization constraints in a transaction processing complex of N coupled systems is also determined, by using an approximate analytical model driven by measured workload parameters. Despite large assumed cost advantages on a per MIPS basis we find that small systems do not match up to the cost/performance of some larger systems. Besides multi-system's coupling degradation, there is a small system effect. Because of the increased transaction execution time in smaller systems, transaction hold on to resources longer, thereby causing increased inter-system interference. Our cost criterion indicates that there is an optimum processor size below which total system costs would increase appreciably. Ways to reduce the inter-system interference and coupling protocol overheads are investigated and shown to shift this optimum.
13493#This paper presents empirical results on the performance of CD, a compiler directed memory management policy, and the Working Set policy in a multiprogramming system. A description of the multiprogramming model used in the experiments is also presented. The results show that CD outperforms WS in terms of fault rate, space time cost, and throughput characteristics. Moreover, WS is shown to lack controllability. Two anomaly types are reported in this paper, both of which are exhibited by WS but not by CD.
13494#Trace-driven simulation is often used in the design of computer systems, especially caches and translation lookaside buffers. Capturing address traces to drive such simulations has been problematic, often involving 1000:1 software overhead to trace a target workload, and/or mechanisms that cause significant distortions in the recorded data. A new technique for capturing address traces has been developed to use a processor's microcode to record addresses in a reserved part of main memory as a side effect of normal execution. An experimental implementation of this technique on a VAX1 8200 processor shows a number of advantages over previous techniques, including fewer distortions of the address trace and a hundred times faster recording. With this technique, it is possible to gather full operating-system traces of multi-tasking workloads.
13495#The EPILOG language and model of computation are briefly described, together with four multiprocessor architectures on which it is proposed to run the model: a form of chordal network and a slight variant of Wu and Feng's Baseline and Reverse Baseline networks. Results are reported for the simulated execution of some EPILOG programs on these architectures. Finally, some tentative conclusions are drawn and some possible avenues for future research are indicated.
13496#In this paper, an implementation of unification using a systolic-like method is presented for a VLSI-oriented Prolog machine. Not pointers but a line of symbols and the arity of each symbol are used to express the structure of terms on a uniformly structured cellular hardware. This data structure is demanded by the systolic-like method. Using the systolic-like method, copying structure, and occur check are easily executed during the process of unification. Moreover, searching variable is executed in parallel using a broadcast bus.
13497#A parallel inference machine based on the dataflow model and the mechanisms to support two types of logic programming languages are presented. The machine is constructed from multiple processing elements and structure memories interconnected through a low-latency hierarchical network. The preliminary evaluation results of the experimental machine are also presented. The evaluation results show that the machine can exploit parallelism in programs.
13498#When processing vectors on SIMD computers, the interconnection network may become the bottleneck for performances if it lacks an efficient routing control unit. In the pass, many multistage networks have been designed, but general algorithms to control them cannot be used at execution time : they are too time consuming. This has led many manufacturers to use crossbar networks in the design of SIMD computers. In [Se84a],[Se84b], we defined the Sigma network &Sgr;(n) and we gave realistic algorithms to control it for performing families of permutations covering standard needs in vector processing. Here, we expose the design of a very efficient control unit for the Sigma network &Sgr;(4) (16 entries, 16 exits).
13499#In order to build lower cost multimicroprocessor systems, a narrow synchronous bus (15 active lines) is proposed. It multiplexes address and data on 8 bits, and arbitrates in two pipe-lined cycles on four lines. Due to the 20 to 40 MHz bus clock, and the pipelined control logic, the performances are equivalent to Multibus-2, IEEE-P896 and similar 32-bit buses.For the implementation, cards are disposed radially around a special connector. The very short connections allows for the usage of fast HC-MOS drivers with only a light adaptation.
13500#The augmented data manipulator (ADM), inverse augmented data manipulator (IADM), and the gamma network are based on the Plus-Minus-2i connection patterns. In such a network there exist multiple paths to connect a source S to a destination D except when S=D. The number of paths for (S,D) is a function of the tag value (D-S) modulo N, and the size of the network N.parIt is shown in this paper that by adding an extra stage to the original PM21 interconnection network, multiple paths are provided for all the tag value including 0. The extra stage can be any stage out of n=log2N stages of the original network.The analyses on the distribution of the number of paths for various tag values are performed for n possible choices of the extra stage. It is shown that the extra stage of 0, +1, -1 connection patterns gives the most uniform distribution, and also results in a 1-fault tolerant interconnection network.
13501#The FACOM ALPHA is the first and only commercially dedicated processor for Lisp and Prolog manufactured in Japan. This paper discusses the evaluation of the FACOM ALPHA for Lisp execution when compared with a general-purpose computer. The CPU use rate of machine instructions and the utilization ratio of the hardware resources are discussed. This paper also explains the interaction between the garbage collector and the virtual memory system, which improves system response time.
13502#In this paper, we present a Lisp machine architecture that supports efficient list manipulation. This Lisp architecture is organized as two processing units: a List Processor (LP), that performs all list related operations and manages the list memory, and an Evaluation Processor (EP), that maintains the addressing and control environment. The LP contains a translation table (LPT) that maps a small set of list identifiers into the physical memory addresses of objects. Essentially, the LP and LPT virtualize a list. The EP then operates on these virtualized lists. Such an organization permits the overlap of EP function evaluation with LP memory accesses and management, thus reducing the performance penalties typically associated with Lisp list manipulation activities. We used trace-driven simulations to evaluate this architecture. From our evaluation a relatively small LPT is seen to be sufficient, and to yield “hit rates” on data accesses higher than those of a data cache of comparable size.
13503#The SPUR microprocessor has a 40-bit tagged architecture designed to improve its performance for Lisp programs. Although SPUR includes just a small set of enhancements to the Berkeley RISC-II architecture, simulation results show that with a 150-ns cycle time SPUR will run Common Lisp programs at least as fast as a Symbolies 3600 or a DEC VAX 8600. This paper explains SPUR's instruction set architecture and provides measurements of how certain components of the architecture perform.
13504#The architecture of a proto-type functional level simulator element of a massively parallel machine (MAN-YO) designed for logic design automation is presented. At functional level, hardware systems are described in a hardware description language, FDL. The FDL description is compiled into stack oriented intermediate language instructions. Communicating with other gate level/block level/ functional level processors, each functional simulator interprets the compiled instructions and simulates various circuits using 4-value logic. In order to realize high speed processing of 4-value logic/arithmetic operations, the functional simulator utilizes low-level parallelism realized by 3 ALUs which are controlled by the different fields of a long horizontal type microinstruction.By utilizing low-level parallelism at processor level, as well as processor level parallelism, high speed execution of mixed level simulation becomes possible. The system also provides further performance enhancement by compiling often used FDL macros into microcode.This paper describes an outline of the MAN-YO (Japanese for ten thousand leaf-nodes in the processor tree), a brief description of FDL, and the architecture of the functional level simulator element (called FDLPE). A rough performance based on the current design is also described.
13505#The parallelism inherent in actual circuits suggests that this parallelism might be exploited in a switch-level simulation machine, in order to reduce total simulation time. This paper explores the extent to which this parallelism exists and the extent to which it can be exploited. The exploration is done in the context of a proposed multiprocessor simulation machine called the Fast-1. The Fast-1 is a form of data-flow machine in which switch-level circuits are represented as programs consisting of transistor and node instructions. In a multiprocessor Fast-1 these programs are partitioned onto one or more processors. Using a simulation of the Fast-1, experiments were performed using thirteen circuits, ranging in size from 78 to 20233 transistors. The most parallel circuit measured in these experiements potentially could be simulated almost 200 times faster on a multiprocessor than on a uniprocessor, assuming one instruction per processor and no-cost interprocessor communication. Using 64 processors, an atual speedup of 28 was achieved using contention-free interconnect, while a speedup of 12 was achieved when the 64 processors were connected by a broadcast bus for which they had to arbitrate.
13506#This paper describes two custom architectures tailored to a speech recognition beam search algorithm. Both architectures have been simulated using real data and the results of the simulation are presented. The paper also describes the design process of the custom architectures and presents a number of ideas on the automatic design of custom systems for data dependent computations.
13507#A processing element and a structure element of data flow computer SIGMA-1 for scientific computations is now operational. The elements are evaluated for several benchmark programs. For efficient execution of loop constructs, the sticky token mechanism which holds loop invariants is evaluated and exhibits a remarkable effect. From the standpoint that performance of a single processor of a data flow computer must be comparable to that of a Von Neumann computer, comparison of both computers is discussed and improvement of the SIGMA-1 instruction set is proposed.
13508#Experience with the Manchester Dataflow Machine has highlighted the importance of efficient handling of stored data structures in a practical parallel machine. It has proved necessary to add a special-purpose structure store to the machine, and this paper describes the role of this structure store and the software which uses it. Some key issues in data structure handling for parallel machines are raised.
13509#A design for a highly parallel data structure store for the prototype Manchester Dataflow Computer is presented. The main design objective is to allow all storage functions to be performed concurrently. The functions include space allocation and garbage collection, as well as operations for reading and writing the store. The resulting design is scalable in that an incremental increase in performance for any function can be achieved by adding appropriate hardware modules into the system. A relative balance in performance between the different functions can therefore be achieved. In the hardware structure store, the logical and the physical function units are designed separately. This increases flexibility for configuring multiprocessor dataflow systems. A single hardware module performing all the functions has been constructed and attached to the prototype Manchester Dataflow Machine. The performance of this configuration is discussed.
13510#We can perform a N-point FFT with time performance T=&Ogr;(log N) and area-time performance AT2=&Ogr;(N log4 N), by using the 3-dimensional VLSI system which is optically interconnected. This performance exceeds the theoretical lower bound of the area-time performance (N2 log2 N) of the conventional VLSI.
13511#The paper presents two new versions of the FFT algorithm. Based on these versions a new VLSI oriented architecture for implementing of the FFT algorithm is introduced. It consists of a homogenous structure of processing elements. The structure has a performance equal to 1/tB transforms per second, where tB is the time needed for execution of a single butterfly computation.Besides high performance the architecture is modular and makes it possible to design a system which performs the DFT of any size with constant performance and without any extra circuitry. Moreover, the system can provide a built-in self test.
13512#A methodology to transform dense to band matrices is presented in this paper. This transformation, is accomplished by triangular blocks partitioning, and allows the implementation of solutions to problems with any given size, by means of contraflow systolic arrays, originally proposed by H.T. Kung. Matrix-vector and matrix-matrix multiplications are the operations considered here.The proposed transformations allow the optimal utilization of processing elements (PEs) of the systolic array when dense matrix are operated. Every computation is made inside the array by using adequate feedback. The feedback delay time depends only on the systolic array size.
13513#We proposed a computer with low-level parallelism as one of the basic computer architectures and built a large scale experimental system called QA-2. By low-level parallelism, we mean that a long-word instruction controls simultaneously many ALUs, busses, registers and memories in a mode of fine-grained parallelism. The QA-2 employs a 256-bit instruction by which four different ALU operations, four memory accesses to different/continuous locations and one powerful sequence control are all specified and performed in parallel. If many simultaneously executable operations are detected and embedded in one instruction at compile time, this type of computer can provide a high-degree of performance for a wide variety of applications. This paper describes the architectural benefits and limitations of low-level parallelism in performing 3-D color image generation and interpreting Prolog/Lisp programs. The hardware organization with four ALUs, which are actually implemented in the QA-2, is verified to be adequate. In fact, nearly three out of four ALUs can work in parallel. Any architecture with more than four ALUs can not achieve a significant degree of performance enhancement. This paper also shows the degree of performance improvement achieved by the techniques such as ALU chaining and highly-structured sequence control mechanisms. As compared with the IBM 370 architecture, the QA-2 can generate 3-D color images in 1/5 of dynamic instruction steps. The compiler version of Prolog machine on the QA-2 is as fast (45K LIPS) as the ICOT's PSI. From all results, we expect that the QA-2 is a high-performance computer which will be utilized in the future personal computing environment.
13514#In order to realise dedicated functions that have no special parallel algorithms for efficient full custom VLSI implementation, we propose an asynchronous architecture that consists of several asynchronous functional modules and controls the chip by the local communication among these functional modules. As this architecture is very suitable for mapping from the behavioral specification described by the software onto silicon, it is very useful as a target architecture for silicon compilers.This paper describes the concept and the VLSI implementation of the asynchronous architecture. An evaluation of the size and the execution speed of chips based on this architecture model is also described.
13515#Our recent work in microarchitecture has identified a new model of execution, restricted data flow, in which data flow techniques are used to coordinate out-of-order execution of sequential instruction streams. We believe that the restricted data flow model has great potential for implementing very high performance computing engines. This paper defines a minimal functionality variant of our model, which we are calling HPSm. The instruction set, data path, timing and control of HPSm are all described. A simulator for HPSm has been written, and some of the Berkeley RISC benchmarks have been executed on the simulator. We report the measurements obtained from these benchmarks, along with the measurements obtained for the Berkeley RISC II. The results are encouraging.
13516#This paper proposes a design of matrix machines for solving large-scale band-limited matrix equations. The design provides a guide-line for specifying functionality of each processing element PE, array arrangements of PEs, communication structures and parallel algorithms. The basic feature of the design is (1) a rotary array arrangement of data-flow type PEs with the slant width 2B-1 and circumference Z, on which the diagonal strip of a band-limited matrix data is wound around, and (2) wavefront-sequential executions of tasks, each of which is consisted of a group of pipelined wavefronts and circulates around the rotary array. The wavefront algorithm first produces the Gaussian solution via LU decomposition and then its accuracy is improved by applying the incomplete LU (conjugate) residual iteration.
13517#The explicit finite element method for dynamic structural analysis can be expressed in a highly parallel form. A proposed architecture is described that addresses the fundamental algorithmic issues of the method. An approximation equation for the efficiency is given as a function of processing time for a single element, the fundamental interprocessor communication time, the number of processors, and the number of finite elements. The predicted speedups are plotted against postulated parallel processor speedup bounds, and are shown to be much closer to the upper (linear) bound than to the lower bounds of Amdahl and Minsky.
13518#This paper presents and evaluates a scheme for reducing the average memory access time in a vector processing architecture. This scheme uses data skewing to distribute vectors among the modules of a parallel memory system in such a way that, for typical vector access patterns, the average number of memory conflicts is reduced. It also employs both address and data buffers in each module to smooth out the transient irregularities that occur in some vector access patterns.Most previous data skewing techniques were developed to provide conflict-free access for a limited set of access strides. While the proposed scheme does not eliminate all conflicts, it improves the average performance over non-skewed parallel memories by significantly reducing the number of conflicts for a wide range of strides. Also, this effect is much less dependent on the number of memory modules than the skewing schemes used to obtain conflict-free access.
13519#A highly integrated array processor (AAP2)-LSI has been developed. After the past 3 years study on the adaptive array processor 1 (AAP1), a challenging improvements on the SIMD's restraints are achieved by using the AAP2-LSI. The AAP2 array system makes it possible to carry out wideband modifiable operation (pseudo MIMD). Furthermore, each PE is capable of supporting a large amount of memory. The AAP2 potential for massively, parallel and pipelined processing is discussed in the field of image processing and CAD applications.A highly integrated array processor (AAP2)-LSI has been developed. After the past 3 years study on the adaptive array processor 1 (AAP1), a challenging improvements on the SIMD's restraints are achieved by using the AAP2-LSI. The AAP2 array system makes it possible to carry out wideband modifiable operation (pseudo MIMD). Furthermore, each PE is capable of supporting a large amount of memory. The AAP2 potential for massively, parallel and pipelined processing is discussed in the field of image processing and CAD applications.
13520#This paper describes the scan line array processor (SLAP), a new architecture designed for high-performance yet low-cost image computation. A SLAP is a SIMD linear array of processors, and hence is easy to build and scales well with VLSI technology; yet appropriate special features and programming techniques make it efficient for a surprisingly wide variety of low and medium level computer vision tasks. We describe the basic SLAP concept and some of its variants, discuss a particular planned implementation, and indicate its performance on computer vision and other applications.
13521#This paper describes the scan line array processor (SLAP), a new architecture designed for high-performance yet low-cost image computation. A SLAP is a SIMD linear array of processors, and hence is easy to build and scales well with VLSI technology; yet appropriate special features and programming techniques make it efficient for a surprisingly wide variety of low and medium level computer vision tasks. We describe the basic SLAP concept and some of its variants, discuss a particular planned implementation, and indicate its performance on computer vision and other applications.
13522#In the design of SPUR, a high-performance multiprocessor workstation, the use of large caches and hardware-supported cache consistency suggests a new approach to virtual address translation. By performing translation in each processor's virtually-tagged cache, the need for separate translation lookaside buffers (TLBs) is eliminated. Eliminating the TLB substantially reduces the hardware cost and complexity of the translation mechanism and eliminates the translation consistency problem. Trace-driven simulations show that normal cache behavior is only minimally affected by caching page table entries, and that in many cases, using a separate device would actually reduce system performance.
13523#VMP is an experimental multiprocessor that follows the familiar basic design of multiple processors, each with a cache, connected by a shared bus to global memory. Each processor has a synchronous, virtually addressed, single master connection to its cache, providing very high memory bandwidth. An unusually large cache page size and fast sequential memory copy hardware make it feasible for cache misses to be handled in software, analogously to the handling of virtual memory page faults. Hardware support for cache consistency is limited to a simple state machine that monitors the bus and interrupts the processor when a cache consistency action is required.In this paper, we show how the VMP design provides the high memory bandwidth required by modern high-performance processors with a minimum of hardware complexity and cost. We also describe simple solutions to the consistency problems associated with virtually addressed caches. Simulation results indicate that the design achieves good performance providing data contention is not excessive.
13524#Single-chip computers are becoming increasingly limited by the access constraints to off-chip memory. To achieve high performance, the structure of on-chip memory must be appropriate, and it must be allocated effectively to minimize off-chip communication. We report experiments that demonstrate that on-chip memory can be effective for local variable accesses. For best use of the limited on-chip area, we suggest organizing memory as registers and argue that an effective register spilling scheme is required. We introduce a heuristic algorithm for register spilling within basic blocks and demonstrate that trace optimization techniques can extend the use of the algorithm to global allocation. Through trace simulation, we show that the use of registers can be more effective in reducing the bus traffic than cache memory of the same size.
13525#High speed scalar processing is an essential characteristic of high performance general purpose computer systems. Highly concurrent execution of scalar code is difficult due to data dependencies and conditional branches. This paper proposes an architectural concept called guarded instructions to reduce the penalty of conditional branches in deeply pipelined processors. A code generation heuristic, the decision tree scheduling technique, reorders instructions in a complex of basic blocks so as to make efficient use of guarded instructions. Performance evaluation of several benchmarks are presented, including a module from the UNIX kernel. Even with these difficult scalar code examples, a speedup of two is achievable by using conventional pipelined uniprocessors augmented by guard instructions, and a speedup of three or more can be achieved using processors with parallel instruction pipelines.
13526#Pipelining is the major organizational technique that computers use to reach higher single-processor performance. A fundamental disadvantage of pipelining is the loss incurred due to branches that require stalling or flushing the pipeline. Both hardware solutions and architectural changes have been proposed to overcome these problems. This paper examines a range of schemes for reducing branch cost focusing on both static (compile-time) and dynamic (hardware-assisted) prediction of branches. These schemes are investigated from quantitative performance and implementation viewpoints.1
13527#This paper examines the relationship between the degree of central processor pipelining and performance. This relationship is studied in the context of modern supercomputers. Limitations due to instruction dependencies are studied via simulations of the CRAY-1S. Both scalar and vector code are studied. This study shows that instruction dependencies severely limit performance for scalar code as well as overall performance.The effects of latch overhead are then considered. The primary cause of latch overhead is the difference between maximum and minimum gate propagation delays. This causes both the skewing of data as it passes along the data path, and unintentional clock skewing due to clock fanout logic. Latch overhead is studied analytically in order to lower bound the clock period that may be used in a pipelined system. This analysis also touches on other points related to latch clocking. This analysis shows that for short pipeline segments both the Earle latch and polarity hold latch give the same clock period bound for both single-phase and multi-phase clocks. Overhead due to data skew and unintentional clock skew are each added to the CRAY-1S simulation model. Simulation results with realistic assumptions show that eight to ten gate levels per pipeline segment lead to optimal overall performance. The results also show that for short pipeline segments data skew and clock skew contribute about equally to the degradation in performance.
13528#Standardization of a high performance blackplane bus, so that it can accommodate boards developed by different vendors, implies the need for a standardized cache consistency protocol. In this paper we define a class of compatible consistency protocols supported by the current IEEE Futurebus design. We refer to this class as the MOESI class of protocols; the term “MOESI” is derived from the names of the states. This class of protocols has the property that any system component can select (dynamically) any action permitted by any protocol in the class, and be assured that consistency is maintained throughout the system. Included in this class are actions suitable for copyback caches, write through caches and non-caching processors. We show that the Berkeley protocol and the Dragon protocol fall within this class, and can be extended to be compatible with other members of the class. The Illinois, Firefly and Write-Once protocols can be adapted to be compatible with this class; the facilities of he Futurebus currently do not support those protocols without adaptation. We discuss very briefly performance choices among protocols, and also other issues relating to a standard bus consistency protocol.
13529#Many options are possible in a cache synchronization (or consistency) scheme for a broadcast system. We clarify basic concepts, analyze the handling of shared data, and then describe a protocol that we are currently exploring. Finally, we analyze the evolution of options that have been proposed under write-in (or write-back) policy. We show how our protocol extends this evolution with new methods for efficient busy-wait locking, waiting, and unlocking. The lock scheme allows locking and unlocking to occur in zero time, eliminating the need for test-and-set. The scheme also integrates processor atomic read-modify-write instructions and programmer/compiler busy-wait-synchronized operations under the same mechanism. The wait scheme eliminates all unsuccessful retries from the bus, and allows a process to work while waiting.
13530#In highly-pipelined machines, instructions and data are prefetched and buffered in both the processor and the cache. This is done to reduce the average memory access latency and to take advantage of memory interleaving. Lock-up free caches are designed to avoid processor blocking on a cache miss. Write buffers are often included in a pipelined machine to avoid processor waiting on writes. In a shared memory multiprocessor, there are more advantages in buffering memory requests, since each memory access has to traverse the memory- processor interconnection and has to compete with memory requests issued by different processors. Buffering, however, can cause logical problems in multiprocessors. These problems are aggravated if each processor has a private memory in which shared writable data may be present, such as in a cache-based system or in a system with a distributed global memory. In this paper, we analyze the benefits and problems associated with the buffering of memory requests in shared memory multiprocessors. We show that the logical problem of buffering is directly related to the problem of synchronization. A simple model is presented to evaluate the performance improvement resulting from buffering.
13531#Proceedings of the 13th annual international symposium on Computer architecture
13532#Wordstar simplified with Wordstar 3.3, Mailmerge, Spellstar, and Starindex
13533#Conference proceedings on Electronic printing systems: directions in digital imaging. Vol. 1, technology
13534#Tools of the trade are changing
13535#Automating graphics in the corporate environment
13536#Image capture and management: today's perspective
13537#Interactive image digitizing with the AGFA S200
13538#Abaton SCAN300: price, resolution: breaking barriers
13539#Resolution, gray scale and color for corporate publishing images
13540#Interpress printing architecture and interface to other worlds
13541#Output imaging alternatives: high resolution and color under Interpress
13542#Electronic publishing and Interpress printing
13543#Postscript: a page description standard
13544#IBM strategy in output formats
13545#Imagen's multilingual approach to languages and the impact of document description language
13546#Application specific vs. generalized languages and the direction of Printronix in laser printers
13547#The graphic software systems strategy for systems with graphics-based applications
13548#Raster image handling facility and soft proofing for mainframes
13549#Pictures into text for electronic technical publishing
13550#Merging text and pictures for electronic technical documentation
13551#Co-existence of raster and vector technologies in an electronic publishing system
13552#Outline or bitmap type
13553#Device independence for popular type
13554#Toward an ideal font technology
13555#Resolution and digital type
13556#What paper for what resolution
13557#Hard copy color for the corporate publishing application
13558#Ink jet color systems for electronic printing
13559#Xerographic quality and throughput issues
13560#Choosing output devices for electronic printing systems
13561#High quality text and graphics output for electronic publishing
13562#The Ultre*Setter high quality low cost film recorder
13563#Genesis: a modular system for production environments
13564#What? Your laser printer won't do color]
13565#Supporting professional applications with Agfa LED printers
13566#The use of electronic printing for direct mail and MICR applications
13567#The 3812 LED Pageprinter and proof utility applications with the PC and mainframe
13568#Finishing in the future
13569#Finishing the output of non-impact printers—roll and sheet fed
13570#Converting technology
13571#Laser printing applications in retail merchandising
13572#Magnetic printing technology overview
13573#Dataproducts laser printers and their applications
13574#Electronic printing press with multiple paper handling
13575#Computers and modern language studies
13576#Integrating the computer into a language course
13577#The use of the micro in an integrated German language course at university level
13578#Computer applications for final-year linguists
13579#GRACE—a call system for the acquisition of reading skills
13580#CAL in Italian at the University of Leeds
13581#A sense of perspective: CALL for Russian
13582#Computers in Arabic language teaching
13583#Computer assisted reading—work in progress at the University of East Anglia
13584#Analysis of conjugation mistakes in French verbs on a microcomputer
13585#Computer assisted learning or computer inhibited acquisition?
13586#New approaches to computer aided language learning
13587#Help levels in CALL materials
13588#CALLS: computer-assisted language learning simulation
13589#The potential of computerized interpreting in teaching
13590#Computerized information retrieval system for undergraduates of Spanish
13591#The ideal teaching machine
13592#Topics in computer education: national educational computer policy alternatives
13593#Introduction to National educational computer policy alternatives
13594#E2 = M x C2: excellence in education = motivation times commitment times commitment
13595#Computers and education: the need for research
13596#Evaluating computer education programs in the schools
13597#Planning strategies and considerations for the effective use of the emerging technology
13598#Computers and the shape of the future: implications for teaching and learning
13599#Ethics of information technology in the educational system
13600#Education and computing: its relevance to our probable future
13601#Information technology and education: public policy and America's future
13602#Information technology: human impacts and federal policy
13603#Academic software—vision and perspective
13604#What is fundamental in an information age? A focus on curriculum
13605#Learning from the past: guidelines for the future
13606#The costs of personal computing in an educational institution: a case study
13607#The role of federal policy in stimulating appropriate use of computers in elementary-secondary schools
13608#Difficulties in realizing large-scale educational computing projects
13609#Federal assistance for computers in elementary and secondary schools
13610#How will computing change education?
13611#Computers in the schools: the federal role
13612#Drawing a random sample from a density selected at random
13613#On estimating the number of components in a finite mixture of power series distributions
13614#Dimension reduction for predictive discrimination
13615#Penultimate versus ultimate in statistical theory of extremes-A simulation study
13616#The number of minimally connected block designs
13617#Venture capital financing in the computer industry
13618#The 1984 federal computer crime statute: A partial answer to a pervasive problem
13619#Litigating computer trade secrets in California
13620#Copyrightability of object code and ROM in Japan, Australia, and Germany: Surpassing traditional copyright limits
13621#Copyright law and integrated circuit protection: When the chips are down
13622#Third-party computer leases: The effect of the lessor's bankruptcy
13623#Software Metrics
13624#Modular programming tools
13625#Cross-referencing in C and Pascal
13626#A guide to real-time executives
13627#Power tools for programmers: 12 editors for the IBM PC
13628#Six make utilities to keep you up-to-date
13629#Multiply by small fractions without floating point
13630#MS-DOS BASIC preprocessors
13631#REXX: A beginner's alternative
13632#GKS: The new graphics standard
13633#Area filling algorithms
13634#Clipping and filling polygons
13635#Contour plots of large data sets
13636#Eight Pascal compliers for your IBM PC
13637#Two Pascal compilers for the Macintosh
13638#Turbo Pascal in the public domain
13639#Pattern matching languages
13640#Generation of high order surfaces over arbitrary polyhedral meshes
13641#Incremental generalized integrator
13642#ALG: a model for generating alternative layout graphs under architectural constraints
13643#A matrix approach to the analysis of recursively generated B-spline surfaces
13644#SML: a solid modelling language
13645#Using CAD macros and languages for productivity on a Unigraphics system
13646#Academic institutions and information services: the position of the library
13647#PRACTIBASE: a very practical choice for database management
13648#Dynamic line segment intersection search algorithms based on computational geometry and their applications
13649#Dynamic task scheduling for control of hot strip mill lines
13650#Parallel processing of robot-arm control computation using multi-processor scheduling algorithms
13651#WSM and its application—designing of a lift control system in WSM
13652#A specification of a scheduler using WSM
13653#Metalevel description in WSM
13654#Approximation algorithm of a fuzzy graph
13655#A note on concatenated codes and product codes (2)
13656#One approach to the research laboratory system
13657#Information society and information network system
13658#An analysis of information retrieval systems with cluster-outputs
13659#Towards an intelligent knowledge-based CAI system, considering the student's learning states
13660#Stroke extraction methods for "Hiragana" character patterns
13661#Non-stationary analysis of speech by a hierarchical linear prediction method
13662#An application of a formal approach to the reconstruction of large software
13663#The roles of computer at the department of psychology and the problems thereof: case report
13664#The extended communication mechanism of CSP
13665#A note on concatenated codes and product codes, part I: concatenated codes
13666#A neural network model for the mechanism of pattern information processing
13667#Teaching programming on a personal computer: design and system overview
13668#A software development environment to support abstraction mechanisms
13669#Instructor-learner paradigm for the study of problem solving and its applicability
13670#Applications of knowledge engineering to software prototyping
13671#The system FLm,n for specification analysis and an automatic theorem prover for FLm,n
13672#A research on VLSI layout pattern design methods
13673#Selection of word-candidates based on vector quantization for speaker independent word recognition
13674#A parallel processing scheme for an iterative IF statement on a multiprocessor system
13675#An example of computer utilization in Oriental studies—problems and prospects
13676#A proposal of behavioral simulation system based on frame theory
13677#Steady-state analysis of nonlinear oscillatory circuits by a simplicial homotopymethod
13678#The information processing symbols of a hierarchical flowchart language hichart
13679#Application and control of Centre for Informatics of Waseda University
13680#On the flow between two rotating rounded discs
13681#The calculations of supersonic viscous flows using the parabolized Navier-Stokes equations
13682#The heat transfer from a sphere in free convective flow
13683#A finite-difference scheme for the solution of the steady Navier-Stokes equations
13684#Computation of the maximum flow rate of a perfect gas through a slit in a plane wall
13685#Fluid flow and heat transfer past two spheres in a cylindrical tube
13686#Creeping motion of a cylinder through incompressible fluid bounded by a coaxial closed cylinder
13687#An implicit, conservative, zonal-boundary scheme for Euler equation calculations
13688#Preconditioned conjugate residual methods for the solution of spectral equations
13689#Shock-wave laminar boundary-layer interaction in supercritical transonic flow
13690#Separated supersonic flow past a trailing edge at incidence
13691#Micropolar flow past a porous stretching sheet
13692#Calculation of quasi-one-dimensional flows with shocks
13693#Computation of two-dimensional time-dependent natural convection in a cavity where there are internal bodies
13694#Analysis of free-surface flows past overflow gates using finite element method
13695#The prediction of laminar inclined flow through tube banks
13696#On the management organization and procedural standardization of geologic research
13697#FASP,an analytic resource appraisal program for petroleum play analysis
13698#An application of coconditional simulation for petroleum exploration
13699#Cokriging: multivariable analysis in petroleum exploration
13700#Correcting well-log information for computer processing and analysis
13701#WSULOG,microcomputer-based well-log evaluation for cabonate reservoirs in Kansas
13702#Color images of Kansas subsurface geology from well logs
13703#Geological and computer traps in petroleum exploration
13704#Trend-surface analysis revisted--a case history
13705#The application of remote sensing to Canadian petroleum exploration: promising and yet unexploited
13706#WSU-MAP: a microcomputer-based reconnaissance mapping system for Kansas subsurface data
13707#Geostatistical analysis of gas potential in Devonian shales of West Virginia
13708#Computerization of biostratigraphic data collection and analysis
13709#Distribution of Cenozoic foraminifera from the northwestern Atlantic margin analyzed by correspondence analysis
13710#The isolated effects on porosity of grain sizes in binary mixtures
13711#Extracting genetic information from coarse clastic modes
13712#Paradox 1.1: more power and less pain
13713#DOCumentary evidence
13714#Two tips to get the user's attention
13715#How to save damaged dBASE files
13716#Programming in PAL
13717#User-defined validation and context-specific help
13718#Extending the power of dBASE
13719#Bugs & fixes
13720#Setting up your database
13721#Externalizing variables
13722#Flexible database definitions
13723#Exceptional utilities and other niceties
13724#LEAP: an alternative AI language
13725#Expand your system's knowledge base
13726#Fifth generation languages: what are they good for?
13727#Conventional programming and expert systems
13728#Five-minute PROLOG
13729#What's new with LISPs,PROLOGs, and expert systems
13730#Writing predicates
13731#Tag—you're it]
13732#Artificial intelligence in the public domain
13733#Relational data bases and SQL
13734#Establishing the high ground
13735#The BCS and the Engineering Council
13736#The Picture Book of Quantum Mechanics
13737#Microsoft BASIC Using Modular Structure
13738#Programming in BASIC for Business
13739#Understanding structured COBOL; (2nd ed.)
13740#Graphics for the Dot-Matrix Printer
13741#A Manual of Operation for the Automatic Sequence Controlled Calculator: Volume 8
13742#Theory of linear and integer programming
13743#Ada for conventional language programmers
13744#Packages: Ada's integrated circuit
13745#Logic, Binary, & Bits
13746#Enhancing dBASE III plus with assembly
13747#Forth: Another dimension
13748#Ada compilers: Mission-critical software for the PC-part I
13749#Recognizing input, Part II
13750#Scissors, paper, stone: A tournament of schemes
13751#Slime: A public domain, goal-directed language
13752#Multiprocessor ray tracing
13753#Overlap operations and raster graphics
13754#Generating lines using quadgraph patterns
13755#GKS-based graphics programming in PROLOG
13756#An image and text management system for editorial applications
13757#High performance colour displays for computer graphics
13758#Integration of town planning, landscaping and 3D architecture: Results and future enhancements since CAMP '83
13759#Loughborough workshop report: Scientific software based on GKS
13760#Static checking of variable handling in Dijkstra's guarded commands language
13761#Obtaining coroutines with continuations
13762#On processes, synchronization and redundant code in communicating sequential processes
13763#Program derivation in type theory: A partitioning problem
13764#Two-level grammar as an implementable metalanguage for axiomatic semantics
13765#Make way for progress
13766#Stalking bugs with dBIIIDebugger
13767#Compound interest with dBASE III
13768#Lite bar plus
13769#Handling critical errors
13770#Quick key work search
13771#Screen erasing techniques
13772#Is dRate the answer?
13773#Innovative R:BASE system V
13774#Hilite: Menus with no coding
13775#Alpha/three: Is it dBASE junior?
13776#How to save damaged dBASE files. Part 2: internal details of dBASE data files.
13777#Recursion in dBASE
13778#Introducing PAL: The paradox applications language
13779#Exploding data files
13780#Finding the day of the week
13781#Ramclear utility
13782#Operating environments: supercharging your AT
13783#Track personal investments with simple graph
13784#New tools for worktech workbench
13785#How to save damaged dBASE files. Part 1: an introduction to dBASE files.
13786#Designing dBASE screens
13787#Managing multiple files
13788#Stamp out sluggish screens
13789#Maximum printer control
13790#Save and recreate dBASE III “Views”
13791#Clipper multi-user utilities
13792#Clipper extensions to the dBASE language
13793#Using unique dBMAN functions
13794#Selected proceedings from the CAL '85 Symposium on Computer assisted learning
13795#On a purely Lagrangian formulation of sloshing and fluid-induced vibrations of tanks
13796#Simulation of forming processes, using the arbitrary Eulerian Lagrangian formulation
13797#Finite element analysis of steady nonlinear harmonic oscillations of axisymmetric shells
13798#Fluid-structure interaction of tanks with an eccentric core barrel
13799#A three-dimensional finite-strain rod model. Part II: Computational aspects
13800#IBM PC assembler language and programming
13801#Proceedings of a conference on Mathematics and its applications on Algebraic and geometric methods in nonlinear control theory
13802#Proceedings of the international conference on APL: APL and the future
13803#Application development systmes: the inside story of multinational product development
13804#UNIX shell programming
13805#The MUNAP computer: structures and applications of a microprogrammable, parallel computer with nonnumeric functions
13806#Information technology and a new international order
13807#Software engineering: a programming approach
13808#Natural and artificial intelligence: processor systems compared to the human brain
13809#Extending AppleWorks: advanced features & techniques
13810#Understanding statistics: Statpal, a statistical package for microcomputers: PC-DOS version 5.0 for the IBM PC and compatibles
13811#The report on integrated voice and data terminals
13812#Telecommunications annual planning report
13813#Learning about Logo for use with Apple II+, Apple IIe, and Apple IIc computers
13814#Graphs & digraphs (2nd ed.)
13815#The Apple programmer's challenge: 50 challenging problems to test your programming skills—with solutions in BASIC, Pascal, and C
13816#Programmer's challenge: 50 challenging problem to test your programming skills—with solutions in BASIC, Pascal, and C
13817#Multivariate approximation theory: selection topics
13818#Elementary decision theory
13819#Computer essentials: applications for the modern world
13820#Programming IBM PC BASIC
13821#Turbo Pascal: programming examples and subroutines
13822#Turbo Pascal programmer's guide
13823#Interactive workstations
13824#Ask Byte
13825#Data processing: current theories and practices (2nd ed.)
13826#Basic programming for the IBM PC
13827#Classroom activities for computer education
13828#The Paradox companion
13829#COBOB: elements of programming style: the art of programming IBM personal compu ters
13830#Bilingual computer dictionary: English/Afrikans
13831#Applied statistics and the SAS programming language (2nd ed.)
13832#Ada as a second language
13833#Human foundations of advanced computing technology: the guide to the select literature
13834#Trinet managerial information use report
13835#X/open portability guide
13836#Datapro reports on information security
13837#Creating reports and mailing labels with dBASE III plus
13838#Classification of minimally connected 23 factorial experiments
13839#Recursive instrumental variable estimation simultaneous equations with autoregressive disturbances
13840#An alternative to ordinary q-q plots: Conditional q-q plots
13841#Stratification by stepwise regression, correspondence analysis and recursive partition: A comparison of three methods of analysis for survival data with covaria
13842#Programming common distributions for precise 23-values
13843#Microprogram sequencers depart from classic architectures
13844#ICE makers grapple with 32-bit microprocessors
13845#RISCs and parallel processors drive multiprocessing innovations
13846#Advances in CMOS and ECL process technology yield powerhouse ICs
13847#Price and performance improvements drive design tool market
13848#Graphics developments geared toward speed and capacity
13849#CASE: automatic generation of electrical diagrams
13850#Representation of rational Be´zier curves and surfaces by recursive algorithms
13851#LSI layout using hierarchical design with compaction
13852#Calculations of the radiation configuration factor using ray casting
13853#Linear time geometrical design rule checker based on quadtree representation of VLSI mask layouts
13854#Approximate analytical methods for multi-dimensional Stefan problems
13855#An assessment of higher-order isoparametric elements for solving an elastic problem
13856#Symmetry, groups and boundary value problems. A progressive introduction to noncommutative harmonic analysis of partial differential equations in domains with geometrical symmetry
13857#Application of deformable-body mean axis to flexible multibody system dynamics
13858#A preconditioning technique based on element matrix factorizations
13859#A weighted group explicit method for the diffusion equation
13860#Generation of the compatibility matrix in the integrated force method
13861#Resultant-stress degenerated-shell element
13862#Microcrack-induced damage accumulation in brittle rock under dynamic loading
13863#A calculation procedure for three-dimensional steady recirculating flows using multigrid methods
13864#Moderate-degree tetrahedral quadrature formulas
13865#On time-harmonic elastic-wave analysis by the boundary element method for moderate to high frequencies
13866#A moving-mesh finite element method with local refinement for parabolic partial differential equations
13867#Basic principles of feedback and adaptive approaches in the finite element method
13868#A consolidation of various approaches in developing naturally based quadrilaterals
13869#An adaptive characteristic Petrov-Galerkin finite element method for convection-dominated linear and nonlinear parabolic problems in two space variables
13870#Efficient adaptive procedures for fluid-flow applications
13871#An accurate and efficient a posteriori control of hourglass instabilities in underintegrated linear and nonlinear elasticity
13872#Adaptive grid-design methods for finite delement analysis
13873#Automatic mesh generation allowing for efficient a priori and a posteriori mesh refinement
13874#Mesh design for the p-version of the finite element method
13875#Consistent linearization for path following methods in nonlinear FE analysis
13876#Zero and negative masses in finite element vibration and transient analysis
13877#Discontinuity-capturing finite element formulations for nonlinear convection-diffusion-reaction equations
13878#Adaptive finite element methods for the analysis of inviscid compressible flow: Part I. Fast refinement/unrefinement and moving mesh methods for unstructured meshes
13879#A computer program for evaluating risks in constructing choropleth maps by point sampling along transects
13880#SHALL4—an implicit compact fourth-order FORTRAN program for solving the shallow-water equations in conservation-law form
13881#GUSTAF: a quasi-Newton nonlinear ADI FORTRAN IV program for solving the shallow-water equations with augmented Lagrangians
13882#DIGMAP: a computer program for accurate acquisition by digitizer of geographical coordinates from conformal projections
13883#Management of the life and death of an earth-science database: some examples from GEOTHERM
13884#A program for 2D seismic-ray tracing in Benioff zones
13885#Automatic mineral deposit assessment using triangular prisms
13886#The effect of sealevel fluctuations in subsiding basins
13887#TETRASEZ: an interactive program in BASIC to perform tetrahedral diagrams
13888#Letter to the editor comment on “comparing splines and kriging”
13889#KALTA: a BASIC program for simulation of the experimental determination of the phase diagram for the system kalsilite—silica
13890#PERANORM: a BASIC program to calculate a modal norm for peraluminous granitoids
13891#Straightforward GINO-F map digitizing software
13892#HAZAN: a FORTRAN program to evaluate seismic-hazard parameters using Gumbel's theory of extreme value statistics
13893#SEDCODE: a FORTRAN 77 program for decoding sedimentological field data
13894#A computer program for the analysis of sieve and hydrometer data
13895#A simple BASIC program for computing terrain corrections on a microcomputer
13896#A computerized particle-size analysis system
13897#Borehole desurvey calculation
13898#New performance measures for design and evaluation of real-time multiprocessors
13899#Simulation study of multitasking of open computer system networks
13900#Methodology for complex system description via extended Petri nets
13901#Pseudo-exhaustive testing strategy for large combinational circuits
13902#Relectronic 85: economy and system reliability
13903#Annual review of computer science vol. 1, 1986
13904#DADO: a tree-structured architecture for artificial intelligence computation
13905#Frame-buffer display architectures
13906#Natural-language interfaces
13907#Advances in compiler technology
13908#Computer system performance evaluation using queueing network models
13909#Architecture and applications of a heterogeneous, massively parallel machine
13910#Computerized reconstruction and 3-D imaging in medicine
13911#Programming environments today
13912#Sequential and parallel algorithms for finding maximum matchings in graphs
13913#Dataflow architectures
13914#Knowledge representation and reasoning
13915#Type architectures, shared memory, and the corollary of modest potential
13916#Information-based complexity
13917#Qualitative student models
13918#SUPRENUM—a MIMD multiprocessor system for large scale scientific computing
13919#Comparing causes of system failure
13920#Event-flow computation as key to fast digital design simulation
13921#C_TPDL*: adapting TPDL* to concurrent simulation environments
13922#A gate-level simulator for MS-DOS personal computers
13923#A Pascal-like portable, interactive development system for small microcontrollers
13924#Embedded microcontroller operating system with state-machine support
13925#Interpretive execution of program code increases software robustness in embedded computer systems
13926#A Prolog preprocessor for Warren's abstract instruction set
13927#A new strategy for interpreting LISP
13928#A blackboard based robot position estimator
13929#A CAD tool box for VLSI around a hardware description language
13930#An expert system for mapping computer architectures into semicustom integrated circuits
13931#Compiling an RT level hardware description level into layout of NMOS cells
13932#A two-dimensional hardware design language for VLSI
13933#A concurrent network simulator for automated protocol development and performance evaluation
13934#A local area network with dynamic switch-over between a CSMA/CD and a token-passing access protocol
13935#Virtual token access method and its implementations
13936#Design of a VLSI communicating circuit for an industrial local network in control process and automated production
13937#Concurrent systems, programming primitives and languages: a comparative study
13938#VLSI-based monitoring of the inter-process-communication in multi-microcomputer systems with shared memory
13939#Cache interleaving in multiprocessor systems
13940#A shared-memory MODULA-2 multiprocessor for real-time control applications
13941#Integrated computer support in the software engineering environment EPOS
13942#The design and prototype implementation of a “structure attribute” model for tool interfacing within an IPSE
13943#Automatic hardware synthesis from a behavioural description language: OCCAM
13944#An algorithm for the synthesis of processor structures from behavioural specifications
13945#An automatic microcode generator for high level language machines
13946#Diagnosis by comparison with faulty comparators
13947#An approach to fault-tolerance in architectures for discrete Fourier transforms
13948#Interfacing VME-bus to a fault-tolerant architecture in the industrial environment
13949#EDDA, a language based on Petri nets and the dataflow principle for the development of parallel programs
13950#Message passing and graph transformations: a model of actor computation
13951#A new methodological proposal for program maintenance
13952#Synthesis of control structures from Petri net descriptions
13953#VLSI-top-down design based on the separation of hierarchies
13954#Optimizations in high level synthesis
13955#Intelligence driven test sequence generator for VLSI design
13956#BAT: optimization algorithms and overall design of a behavioral automatic tester
13957#Test generation for circuits described in procedural hardware description languages (HDLs)
13958#Realtime high level debugging in host/target environments
13959#DISDEB: an interactive high-level debugging system for a multi-microprocessor system
13960#Monitoring tools for multiprocessors
13961#A pre-design tool for a class of parallel processing systems
13962#Design methodology for low-power full custom RISC microprocessors
13963#VLSI implementation of linear feedback shift registers for microprocessor applications
13964#Fast and dense embedded arrays for microprocessors in CMOS-technology
13965#The MADMACS layout system
13966#Object oriented system supporting dynamic configuration
13967#Study of a class of conflict resolution strategies for synchronous multiprocessor interconnection networks
13968#Multichannel protocols for real-time microcomputer networks
13969#Research and design of a communication subnet for supporting distributed systems
13970#A model of the I/O subsystem of the Philips P4500 minicomputer
13971#Disk space allocation schemes for real-time data gathering applications
13972#Multimedia filing & retrieval based on optical and magnetic mass-storage technologies
13973#AMDAS—an advanced microprogrammed data acquisition system: a first evaluation prototype
13974#An image processor for a multi-image processing system
13975#Multiwindow screens without window overlapping
13976#SMAX—a CONLAN member language for verifiable hardware descriptions
13977#An extension to base CONLAN in the temporal domain
13978#A language for behavior, structure and geometry
13979#An RSA cryptography processor
13980#A VLSI architecture for the central processor of a digital switch
13981#On the physical interconnection of a CTD multiprocessor
13982#Software metrics: a critical evaluation and an application to PASCAL
13983#Quantitative evaluation and selection criteria for implementations of decision tables
13984#Information retrieval using microcomputers
13985#The dependency notation as a graphical description language for logic design and silicon compilation
13986#Semantics of a hardware specification language
13987#Microprocessors in factory automation—a case study of an automated guided vehicle system and its integration into a hierarchical control structure
13988#A precisely timed fully parallel process input/output facility for control applications
13989#Capacity and performance prediction in large distributed microprocessor systems under increasing processing speed
13990#Workload generator for the performance analysis of some Philips minicomputers
13991#Proceedings of the symposia 1983 and 1984 on RIMS symposia on software science and engineering II
13992#A fast parallel merging algorithm for 2-3 trees
13993#Evaluation of graph representations with active nodes
13994#On equivalence transformations for term rewriting systems
13995#A portable logic simulation system for development of FLATS machine
13996#Partial computation with a dataflow machine
13997#OR-parallel optimizing Prolog system: POPS its design and implementation in concurrent Prolog
13998#Incorporating naive negation into Prolog
13999#Algebraic specification method of programming languages
14000#Multiversion concurrency control scheme for a distributed database system—a trial to break concurrent update of redundant copies
14001#Global storage allocation in attribute evaluation
14002#On program transformation with tupling technique
14003#Evaluation of working set algorithms for data-flow machines
14004#Comparison of closure reduction and combinatory reduction schemes
14005#The BC-chain method for representing combinators in linear space
14006#Circuit simulation code generation by computer algebra
14007#Achieving CAD productivity through user programmable languages
14008#Fundamentals of artificial intelligence: an advanced course
14009#Knowledge representation: features of knowledge
14010#Deduction and computation
14011#An introduction to automated deduction
14012#Fundamental mechanisms in machine learning and inductive inference
14013#Methods of automated reasoning
14014#Term rewriting as a basis for the design of a functional and parallel programming language. A case study: the language FP2
14015#Concurrent PROLOG: a progress report
14016#Advanced computer architecture
14017#The impact of classification schemes on computer architecture
14018#The CRAY-1 computer system
14019#Design of a massively parallel processor
14020#A controllable MIMD architecture
14021#A pipelined, shared resource MIMD computer
14022#The FLEX/32 multicomputer
14023#The varieties of data flow computers
14024#A hardware design of the SIGMA-1, a data flow computer for scientific computations
14025#Cedar—a large scale multiprocessor
14026#SIMD and MSIDM variants of the NON-VON supercomputer
14027#High speed arithmetic arrays
14028#Bit sequential arithmetic for parallel processors
14029#The expression processor: a pipelined, multiple-processor architecture
14030#Towards a family of languages for the design and implementation of machine architectures
14031#Design and performance of generalized interconnection networks
14032#Dynamic accessibility testing and path length optimization of multistage interconnection networks
14033#Analysis of multiple bus interconnection networks
14034#Effectiveness of private caches in multiprocessor systems with parallel-pipelined memories
14035#Instruction issue logic for pipelined supercomputers
14036#Synchronous nets for single instruction stream multiple data stream computers
14037#Performance of the butterfly processor—memory interconnection in a vector environment
14038#Analysis of chordal ring network
14039#Generalized hypercube and hyperbus structures for a computer network
14040#Some new results about the (d,k) graph problem
14041#A simulation study of multimicrocomputer networks
14042#Modeling algorithm execution time on processor arrays
14043#Optimal load balancing strategies for a multiple processor system
14044#A task allocation model for distributed computing systems
14045#Evaluating the performance of multicomputer configurations
14046#The Cm* testbed
14047#New design methodologies and circuits needed for parallel VLSI supercomputers
14048#The peripheral processor PP4: a highly regular VLSI processor
14049#Why systolic architectures?
14050#Introduction to the configurable highly parallel computer
14051#The transputer
14052#Dictionary machines with a small number of processors
14053#PASM: a partitionable SIMD/MIMD system for image processing and pattern recognition
14054#A pipelined pseudoparallel system architecture for real-time dynamic scene analysis
14055#DADO: a parallel processor for expert systems
14056#Performance studies of a PROLOG machine architecture
14057#Computer conferencing and online education: designing for the medium
14058#Ranganathan, cognition and expert systems
14059#Guide to microcomputer software sources
14060#The inverted index: a semiotic approach
14061#Telidon and Manitoba
14062#Online searching: a five star review of research
14063#Problems of information science research—an opinion paper
14064#From librarian to information scientist: educational directions for a changing profession
14065#UNIX:3E system readings and applications. Volume I: UNIX:3E time-sharing system
14066#The UNIX time-sharing system
14067#UNIX implementation
14068#A retrospective
14069#The UNIX shell
14070#The C programming language
14071#Portability of C programs and the UNIX system
14072#The MERT operating system
14073#UNIX on a microprocessor
14074#A minicomputer satellite processor system
14075#Document preparation
14076#Statistical text processing
14077#Language development tools
14078#The programmer's workbench
14079#The UNIX operating system as a base for applications
14080#Microcomputer control of apparatus, machinery, and experiments
14081#Circuit design aids
14082#A support environment for MAC-8 systems
14083#No. 4 ESS diagnostic environment
14084#RBCS/RCMAS—converting to the MERT operating system
14085#The network operations center system
14086#First Page of the Article
14087#First Page of the Article
14088#First Page of the Article
14089#First Page of the Article
14090#First Page of the Article
14091#First Page of the Article
14092#Modula-2: discipline & design
14093#Applied C
14094#Microprocessors and microcomputers: the 6800 family
14095#The UNIX system encyclopedia
14096#On the equivalence of mode decomposition and mixed finite elements based on the Hellinger—Reissner principle: part I: theory
14097#On the equivalence of mode decomposition and mixed finite elements based on the Hellinger—Reissner principle: part II applications
14098#Stock-free transonic airfoils with a given pressure distribution
14099#A new finite element formulation for computational fluid dynamics: III. The generalized streamline operator for multidimensional advective-diffusive systems
14100#A new finite element formulation for computational fluid dynamics: IV. A discontinuity-capturing operator for multidimensional advective-diffusive systems
14101#Numerical simulation of viscous flows in hydraulic turbomachinery by the finite element method
14102#Limitations of Galerkin's method in optimal design of beam columns
14103#An equal-order velocity-pressure formulation that does not exhibit spurious pressure modes
14104#Unconditionally stable concurrent procedures for transient finite element analysis
14105#A mathematical programming approach to three-dimensional contact problems with friction
14106#Galerkin finite element analysis of complex viscoelastic flows
14107#An arbitrary Lagrangian-Eulerian finite element method for path-dependent materials
14108#Computing in America: Electronic Learning's sixth annual survey of the states
14109#IBM's college grants unlock research potential
14110#Barriers slow use of technology in colleges
14111#Catching knowledge in neural nets
14112#Intelligence and the computer
14113#Understanding frame languages, part II
14114#Knowledge engineering in practice
14115#Retrieval from a frame data base
14116#Pascal and LISP: a tale of two languages
14117#Second thoughts about AAAI'86
14118#Level five research: Insight 2+
14119#Multipurpose inspection task simulator
14120#A cross decomposition procedure for the facility location problem with a choice of facility type
14121#Production management applications for microcomputers: survey and analysis
14122#A generative simulation-optimization system
14123#Interfacing simulation models for predicting profitability of irrigated grain sorghum
14124#Wavesolder assistant: an expert system to aid troubleshooting of the wave soldering process
14125#Su models of the maximum of several dependent random variables: development and computer application
14126#A sorting program for orientation analysis of data on a sphere
14127#PT-SYSTEM, TX-SYSTEM, PX-SYSTEM: three programs which calculate pressure-temperature-composition phase diagrams
14128#NPSTAT: a FORTRAN-77 program to perform nonparametric variable-by-variable comparisons on two or more independent groups of data
14129#SOIL PROFILE RECORDER: a program to enable the recording of soil profile descriptions in the field
14130#REGRES: a FORTRAN-77 program to calculate nonparametric and :20structural” parametric solutions to bivariate regression equations
14131#Efficient selection, storage, and retrieval of irregularly distributed elevation data
14132#COSIM: a FORTRAN IV program for coconditional simulation
14133#A computer program for reconstructing blocky rock geometry and analyzing single block stability
14134#The construction of digital terrain models on small computers
14135#SPHERE: a contouring program for spherical data
14136#DENBRAN: a BASIC program for a significance test for multivariate normality of clusters from branching patterms in dendrograms
14137#A corrected CIPW program for interactive use
14138#Testing linear hypotheses in contingency tables with zero cell counts
14139#Re-sampling procedures for reducing bias of error rate estimation in multinomial classification
14140#Analysis of conditional covariance structure models
14141#An improved data-based algorithm for choosing the window width when estimating the density at a point
14142#A note on degrees of freedom in sparse contingency tables
14143#The pressure correction method
14144#Smoothing patched grids
14145#Spectral and finite difference solutions of the Burgers equation
14146#Applications of a conservative zonal scheme to transient and geometrically complex problems
14147#Numerical solution of the separating flow due to an obstruction
14148#A local mesh-refinement technique for incompressible flows
14149#Covering graphs by the minimum number of equivalence relations
14150#Eigenvalues, geometric expanders, sorting in rounds, amd Ramsey theory
14151#Packing and covering a tree by subtrees
14152#A non-analytic proof of the Newman:80Zna´m result for disjoint covering systems
14153#A characterization of the minimal basis of the torus
14154#On the sharpness of a theorem of B Segre
14155#Contractible edges in triangle-free graphs
14156#On the non-existence of Barker sequences
14157#Orthogonal vectors in the n-dimensional cube and codes with missing distances
14158#On Lova´sz' lattice reduction and the nearest lattice point problem
14159#The asymptotic number of acyclic digraphs
14160#A parity digraph has a kernel
14161#A size-width inequality for distributive lattices
14162#Constructing a perfect matching is in random NC
14163#Legal coloring of graphs
14164#Balancing vectors in the max norm
14165#The solution of Graham's greatest common divisor problem
14166#On the number of paths and cycles for almost all graphs and digraphs
14167#Proceedings of the International Symposium on Nanometer structure electronics
14168#The Church Computer Manual
14169#The mirco to mainframe communications directory, 2nd. ed.
14170#Data communications product directory, vol. 2
14171#How to evaluate and select local area networks/cabling systems
14172#The LAN software directory
14173#The LOCALNetter designer's handbook, 4th ed.
14174#The Commodore programmer's challenge: 50 challenging problems to test your programming skills—with solutions in BASIC, Pascal, and C
14175#The IBM programmer's challenge: 50 challenging problems to test your programming skills:8with solutions in BASIC, Pascal, and C
14176#Vector analysis; an introduction to vector-methods and their various applications to physics and mathematics
14177#Local area networks: an introduction to the technology
14178#Local area networks (LANs)
14179#Facsimile terminals
14180#Microcomputer data management software
14181#Local area networks and the data communications capabilities of PABXs
14182#Selecting and installing PABX systems
14183#Proceedings of the International Symposium on interval mathematics on Interval mathematics 1985
14184#Interpolation of an interval-valued function for arbitrarily distributed nodes
14185#Acceptable solutions of linear interval integral equations
14186#Maximization of multivariable functions using interval analysis
14187#Modal intervals: reason and ground semantics
14188#Convergent bounds for the range of multivariate polynomials
14189#On an interval computational method for finding the reachable set in time-optimal control problems
14190#On the optimality of inclusion algorithms
14191#Interval operators and fixed intervals
14192#Arbitrary accuracy with variable precision arithmetic
14193#An interval method for systems of ODE
14194#Linear interval equations
14195#How to fight the wrapping effect
14196#Arithmetic of circular rings
14197#Improved interval bounds for ranges of functions
14198#Inner solutions of linear interval systems
14199#Embedding theorems for cones and applications to classes of convex sets occurring in interval mathematics
14200#Interval test and existence theorem
14201#Technical calculations by means of interval mathematics
14202#Generalized theory and some specializations of the region contraction algorithm I - Ball operation
14203#Complex and distributed systems: analysis, simulation, and control
14204#A measure of transaction processing power
14205#String-matching cannot be done by a two-head one-way deterministic finite automation
14206#Experiments with trees of the storage and retrieval of future events
14207#Approximate storage utilization of B-trees
14208#Lower and upper bounds of the sizes of domains: estimates and experiments
14209#Determining the shape of a convex n-sided polygon by using 2n+k tactile probes
14210#Set-theoretic problems of null completion in relational databases
14211#Batched search of index sequential files
14212#On the calculation of control transition probabilities in a program
14213#Winchester/cartridge/optical disk drives
14214#Communications capabilities of micros and micro-to-mainframe links
14215#Switch/nonswitched transmission facilities
14216#Proceedings of the ACM SIGCOMM conference on Communications architectures & protocols
14217#MAP is a standard computer networking discipline and a unified set of communications protocols which make it possible to implement a vendor independent network of computers. MAP provides a complete service to the user or application program. The major facilities, file transfer, process to process messaging, inter-machine messaging, and directory service are supported. Virtual terminal protocol support is planned for the near future.MAP is a subset of the internationally agreed Open Systems Interconnection computer networking architecture, protocols and supporting standards. The MAP subset of OSI Protocols was originally selected by General Motors and has been agreed by a MAP Task Force comprised of nearly 100 user and vendor corporations. MAP specifications are also agreed by the NBS/OSI Implementor's Workshop, indicating that the MAP specifications are OSI compatible.The MAP System and Protocols are described here in sufficient detail to permit the reader to gain a general understanding of MAP against a background of OSI fundamentals. The future growth trends for MAP conclude this paper.
14218#The state of the art in protocol engineering
14219#Consider the problem of providing a logical channel for message exchange between two user processes in a network environment. When is protocol conversion needed? To answer this question, we first define a model of layered architectures. Specifically, three stepwise refinement rules are given. Any architecture that can be obtained by a sequence of applications of the stepwise refinement rules is said to be well-structured. We show that this class of well-structured architectures has several correctness properties. It is also very general and includes many well-known networking and internetworking architectures in the literature. Logical connectivity in such an architecture is defined recursively. As a result, to determine if a logical channel can be provided between two user processes, it is sufficient to examine peer protocols specified for each level of the architecture's hierarchy of processes one at a time. Thus the original problem reduces to the problem of determining if a set of processes will interoperate.When protocol conversion is needed to achieve interoperability between processes that implement different protocols, how should it be done? How does one prove that a conversion is correct? What is meant by a correct conversion? We propose the use of projections and image protocols (previously developed by Lam and Shankar for protocol verification [10]) for specifying conversions and for reasoning about the correctness of conversions. Given two processes implementing different protocols P and Q, our objective is to find the largest protocol that is an image protocol of P as well as Q. The correctness of the conversion is a consequence of the correctness properties of image protocols.There are several open problems. Most importantly, heuristics are used for finding the necessary image protocol for conversion. Although, an image protocol common to both P and Q can always be found, it may not be easy to find one with useful functionality. There are also some implementation and design issues to be addressed, such as: the construction of converters that are transparent and converters that add functionality to an image protocol common to P and Q.
14220#The need for the protocol conversion has been recognized with the proliferation of heterogeneous networks. From a formal viewpoint, we regard that problem as generating a protocol which satisfies the properties of the conversion. In this paper, we prove that, one can determine whether a converter exists, for some protocol classes, given protocols in the form of communicating finite automata, Moreover, we give a construction method for such a converter for those classes, and derive an upper bound of the computational complexity of the construction algorithm.
14221#Demand assignment protocols have been implemented in a large number of operational LANs. However, the analytic models for protocol evaluation currently capture only a limited range of LAN operational circumstances. In this paper we present an analytic tool for evaluating fair and prioritized demand assignment protocols with a relatively general workload model. We consider arbitrary and station dependent message size distributions and arrival rates. This allows the modeling of LANs with heterogeneous workloads, thus permitting a larger correspondence between the modeled system and the real life network.
14222#Most recently proposed optical fiber-based LAN architectures may be considered as different implementations of the basic round-robin transmission service in different topologies using special signal patterns or events to achieve the effect of the token passing protocol. Prioritizing the transmission of various data and control messages is necessary for time-critical applications (e.g. in data sensor or process control applications). Some extensions of the basic CSMA-CD protocol to handle packet priorities have been proposed for bidirectional channels but prioritized multiaccess protocols taking advantage of the unidirectional property of optical channels do not appear to be widely available yet. The main thrust of this paper is to propose some distributed prioritized multiaccess protocols for twin-bus optical channels. We will introduce two prioritized protocols: one uses the token packet to convey and enforce priorities and the other employs time-outs to achieve prioritization. Our protocols require only backlogged stations to be active.
14223#This paper describes an implementation of a real-time, packetized voice communication system over a personal computer (PC) based token-passing ring local area network. System configuration and operation are presented. The system implements real-time, conversational transmission of voice packets between two stations on the network. An analysis is shown to calculate the maximum number of two way conversations that can be handled by the system without any reconstitution delay.
14224#A well known disadvantage of standard token-passing in ring and bus networks is the waste of channel bandwidth often seen in lightly loaded or asymmetric systems. It is possible to make use of the broadcast mechanism in token bus systems to distribute nearly up-to-date information about the state of individual stations to the entire system. One such scheme involves the determination of a randomly varying set of more active stations. These stations are given a chance to form a second logical ring above the standard logical ring that characterizes the token bus. The transmission cycles of the system can thus be made to alternate between standard token-passing and transmission cycles, and the cycles of token-passing and transmission within the logical ring of more active stations. We assume that each station makes at most one transmission when given the chance to transmit. For Poisson arrivals and otherwise general input distributions, the cycle-time distribution of the token is derived for each kind of cycle. An important random variable is the random token turnaround time seen by individual stations. For lightly loaded stations this time tends to be larger than for heavily loaded stations. The distribution of this random time, simple performance measures, and a comparative measure of stability, showing the adaptive scheme to be more stable than the standard, are obtained.
14225#As a user's computing environment grows from a single time-shared host to a network of specialized and general-purpose machines, the capability for the user to access all of these resources in a consistent and transparent manner becomes desirable. Instead of viewing commands as binary files, we expect the user to view commands as services provided by servers in the network. The user interacts with a personal workstation that locates and executes services on his behalf.Executing a single service provided by any server in the network is useful, but the user would also like to combine services from different machines to perform complex computations. To provide this facility we expand on the UNIX notion of pipes to a generalized pipeline mechanism containing services from a variety of servers. In this paper we explain the merits of a multi-machine pipeline for solving problems of accessing services in a heterogeneous environment. We also give a design and performance evaluation of a general mechanism for multi-machine pipes using the DARPA UDP and TCP protocols.
14226#A five-layer simulation model of OSI protocols is described and applied to predict transport performance on a local area network (LAN). Emphasis is placed on time-critical applications typical of a small, flexible manufacturing system. The results predict that, with current technology, OSI protocols can provide 1.5 Mbps throughput, one-way delays between 6 and 10 ms, and response times between 15 and 25 ms. The results also indicate that CSMA/CD is a reasonable access method for time-critical applications on small, factory LANS, if loads of less than 40% are anticipated. For loads between 40% and 70%, a token passing access method provides better performance for time-critical applications.
14227#We present a verified sliding window protocol which uses modulo-N sequence numbers to achieve reliable flow-controlled data transfer between a source and a destination. Communication channels are assumed to lose, duplicate and reorder messages in transit. The destination's data needs are represented by a receive window whose size can vary with time. The destination entity uses acknowledgement messages to inform the source entity of the current receive window size and the sequence number of the data word next expected. The source entity responds by sending segments of data words that lie within the allowed window. Each data segment is accompanied by an identifying sequence number and the size of the data segment. The destination entity also uses selective acknowledgement and selective reject messages to inform the source entity of the reception or lack of reception, respectively, of out-of-sequence data segments. Thus, this protocol is a proper extension of the Arpanet's TCP. We have obtained the minimum value of N that ensures correct data transfer and flow control, in terms of the minimum message transmission time, the maximum message lifetime, and the maximum receive window size. The protocol imposes no constraints on the retransmissions of messages or on the data segment sizes; thus, any retransmission policy that optimizes the protocol's performance can be used.
14228#We use a hybrid model based on the first-order logic to specify and verify a transport layer protocol. In this model we specify a protocol as a set of state machines. Time expressions are used to describe the temporal relations of transitions. Given the specification of a protocol, we verify its properties by logical deduction. Reasoning techniques such as decomposition and abstraction are used to reduce the verification complexity.The transport protocol consists of an active process, a passive process, and two communication channels. Each of these components is specified by this model. An outline of verification of this protocol is given.
14229#The integration of voice and data transmission on a CSMA/CD LAN with message priority and deterministic collision resolution is studied. As a result an efficient Stream Traffic Protocol using hybrid switching and implicit token passing is designed. The performance of the protocol both for voice and data is analysed using a discrete event simulation model. The protocol increases the system capacity for voice while the strict real-time constraints for its transmission are still met. It supports a number of subscribers comparable with the equivalent to the capacity of a small PABX, with a good performance for data. The work is part of an overall project of an integrated services LAN offering ISDN S-interfaces.
14230#A new, fully-distributed protocol for integrated voice/data traffic in a local-area, random-access broadcast network is described. The protocol introduces a movable voice-data boundary to framed TDMA/CSMA and eliminates the requirement of system-wide synchronized clocks. The movable boundary is a major advantage in any system where fluctuations in voice and data loads are expected because assignment of idle capacity from one traffic class to the other increases the utilization of the channel. The protocol provides collision-free virtual circuits for voice and periods of non-persistent CSMA/CD for data traffic and call establishment, and can support multi-party calls as well as two-way conversations. The protocol allows variable-size voice packets that have very low overhead and variable-size data packets that may be much longer than voice packets. This is of significant practical advantage over previous work, which has required fixed-size voice and/or data packets, or voice packets with high overhead. A method of dynamically controlling the movable boundary to balance the voice and data traffic is also proposed.
14231#L-Express is a protocol for Local Area Networks based on a single bus topology. It utilizes a simple and efficient virtual token access scheme which provides ordered and collision-free transmission.This paper presents results of measurements performed to investigate in details the behavior of the L-Express protocol under different network speeds, configurations and traffic environments. The measurements are obtained using a mix of simulation and field tests on a network prototype. Voice and integration of voice and data are also taken into account.The results indicate a good behavior (compared with Ethernet) for small size networks (500 m) and Low data rates (10 Mb/s) as well as for Large size networks (5000 m) and high data rates (100 Mb/s).
14232#We present an object-oriented architecture for a computer-based, real-time, multimedia conferencing system. This architecture divides the system into five functional areas: a multimedia shared workspace, a user interface, conference management, communications, and an information base. The structure and operation of the first four areas are modeled with object-based concepts that address design requirements identified during the development of a proof-of-concept prototype, that preceded the architecture specification.The shared workspace, the most important component, is thoroughly discussed; the other components support its realization. The modeling of workspace entities emphasizes their aggregation into composed entities and the homogeneous handling of several data media. The user interface manages uniformly the man-machine interaction for both local and remote user actions. Conference management deals with session establishment, participation, and control of multiple media floors. The communication functions replicate user actions over workspace objects in all hosts participating in a conference, matching traffic types with transmission services in the process.
14233#The tier automation is presented as a model for communication protocols. Several advantages of the model are cited, among which are universality of representation and manipulability. A scheme for using the tier automation to model specific distributed architectures and their protocols is described. The scheme is then used on a sample protocol and a transmission session with the sample protocol as exhibited.
14234#Deriving protocol specifications from service specifications
14235#Petri net is a powerful model for analyzing communication protocols because they share many common properties. Currently, protocol analysis suffers the state explosion problem especially for error-recoverable protocols and multi-party protocols. Protocol synthesis relieves this problem by generating new and complicated protocols from simple subsets of the protocol models. Reduction analysis provides theoretical ground for correct synthesis or expansion. Thus, reduction is a very important research area. In this paper, we present a general Petri net reduction algorithm that reduces the number of states while preserving all desirable and undesirable properties. To the best of our knowledge, this is the first general Petri net reduction algorithm for protocol analysis. We first present and extend Dong's [DON 83] definition of WBMs to include more subnets as WBMs. To render the reductions automated, a new concept of simple well-behaved modules (SWBMs) is introduced. Recursively performing reductions of SWBMs, complicated WBMs can be reduced. A main program is written to implement this recursive procedure. The problem is then reduced to finding conditions for SWBMs. We do this by progressing from simpler SWBMs to more complicated ones, i.e., from single-arc ones to multi-arcs ones. Finally, we demonstrate the usefulness of this algorithm by applying it to the state exploration in protocol synthesis. Other applications such as error detection, performance evaluation, and software engineering will be discussed in future.
14236#LOTOS is an executable specification language for protocols and services currently being standardized within ISO. It is based on an extended version of Milner's Calculus of Communicating Systems (CCS) and ACT ONE Abstract Data Type formalism. After a brief introduction to LOTOS, we give here an account of a prototype LOTOS interpreter, which includes an interactive system that allows the user to direct the execution of a specification. The interpreter was implemented in YACC/LEX, C, and Prolog. The discussion includes the following topics: syntax and static semantics analysis; translation from LOTOS external format to internal representation; evaluation of Abstract Data Type value expressions and CCS* clauses.
14237#The development of “very high speed” networks is being motivated by emerging applications and is therefore attracting increasing attention. As demonstrated in the past, in conventional high speed systems the high ratio between the end-to-end propagation delay and the message transmission time severely restricts the system performance. Thus the increase in channel bandwidth may be accompanied by only a marginal increase in actual system capacity. In this paper we propose a network architecture which eliminates this problem by introducing a combined Frequency - Time Division based control of the high speed channel. We consider the implementation characteristics of the resulting multichannel system and show that the design of protocols in these systems is subject to unique channel control penalties. Specifically, we show that in addition to the relatively high cost of channel sensing, the allocation of channel on a demand assignment basis is hindered in the multichannel configuration by the time penalty involved in locating an idle channel and by practical limitations of multichannel node interface design. We therefore introduce a new class of “allocation” protocols in which the channel access is obtained without the aforementioned penalties. The allocation protocols build on message source and destination oriented transmission rights allocation, taking into account the implementation aspects of multichannel networks. We show that the class of “multichannel allocation” protocols covers the whole range of random access to fixed channel access control policies and introduce an analytic approach for a uniform analytic treatment. The analysis demonstrates the potential for a significant improvement in the system capacity and the average message delay, when compared to a conventional single (undivided) channel system.
14238#The definition of a backchannel architecture for open systems interconnection over satellite links has been the subject of the SENS-project1 The new proposal is based on existent international standards and uses the options of the ISO-class 4 transport layer protocol in order to enclose in level 4 data link control functions for unidirectional satellite links following the rules of the IBM-checkpoint protocol. This paper provides performance values of the SENS architecture in comparison with those of common satellite communication systems. With means of elementary probability theoretical methods an approximate analysis of the IBM-checkpoint protocol is accomplished. The results show that for large amounts of data the new architecture proves to be best suited for cost efficient use of public satellite data links.
14239#Multiprocessor computer systems have proven effective as high performance switching nodes in packet switched data communications networks. They are well suited to performing the required queuing, routing, and scheduling tasks, and can scale upward to provide higher system throughput when combined with software that exploits the parallelism provided by the hardware. This paper describes the packet switch used in the DARPA Wideband Packet Satellite Network and the Butterfly™ Multiprocessor on which it is based.
14240#Noahnet is a robust, highly available, high bandwidth local area network (LAN) architecture, in the implementation phase at the University of Delaware. Noahnet uses a distributed switch-oriented node topology, a flooding approach for message routing, and high bandwidth communication media. The purpose of this paper is to consider some of the important issues in detail such as: the various ways flood control can be implemented; their relative advantages/disadvantages; the functions of a node; and one possible implementation of a node in Noahnet. Expected performance of the Noahnet in comparison to Ethernet and token ring networks is also discussed. Though Noahnet uses more complex structure and protocol, we demonstrate that the overhead of using flooding in Noahnet is minimal and that a Noahnet node implementation is very simple and inexpensive. The paper concludes that Noahnet provides features such as robustness, high availability, high throughput, and high communication band width at almost no additional cost.
14241#In this paper we propose a methodology for conformity analysis of communication protocols. By conformity analysis it is meant to demonstrate that a protocol does indeed provide the service for which it is intended. We specify both a protocol and its service by a CSP (Communicating Sequential Processes) based language. To perform the conformity analysis we develop a transformation system to extract from a CSP process the communication sequences that may arise during its execution, and to express these sequences in terms of behavior expressions in CCS (Calculus of Communicating Systems). By performing algebraic manipulations and the equivalence proof on these expressions, we can show that the external behavior of a protocol conforms to its intended service. A version of the Alternating Bit Protocol is used to demonstrate the feasibility of the methodology.
14242#We have developed a correct, general, and efficient procedure of synthesizing two-party error-recoverable protocols for noisy channels where messages could be lost, corrupted, and/or missequenced. The state explosion problem has been tackled by synthesizing the error-recoverable protocol (ERP) from its noiseless local entity model using certain rules. This reduction arises from the approaches of local modeling and elaboration. We expect that these two approaches will also play a major role in tackling the complexity problems in designing multi-party protocols. Measures of efficiency and functionality improvements have been discussed.
14243#The paper discusses the use of formal specifications for conformance testing of OSI protocols and divides the discussion in two parts: test design and tester design. A draft standard formal specification of the Class 4 transport protocol in Estelle is taken as the starting point for test design. The test design technique used to derive a conformance test suite is semi-formal based in part on the formal specification and also the informal specification. The tests obtained are expressed in natural language. In the tester design part, we discuss the distributed test architecture of ISO and give the detailed designs of upper and lower testers. It is shown that, in testing Class 4 transport implementations, a parametrized protocol implementation approach in the lower tester design, renders the tests easier to implement.
14244#The interactive test sequence generator (ITSG) is a software tool which provides the capability of generating test sequences from logic specifications in an interactive manner. A logic specification is a collection of Horn clauses coded in Prolog describing the externally observable behaviour of a system. ITSG facilitates a controlled traversal of the execution paths described by a logic specification and is written in C_Prolog running under UNIX 4.2 on Vax 750.In this paper, first the form of logic specifications is described and an outline of a logic specification for a protocol entity (i.e., protocol specification) is presented. Then, ITSG is introduced and its functionality is explained. As well, the possible usage of ITSG in constructing conformance test suites for protocol implementation testing is discussed and a simple scenario for developing a conformance test suite is presented.
14245#When two or more distinct organizations interconnect their internal computer networks they form an Inter-Organization Network(ION). IONs support the exchange of cad/cam data between manufacturers and subcontractors, software distribution from vendors to users, customer input to suppliers' order-entry systems, and the shared use of expensive computational resources by research laboratories, as examples. This paper analyzes the technical implications of interconnecting networks across organization boundaries.After analyzing the organization context in which IONs are used, we demonstrate that such interconnections are not satisfied by traditional network design criteria of connectivity and transparency. To the contrary, a primary high-level requirement is access control, and participating organizations must be able to limit connectivity and make network boundaries visible. We describe a scheme based on non-discretionary control which allows interconnecting organizations to combine gateway, network, and system-level mechanisms to enforce cross-boundary control over invocation and information flow, while minimizing interference with internal operations.Access control requirements such as these impose new requirements on the underlying interconnection protocols. We demonstrate such alternative interconnection protocols that support loose coupling across administrative boundaries and that accommodate the necessary control mechanisms. Message-based gateways that support non-real-time invocation of services (e.g., file and print servers, financial transactions, VLSI design tools, etc.) are a promising basis for such loose couplings.
14246#The Mach operating system supports secure local communication within one node of a distributed system by providing protected communication abstraction can be extended over a network by Network Server tasks. The network servers effectively act as local representatives for remote tasks by implementing an abstraction of Network Ports. To extend the security of the port-based communication abstraction into the network environment, the network servers must protect both the messages sent over the network to network ports and the access rights to network ports. This paper describes in detail the protocols used by the network servers to support security.
14247#Hosts are under EMCON condition, short for Emission Control, when they are prohibited from transmitting any data. Under such condition, hosts can only receive data passively and can not acknowledge any data reception. This unidirectionality of the communication channel breaks down all currently defined transport protocols. In this paper, we present architectural alternatives that would support limited communication service under such condition and also discuss other open issues.
14248#Directory Systems to support communications networks are currently the subject of serious international standardization efforts. The most recent CCITT and ISO proposals for Directory Systems are summarized, and within this context the requirements for flexible and robust access control mechanisms are examined. The existence of varied access control policies at the international, national and local levels and the need to maintain the integrity of Directory System information are identified as major factors determining access control procedures. Techniques are suggested for access control mechanisms capable of capturing and enforcing the relevant access control semantics at each network site.
14249#Selective repeat automatic-repeat-request (ARQ) schemes with finite receiver buffer have been studied and analyzed extensively for point-to-point communications. In this paper, we propose a selective repeat ARQ scheme for point-to-multipoint communications where each receiver has a finite buffer size. A lower bound on the throughput efficiency of the proposed scheme is obtained. Computation of the lower bound and simulation of the scheme reveal that the ARQ scheme performs quite satisfactorily, particularly for channels with large round-trip delay and high data rate like the satellite channel. The proposed scheme outperforms the full-memory go-back-N scheme proposed by Gopal, et al. [13]. The scheme seems ideally suited for the case of a satellite operating in broadcast mode with many receivers.
14250#A class of slotted ALOHA dynamic control strategies is considered. These strategies are simple to implement and can yield lossless and stable operation for arbitrarily large user populations with aggregate arrival rates below e-1 packets/slot. An ergodicity analysis is given that provides conditions on the system parameters, such that any specified set of control parameters that satisfies the given conditions is guaranteed to yield stable performance. The system state is modelled as a two-dimensional Markov chain that incorporates the backlog (the number of packets awaiting retransmission) and the estimate of the backlog. The geometrical concepts are illustrated by figures corresponding to an example case. Simulation results are presented that compare alternative control schemes.
14251#The performance of a contention-based TDMA technique is studied in this paper. The frame structure of the time-axis is similar to [1] and [2]. The protocols proposed in [1],[2] and here are all active multiaccess techniques. The protocol in [1] is contention free and suitable for heavy traffic while a contention-based protocol suitable for light traffic is considered in [2]. The protocol to be studied in this paper is also contention in nature and performs considerably better than [2]. This protocol is less complicated than [1] and out-performs [1] unless traffic is very high. Performance analyses, both transient and steady-state, have been successfully completed. Results obtained include average queue length and packet delay, etc. The validity of analysis is also verified by computer simulations.
14252#Most of interprocess communications in transaction oriented distributed systems are based on client-server model, in which one process communicates with several processes simultaneously. Datagram service fits this type of communication rather than virtual circuit service. Transaction oriented distributed systems sometimes need to move large data such as a file or a part of database from a machine to other. The reliable delivery is fairly important since an error might cause retransmission of a whole data. In this paper, we propose the efficient mechanism for reliable datagram service, i) the concept of semi-virtual circuit and ii) the simple error detection and recovery algorithm based on our existing transport protocol, UDSTP. We describe implementation details supporting those facilities and performance results.
14253#A new diagnostic message protocol that provides fault diagnosis capabilities for the communications in a distributed system environment is described. The protocol is designed to operate in conjunction with a standard end-to-end communication protocol and uses special messages to determine the system fault state. A diagnosis message is represented using a test dependency model that is derived from the system topology. These messages are used by an adaptive strategy designed to achieve specific objectives such as reduced testing cost. Using the test dependency model, a general purpose algorithm is developed for generating these strategies based on an information theory criterion. Specific properties of the protocol are discussed, and several examples of strategies for a distributed system topology are provided.
14254#In this paper, we study the performance characteristics of a client-server style distributed system by a queueing network model. The system being modeled was based on an experimental distributed system currently being prototyped. As a specific detailed case study, we have evaluated the performance of a file server. A file server is a key component to achieve the data sharing necessary in a distributed system. The file server is probably the most heavily used resource of the distributed system and as a result, its performance is critical to the success of the system. The primary goal of the study was to identify and quantify the effects of the bottlenecks in the server and assess design alternatives to enhance performance. In particular, the improvements due to file caching, outboarding transport functions and the effect of multiple network interfaces were studied. We model in detail the various stages of processing of a request to a file server. Parameterization of the model was achieved by initial measurements made on the prototype system. An important characteristic modeled was the buffer overflow from the network interfaces. This required the approximate solution of a non-product-form queueing network.
14255#This paper presents a study of a distributed system consisting of a number of hosts connected by a local area network. The system model is based on the LOCUS distributed file system. The LOCUS file system allows replicated files, and the synchronization policy is enforced by the use of the Centralized Synchronization Sites (CSS). All requests to open a file for access must be sent to the file's CSS which checks for access conflicts. Our simulation model allows process migration. The focus of this study is on load balancing as applied to optimal process and read site placement. An algorithm is proposed that increases system performance through load balancing. This algorithm uses data collected by the system on which to base its decisions. The characteristics of the algorithm and their effects on system performance are analyzed and discussed.
14256#We present a resilient distributed protocol that enables a synchronous algorithm to run on an asynchronous network. The protocol is resilient in the sense that it can continue providing network synchronization in the presence of topological changes in the underlying communication network of a distributed system. These changes are caused by link/node failures and recoveries that occur while running the protocol. In general, the protocol is a useful tool in the design of resilient distributed algorithms as it isolates the algorithm from the characteristics of the communication network.
14257#In distributed systems surveillance protocols are used for monitoring the status of remote sites. A remote site is regarded as being available as long as messages are received from this site, otherwise it is regarded as being unavailable. If a site becomes unavailable, this will be reported to other sites and recovery actions can be initiated. Using an example it will be shown that in certain cases it is necessary, that whenever some site S1 detects the unavailability of some other site S2, within a fixed amount of time S2 must also have detected an unavailability of S1. Unfortunately, this cannot be guaranteed by existing surveillance protocols. Another problem with existing protocols is, that remote sites are usually reported as being unavailable after being timed out only once, i.e. the loss of just one message might cause complete systems to back out.Two versions of a protocol for so-called symmetric surveillance are presented. Both guarantee, that if S1 detects the unavailability of S2 at time t0, then S2 (provided that S2 has not crashed) will become aware of this fact at t1 such that [t1 - t0]
14258#A distributed algorithm for the detection of deadlocks in store-and-forward communication networks is presented. At first, we focus on a static environment and develop an efficient knot detection algorithm for general graphs. The knot detection algorithm uses at most &Ogr;(n2 + m) messages and &Ogr;(log(n)) bits of memory to detect all deadlocked nodes in the static network. Using the knot detection algorithm as a building block, a deadlock detection algorithm in a dynamic environment is developed. This algorithm has the following properties: It detects all the nodes which cause the deadlock. The algorithm is triggered only when there is a potential for deadlock and only those nodes which are potentially deadlocked perform the algorithm. The algorithm does not affect other processes at the nodes.
14259#This paper describes new interprocess communications facilities that have been added to the Locus system [POPEK 81][WALKER 83]. The facilities improve Locus's interprocess communication repertoire by providing distributed support for three separate subsystems from System V UNIX: messages, semaphores, and shared memory. Here we describe these subsystems and their integration into in the Locus architecture.
14260#Repeated observation of TCP retransmission timer problems stimulated investigation into the roles and limitations of timers. Timers are indispensable tools in building up reliable distributed systems. However, as the experience with the TCP retransmission timer has shown, timers have intrinsic limitations in offering optimal performance. Any timeout based action is a guess based on incomplete information, and as such is bound to be non-optimal. We conclude that, if we aim at high performance, we should use external events as a first line of defense against failures, and depend on timers only in cases where external notification has failed.
14261#The Versatile Message Transaction Protocol (VMTP) is a transport-level protocol designed to support remote procedure call, multicast and real-time communication. The protocol is optimized for efficient page-level network file access in particular.In this paper, we describe the significant aspects of the VMTP design, including the VMTP treatment of sessions, addressing, duplicate suppression, flow control and retransmissions plus its provision for multicast. The VMTP design reflects a change in the use of computer communication as well as a change in the underlying hardware base for the next generation of communication systems. It also challenges certain established notions in the design of protocols.
14262#Compute]'s 128 programmer's guide
14263#Compute's Amiga programmer's guide
14264#Compute's machine language games for the Commodore 64
14265#Compute]'s second book of IBM
14266#Compute]'s ST programmer's guide
14267#Computer & telecommunications acronyms
14268#Computer architecture: concepts and systems
14269#Computer security: readings from Security management magazine
14270#Combinatorial geometries
14271#Amiga assembly language programming
14272#Communication failure in dialogue and discourse: detection and repair processes
14273#Lecture notes in mathematcs; 1234 on Colloquium on combinatorial enumeration
14274#31st IEEE Computer Society International Conference on Compcon
14275#Computer sleep stage scoring: an expert system approach
14276#bstance, not form on Striking a balance between technology, economics, politics, and reality---for su
14277#Computers and security
14278#Concurrency control and reliability in distributed systems
14279#Concurrency PC DOS
14280#Parallel execution of logic programs
14281#Proceedings of the conference on complex analysis and approximation theory on Complex analysis, functional analysis, and approximation theory
14282#Proceedings of the conference on continous system simulation languages on Languages for continous system simulation
14283#Contemporary mathematics/American Mathematical Society , 0271-4132; Vol. 59 on Conference on function estimates
14284#The professional user's guide to acquiring software
14285#Combinational theory and statistical design
14286#Applied numerical methods with personal computers
14287#Constructive methods of Wiener-Hopf factorization
14288#Contributions to the theory and application of statistics: a volume in honor of Herbert Solomon
14289#An obstacle-avoiding router for custom VLSI
14290#Reliable task allocation in a fault-tolerant distributed system
14291#On applying heterogeneous parallelism to elements of knowledge-based data management
14292#Deterministic time and analytical models of parallel architectures
14293#Highly concurrent scalar processing
14294#A study of the worst-case of shell-sort
14295#Proceedings of the Academy of Science of the German Democratic Republic on Convergence structures and applications, II
14296#Potential pattern recognition in chemical and medical decision making
14297#Understanding and using MS-DOC/PC-DOS: a complete guide
14298#Historical dictionary of data processing—technology
14299#Critical issues in information systems research
14300#An asymptotic theory for empirical reliability and concentration processes
14301#Current advances in distributed computing and communications
14302#Lecture notes in computer sciences; 218 on Advances in cryptology---CRYPTO 85
14303#Computer-integrated manufacturing
14304#Parmeterizable cells strike middle ground between fixed and compiled cells
14305#Circuit simulator tackles electrical and mechanical components
14306#General-purpose machines and PCs emerge as AI platforms
14307#LCDs leads the assault on CRT'S dominance
14308#Dedicated graphics terminals achieve price advantage of PCs
14309#High-speed processor revamps bit-slice design
14310#Debug system targets multiprocessor design
14311#Code optimization speeds C throughput
14312#Advanced packaging
14313#Flash converters move up in performance but still lag behind hybrids
14314#Four approaches to nonvolatile memory open to designers
14315#Design tools combine expert and algorithmic software
14316#Embedded controllers yield "standard" disk drives
14317#MAP picks more support but products slow to appear
14318#Improved C compilers boost system throughput
14319#Silicon compilers ease complex VLSI design
14320#Task partitioning eases concurrent programming
14321#Supermicrocomputers
14322#Packet-switched communications extend multiprocessor's range
14323#Modem ICs increase speed and functionality
14324#Logic analyzer vendors focus on integration and flexibility
14325#Designers choose from software-development environments
14326#Reaping the rewards of vector processing
14327#High-density interfaces aren't superfluous anymore
14328#Scan techniques aid testing of small systems
14329#Increased use of radiation-hardened ICs calls for more careful interpretation of test claims
14330#Standards converge for CAE/CAD data and languages
14331#Board-level modems boast higher speeds, more features and lower cost
14332#Design tools move toward the 21st century
14333#Getting the most out of today's technology
14334#PCs and LANs revolutionize the office
14335#Defense systems-the high road to SDI
14336#Development systems
14337#Customizable serial bus brings low cost, high performance and reliability to control systems
14338#Analog standard cells still more custom than semicustom
14339#Speech I/O products offer board-level solutions
14340#Silicon software tackles AI problems
14341#Machine vision finds a niche in automated inspection
14342#Fault-tolerant chips increase system reliability
14343#Cache design boosts SMD disk drive performance
14344#Tapping into the knowledge power of expert systems
14345#On merging software extensions
14346#The reliability of life-critical computer systems
14347#Availability of a distributed computer system with failures
14348#Information theoretic analysis for a general queueing system at equilibrium with application to queues in tandem
14349#Sets with small generalized Kolmogorov complexity
14350#Decomposition of graphs and monotone formula size of homogeneous functions
14351#Monte Carlo circuits for the Abelian Permutation group intersection problem
14352#A simple fixpoint argument without the restriction to continuity
14353#Specification-oriented semantics for communicating processes
14354#Acceptable functional programming systems
14355#On deciding whether a monoid is a free monoid or is a group
14356#On the average internal path length of many search trees
14357#ALLC Journal
14358#Lexical organisation from three different angles
14359#Microcomputer software tools for a bilingual dictionary
14360#A quantitative approach to semantic nd morphosemantic fields in literary work
14361#The weird ways of vocabulary
14362#Text analysis by microcomputer
14363#The stylistic analysis of a large corpora of literary texts
14364#A thesaurus Proprius for Chaucer's narrative vocabulary in The Canterbury Tales
14365#A path to successful factory automation
14366#Making the most of IDEF modeling-The Triple Diagonal Concept
14367#Using simulation for process planning
14368#Guidelines for implementing global manufacturing systems
14369#Justifying CIM: A quantitative analysis tool
14370#Technology accounting -The value-added approach to capital asset depreciation
14371#Accounting for quality costs-A Critical component of CIM
14372#Integrated systems play a leading role in Chrysler's comeback
14373#MRP II won't schedule the factory of the future
14374#International standards-An evolutionary process for a revolutionary field
14375#A fully automated system for electronic assembly and testing
14376#Bringing image processing into focus
14377#Integrated workstation control
14378#A proven approach to CIM systems design and planning
14379#Computer technology: the next revolution
14380#Object-oriented programming: a new approach for automatic factories
14381#ROI for quality systems
14382#Precompilation of syntactical descriptions and knowledge directed analysis of patterns
14383#Development tools for a model directed workpiece recognition system
14384#Shape grammar compilers
14385#Classifying and validating intermittent EEG patterns with syntactic methods
14386#An attribute grammar for QRS detection
14387#Syntactic ECG processing: a review
14388#Direct parsing
14389#T-recognition of T-languages, a new approach to describe and program the parallel pattern recognition capabilities of d-dimensional tesselation structures
14390#Rates of convergence for classes of functions: the non-i.i.d. case
14391#Multidimensional large deviation local limit theorems
14392#n the angle between past and future for multivariate stationary stochastic processes
14393#Robust estimation in the linear model with asymmetric error distributions
14394#The distribution of a generalized least squares estimator with covariance adjustment
14395#Transformations preserving normality and wishart-ness
14396#On the limiting Pitman efficiency of some rank tests of independence
14397#A characterization of spherical distributions
14398#On stochastic integral representation of stable processes with sample paths in Banach spaces
14399#Uniform bound in the central limit theorem for Banach space valued dependent random variables
14400#A random CLT for dependent random variables
14401#Non-linear prediction of the degree n of a Gaussian N-ple Markov process
14402#Cooperating rewrite processes for natural-language analysis
14403#Conjunction in meta-restriction grammar
14404#An approach to natural-language semantics in logic programming
14405#A perspective on computing and special education
14406#Issues and concerns in special education microcomputing
14407#Selecting a computer for your special education classroom
14408#Software for the special education classroom
14409#Evaluating software for use by mentally handicapped learners
14410#Computers aids for the handicapped
14411#A comparison of LD and Non-LD students' learning LOGO and on-task behavior
14412#Modifying cursing behavior using a microcomputer as a reward
14413#Intelligibility of computer synthesized speech among mildly handicapped and nonhandicapped youth
14414#Is special education a computer management issue?
14415#IEPS and data management: a case in point
14416#Selection of IEP management systems
14417#Microcomputers in special education classrooms: themes from research and implications for practice
14418#Computers: an ESSENTIAL tool for learning disabled students
14419#Using microcomputers to teach verbal mathematical problem solving to learning disabled students
14420#Computer-assisted speech synthesis for severely disabled nonverbal individuals
14421#Microcomputers in communications disorders
14422#Computer programming in special education: the promise of Logo
14423#Specialized services and expert systems: an examination of the potential and reality
14424#Ethical and legal considerations for microcomputer use in special education
14425#Specialist group distributes database information
14426#Standardization for information technology (IT) - status: November 1986
14427#An extended integrating dual-slope analogue-to-digital converter suitable for continuous bipolar operation
14428#European memoranda on functional standards
14429#Latent benefits of consensus processes
14430#Accredited standards committee for information processing systems,X3
14431#Ergonomic guidelines for computerized user interfaces
14432#Lessons from the MOSI project
14433#Application of extended Galerkin's method to nonconservative stability problems of the columns with thin-walled open cross-section
14434#A Mindlin element for thick and deep shells
14435#An investigation of boundary element methods for the exterior acoustic problem
14436#Solving unilateral problems for beams by finite element methods
14437#Transient analysis of flexible multi-body systems. Part I: dynamics of flexible bodies
14438#Transient analysis of flexible multi-body systems. Part II: application to aircraft landing
14439#Laminar flows of a non-Newtonian fluid in mild stenosis
14440#What is electronic publishing?
14441#The conundrum of optical storage
14442#Typography and electronic publishing
14443#Commercial applications of electronic publishing, the Fifth Annual Conference ofIEPRC
14444#Local area and multiple access networks
14445#A tutorial on the IEEE 802 Local Network Standard
14446#Channel efficiency for LANs
14447#Mean waiting time for a token ring with station dependent overheads
14448#A programmable VLSI controller for standard and prioritized Ethernet local networks
14449#Performance evaluation of a metropolitan area network
14450#Congestion control in interconnected local area networks
14451#Performance evaluation of MAGNET protocols
14452#Address-based and non-address-based routing schemes for interconnected local area networks
14453#Derivation of asynchronous code division multiple access (CDMA) throughput
14454#High performance asynchronous limited sensing algorithms for CSMA and CSMA-CD channels
14455#Flow control in integrated voice and data local area networks
14456#Collision detection in radio channels
14457#LAN vs. PABX
14458#A validation of the OSI session layer protocol
14459#Step-wise validation of communication protocols and services
14460#Analysis and control of traffic routing in circuit-switched networks
14461#Analysis of a Hybrid (demand assignment TDMA) protocol for video teleconferencing-voice data optical networks
14462#PTC'86 — Pacific telecommunications conference
14463#Synchronous communication protocols for local networks
14464#Multirate voice coding for load control on CSMA/CD local computer networks
14465#CSMA/CD LANs with overload detection and protection
14466#Reliability mechanisms of the FDDI high bandwidth token ring protocol
14467#Implementation of a dynamic address assignment protocol in a local area network
14468#Pacific computer communications symposium
14469#Applications of power series in computational geometry
14470#Link between Be´zier and lagrange curve and surface schemes
14471#Converting standard bivariate polynomials to Bernstein form over arbitrary triangular regions
14472#Techniques for reducing Boolean evaluation time in CSG scan-line algorithms
14473#Unified interactive geometric modeller for simulating highly complex environments
14474#Expert systems applications in computer-aided design
14475#Developments in computer-aided control system design
14476#Nonlocal sensitivity analysis, automatic derivative evaluation, and sequential nonlinear estimation
14477#A data based algorithm for the generation of random vectors
14478#The general problem of ill conditioning and its role in statistical analysis
14479#Truncated group sequential test for clinical trials
14480#Repeated measures regression: An application to the analysis of mood and chronic pain
14481#Application-specific ICs
14482#Database accelerator system relieves sorting bottlenecks
14483#RTL simulation makes a comeback for complex VLSI
14484#Carrierband is low-cost, single-channel solution for MAP
14485#Floating-point methods combine to boost performance
14486#Benchmarking lends a hand in making CAE/CAD selection decisions
14487#Automatic test generation tackles sequential logic
14488#Proliferation of Ada compilers keeps validation services running
14489#Electronic assembly becoming dependent on robotic tools
14490#32-bit parts and architectures vie for attention
14491#Chip set geared to Unix simplifies high-end designs
14492#Processor offers code compatibility, VAX-like architecture
14493#Graphics ICs provide high-resolution, color CRT displays
14494#VMEbus controller taps into 32-bit potential
14495#Computer Decisions
14496#The computer decisions 100: The year the party ended
14497#IBM prospects for rich frontiers
14498#Up & comers: Breaking out of the pack
14499#Utilities strengthen VM
14500#Building bridges to DISOSS
14501#An interpreter for SLIPS—an applicative language based on LAMBDA-calculus
14502#Case study: the PAISley approach applied to its own software tools
14503#A closer look at export and import statements
14504#Parsing in parallel
14505#Free-edge stress concentration in composite laminates: A boundary layer approach
14506#Grid orthogonalization for curvilinear alternating-direction techniques
14507#Stream function and stream-function-coordinate (SFC) formulation for inviscid flow field calculations
14508#The solution of multi-parameter systems of equations with application to problems in nonlinear elasticity
14509#On small finite deflections of sheardeformable elastic plates
14510#A moving-grid finite element algorithm for supersonic flow interaction between moving bodies
14511#Eigen values and expanders
14512#Independent unbiased coin flips from a correlated biased source:80a finite state Markov chain
14513#Efficient algorithms for finding minimum spanning trees in undirected and directed graphs
14514#An augmenting path algorithm for linear matroid parity
14515#Nonlinearity of Daveport:80Schinzel sequences and of generalized path compression schemes
14516#The average-case analysis of some on-line algorithms for bin packing
14517#Performance monitor for an operational LAN
14518#Design of integrated data/voice stations for a CSMA/CD LAN
14519#Fast packet approach to integrated broadband network
14520#Reference models for a fast packet based network
14521#Information technology at the national computing centre
14522#Distribution lists in an X.400 message handling system
14523#CSMA/CD-based protocol with dynamic segmentation
14524#Performance of multiple-access schemes for data communication
14525#Telecommunications network developments
14526#Implementing and integrating office automation
14527#Computer based message services
14528#Homework for adults—the telecommuting solution
14529#Electronic mail—future directions
14530#DTI support for OSI
14531#Message handling standards
14532#Product supplier view of electronic mail and document standards
14533#Electronic mail synergy
14534#Security in electronic mail
14535#Local area network management for distributed applications
14536#Electronic mail in the UK academic community
14537#Digital experience with electronic mail
14538#Intersection of parametric surfaces in the Bernstein—Be´zier representation
14539#Generation of continuous smooth curves resulting from operations on parametric surface patches
14540#GEODERM: Geometric shape design system using an entity-relationship model
14541#Computer-aided design for a real-time acceleration of the convergence of adaptive control algorithms
14542#Smoothing of shapes designed with free-form surfaces
14543#Functional specification for CAD databases
14544#Computer-aided design of robotic manipulators
14545#Inputting constructive solid geometry representations directly from 2D orthographic engineering drawings
14546#Automatic interpretation of engineering drawings for 3d surface representation in CAD
14547#An introduction to computer graphics
14548#Adaptive subdivision algorithms for a set of Bezier triangles
14549#Curve fitting algorithm for rough cutting
14550#Design knowledge in architectural CAD
14551#Improving the efficiency of scanline algorithms
14552#An algorithm for silhouette of curved surfaces based on graphical relations
14553#Multivariate spline methods in CAGD
14554#Curvature continuous curves and surfaces
14555#Boundary to constructive solid geometry mappings: a focus on 2D issues
14556#Construction of curves and surfaces using numerical optimization techniques
14557#Parameterization in grid generation
14558#The definition and computation of a metric on plane curves
14559#Parabolic curve approximation in design and finite element applications
14560#Numerical estimation of the curvature of surfaces
14561#Some negative results in N sided patches
14562#Piecewise triangular C1 surface strips
14563#Natural bias approach to shape preserving curves
14564#Shape preserving spline interpolation
14565#Comparison of three curve intersection algorithms
14566#The IBM RT personal computer
14567#The IBM PC convertible
14568#Intel's 80386 architecture
14569#Virtual memory, virtual machines
14570#A protected-mode program for the PC AT
14571#IBM PC accelerators
14572#Lotus/Intel/Microsoft expanded memory
14573#Performance programming
14574#RAM-loadable character sets for the IBM PC
14575#Speeding up the PC AT
14576#Using assembly language interrupt routines
14577#Memory manipulations
14578#Writing assembly language interrupt routines
14579#C VERSUS assembly-C plus assembly
14580#The Compaq Deskpro 386
14581#Lotus manuscript
14582#Build the GT180 color graphics board Part I: Basic technology
14583#Programming insight: Extracting the nth root from a binary number
14584#Programming insight: Passing file names to compiled basic
14585#Memory management units for 68000 architectures
14586#The state of Soviet microelectronics
14587#Finding rules in data
14588#A bit mapped classifier
14589#Predicting international events
14590#Handling conflicts in data
14591#The art of deduction
14592#Rule-based programming
14593#Integrated services digital network: ISDN
14594#EUREKA, RARE, and the Deutsche Forschungsnetz
14595#Background on EARN, The European academic research network
14596#Interview with David Lord in EARN
14597#Standardization for information technology
14598#The graphic kernel system (GKS)-ISO 7942
14599#A UK consortium for OSI testing
14600#Peter Jones on standards information technology
14601#International electrotechnical association (IEC)
14602#Computers and manufacturing at the NEL
14603#CAM for aero-engine disc components
14604#Why European industry wants MAP
14605#Robotic based manufacturing: the sociotechnical concept
14606#Computers in manufacturing and design, robotics and graphics
14607#Another step forword in simulation
14608#John Fairclough: adviser to government
14609#Some remarks on data processing degrees
14610#The down side of Unix
14611#The office of the future
14612#Cognitive aspects of HCI
14613#Human factors in the IT specification process
14614#User interface design and formal methods
14615#Human factors in computer based message systems
14616#Software, vital key to UK competitiveness
14617#The use and misuse of VDU'S
14618#You can never have too much disk space
14619#An overview of optical storage
14620#From print to platter—publishing with CD-ROMS
14621#Is there a CD-ROM in your future?
14622#Putting optical discs to work: a case study
14623#CD-ROMs on the job—one organization's experience
14624#Coping with computer crime today
14625#Cover your high tech assets
14626#Contingency planning will limit a disaster's effects
14627#Decision support systems:new perspective for business
14628#Solving the problem of data security
14629#Integrated information systems: legal considerations
14630#Rediscovering the importance of manufacturing
14631#Whatever happened to the robot boom?
14632#Technological change and industrial relations
14633#The CAO/FAO and the importance of risk management
14634#Not just a computer graphics toy
14635#Kanban's impact on data processing & production scheduling
14636#New tools for design engineers
14637#Mapping out a new communication standard
14638#CIM-benefit estimates and benefit deliveries
14639#Making a trade show fit your marketing plan
14640#A method of specification and analysis of processes
14641#A class of applications level protocols
14642#An interface between application programs and the session level of local computer networks
14643#Interaction facilities of network processes in AT-Pascal language
14644#Analysis of transit delays in a channel network of signalization system No 7
14645#Transfer time characteristics of a specified information volume transmitted through a network channel with possible failures
14646#Principles of implementation of a multifunctional integrated network service
14647#A method of communication channel testing in a computer network
14648#Simulation models for analysis and optimization of the performance indicators of local computer networks
14649#Diagnostic facilities of local computer networks
14650#The hardware components of a transport radio network
14651#Reliability of the analysis by check-sum method and signature analysis method in testing and diagnosis of network discrete structures
14652#Testing a microprogramming control unit of microprogrammable microprocessor systems
14653#Control over inexact reasoning
14654#Concurrency in intelligent systems
14655#Rule-based programming in OPS83
14656#Multitasking for common Lisp
14657#Augmented transition networks for natural language parsing
14658#PROLOG from the bottom up
14659#Components of AI system
14660#Turbo PROLOG: A PROLOG compiler for the PC programmer
14661#On principles of stationarity for non-selfadjoint rod problems
14662#Distributed processing comes to automotive electronics
14663#CMOS monolithic 12-bit A-D converter achieves 5-&mgr;s conversion time
14664#One-megabit EPROMs insure upward compatibility
14665#CAE workstations automate documentation tasks
14666#Nonimpact printers offer speed, color, and silence
14667#Rash of new compilers brings multiprocessors into the Ada fold
14668#Drainage network simulation
14669#A two-phase finite-element program for displacement simulation processes in porous media
14670#Radiative cooling in valleys and hollows
14671#FRACT—a FORTRAN subroutine to calculate the variables necessary to determine the fractal dimension of closed forms
14672#Computation of the fractal dimension of topographic surfaces using the triangular prism surface area method
14673#To transfer VisiCalc spreadsheet files from commodore computer across to Lotus worksheets in a Rainbow computer
14674#A FORTRAN program to transform polar coordinates to a new pole for mapping and graphics applications
14675#An exact test for the mean of a normal distribution with a known coefficient of variation
14676#A reliable method for estimating the variance function in immunoassay
14677#A simple test for the Behrens-Fisher problem
14678#A fast algorithm for iterative proportional fitting in log-linear models
14679#Software for statistical and survey analysis
14680#Triangular Berstein-Be´zier patches
14681#Offsetting operations in solid modelling
14682#Efficient evaluation of multivariate polynomials
14683#The Wilson-Fowler spline is a v-spline
14684#Scattered data interpolation and approximation with error bounds
14685#Geometric surface patches without twist constraints
14686#On the piecewise structure of discrete box splines
14687#On invariant curve forms
14688#Error analysis for piecewise quadratic curve fitting algorithms
14689#Two moving coordinate frames for sweeping along a 3D trajectory
14690#Design and validation of a transport protocol for local area network
14691#Lattice and ring array topologies using transputers
14692#Unison project
14693#Performance evaluation of an Ethernet network
14694#Multitasking across a LAN for communications switching
14695#Numerical solution to limited service polling models
14696#Methodology for LAN design
14697#Integrating voice and data on SALAN: an experimental local area network
14698#AALAN: an advanced automation local area network
14699#Adding SCSI to the SBI80 computer Part 1
14700#Data compression with Huffman coding
14701#Modula-2 as a systems programming language
14702#Linking data flow and functional languages
14703#Easy C
14704#Programming insight: Subroutine overlays in GW-BASIC
14705#The evolution of mass storage
14706#CD-ROM software development
14707#The application interface of optical drives
14708#Optical disk error correction
14709#A roundup of optical desk drives
14710#Tape backup systems
14711#Laser libraries
14712#Computer performance evaluation and capacity management
14713#Society for Computer Simulation on Conference on intelligent simulation environments
14714#Historical dictionary of data processing—biographies
14715#Microcomputer data security: issues and strategies
14716#Proceedings of the ESPRIT/LPC advanced school on current trends in concurrency on Current trends in concurrency: overview and tutorials
14717#Strategic value analysis: a modern approach to systems and data planning
14718#Nonlinear methods in numerical analysis
14719#Database management systems
14720#A guide to the SQL standard
14721#A guide to INGRES
14722#Dictionary of computing: data communications hardware and software basics, digital electronics
14723#Dictionary of computing
14724#BASIC programming for the IBM personal computer
14725#Programming Macintosh Pascal
14726#Paradox for the programmer
14727#R:base 5000 for the programmer
14728#Simply REFLEX: solving business problems with REFLEX
14729#Proceedings of an international workshop on Dimensions and entropies in chaotic systems: quantification of complex behavior
14730#Proceedings of the Japan-US joint seminar on Discrete algorithms and complexity theory
14731#Distributed systems; vol. 1 & 2
14732#Using computers
14733#Numerical methods with Fortran IV case studies
14734#Dictionary of computer terms
14735#Dr. Dobb's toolbook of 68000 programming
14736#Introduction to 6800/68000 microprocessors
14737#Graphical exploratory data analysis
14738#Direct methods for sparse matrices
14739#Four software tools: DOS for IBM PC and MS DOS, work processing using WorkStar, spreadsheets using VP-Planner, data base management using dBase III
14740#Advanced MS-DOS: the Microsoft guide for assembly language and C programmers
14741#Applied statistics: analysis of variance and regression (2nd ed.)
14742#Complete Turbo Pascal (2nd ed.)
14743#Fixed point index theory for a class of nonacyclic multivalued maps
14744#Proceedings of the Eastern simulation conference on simulation in Ada on Simulation in Ada
14745#Society for Computer Simulation on Simulation at the frontiers of science with papers on software and hardware systems for the simulationist
14746#A structured approach to computer strategy
14747#Free (and almost free) software for the Macintosh
14748#Topologically sweeping an arrangement
14749#Randomization tests
14750#A Fuller explanation: the synergetic geometry of R. Buckminister Fuller
14751#Spectral theory and differential operators
14752#Prentice-Hall encyclopedia of information technology
14753#Papers presented at the Software Engineering Education Workshop on The educational needs of the software community
14754#Skillbuilding: building speed and accuracy on the keyboard
14755#Systems development: analysis, design and implementation
14756#Computer systems software: the programmer/machine interface
14757#BCPL and C
14758#Direct connections: making your personal computers communicate
14759#Mastering reflex
14760#ESPRIT '85: status report of continuing work; vol. 1 & 2
14761#ESPRIT '85: results and achievements
14762#The state of information science in France
14763#Structured FORTRAN 77 for engineers and scientists
14764#Lecture notes in computer science; vol. 213 on ESOP 86: European symposium on programming
14765#Proceedings of the first European workshop on parallel processing techniques forsimulation on Parallel processing techniques for simulation
14766#Fortran programming (2nd ed.)
14767#Modeling, simulation, and control
14768#Order form IEEE Computer Society on Expert systems in government symposium
14769#Advanced COBOl
14770#A new means of international protection of computer programs through the Paris convention-A new concept of utility model
14771#Computer data and reliability: A call for authentication of business records under the Federal rules of evidence
14772#Computers: the link to missing children
14773#The flagler dog track case
14774#The threat from within: Cable television and the invasion of privacy
14775#Cahiers du Centre d'Etudes de Recherche Operationelle
14776#Some recent results on nonparametric prediction of a stationary process
14777#Exchangeability of chronologic series: some exact results on autocorrelations and portmanteau statistics
14778#Rank tests in chronologic series analysis
14779#Some aspects of nonparametric prediction: Ge´rard Collomb (1951-1985) on nonparametric analysis of temporal series
14780#Rank tests for a multivariate white noise hypothesis by report of an order 1 autoregressive dependence
14781#An optimality theorem and its application to estimation
14782#Distribution free modeling of time series with rank order chain
14783#Hermite functions and statistics of mixed processes
14784#Rank statistics in the identification of chronologic series models
14785#Weak convergence of multidimensional rank statistics in 0 mix or strong mix
14786#Nonparametric estimation of a tendency or spectral density by movable polynomial regression
14787#Identification and multicriteria decision aid
14788#Non parametric estimation of spectral densities and their derivatives: Integrated mean squared error, choice of window width and applications
14789#A nonmetric approach for decomposition time series data
14790#Nonparametric estimation from time series residuals
14791#A method for comparing non parametric spectral estimates
14792#An extension of ARIMA models: DF-Stationansable processes, properties and identification
14793#Nonparametric regression and prediction of a Markov process
14794#Frontiers of one-letter languages
14795#A multi-visit characterization of absolutely noncircular attribute grammars
14796#Indexed LL(k) grammmars
14797#On vi-products of commutative automata
14798#On finite definite automata
14799#On involutorial automata and involutorial events
14800#A solution of the early bird problem in an n-dimensional cellular space
14801#Language extension in the HLP/SZ system
14802#Some results about key of relational schemas
14803#A queueing model for multiprogrammed computer system with different I/O times
14804#Characterization of clones acting bicentrally and containing a primitive group
14805#On the weak equivalence of Elgot's flow-chart schemata
14806#On the equivalence of the frontier-to-root tree transducers I
14807#Atomic characterizations of uniform multi-pass attribute grammars
14808#On the equivalence of the frontier-to-root tree transducers II
14809#Systems of linear equations over a bounded chain
14810#Metric representations by vi
14811#A partial solution of the finite spectrum problem
14812#Network design problem: structure of solutions and dominance relations
14813#Using SuperCalc: the next generation: a self-teaching guide
14814#Using small Business Computers with Lotus 1-2-3, dBase II, and Wordstar
14815#Using concurrent PC DOS
14816#A structured approach to Fortran
14817#Scientific programming with Macintosh Pascal
14818#Applied finite element analysis: an Apple II implementation
14819#Catalogue of artificial intelligence tools; (2nd, rev. ed.)
14820#Mastering Symphony- 2nd Edition
14821#Essentials of information processing
14822#Illustrating BBC-Basic
14823#Telecommunications Measurements, Analysis, and Instrumentation
14824#Microcomputer Art
14825#Putting Pascal to work
14826#Managing money with your VIC 20
14827#Managing money with your Commodore 64
14828#Managing money with your IBM PC
14829#Data Processing project management: second edition
14830#Apple IIc and IIe Assembly Language
14831#The complete guide to dBase III: A self-teaching guide
14832#Structured COBOL programming
14833#The Munich Project CIP: Volume I: the wide spectrum language CIP-L
14834#Computers peripherals that you can build: 2nd edition
14835#High tech survival kit: Managing your stress
14836#Scientific and technical text processing using wordstar: a guide for beginning and advanced users
14837#The stationary semiconductor device equations
14838#Computers and data processing today: 2nd edition
14839#Proceedings on STACS 85 2nd annual symposium on theoretical aspects of computer science
14840#On the relative complexity of subproblems of intractable problems
14841#On Lova´sz' lattice reduction and the nearest lattice point problem
14842#Layouts with wires of balanced length
14843#On the single-operation worst-case time complexity of the disjoint set union problem
14844#Deterministic languages and non-generators
14845#Simulation of large networks on smaller networks
14846#Petri nets and algebraic calculi of processes
14847#Non-deterministic two-tape automata are more powerful than deterministic ones
14848#Construction of a family of factorizing codes
14849#On Hotz groups and homomorphic images of sentential form languages
14850#Using domain algebras to prove the correctness of a compiler
14851#Sorting and recognition problems for ordered sets
14852#Tree automata and logic programs
14853#Structure of relations satisfying certain families of dependencies
14854#A single source shortest path algorithm for a planar distributed network
14855#An algorithm for two-layer channel routing
14856#New algorithms for special cases of the hidden line elimination problem
14857#An algorithm to construct Minkowski-reduced lattice-bases
14858#Non-finite base of varieties
14859#An O(N1.5+ε) expected time algorithm for canonization and isomorphism testing of trivalent graphs
14860#On the complexity of deadlock recovery
14861#On the planar monotone computation of threshold functions
14862#Planar circuits have short specifications
14863#Shortest paths on polyhedral surfaces
14864#Fairness in context-free grammars under canonical derivations
14865#Distributed termination in CSP: symmetric solutions with minimal storage
14866#A dynamization of the all pairs least cost path problem
14867#Boundedness, empty channel detection and synchronization for communicating finite state machines
14868#Deriving stack semantics congruent to standard denotational semantics
14869#Translating polygons in the plane
14870#Geometric containment is not reducible to Pareto dominance
14871#The volume of the union of many spheres and point inclusion problems
14872#Combined simplicity and immunity in relativized NP
14873#Groups, codes and unambiguous automata
14874#Reduced memory space for multi-dimensional search trees
14875#Proximity on a grid
14876#A symposium held at the American Philosophical Society on The visual arts and sciences
14877#The computer and creativity
14878#Symposium cosponsored by University of Pittsburgh Law Review and The Software En on The future of software protection
14879#Protection of computer programs: the copyright/trade secret interface
14880#The patentability of algorithms
14881#The models are broken, the models are broken]
14882#Common law, uncommon software
14883#Infringement of copyright in computer programs
14884#The uncertain case for special legislation protecting computer software
14885#Allocating ownership rights in computer-generated works
14886#The bundle of rights suited to new technology
14887#This paper presents a hierarchical firmware design method. It allows to structure the design of a microprogrammed (level of a) computer architecture into independently verifiable modules. To specify the behaviour of the system we use the axiomatic architecture description language AADL. We illustrate the design and specification style using an emulation example.
14888#Efficient hardware for multiway jumps and pre-fetches
14889#The paper is concerned with efficient implementation of evolved modular and structured microprogramming. A microprogrammable architecture is presented that permits designing hierarchical complicated modular microprograms at two distinct levels: the global control and the data processing level. The architecture is based on two cooperating microprogram control units that separately store and perform control and executive microinstructions and microcode modules. The control organization of an implementing computer is presented which assures the quasi time-transparency of modular control in microprograms during the microprogram execution. This is achieved by parallel functioning of constituent control units, that permits preparing in advance addresses of executive modules referenced by control microinstructions. The efficient implementation of control statements of high level languages and microprogramming at the assembler language level for the proposed architecture are also discussed in the paper.
14890#This paper discusses the design and implementation of a debugging/diagnostic subsystem for a bit-slice processor. The subsystem uses serial shadow registers under the control of a single chip microcomputer both to observe and to control processor behavior. Serial lines link the microcomputer to a diagnostic host which provides the user with a comprehensive set of interactive diagnostic commands. Using these commands, the user is able to load the writable control store, verify its contents, load mapping facilities, set breakpoints and examine registers during single-stepping sequences. The subsystem can considerably speed up the firmware development process and when incorporated into the design as a permanent feature, it provides a very low-cost facility for register-level diagnostics during the life of the system. Portability of the diagnostic subsystem across a number of processors is also possible and is conducive to the efficient management of machine diagnosis in the field.
14891#This paper describes a microcode-evaluation methodology. The supporting test tools were developed by the IBM General Products Division in Tucson, Arizona, to allow effective and comprehensive evaluations of microcode systems. The methodology has been used successfully by the Tucson Test Laboratory (TTL) during the past several years.The evaluation methodology is characterized by an integrated application of static and dynamic analysis techniques. These two modes of analysis are complementary and they allow a level of automation that can significantly enhance the productivity of a testing organization through the systematic application of automated testing techniques. The methodology also establishes a discipline for the microcode-testing process that promotes a formal program of defect removal. Of course, improving the process of removing defects produces a corresponding enhancement in product quality.
14892#Advances in microcode support software
14893#We apply the verification methodology underlying the S*-System[12], [13] to the verification of a hierarchically structured design [16] of an emulation of the instruction-set of a commercially available computer on a commercially available micro-architecture. Based on this case-study, we discuss some aspects of the relation between verification and generation of microcode.
14894#A proven method of obtaining high performance for Prolog programs is to first translate them into the instruction set of Warren's Abstract Machine, or W-code [1]. From that point, there are several models of execution available. This paper describes one of them:- the compilation of W-code directly into the vertical microcode of a general purpose host processor, the NCR/32-000. The result is the fastest functioning Prolog system known to the authors. We describe the implementation, provide benchmark measurements, and analyze our results.
14895#This paper describes the architecture and the current implementation of the hardware unification unit (HUU). The HUU performs the literal unification operation in Prolog processing. It is designed as a coprocessor to a host system that handles other operations of Prolog processing such as bookkeeping and sequencing. After the host system provides input values to the HUU and activates it, the HUU works independently from the host system; when it finishes its operation it reports the result to the host system. The HUU contains local memory that stores the variable binding information. The microinstructions and a sample microprogram of the HUU are described. Performance measures obtained from the HUU simulator are presented and discussed.
14896#HPS (High Performance Substrate) is a new microarchitecture targeted for implementing very high performance computing engines. Our model of execution is a restriction on fine granularity data flow. This paper introduces the model, provides the rationale for its selection, and describes the data path and flow of instructions through the microengine.
14897#HPS is a new model for a high performance microarchitecture which is targeted for implementing very dissimilar ISP architectures. It derives its performance from executing the operations within a restricted window of a program out-of-order, asynchronously, and concurrently whenever possible. Before the model can be reduced to an effective working implementation of a particular target architecture, several issues need to be resolved. This paper discusses these issues, both in general and in the context of architectures with specific characteristics.
14898#Current digital logic simulators running on engineering workstations lack capacity and speed. This paper discusses a hardware accelerator for a workstation simulator which addresses these problems. The accelerator runs 100x faster than its software counterpart and can simulate up to 1 million gates. The accelerator has been built and is being sold commercially. The architecture of the accelerator is similar to that of a classical dataflow machine. We describe the architecture of the machine and illustrate how it would simulate a simple circuit. We then briefly discuss the relationship between event driven simulation and dataflow.
14899#Microprogramming has traditionally been done in assembly language because of the perceived need for fast execution; compiler technology does not yet exist for discovering and performing many of the clever tricks of an experienced microprogrammer. Unfortunately, programming at the machine-instruction level is both tedious and error-prone. A possible compromise between these two approaches is that of an interactive compiler, where the programmer guides the crafting of critical data structures and sections of code, while the compiler ensures that the resulting code has the same semantics as the original program, generates code where speed is not critical, and performs bookkeeping tasks. We are in the process of implementing a prototype of such a system. This paper describes the system being developed and discusses some of the key design issues.
14900#We describe a system which allows high-level microprogramming without requiring programmer knowledge of the target architecture, depending instead on retargetable microcode generation and optimization. In the ideal system the code generation, microcode compaction, encoding and simulation are driven by a single description of the target microarchitecture. An initial implementation, which is now working for a real microprogrammable processor, demonstrates the feasibility of the key technologies.
14901#The aim of this paper is to develop a top-down design automation tool for digital system design such as microprogrammed processors. The package contains a hardware description language to specify the design, a microcode development module to generate an efficient microprogam for the microprogrammed processor's control, and a functional simulator module to verify the validity of the design. The goal of this project is to develop an interactive computer-aided design environment for specification, design and verification of instruction set processors.
14902#STEP Development Tools (SDT) is a general-purpose microprogram development system. The METASTEP language system is composed of four tools of the SDT needed to write microprograms: a Definition Processor, a Retargetable Assembler, a Retargetable Cross-Assembler, and a Relocatable Linker.These tools are of commercial quality, providing complete languages, quality diagnostics, full interface to other support tools, and high performance. The language system supports microcode debug by providing complete run-time information and by interacting directly with other debug tools provided in SDT.
14903#We believe that the intellectual efforts of persons should be protected, but that the needs of society must be protected, too. Substantial interest in this issue, as it pertains to the protection of microcode, has prompted the preparation of this paper as a position statement to initiate discussion at the 18th International Microprogramming Workshop. We describe the relevant protection mechanisms and some of the nuances regarding them. We describe the important characteristics of microcode. Finally, we assume an advocacy position.
14904#Global microcode compaction is an open problem in firmware engineering. Although Fisher's trace scheduling method may produce significant reductions in the execution time of compacted microcode, it has some drawbacks. There have been four methods. Tree, SRDAG, ITSC , and GDDG, presented recently to mitigate those drawbacks in different ways.The purpose of the research reported in this paper is to evaluate these new methods. In order to do this, we have tested the published algorithms on several unified microcode sequences of two real machines and compared them on the basis of the results of experiments using three criteria: time efficiency, space efficiency, and complexity.
14905#JAM (Just Another Microsequencer) is a flexible - dual role microcode sequencer. It supports high performance N-Way microsequencing operations (traditional 360/370 type branch address generation techniques), along with more traditional (a la AMD 2910) sequencing control over “structured” microcode. A unique feature of the chip is that the degree of parallel branching can be changed dynamically. That is, the chip can be reconfigured to support 2-way, 4-way, … up to 256-way branching on a 14 bit Control Store address.There are 16 microsequencing operations supported including:Next Sequential Control Store AddressN-Way Branch, N-Way Call and N-Way Return (Including several submodes)Conditional Branch, Conditional Call and Conditional ReturnLoop ControlAn on-chip stack provides micro-routine nesting up to 8 levels deep. The stack is also used for looping and a special conditional branching mechanism. The chip has been designed and fabricated using 4 micron NMOS technology and has a cycle time of under 100 nanoseconds.
14906#The paper reports on the control store cost minimization using an approach related to the bit reduction method. A methodology is presented for finding the microinstruction format which provides a minimum joint cost of the control store and microinstruction decoder circuitry for a given set of microprograms. The optimization criterion measures the area taken by the control store and decoders in a large scale integrated circuit. The methodology is based on the concepts of codable microoperation classes and microoperation class distributivity introduced in the paper. The codable classes are those that provide the length reduction of the microinstruction field used for binary encoding microoperation combinations, compared to the single bit/microoperation encoding method. Microoperation class properties and basic types of fields assignments in microinstruction word formats for codable class approach are also discussed.
14907#Proceedings of the 18th annual workshop on Microprogramming
14908#Proceedings of a workshop (Eurographics Seminars on Data structures for raster graphics
14909#COBOL: a systems and structured approach
14910#Twelfth Euromicro symposium on Microprocessing and microprogramming on Microarchitectures, developments and applications
14911#Fast algorithms and their implementation on specialised parallel computers
14912#The Turbo Pascal handbook
14913#The fault-tolerant multiprocessor computer
14914#The hierarchy of energy systems
14915#FERMAT days 85
14916#Fifth generation computers
14917#65816/65802 assembly language programming
14918#Essentials of data processing
14919#Parallel programming in ANSI Standard Ada
14920#Methods of mathematics applied to calculus, probability, and statistics
14921#Introduction to the C programming language
14922#A geometric investigation of reach
14923#Foundations and applications of Montague grammar Part 2: Applications to natural language
14924#Personal Computers in Business
14925#Information systems architecture: A system developer's primer
14926#Handbook of the Napier Tercentenary Celebration or modern instruments and methods of Calculation: Volume III
14927#Getting a handle on productivity
14928#Executive view of microcomputers
14929#Preparing for repercussions
14930#Strategy on the slopes
14931#Telecomm comparison shopping
14932#Can COBOL live forever?
14933#Reeling with the possibilities
14934#Planning by the numbers
14935#On a clear day you can see the trend
14936#Skills shortages and the user
14937#An MSC perspective
14938#Professional development scheme
14939#Kingston Polytechnic agents of change
14940#Computer based training
14941#A microprocessor for teaching
14942#Third World computing
14943#Flying a computer
14944#Computer applications in R&D management
14945#Logica
14946#An overview of computing in China
14947#Security and reliability in banking
14948#Local area network
14949#Reflections on the typology of linguistic borrowing and bilingual situations
14950#The function and formation of semantic systems: a new Chinese Thesaurus of Synonyms
14951#On research in Spanish
14952#Pre-editing of machine-translation input—an experimental evaluation
14953#Rapid and conventional editing: two modalities of one specific activity
14954#Linguistic (semantic) and extra-linguistic (pragmatic) criteria for the evaluation of conference interpretation and interpreters
14955#Demonstrating, explaining, correcting
14956#Most AI applications are still written in LISP, but the recent growth of interest in object oriented programming has given rise to "shell" systems such as LOOPS and KEE, and, thereby, it has emphasised that there is now a need for an AI engine which will efficiently support an arbitrary number of object classes; it seems that it is no Longer sufficient simply to provide for Lists.This paper will demonstrate how the REKURSIV processor and its OBJEKT store can be microcoded to provide an object oriented instruction set like that defined by the SmallTalk-80 virtual machine, and that doing so can lead to an implementation which will run in excess of 250,000 bytecodes/second, a rate which is considerably faster than commerical SmallTalk systems.
14957#An annotated bibliography on reduced instruction set computers
14958#An information-based methodology for the design of concurrent systems
14959#VAX BASIC for business: A screen approach
14960#Calculating Machines—Recent and prospective developments and their impact on mathematical physics and Calculating Instruments and Machines: Volume VI
14961#Pascal Programming: A beginner's guide to computers and programming
14962#A survey of vector optimization in infinite-dimensional spaces, Part 2
14963#Coefficient estimation in a first-order nonlinear hyberbolic Cauchy problem
14964#A general class of branch-and-bound methods in global optimization with some new approaches for concave minimization
14965#Conventional penalty optimization methods
14966#Closed-form recursive formula for an optimal tracker with terminal constraints
14967#Optimal coverage of convex regions
14968#Internal modeling of objective functions for global optimization
14969#A noniterative algebraic solution for Riccati equations satisfying two-point boundary-value problems
14970#Solutions to a class of minimax decision problems arising in communications systems
14971#A Game locating a needle in a square haystack
14972#A relaxed version of Bregman's method for convex programming
14973#Numerical integration of a class of singular perturbation problems
14974#Algorithms for optimization problems with exclusion constraints
14975#Enhanced methods of feasible directions for engineering design problems
14976#Feedback law design and the Liapunov approach
14977#Combinatory analysis: K-distortions of U1,ne and N
14978#Optimal representations of partially ordered sets and limit Sperner theorem
14979#Distance-transitive graphs of valency 5,6 and 7
14980#Simple random walks on trees
14981#A characterization of buildings of a spherical type
14982#Sperner properties for groups and relations
14983#Collapse of the metric hierachy for bipartite graphs
14984#Trapezoidal chains and antichains
14985#Clutters and atomistic lattices
14986#Extremal problems concerning transformations of the set of edges of the complete graph
14987#A class of graphs containing the polar spaces
14988#On k-optimum dipath partitions and partial k-colourings of acyclic diagraphs
14989#Distance-regular graphs and halved graphs
14990#Characters of finite quasigroups II: induced characters
14991#A note on character induction in association schemes
14992#Subdivision of Narayana numbers according to two additional parameters
14993#Discrepancy of set-systems and matrices
14994#Hereditary attributes of surjections and parameter sets
14995#Adjacency in binary matroids
14996#Triples in matroid circuits
14997#A characterization of graphs associated with Fischer groups
14998#A case study of parallel execution of a rule-based expert system
14999#Modeling concurrency with partial orders
15000#Control and data driven execution of logic programs: A comparison
15001#Equivalence of the Gries and Martin proof rules for procedure calls
15002#Precedence technique is not worse than SLR(1)
15003#A comparison of storage optimizatons in automatically-generated attribute evaluators
15004#The Merlin-Randell problem of train journeys
15005#A single server queue with mixed types of interruptions
15006#Ciarcia's circuit cellar: parallel interfacing: A tutorial discussion, part 1: Basics
15007#Programming project: build a spreadsheet program
15008#Programming insight: anagram solving in Pascal
15009#The Definicon 68020 coprocessor Part I: the hardware and operating system
15010#Engineering on a Micro
15011#Computer circuit simulation
15012#Analog circuit analysis
15013#An 8031 in-circuit emulator
15014#Structural analysis
15015#Stress analysis
15016#A material selection program
15017#Small-scale engineering applications
15018#On commercial expert systems projects
15019#Expert systems in management science
15020#System structure for parallel logic programming
15021#Competent systems: The only future for inference-making computers
15022#International conference on information processing and management of uncertainty in knowledge-based systems
15023#The art of computer conversation: a new medium for communication
15024#Linguistic data processing: a text book
15025#Substituting energy technologies
15026#Mathematical model to optimizing the functioning of the national energy system
15027#Graphical systems using the Basic interpreter—A simple interactive graphical system
15028#Algorithmic methods and models Vol.I, the basics, 3rd ed., revised
15029#IBM PC/XT: Basic programming and applications
15030#Advanced BASIC for business
15031#Fundamentals of programming in BASIC: A structured approach 2nd edition
15032#Business analysis and graphics with Lotus 1-2-3
15033#Relational Information Systems
15034#Elements for practical performance modeling
15035#Programming the ADAM computer with ready-to-run programs
15036#Mastering dBase II in less than a day
15037#BASIC programming today: A structured approach
15038#Structured DEC Basic for business using files
15039#Using the Microsoft Business BASIC complier on the IBM PC
15040#Apple Writer tutor: a step-by-step tutorial on Apple Writer IIe/II/III
15041#Applied Digital Control: Theory, design and implementation
15042#BASIC for electronic and Computer Technology
15043#Fundamentals of engineering drawing: with an introduction to interactive computer graphics for design and production, (9th ed.)
15044#Industrial Lasers and their applications
15045#Applied FORTRAN for engineering and science, 2nd Edition
15046#Macintosh Graphics in Modula-2
15047#Easy-writer II system made easy-er
15048#Programming the Macintosh User Interface
15049#Executive's guide to data communications in the corporate enviornment
15050#Data processors' survival quide to accounting
15051#Salesbook Spreadsheets: Sales management, cash management, general management
15052#Fortran 77 for Humans, 3rd Edition
15053#Willwriter: Use your computer to prepare and update your own valid will
15054#Coming of age in the land of computers: a parent's guide to computers for children
15055#Supercalc 3: Learning using and mastering
15056#Word Processing with Display Write 3: a self-teaching guide
15057#A numerical analysis of vortex growth in a bounded rectangular jet
15058#The prediction of turbulent inclined flow in rod bundles
15059#A numerical investigation of Benard convection using finite elements
15060#Stability and phase speed for various finite element formulations of the advection equation
15061#A comparison of high resolution schemes for the two-dimensional linear advection equation
15062#A finite element analysis of laminar flows through planar and axisymmetric abrupt expansions
15063#Steady laminar flow through a twisted pipe of elliptical cross-section
15064#Bicubic patches for approximating non-rectangular control-point meshes
15065#The approximation of non-degenerate offset surfaces
15066#The sphere as a rational Be´ier surface
15067#A representation of a C2 interpolant over triangles
15068#Improperly parametrized rational curves
15069#A new proof of Erdo¨s's theorem on monotone
15070#Graphical constructions of means
15071#Gini means
15072#Remarks on the history and philosophy of mathematics
15073#The William Lowell Putnam mathematical competition
15074#A simple proof of the fundamental theorem of finite Markov chains
15075#A new formula for &pgr;
15076#A characterization of dimension
15077#The Jimmy's book
15078#Maximum products and lim
15079#On characterizations of analyticity
15080#Simultaneous complements in finite-dimensional vector spaces
15081#Oppenheim's inequality for positive definite matrices
15082#Counterexamples to L'Hoˆpital's rule
15083#Convolutions of Cauchy distributions
15084#A method for finding the Eigenvectors of an n x n matrix corresponding to Eigenvalues of multiplicity one
15085#Perspectives for European cooperation
15086#Community strategy in information technology and telecommunications
15087#The technological perspective
15088#The market perspective
15089#Issues basic to the development of a European information technology
15090#Cooperative R&D of information technologies between the government and private sector in Japan
15091#U.S. industrial cooperation in R&D
15092#ESPRIT in action
15093#A return visit to ICOT
15094#Network support of supercomputers
15095#Database Derby highlights
15096#Bugs & fixes
15097#How to save damaged dBASE files
15098#Of bugs & men: Maytags have no anomalies
15099#An introduction to PAL programming
15100#Loan amortization with dBASE III
15101#Using dBASE III plus effectively
15102#Naming days of the week
15103#User defined functions demystified
15104#Assembly language user-defined functions
15105#In search of a standard
15106#Operating environments and a source print update
15107#Financial applications for decision making
15108#AEDS Journal
15109#Effectiveness of computer-based education in colleges
15110#Improving recall using database management systems: A learning strategy
15111#Instructional design for developing computer-based learning materials
15112#Computer assisted instruction performance standards for the design of interactive feedback and control software
15113#Educational malpractice for computers in instruction: A perspective for legal advocacy
15114#Statistical analysis of the characteristics of the secondary school computer studies' students in Hong Kong
15115#A microcomputer system for scheduling job interviews
15116#Effects of learning to program a computer in BASIC or Logo on problem-solving abilities
15117#Authoring languages/systems comparisons
15118#Effects of computer assistance on acquisition of piagetian conceptualization among children of ages two to four
15119#High school experience and university achievement
15120#Identifying student characteristics influencing success in introductory computer science courses
15121#The impact of training methods on the performance of programmers
15122#Global-local methodologies and their application to nonlinear analysis
15123#Elasto-plastic analysis for plane stress contact problems using a modified RBSM method
15124#On the numerical performance of three-dimensional thick shell elements using a hybrid/mixed formulation
15125#An introduction to hierarchical displacement elements and the adaptive technique
15126#An elastic-plastic finite element solution for a cracked plate
15127#A new generation of silicon compilers stalk system-level design and simulation
15128#Higher performance marks floating-point chips
15129#Vendors and users unite on data communications standards
15130#Machine vision inspection market still wide open
15131#Data acquisition
15132#Benchmarking clinches CAE front-end selection
15133#Modem design boosts data processing throughput
15134#Easing the evaluation of standard power supplies
15135#Six DSP processors tackle high-end signal-processing applications
15136#Apollo entry fuels CAE/CAD workstation battle
15137#Documentation start-up emphasizes ties to CAE
15138#DEC's 32-bit bus spawns new industry for VAX-compatible systems
15139#Fault-tolerant computers enter fourth generation
15140#Graphics controller boards bring speed and resolution to bus architectures
15141#Designers confront metastability in boards and buses
15142#Scan-design methods increase testability of standard cells
15143#LCC simulators speed development of synchronous hardware
15144#CAE workstation competition intensifies with new contender from IBM
15145#IBM RISC workstation features 40-bit virtual addressing
15146#Plug-in boards transform PCs into floating-point workstations
15147#Natural touch screen input demands hardware/software blend
15148#Quarter-inch tape cartridges tackle higher capacities
15149#Image processors allow hardware reconfiguration to match applications
15150#Parallel-processing building blocks lift 32-bit performance
15151#Expert system development requires knowledge engineering
15152#Easy interchange of data reduces PCB test efforts
15153#Modified Harvard architecture doubles performance of 68020
15154#`Chip' makers cut cost of PCs and peripherals
15155#Printed circuit board autorouters gain speed and intelligence
15156#Graphics software rides a wave of silicon advances
15157#Graphics pixel processing sizzles with smart frame buffer
15158#Plotters keep up with IC and PC-board advances
15159#Board-level computers
15160#A modular approach to real-time software
15161#Good interconnect design optimizes IC performance
15162#The IEEE-488 bus links to Unix
15163#HINET: a programming language for the construction of reliable, modular distributed programs
15164#Decision properties for chain code picture languages
15165#Algorithms for information extraction and classification of bandlimited signals using level crossings
15166#Syntactic extensions in the programming language LISP
15167#Contributions to information based complexity, image understanding and logic circuit design
15168#A unified approach to the control of conflict in multi-access resource systems
15169#The design and implementation of a TPL compiler system—a system for transporting high level language programs
15170#Structure design for fault tolerant distributed programs
15171#Placement and routing for structured standard cell chips
15172#A parallel execution model for logic programming
15173#A methodology for specifying and analyzing communication protocols and services
15174#Resource bounded Kolmogorov complexity, a link between computational complexity and information theory
15175#Methods for cell compilation with constraints
15176#Automated validation of communication protocols
15177#Optimistic partitioned operation in distributed database systems
15178#An extended abstract data type specification mechanism
15179#A comparison of file allocation decision-making schemes
15180#Analysis of cache memories in highly parallel systems
15181#Relational database conversion system: an attribute classification technique
15182#Markovian analysis and optimization of database recovery protocols
15183#Test generation at the transistor level for MOS combinational logic circuits
15184#A complexity measure during software design
15185#Search with very limited resources
15186#Algorithms for VLSI CAD
15187#On the routing problem for printed circuit boards (VLSI)
15188#On moving and orienting objects
15189#Performance, reliability and queueing analysis of fault-tolerant computer systems
15190#Fault tolerance analysis of full-access interconnection networks
15191#Incremental graph algorithms for parallel random access machines
15192#Advanced COBOL
15193#Apple II applications: forty programs for you Apple
15194#Compute's Amiga applications
15195#File structures: a conceptual toolkit
15196#High-tech society: the story of the information technology revolution
15197#Foundations of statistical inference
15198#Fourth generation languages and applications generators
15199#Fairness
15200#A course of H∞0Econtrol theory
15201#Introduction to VAX-11 architecture and assembly language
15202#Software perspectives: the system is the message
15203#The Apple IIc: your first computer
15204#Frequency domain and state space methods for linear systems
15205#Mathematical statistics (4th ed.)
15206#Introduction to knowledge base systems
15207#Measurement error models
15208#Functional programming: languages, tools, and architecture
15209#Fundamentals of information technology
15210#Nonlinear statistical models
15211#Prolog, programming techniques and applications
15212#Statistical spectral analysis: a nonprobabilistic theory
15213#COBOL 85 example book
15214#Turbo Pascal for BASIC programmers
15215#Turbo Pascal toolbox—a programmer's guide
15216#The third Apple: personal computers and the cultural revolution
15217#Introduction to analysis (3rd ed.)
15218#UNIX Ada programming
15219#Parallel processing: the Cm* experience
15220#Drinfeld modular curves
15221#Non-antagonistic games
15222#Programming language concepts (2nd ed.)
15223#H-embeddings in Hilbert space and optimization on GGD-sets
15224#Proceedings of the 1st GI conference on Data protection and security in changing information technologies
15225#Proceedings of the 3rd GI-NTG technical conference on Measurement, modeling, and evaluation of computer systems
15226#Proceedings of the NGT=GI conference on Architecture and operation of computer systems
15227#Microcomputers for engineers and scientists (2nd ed.)
15228#Apple IIc and IIe assembly language
15229#Assembly language programming for the 68000
15230#Ada, a guided tour and tutorial
15231#Algorithms in SNOBOL4
15232#A glossary of computing terms: an introduction (5th ed.)
15233#How to look it up online
15234#Invariant subspaces of matrices with applications
15235#Exploring language
15236#Computer science: a modern introduction (2nd ed.)
15237#Getting a job in the computer age
15238#An introduction to BASIC programming on the IBM PC (3rd ed.)
15239#Microcomputer applications
15240#Microsoft BASIC for the Macintosh
15241#Structured programming with True BASIC
15242#Turbo Pascal
15243#The idea box for your Apple II: how to put your Apple II to work at home
15244#Advanced Macintosh Pascal: files, quickdraw, toolbox, and inlines
15245#Goodness-of-fit techniques
15246#The microcomputer laboratory manual: based on the 8085 microprocessor
15247#Mediators: a synchronization mechanism
15248#Mediators: a high-level language construct for distributed systems
15249#The protection of information resources
15250#Microcomputer applicationss
15251#An introduction to computer systems
15252#Zen and the art of the Macintosh
15253#Optimal control and stochastic estimation: theory and applications
15254#The implementation of the Icon programming language
15255#Functional calculus of pseudo-differential boundary problem
15256#Tilings and patterns
15257#Guidelines for the documentation of software in industrial computer systems
15258#UNIX: an introduction to concepts and commands in UNIX, version 7, system III, and system V (2nd rev. ed.)
15259#Introductory mathematical analysis for business economics, and the life and social sciences (5th ed.)
15260#The complete guide to IBM PC AT assembly language
15261#Mastering Xenix on the IBM PC AT
15262#Boole's logic and probability: a critical exposititon from the standpoint of contemporary algebra, logic, and probability theory
15263#Multivariate data analysis with readings (2nd ed.)
15264#Making it big in data processing
15265#Advanced Amiga BASIC
15266#Microprocessors and interfacing: programming and hardware
15267#Computer basics for human resource professionals
15268#Numerical methods for scientists and engineers (2nd ed.)
15269#Introduction to FORTRAN 77 and the personal computer
15270#Multivariate analysis of variance for behavioural scientists
15271#Proficient C: the Microsoft guide to advanced C programming
15272#vi—the UNIX screen editor: a user's guide
15273#Keyboarding for information processing (2nd ed.)
15274#C, a reference manual (2nd ed.)
15275#Commodore 128 BASIC: programming techniques
15276#Algorithmics: the spirit of computing
15277#Systems analysis and design projects
15278#The Macintosh advisor
15279#on The First Annual Hartford Graduate Center Computer Science Conference
15280#Creating simulation games on your computer
15281#Exploring artificial intelligence on your Apple II
15282#Exploring artificial intelligence on your IBM PC
15283#A stochastic maximum principle for optimal control of diffusions
15284#Assembly language programming on the IBM PC
15285#Pascal programming: a beginner's guide to computers and programming (2nd ed.)
15286#Matrices for statistics
15287#Your Commodore 128: a guide to the Commodore 128 computer
15288#Salvaging damaged dBASE files
15289#Commodore 128 reference guide for programmers
15290#Data compression: techniques and applications: hardware and software considerations (2nd ed.)
15291#The spectral theorem
15292#Using Microsoft and IBM BASIC: an introduction to computer programming
15293#Microsoft QuickBASIC: developing structured programs with Microsoft BASIC
15294#Data structured software maintenance: the Warnier/Orr approach
15295#Apple machine/assembly language programming
15296#Pascal programming
15297#The mathematics of programming: an inaugural lecture delivered before the Univ. of Oxford on Oct. 17, 1985
15298#Applications of knowledge based systems to microelectronic CAD
15299#Proceedings of the second European conference on TEX for scientific documentation
15300#Running TEX in an interactive text processing environment
15301#How to please authors and publishers: a versatile document preparation system at Karlsruhe
15302#An improved user environment for TEX
15303#The VORTEX document preparation environment
15304#EasyTEX: Towards interactive formulae input for scientific documents input with TEX
15305#A multilingual TEX
15306#INRSTEX: a document preparation system for multiple languages
15307#ASHTEX: An interactive previewer for TEX or The marvellous world of ASHTEX
15308#A language to describe formatting directives for SGML documents
15309#Retrieving mathematical formulae
15310#Integrating TEX in an EDDS with very high resolution capabilities
15311#The TEX-based document factory in a university environment: process model, implementation steps, experiences
15312#GRIF: An interactive environment for TEX
15313#Abstract markup in TEX
15314#Designing a new typeface with METAFONT
15315#“Verheissung und Versprechen”, a third generation approach to theological typesetting
15316#Proceedings of the international conference on Mathematical foundations of programming semantics
15317#Standard, storeless semantics for ALGOL-style block structure and call-by-name
15318#Cartesian closed categories, quasitopoi and topological universes
15319#Concrete categories and injectivity
15320#Fixed points in process algebras with internal actions (a preliminary note)
15321#A fully abstract semantics and a proof system for an ALGOL-like language with sharing
15322#Comparing categories of domains
15323#Galois connections
15324#Retracts of SFP objects
15325#Continuous categories
15326#Free constructions of powerdomains
15327#Additive domains
15328#A topological framework for cpos lacking bottom elements
15329#Detecting local finite breadth in continuous lattices and semilattices
15330#On the variety concept for &ohgr;-continuous algebras. Application of a general approach
15331#On denotational semantics of data bases
15332#Postconditional semantics of data base queries
15333#What is a model? A consumer's perspective on semantic theory
15334#Modal theory, partial orders, and digital geometry
15335#An FP domain with infinite objects
15336#Union complete countable subset systems
15337#On the syntax and semantics of concurrent computing
15338#Proceedings of the IFIP TC 8 working conference on office systems on Office Systems
15339#The field of office systems
15340#Perspectives and views of the office: alternative approaches to understanding the office
15341#Office tool development
15342#Functional analysis of office requirements (FAOR)
15343#Trends in office modeling
15344#Architectural implications of office systems
15345#Human factors in office systems
15346#Organizational implications of office systems: toward a critical social action perspective
15347#Security of office systems
15348#Implementation of office systems
15349#Accurate numerical solutions for Drucker-Prager elastic-plastic models
15350#Efficient implementation of quadrilaterals with high coarse-mesh accuracy
15351#Uses of artificial intelligence in design optimization
15352#On stress computation in displacement finite element models
15353#A new finite element formulation for computational fluid dynamics: II. Beyond SUPG
15354#Touch-sensitive screens: the technologies and their application
15355#A phonemic transcription program for Polish
15356#A framework for investigating language-mediated interaction with machines
15357#Criteria for the selection of search strategies in best-match document-retrieval systems
15358#Learning computer programming through dynamic representation of computer functioning: evaluation of a new learning package for Pascal
15359#Transitive closures of fuzzy thesauri for information-retrieval systems
15360#Maintenance training simulator fidelity and individual differences in transfer of training
15361#The effects of pavement edgelines on performance in a driving simulator under sober and alcohol-dosed conditions
15362#Drowsy driver detection using discriminant analysis
15363#Processing demands, training, and the vigilance decrement
15364#No effect of noise on vigilance performance?
15365#Take complexity in visual inspection
15366#A high-performance memory management scheme
15367#Evaluating the performance of multicomputer configurations
15368#First Page of the Article
15369#First Page of the Article
15370#First Page of the Article
15371#First Page of the Article
15372#Proceedings of CRYPTO 84 on Advances in cryptology
15373#A prototype encryption system using public key
15374#A new signature scheme Is proposed together with an implementation of the Diffie - Hellman key distribution scheme that achieves a public key cryptosystem. The security of both systems relies on the difficulty of computing discrete logarithms over finite fields.
15375#The undecidable word problem for groups and semigroups is investigated as a basis for a public-key cryptosystem. A specific approach is discussed along with the results of an experimental implementation This approach does not give a provably secure or practical system, but shows the type of cryptosystem that could be constructed around the word problem. This cryptosystem is randomized, with infinitely many ciphertexts corresponding to each plaintext.
15376#Signatures based on polynomial equations modulo n have been introduced by Ong, Schnorr, Shamir [3]. We extend the original binary quadratic OSS-scheme to algebraic integers. So far the generalised scheme is not vulnerable by the recent algorithm of Pollard for solving s12 + k s22 = m (mod n) which has broken the original scheme.
15377#Identity-based cryptosystems and signature schemes
15378#We introduce a new knapsack type public key cryptosystem. The system is based on a novel application of arithmetic in finite fields, following a construction by Bose and Chowla. Appropriately choosing the parameters, we can control the density of the resulting knapsack. In particular, the density can be made high enough to foil "low density" attacks against our system. At the moment, we do not know of any attacks capable of "breaking" this system in a reasonable amount of time.
15379#Some public key crypto-functions as intractable as factorization
15380#Computing logarithms in GF(2n)
15381#This paper presents the results of a simulation of an analog encryption scheme. The scheme, introduced in 1979 by Aaron Wyner of Bell Telephone Laboratories, provides secure, accurate scrambling of speech waveforms, while conforming to the bandlimitedness of a telephone channel. The simulation confirms the scheme's theoretical properties, based on numerical measures and on listening to encrypted and decrypted waveforms.
15382#On rotation group and encryption of analog signals
15383#The history of book ciphers
15384#Since Crypto 83 we have had considerably more experience in factoring large integers. Implementation of various modifications to the quadratic sieve algorith have enabled the factorization of hard 70- digit numbers in times comparable to 50 digits one year ago. These modifications include: 1) Subsequences with large divisors (Special q's). 2) Multipliers to improve quadratic properties. 3) Increased size of prime base using segmented Gaussian Elimination. 4) Optimization of the code with respect to Cray hardware.Using this code in its various stages of development the 10 most wanted numbers from the Cunningham Project have been factored. Details will be published elsewhere.
15385#This paper describes an LSI digital encryption processor (DEP) for data ciphering. The DEP combines a fast hardware implementation of the Data Encryption Standard (DES) published by the National Bureau of Standards (NBS) with a set of multiplexers and registers under the control of a user programmed sequencer. This architecture enables the user to program any of the DES modes of operation published by NBS. In addition, multiple ciphering operations and multiplexed ciphering operations using up to four different keys may be programmed and internally executed without any external hardware.The DEP is designed as a standard microprocessor peripheral. This LSI device should reduce the current cost and simplify the process of encrypting digital data to a point where it is feasible to include a ciphering function in modems, terminals, and work stations. The ability to internally program cascaded ciphers should substantially increase the security of the DES algorithm and hence, the life of the encryption equipment.
15386#Importance of DES: NBS, ANSI and ISO (in study) have DES as standards.The available devices or programs have some tedious properties for an extensive use: 驴 hardware is expensive or slow, and limited, 驴 software is slow.We describe methods for obtaining efficient hardware and software implementations for the DES, i.e.
15387#Several improvements to realize implementations for DES are discussed. One proves that the initial permutation and the inverse initial permutation can be located at the input, respectively the output of each mode in DES. A realistic design for an exhaustive key search machine is presented.
15388#A cipher system used for secure communication over a noisy channel can automatically synchronize the sender and receiver by computing a stateless function of a key and a limited amount of the recent cipher-text. The more ciphertext feedback is used, the more the errors from the noisy channel are propagated. The less feedback is used, the easier ciphertext-only and chosen-plaintext attacks become. There is a trade-off between security and noise that must be made when a self-synchronizing system is built.This paper presents a self-synchronizing cascaded cipher system that permits most combinations of key and ciphertext feedback lengths and also allows adjustment of the trade-off between security and noise during system operation. At times when maximum security is not needed, the error propagation can be reduced temporarily.As implemented in hardware, the cascaded cipher has a storage register for each stage. The function computed would normally depend on the state of this storage, but different clocks are used at each stage to render the function stateless. The use of a cascade helps to keep the hardware cost down.
15389#Cryptographically secure pseudo-random number generators known so far suffer from the handicap of being inefficient; the most efficient ones can generate only one bit on each modular multiplication (n2 steps). Blum, Blum and Shub ask the open problem of outputting even two bits securely. We state a simple condition, the XOR-Condition, and show that any generator satisfying this condition can output logn bits on each multiplication. We also show that the logn least significant bits of RSA, Rabin's Scheme, and the x2 mod N generator satisfy this condition. As a corollary, we prove that all boolean predicates of these bits are secure. Furthermore, we strengthen the security of the x2 mod N generator, which being a Trapdoor Generator, has several applications, by proving it as hard as Factoring.
15390#An LSI random number generator (RNG)
15391#A generalized linear threshold scheme is introduced. The new scheme generalizes the existing linear threshold schemes. The basic principles involved in the construction of linear threshold schemes are laid out and the relationships between the existing schemes are completely established. The generalized linear scheme is used to provide a hierarchical threshold scheme which allows multiple thresholds necessary in a hierarchical environment.
15392#Security of ramp schemes
15393#A fast pseudo random permutation generator with applications to cryptology
15394#Now that "random functions" can be efficiently constructed ([GGM]), we discuss some of their possible applications to cryptography: 1) Distributing unforgable ID numbers which can be locally verified by stations which contain only a small amount of storage. 2) Dynamic Hashing: even if the adversary can change the key-distribution depending on the values the hashing function has assigned to the previous keys, still he can not force collisions. 3) Constructing deterministic, memoryless authentication schemes which are provably secure against chosen message attack. 4) Construction Identity Friend or Foe systems.
15395#This paper introduces the first probabilistic public-key encryption scheme which combines the following two properties: (1) Perfect secrecy with respect to polynomial time eavesdroppers: For all message spaces, no polynomial time bounded passive adversary who is tapping the lines, can compute any partial information about messages from their encodings, unless factoring composite integers is in probabilisic polynomial time. (2) Efficiecy: It compares favorably with the deterministic RSA public-key cryptosystem in both encoding and decoding time and bandwidth expansion.The security of the system we propose can also be based on the assumption that the RSA function is intractable, maintaining the same cost for encoding and decoding and the Same data expansion. This implementation may have advantages in practice.
15396#We prove that RSA least significant bit is 1/2 + 1/logc N secure, for any constant c (where N is the RSA modulus). This means that an adversary, given the ciphertext, cannot guess the least significant bit of the plaintext with probability better than 1/2 + 1/logc N unless he can break RSA.Our proof technique is strong enough to give, with slight modifications, the following related results: (1) The log log N least significant bits are simultaneously 1/2 + 1/logc N secure. (2) The above also holds for Rabin's encryption function.Our results imply that Rabin/RSA encryption can be directly used for pseudo random bits generation, provided that factoring/inverting RSA is hard.
15397#Information theory without the finiteness assumption, I: Cryptosystems as group-theoretic objects
15398#The ADFGX cryptographic system, invented by Fritz Nebel, was introduced by Germany during World War I on March 5, 1918. The names ADFGX and ADFGVX for the successor system refer to the use of only five (and later six) letters A, D, F, G, (V,) X in the ciphertext alphabet. Kahn [KA] suggests that these letters were chosen because differences in Morse International symbols.
15399#This paper presents an outline of an attack that we have used successfully to break iterated knapsacks. Although we do not provide a proof that the attack almost always works, we do provide some heuristic arguments. We also give a detailed description of the examples we have broken.
15400#New general properties in the S-boxes were found. Techniques and theorems are presented which allow to evaluate the non-substitution effect in f and the key clustering in DES. Examples are given. Its importance related to the security of DES is discussed.
15401#Interest in the cryptanalysis of the National Bureau of Standards' Data Encryption Standard (DES) has been strong since its announcement. Here we describe an attack on a class of ciphers like DES based on linear factors.If DES had any non trivial factors, these factors would provide an easier attack than one based on complete enumeration. Basically, a factor of order n reduces the cost of a solution from 256 to 2n+256-n At worst (n-1 or 55), this reduces the cost of a Diffie-Hellman search machine from 20 million dollars to 10 million dollars: a 10 million dollar savings. At best (n-28), even without iteration, the method could reduce the cost from 256 to 228+ 228: a computation well within the reach of a personal computer.Alas, DES has no such linear factors.
15402#A message authenticator algorithm suitable for a mainframe computer
15403#Key management for secure electronic funds transfer in a retail environment
15404#We consider a communications scenario in which a transmitter attempts to inform a remote receiver of the state of a source by sending messages through an imperfect communications channel. There are two fundamentally different ways in which the receiver can end up being misinformed. The channel may be noisy so that symbols in the transmitted message can be received in error, or the channel may be under the control of an opponent who can either deliberately modify legitimate messages or else introduce fraudulent ones to deceive the receiver, i.e., what Wyner has called an "active wiretapper" [1]. The device by which the receiver improves his chances of detecting error (deception) is the same in either case: the deliberate introduction of redundant information into the transmitted message. The way in which this redundant information is introduced and used, though, is diametrically opposite in the two cases.For a statistically described noisy channel, coding theory is concerned with schemes (codes) that introduce redundancy in such a way that the most likely alterations to the encoded messages are in some sense close to the code they derive from. The receiver can then use a maximum likelihood detector to decide which (acceptable) message he should infer as having been transmitted from the (possibly altered) code that was received. In other words, the object in coding theory is to cluster the most likely alterations of an acceptable code as closely as possible (in an appropriate metric) to the code itself, and disjoint from the corresponding clusters about other acceptable codes.
15405#As the use of computers becomes more pervasive, they are capturing increasingly more revealing data about our habits, lifestyles, values, whereabouts, associations, political and religious orientation, etc. The current approach, which requires individuals to identify themselves in relationships with organizations, allows records of all an individual's relationships to be linked and collected together into a dossier or personal profile. Even though such profiles are too extensive to evaluate manually on a mass basis, automated evaluation is becoming increasingly feasible.A new approach prevents linking of such data, by allowing individuals to conduct relationships under different account numbers or "digital pseudonyms." The pseudonyms are created by a physical random process within a credit-card-sized computer carried by the individual. The card has no secrets from the individual or structure unmodifiable by the individual; it is merely a computer that acts on the individual's behalf and provides a convenient interface.
15406#We consider two problems which arose in the context of "The Exchange of Secret Keys" (see [1]).(1). In the original protocol, one party may halt the exchange and have a 2 to 1 expected time advantage in computing the other party's secret. To solve this problem, when there is a particular point in the exchange where this time advantage may be critical, we presented at CRYPTO 83 (see [5]), a method for exchanging "fractions" of a single bit.In this paper we extend the method so as to apply it to all bits to be exchanged, and show how it can be used in a more abstract setting (as in [2]).(2). We also present a solution to the problem of how to ensure a fair exchange of secrets when one party in the exchange is "risk seeking", while the other is "risk-adverse".
15407#Investigating the capabilities of public key and related cryptographic techniques has recently become an important area of cryptographic research. In this paper we present some new algorithms and cryptographic protocols (Cryptoprotocols) which enlarge the range of applications of public key systems and enable us to perform certain transactions in communication networks. The basic cryptographic tools used are Rabin's Oblivious Transfer Protocol and an algorithm we developed for Number Embedding which is provably hard to invert.We introduce the protocol Subscription to a Public Key, which gives a way to transfer keys over insecure communication channels and has useful applications to cryptosystems. We develop the Secret Blocking Protocol, specified as follows: 'A transfers a secret to B, B can block the message. If B does not block it, there is a probability P that he might get it. (1/2 驴 P
15408#Poker protocols
15409#The complexity of a finite sequence as defined by Lempel and Ziv is advocated as the basis of a test for cryptographic algorithms. Assuming binary data and block enciphering, it is claimed that the difference (exclusive OR sum) between the plaintext vector and the corresponding ciphertext vector should have high complexity, with very high probability. We may refer to this as plaintext/ciphertext complexity. Similarly, we can estimate an "avalanche" or ciphertext/ ciphertext complexity. This is determined by changing the plaintext by one bit and computing the complexity of the difference of the corresponding ciphertexts. These ciphertext vectors should appear to be statistically independent and thus their difference should have high complexity with very high probability. The distribution of complexity of randomly selected binary blocks of the same length is used as a reference. If the distribution of complexity generated by the cryptographic algorithm matches well with the reference distribtion, the algorithm passes the complexity test. For demonstration, the test is applied to modulo multiplication and to successive rounds (iterations) of the DES encryption algorithm. For DES, the plaintext/ ciphertext complexity test is satisfied by the second round, but the avalanche complexity test takes four to five rounds before a good fit is obtained.
15410#An update on quantum cryptography
15411#How to keep a secret alive: extensible partial key, key safeguarding, and threshold systems
15412#Current trends in concurrency. Overviews and tutorials
15413#Dataflow and eduction: data-driven and demand-driven distributed computation
15414#Contrasting themes in the semantics of imperative concurrency
15415#Functional programming and the language TALE
15416#Design, specification and validation of hierarchies of protocols in distributed systems
15417#Infinitary languages: basic theory and applications to concurrent systems
15418#The quest goes on: a survey of proof systems for partial correctness of CSP
15419#Logic programming: the foundations, the approach and the role of concurrency
15420#Process theory: semantics, specification and verification
15421#Applications of temporal logic to the specification and verification of reactive systems: a survey of current trends
15422#Petri nets: basic notions, structure, behaviour
15423#Concepts for concurrent programming
15424#There are four “cultures” of microprogramming: the Bit-Slice Culture, the Commercial Processor Culture, the Microprogrammable Processor Culture, and the Single-Chip Culture. The effect of trends in VLSI (Very Large Scale Integration) on microprogramming can be assessed by looking the effect on each culture. The Bit-Slice Culture will be affected because levels of integration in bipolar have reached 32-bit slices and the performance of CMOS is improving to compete with the dominant bipolar technologies in these applications. The Commercial Processor Culture and the Microprogrammable Processor Culture will be least affected by changes in Technology and integration levels. The Single-Chip Culture will be most affected. There are about two more microprocessor generations to go before chips contain an essentially complete CPU. After that, designs will diversify. Microprogramming still has a good future.
15425#The MONADS-PC System is a capability-based computer constructed around a microprogrammed processor designed and implemented at Monash University in Melbourne, Australia. This paper describes a set of tools developed as part of this project in order to simplify the implementation and testing of the microcode and to ensure consistency between the microcode and macro-level machine instruction set. Although some of these tools are at present machine specific, the paper demonstrates that they could be generalised into a flexible microcode development system.
15426#This paper presents a design technique for computational systems based on the concepts of Model, Abstraction, and Simulation. This technique, developed and evaluated especially in Real Time System applications, is particularly useful to design hierarchical multiprocessor microprogrammed systems. A set of tools and facilities for designing and building the system is also shown.
15427#This paper describes a development environment for horizontal microcode. The environment uses Percolation Scheduling, a transformational system for parallelism extraction, and an interactive profiling system to give the user control over the microcode compaction process while reducing the burdensome details of architecture, correctness preservation, and synchronization. Through a graphical interface the user suggests what should be done in parallel, while the system performs the actual changes using semantics-preserving transformations. If a request cannot be satisfied, the system reports the problem causing the failure. The user may then help eliminate the problem by supplying guidance or information not explicit in the code.
15428#ARCHI is a microarchitecture description language designed to serve as the underlying language for a retargetable firmware development environment. ARCHI provides a hierarchical, procedural description at the register transfer level of the target microarchitecture. This description can then be utilized by a meta-environment to generate an instantiation of the firmware development environment for a specific target microarchitecture.ARCHI has been successfully used to generate debugging simulators for the vertical Perkin-Elmer 3220, and the horizontal VAX-11/780. It is shown that if a microarchitecture description language is powerful enough to retarget a debugging simulator then it can be used to retarget almost every tool in a firmware development meta-environment, and that ARCHI accordingly satisfies its design objectives.
15429#This paper presents a microcode generator, which accepts a source program (algorithm) and a target description (microarchitecture) as input and generates microcode to implement the algorithm on the defined microarchitecture. The target description is similar to the outputs produced by datapath synthesis phase in hardware design packages. Thus, it can be incorporated to synthesise a microprogrammed control.The microcode generator is based on an algorithm which preserves retargetability without sacrificing on design time. This is achieved by implementing the generator in two phases: in the first phase, a set of 'feasible' register transfer operations (called base-set) is generated from the microarchitecture description. In the second phase, translation is carried out by simply searching and matching the source program statements with the base-set.
15430#This paper proposes a hybrid microprocessing/microprogramming (HMM) scheme to implement the algorithmic state machines (ASM). First, a behavior model of the HMM is defined. This model carries out any task by partitioning it into a microprocessing subtask which is executed by a microprocessor unit and a microprogramming subtask which is executed by a microprogrammed unit. The problems of constructing the microprogrammed unit of HMM are then considered, including the synthesis of control store sequencer, compaction of control store, and microcode generation. Finally, an application example using the above method to design a universal floppy disk controller which can accept all kinds of encoding formats is provided.
15431#We have implemented a high performance Prolog engine by directly executing in microcode the constructs of Warren's Abstract Machine. The implementation vehicle is the VAX 8600 computer. The VAX 8600 is a general purpose processor containing 8K words of writable control store. In our system, each of the Warren Abstract Machine instructions is implemented as a VAX 8600 machine level instruction. Other Prolog built-ins are either implemented directly in microcode or executed by the general VAX instruction set. Initial results indicate that our system is the fastest implementation of Prolog on a commercially available general purpose processor.
15432#The VAX architecture is a popular ISP architecture that has been implemented in several different technologies targeted to a wide range of performance specifications. However, it has been argued that the VAX has specific characteristics which preclude a very high performance implementation. We have developed a microarchitecture (HPS) which is specifically intended for implementing very high performance computing engines. Our model of execution is a restriction on fine granularity data flow. In this paper, we concentrate on one particular aspect of an HPS implementation of the VAX architecture: the generation of HPS microinstructions (i.e. data flow nodes) from a VAX instruction stream.
15433#This paper presents a cost-effective scheme for partitioning large data flow graphs. Standard data flow machine architectures are assumed in this work. The objective is to reduce the overhead due to token transfers through the communication network of the machine. When this scheme is employed on large graphs, the load distribution on the rings of the data flow machine is also improved. A canonical form of a data flow graph is introduced to establish the relationship between the communication overhead and the size reduction of the partition cut-set. General lower estimates on the overhead are derived in terms of processing and transmission delay parameters of the machine. The method uses heuristics and an evaluation function to guide the partition algorithm. Some implications of the proposed method on the organization of the data flow machines are discussed.
15434#The software pipeline technique is an effective approach to optimizing loops in array processor programs, but existing methods are of high complexity and the results may not be satisfactory.This paper introduces the URPR algorithm, an extension of the microcode loop compaction algorithm URCR. Firstly, unroll the loop(the number of unrolled loop bodies relies on the inter-body data dependency); secondly, pipeline the unrolled loop bodies one by one; and finally, a new optimized loop body is obtained after rerolling. Preliminary tests indicate that URPR produces favorable results with lower complexity.
15435#There are a growing number of micro-architectures that employ pipelined array units for high-speed floating point applications. To obtain the performance required in such applications, effective loop optimization is crucial. The loop optimization problem for micro-architectures with pipelined processing units is similar to the problem of array processor loop optimization. The URPR method has been proven to be an effective, low-complexity approach to optimizing loops in array processor programs, so we conducted a case study of the method applied to a representative pipelined microarchitecture based on the AMD29500 chip family. The results of applying two URPR compaction algorithms and a new compaction algorithm to the 29500-based micro-architecture are presented. With the new compaction algorithm, we were able to realize microcode as efficient as the complex microcode manually derived by AMD.
15436#Microprogramming is an implementation technique. As computer complexity has risen, it has gained increased importance and wider application. As we proceed through the 80's, we are witness to more specialization and divergence between hardware and software. Hardware trends toward VLSI introduce new tradeoffs that are to be evaluated by design engineers. Concurrency and complex security mechanisms in operating systems and databases have extended the software development discipline to new limits. Each of these examples illustrate the trend toward a larger gap between hardware and software. The purpose of this paper is first, to re-examine the role that microprogramming or firmware engineering plays in the design and implementation of computer systems and, second, to analyze its ability to bridge the gap between hardware and software as perceived and affected by various corporate cultures.
15437#A new, microcoded, RISC-type system is proposed and presented. The microcode is stored in a 256 x 64 PROM Nanomemory in the CPU. The 8-bit opcode of each instruction is a direct address to the Nanomemory. Each Nanomemory 64-bit word (horizontal microcode) corresponds to a specific machine language instruction. A large 2048 x 32 CPU Register file, using the register window approach, is implemented. A bit-sliced (AMD2900) prototype is currently under construction.
15438#This paper describes the design and realization of MLM, a Multi-Lingual machine whose main goal is to provide support for teaching and research in Microprogramming and Computer Architecture. MLM is based on a standard (non-microprogrammable) minicomputer whose microarchitecture has been modified in order to satisfy the requirements of a multi-lingual environment.The resulting machine is microprogrammable, offers facilities for interpreting different target repertoires, and has means to switch from one instruction set to another. MLM implements the concept of dynamic microprogramming, and in its current version there are two control stores defining two conventional levels at any time: the first is the conventional level fixed by the host manufacturer (in PROM); the second may be specified by the user.In addition to the design and implementation issues, the paper also outlines the research potential of MLM and describes the current stage of the work.
15439#This paper describes the micro-architecture of a microprogrammed workstation called MONADS-PC. The system has been specifically designed to support a very large uniform virtual memory, capability-based addressing and information hiding software modules with procedural interfaces. The paper gives a brief introduction to these topics followed by implementation details of the system.
15440#Microcode debuggers may be classified according to the following three criteria: static or dynamic output, the level of debugging, and the type of debugging facilities provided. A very high level interactive debugger that supports dynamic debugging of microcode written for the Perkin-Elmer 3220 is described in this paper.The system allows the user to debug microcode at a very high level because the microarchitecture of the machine can be displayed in the format conceived by the user. The display is dynamic in that the user sees the flow of data as it occurs during the execution of microinstructions. The system supports the usual debugging facilities including setting breakpoints, executing in step or continuous modes, executing in trace mode, examining and changing the contents of memory locations and registers, and restarting the microprogram at an earlier location. But, these facilities are greatly enhanced because the output of the debugger is graphical and dynamic.
15441#BBMSS is a part of our software aided for the development of bit-slice based systems and is used as a tool for testing and debugging of microprograms . It contains three parts : a hardware description language , a parser , and a simulation program . The hardware description language which is an extension to CDL is presented here . The simulation program which handles user's commands to simulate the behaviour and function of microprogram is given and the parser is also described briefly in this paper.
15442#Algebraic methods have been widely used to find properties of programs, especially for use in compiler optimisation. This paper describes the use of this kind of method to prove the absence of particular errors in microcode, or to detect and locate such errors. In order to show the kind of error which may be found we consider a number of examples. All of these have found errors in practical microcode, written for the PERQ computer.
15443#We have developed an environment which allows us to collect data for performance analysis by modifying the microcode of a VAX 8600. This use of microprogramming permits data to be collected with minimal system perturbation (i.e. the data is almost as good as that obtained with a hardware monitor) but at the cost and with the ease of use of a software simulator. In this paper we describe the environment that we have developed and present two examples of its use. The first example, procedure call instrumentation, illustrates a technique for gathering data on how certain architectural features are used. The second example, instruction tracing, illustrates a technique for collecting data that can then be used in trace—driven simulation.
15444#Proceedings of the 19th annual workshop on Microprogramming
15445#Decomposition techniques for the ocean wave identification problem
15446#Existence of finitely optimal solutions for infinite-horizon optimal control problems
15447#The polyadic structure of factorable function tensors with applications to high-order minimization techniques
15448#Simple-motion pursuit-evasion differential games, Part I: stroboscopic strategies in collision-course guidance and proportional navigation
15449#Simple-motion pursuit-evasion differential games,Part 2: optimal evasion from proportional navigation guidance in the deterministic and stochastic cases
15450#A pursuit-evasion differential game with noisy measurements of the evader's bearing from the pursuer
15451#Design of optimal observers with specified eigenvalues via shifted Legendre polynomials
15452#Information systems and the stimulation of creativity
15453#Information infrastructure in the Arab countries: an analysis
15454#Information systems planning and operation in less developed countries.Part 1:planning and operational concerns
15455#An evaluation of information sources for current awareness on occupational diseases
15456#An evaluation of information sources for retrospective literature searching on occupational diseases
15457#Using IBM's ISPF dialog manager: under MSV, VM, and VSE
15458#Proceedings of the 6th colloquium on Computer installations--organization and management of information processing
15459#The C companion
15460#Understanding computers (2nd ed.)
15461#Fundamentals of structured COBOL
15462#Topics in matrix analysis
15463#Cryptography
15464#Understanding and using Microsoft BASIC/IBM PC BASIC
15465#Microcomputer programming languages
15466#Assignment methods incombinatorial data analysis
15467#PL/I structured programming
15468#Elements of statistical inference (6th ed.)
15469#The computer challenge: technology, applications, and social implications
15470#The computer challenge: with BASIC and Pascal
15471#The computer challange using software productivity
15472#Memory resident utilities, interrupts, and disk management with MS and PC DOS
15473#I. Schur methods inoperator theory and signal processing
15474#Proceedings of IBM Europe Institute Workshop on large scale eigenvalue problems on Large scale eigenvalue problems
15475#IBM—small and medium systems
15476#Proceedings of the 14th IFAC/IFIP workshop on Real time programming
15477#Proceedings of the IFAC/IFIP workshop on Real time programming 1985
15478#Proceedings of the second IFAC symposium on IFAC symposium on stochastic control
15479#Proceedings of the 3rd IFIP TC9 conference on human choice and computers on Comparative worldwide national computer policies
15480#Proceedings of the IFIP WG 2.6 working conference on data semantics (DS-1) on Data semantics (DS-1)
15481#Proceedings of the IFIP-WG 7/1 working conference on Recent advances in system modelling and optimization
15482#Proceedings of the IFIP World Computer Congress on Information processing 86
15483#Minidictionary of computing
15484#Institute of Mathematics and its applications conference series on Fourth IMA international conference on control theory
15485#Computer systems: performance and simulation IMACS world congress on systems simulation and computation
15486#Implementing mathematics with the Nuprl proof development system
15487#Information systems education: recommendations and implementation
15488#Information technology and people: designing for the future
15489#Information and society
15490#Advanced color graphics and animation for the IBM PC
15491#IEEE trial-use standard portable operating system for computer environments
15492#Integrated project support environments
15493#Intelligent information systems: pN
15494#Proceedings of the 7th international conference on Analysis and optimization for systems
15495#Interfacing thought: cognitive aspects of human-computer interaction
15496#Proceedings of the II international workshop on parallel processing by cellular au on International workshop on parallel processing by cellular automata and arrays
15497#Making use of the UNIX operation system
15498#Signal processing design techniques
15499#Dictionary of robot technology in four languages: English, German, French, Russian
15500#Numerical methods for scientists and engineers
15501#Telecom: hook up or lose out
15502#Adaptive gray scale mapping to reduce registration noise in difference images
15503#Filling by quadrants or octants
15504#Axial representations of shape
15505#The variational approach to shape from shading
15506#The characterization of parametric surface sections
15507#Recursive region splitting at hierarchical scope views
15508#Proceedings of the Joint International Conference on CAD and robotics in architecture and construction
15509#Methods for solving breakpoint problems
15510#Probabilistic inference: theory and practice
15511#Rapid prototyping for large Ada software system design
15512#Static analysis based on denotational transformations
15513#A 68000 based modular multiprocessor system: design and simulation analysis
15514#Issues in distributed programming languages: the evolution of SR
15515#Compiling queries in indefinite deductive databases under the generalized closed world assumption
15516#Program partitioning and synchronization on multiprocessor systems
15517#Synthesizing realistic textures by the composition of perceptually motivated functions
15518#A storage management system for a reliable distributed operating system
15519#Dynamic control structures for cooperating processes
15520#System design of an integrated communication and access network (ICAN), for the automated office
15521#A hybrid, combinatorial-Markov method of solving performance and reliability models
15522#An integration of decision tables and a relational database system into a Prolog environment
15523#Concurrency control algorithms and their performance in replicated database systems
15524#Modular verification of concurrent systems
15525#On reliability mechanisms in distributed database systems
15526#First Page of the Article
15527#First Page of the Article
15528#First Page of the Article
15529#First Page of the Article
15530#First Page of the Article
15531#First Page of the Article
15532#First Page of the Article
15533#A two-level iteration method for solution of contact problems
15534#Thermal mechanically coupled finite element analysis in metalforming processes
15535#A new method for the coupling of finite element and boundary element discretized subdomains of elastic bodies
15536#Stress determination in edge-cracked anisotropic plates by an extension of boundary-collocation method
15537#A triangular thin-shell finite element based on discrete Kirchhoff theory
15538#A new finite element formulation for computational fluid dynamics: I. Symmetric forms of the compressible Euler and Navier—Stokes equations and the second law of thermodynamics
15539#On the convergence of the bilinear-velocity constant-pressure finite element method in viscous flow
15540#A linearizing algorithm for nonlinear differential equations
15541#The architecture of a homogeneous vector supercomputer
15542#Processor allocation in a multi-ring dataflow machine
15543#Analysis of multiple-bus interconnection networks
15544#An asynchronous algorithm for scattering information between the active nodes of a multicomputer system
15545#Interconnection networks: physical design and performance analysis
15546#Systolic structures: A notion and characterization
15547#Some parallel sorts on a mesh-connected processor array and their time efficiency
15548#An examination of distributed planning in the world of air traffic control
15549#Lattice model of browsable data spaces
15550#System-level diagnosis: analysis of two new models
15551#An LDU decomposition algorithm for a block toeplitz matrix having a parallel and pipelined computing structure
15552#Detection of interlocking components in three-dimensional digital pictures
15553#Order-&agr; weighted information energy
15554#Fuzzy entropy and conditioning
15555#Efficient generation of binary trees from inorder-postorder sequences
15556#A method of accelerating the convergence of series solutions
15557#On the algebra of multiple bilinear transformations
15558#Order estimation of linear time invariant system
15559#Solution of sub, super, harmonic and combination type resonant excitations in nonlinear lumped parameter systems
15560#A geometrical setting for the newtonian mechanics of robots
15561#A radar detector using quantized envelope samples
15562#Recursive reconstruction of sequences from group delay
15563#A finite element method for a singularly perturbed boundary value problem
15564#On a theorem of Stein-Rosenberg type in interval analysis
15565#Bounds on nonlinear operators in finite-dimensional banach spaces
15566#A priori bounds for discrete solutions of monotone operator equations and applications
15567#A new family of mixed finite elements in IR3
15568#Stability and B convergence of linearly implicit Runge-Kutta methods
15569#Monotonicity and boundedness in implicit Runge-Kutta methods
15570#Convergence of the SSOR method for nonlinear systems of simultaneous equations
15571#Analysis of variance of workloads
15572#Computer measurement group conference report
15573#Capacity planning and end-user computing
15574#A computer performance analysis technique
15575#On the number of non-isomorphic strongly connected finite automata
15576#On the standard star height of regular sets. I
15577#The telephone problem for trees
15578#On the estimation of the mean interarrival time in the system M/GI/I/0 by observing the departure process of served demands
15579#Logic on finite structures and logic programming
15580#Representation of sub-definiteness, over-definiteness and absurdity in knowledge bases
15581#Open problems in automata theory related to complexity theory
15582#On the minimization of random Boolean functions, Part 2
15583#Professor W. Kno¨del, 60 years
15584#Graph isomorphism and theorems of Birkhoff-Type
15585#An efficient labeling technique for solving sparse assignment problems
15586#An O(n) Bin-packing algorithm for uniformly distributed data
15587#Iterative improvement of componentwise errorbounds for invariant subspaces belonging to a double or nearly double eigenvalue
15588#Convexity preserving interpolation with exponential splines
15589#An extrapolation method for the efficient composition of maps with applications to non-linear oscillations
15590#A compact variable metric algorithm for nonlinear minimax approximation
15591#An improved algorithm for Boolean matrix multiplication
15592#A management system for the information business: organizational analysis
15593#The magic of Macintosh: Programming graphics and sound
15594#Analysis of incomplete Matrix factorizations as multigrid smoothers for Vector and parallel computers
15595#Algebraic multigrid theory: The symmetric case
15596#Black box multigrid for systems
15597#A multigrid method for multiprocessors
15598#Multigrid calculation of subvortices
15599#The fast adaptive composite-grid method (FAC): algorithms for advanced computers
15600#A vectorized multigrid solver for the three-dimensional poisson equation
15601#On the numerical solution of a nonlinear Stochastic Helmholtz equation with a multigrid preconditioner
15602#Aspects of multigrid methods for problems in three dimensions
15603#Efficient Multigrid algorithms for locally constrained parallel systems
15604#Multigrid convergence for nonsymmetric, indefinite variational problems on one smoothing step
15605#Vectorizable multigrid algorithms for transonic-flow calculations
15606#Application of data flow concepts to a multigrid solver for the Euler equations
15607#Multilevel continuation techniques for nonlinear boundary value problems with parameter dependence
15608#Application of a single-equation MG_FAS solver to elliptic grid generation equations (subgrid and supergrid coefficient generation)
15609#AMG for problems of elasticity
15610#Multigrid-sinc methods
15611#Parallel computation of Euler and Navier-Stokes flows
15612#Basic smoothing procedures for the multigrid treatment of elliptic 3D operators
15613#Hierarchical bases give conjugate gradient type methods a multigrid speed of convergence
15614#On spectral multigrid methods for time-dependent Navier-Stokes equations
15615#In this paper we examine matrix polynomials of the form L(@l) = A@l^2 + @eB@l + C in which @e is a parameter and A, B, C are positive definite. This arises in a natural way in the study of damped vibrating systems. The main results are concerned with the generic case in which det L(@l) has at least 2n - 1 distinct zeros for all @e @e [0, ~). The values of @e at which there is a multiple zero of det L(@l) are of major interest in this analysis. The dependence of first degree factors of L(@l) on @e is also discussed.
15616#The global topology of constant energy surfaces of Hamiltonian systems in four dimensions is investigated using techniques of computer graphics.
15617#Branching structures, alias topological tree structures are fundamental to any hierarchical classification that aims to relate objects according to their similarities or dissimilarities. This paper provides a rigorous treatment of these structures, and continues previous work of Colonius and Schulze on H-structures. Thus extensive use is made of the so-called neighbors relation associated with a dissimilarity index. Arbitrary dissimilarity data are then analyzed by comparing their neighbors relations with ideal, that is, tree-like relations: if it matches an ideal relation, then one can readily construct a tree representing the data that is optimal in a certain sense. Finally, some algorithms are proposed for fitting observed data to tree-like data.
15618#Multiplicative character theory will be used to reprove results from a paper of Auslander-Feig-Winograd (Adv. in Appl. Math.5 (1984), 31-55) on the multiplicative complexity of the discrete Fourier transform. The Fourier transform F"A acting on the space L(A) of all complex-valued functions on A = Zn, n an integer, is decomposed relative to ''rational'' subspaces of L(A) naturally described by multiplicative characters of A. This decomposition is the main tool needed to understand the ad hoc constructions in the Auslander-Feig-Winograd (op cit.) paper.
15619#Framework II
15620#Personal computing with the UCSD p System 2nd Edition
15621#Mechanistic models of asymmetric reductions
15622#Finite Elements: Fluid Mechanics Vol.,VI
15623#Machine interpretation of line drawings
15624#Quality control in automation
15625#The AT&T PC 6300 made easy
15626#Power electronic converters: AC/DC conversion
15627#BASIC computing for calculus
15628#Design and graphics using the Apple computer: an engineer's guide
15629#Solved and unsolved problems in number theory
15630#1001 Things to do with your Commodore 128
15631#Fluid power with microprocessor control: an introduction
15632#SAMNA Luxury word processing
15633#The mathematical structure of the human sleep-wake cycle
15634#Different visions of logo
15635#The need for science versus passion in educational computing
15636#Effects of computer environments on social-emotional development: Logo and computer-assisted instruction
15637#Different Logo learning environments and mastery: relationships between engagement and learning
15638#The effect of Logo on attributions toward success
15639#Research on Logo in education: is the turtle slow but steady, or not even in the race?
15640#Learning Logo: what is really learned?
15641#Winnie the pooh and turtle, too
15642#Developing a Logo environment in the preschool
15643#A turtle in the classroom
15644#Learning mathematics with line art and logo
15645#The roots of Logo's educational theory: an analysis
15646#The great Logo adventure
15647#Logo'84: A unique family gathering
15648#A teacher's view of Logo: from theory to practice
15649#BASIC, Logo, and Pilot: A comparison of three computer languages
15650#Breaking away from BASIC
15651#Once again, stuctured programming: is it necessary?
15652#Evaluating Logo: a case study in requirements for student programming languages
15653#Demystifying Logo recursion: a storage process model of embedded recursion
15654#Recursion-a powerful, but often difficult idea
15655#Rotating cubes: a trigonometry project using Logo
15656#Naming in programming
15657#Using single-stroke Logo programs with young children
15658#A conversation with Logo
15659#Teachers need time for turtles: planning for teacher development with Logo
15660#Logo and the education of the hearing impaired
15661#TRS-Turtle
15662#Turtle 2.C2
15663#Mathematical models in applied mechanics
15664#High-Tech espionage: how the KGB smuggles NATO's strategic secrets to Moscow
15665#Papers of John Von Neumann on computing and computer theory, Vol 12
15666#Lotus, Jazz user's handbook
15667#Looking back to tomorrow
15668#Application Software Directory: a directory of application software packages for pick-based systems (4th ed.)
15669#Artificial Intelligence: bibliographic summaries of the select literature
15670#Guidebook to adventure, Vol 2
15671#Guidebook to adventure
15672#Pick resources guide
15673#Mass storage systems
15674#New silicon intensifies debate over VMEbus/Multibus II multiprocessor support
15675#Second-generation chips displace data encryption standard
15676#Statistical techniques speed evaluation of test patterns
15677#Portable systems reduce cost for microprocessor development work
15678#Graphics ICs increase on-chip functions and intelligence
15679#IC advances expand circuit designer's logic options
15680#Graphics terminal reduces dependence on external host
15681#Instrument system architecture expands testing options
15682#Biomedical image processing using the CLIP system
15683#Invariance in pattern recognition: application to line images
15684#Method for improving image quality in digital linear tomography
15685#Implementation for noise suppression in images
15686#Algorithm for analysing optical flow based on the least-squares method
15687#Edge detection and motion detection
15688#Emerging microcomputer technology for electrical energy management
15689#Computerized energy management systems—why and how
15690#A microcomputer-based wind turbine control system
15691#Microcomputer based system for efficient use of electricity in industry
15692#A computer program for energy and cost management of water supply
15693#Microcomputer-based monitoring and information system for solar heaters
15694#The utilization of stand-alone microprocessor units to control energy intensive systems
15695#A microprocessor-based inrush restrained differential really for transformer protection
15696#A low cost microprocessor based multiple pressure measuring system
15697#Analysis of ultrasound Doppler velocimeter signals using a personal computer
15698#Proc. of the Ada-Europe international conference on Ada: managing the transition
15699#Ada evaluation and transition studies
15700#Global issues in reuse from a real project
15701#Evaluating Ada implementations—smoothing the transition to Ada
15702#Ada compiler performance benchmark
15703#The Magnavox transition to Ada
15704#The economics of Ada
15705#Two years of Ada experiments: lessons and results
15706#Transition to Ada for super computers
15707#The implications of Ada for configuration management and project support environments: towards adequate support
15708#Understanding Ada(R) software reusability issues for the transition of mission critical computer resource applications
15709#Software methodology and the AIE program library
15710#Reusability of software components in the building of syntax-driven software tools written in Ada
15711#A process simulation package concealing multitasking
15712#Transition towards embedded real-time applications in Ada
15713#Designing an interactive, adaptive graphics system using Ada
15714#Software component library
15715#Integrating Ada in an existing environment—the Arcs example
15716#Software engineering applied to curriculum development
15717#A novel approach to a hands-on Ada course for industry
15718#Exploiting generics in Ada training
15719#Ada axiomatic semantics: problems and solutions
15720#The Ada challenge for new formal semantic techniques
15721#Program development by specification and transformation in Ada/Anna
15722#A structured technique for concurrent systems design in Ada
15723#Expressing module interconnections in Ada
15724#REAL-OPS—a real-time engineering applications language for writing expert systems
15725#Sensor fusion: the application of artificial intelligence technology to process control
15726#Toward the development of a real-time expert system
15727#ACTOR, a threaded object-oriented language
15728#Symbolic processing potential of Forth-based microcomputers
15729#Artificial intelligence: the human-computer interface?
15730#Fifth-generation Forth
15731#Forth for AI?
15732#Systems that have ideas instead of rule based knowledge
15733#An implementation of FORPS on a NOVIX Beta Board
15734#Knowledge engineering, expert systems, and real-time environments
15735#Some experiences with EXPERT-2
15736#Pattern variables in Forth
15737#Object oriented programming in fifth
15738#Defining words with class
15739#Fifth: a Forth based programming environment
15740#Postscript
15741#COMICAL: a Forth-based programming language for optimized array processor programming
15742#A survey of the characteristics of very high level languages
15743#A simple authoring system for computer-assisted instruction
15744#A polyphonic electronic organ
15745#REPTIL-promoting dialog between humanoid and computer
15746#Authoring system tools for CAI
15747#C and Forth machines
15748#A requirement definition language, simulator and test harness for programmable logic control systems
15749#ORPHANS-an unreferenced code finder
15750#A more thorough syntax checker for Forth
15751#A threaded interpretive language supporting programming in the large
15752#Automatic word glossary generation
15753#The LMI Forth-83 Metacompiler
15754#Software prototyping with Forth
15755#Comments on documentation
15756#An object-compiled Forth interpreter with a segmented memory model
15757#A Stand-alone Forth system
15758#Release of Z80 RTL to the public domain
15759#MVP-microcoded CPU/16: history
15760#MVP microcoded CPU/16: architecture
15761#An embedded Forth environment for a programmable bus interface
15762#Design of a fast 68000-based subroutine threaded Forth
15763#Making Novix Beta Boards into development workstations
15764#Compiling Forth for performance
15765#An indirect threaded code organization to support dynamic memory management
15766#A single-board Forth computer with versatile analog I/O circuitry
15767#A prototype expert system in OPS5 for data error detection
15768#Developing real time process control in space
15769#Development of an expert system for command and control of an orbiting spacecraft
15770#Use of a Forth-based Prolog for real-time expert systems
15771#A Forth controlled oceanographic instrument
15772#A computerized corrosion monitoring system
15773#A large (10,000 sensor) fire and gas safety system implemented using polyForth and execution queues
15774#The use of Forth in a portable, point of sale environment
15775#What can be done with metacompilers?
15776#Simulating and symbolic debugging
15777#FACS—a Forth analog computer simulator
15778#Forth advanced scientific tools: how intelligent should arrays be?
15779#Exploring Mandelbrot fractals with MMSFORTH
15780#SWIFT—a new type of Forth application
15781#Circular statistics in Forth
15782#Signal space, address space, & symbol space
15783#A century of Forth: issues and trends projected by a remarkably parallel spoken language,Esperanto
15784#Performance evaluations of recursive and iterative algorithms for the towers of Hanoi problem
15785#Strict optimal a posteriori error and residual bounds for Gaussian elimination in floating-point arithmetic
15786#A method for preconditioning matrices arising from linear integral equations for elliptic boundary value problems
15787#Explicit monotone iterations providing upper and lower bounds for finite element solution with nonlinear radiation boundary conditions
15788#On the globalization of Wilson-type optimization methods by means of generalized reduced gradient methods
15789#A note on a globalization of Wilson-type optimization methods
15790#A class of interval-Newton-operators
15791#Algorithms based on difference equations of infinite order and the computation of Laplace-type integrals
15792#A computational process for choosing the relaxation parameter in nonlinear SOR
15793#Quadrature rules for Prandtl's integral equation
15794#A Remez-type algorithm for the calculation of extremal fundamental systems for polynomial spaces on the sphere
15795#Solution of nonlinear systems of equations by an optimal projection method
15796#Grid methods in simulation and random variate generation
15797#Parallel implementation of bisection for the calculation of eigenvalues of tridiagonal symmetric matrices
15798#Computing the genus of the 2-amalgamations of graphs
15799#Some remarks on universal graphs
15800#On the existence of two non-neighboring subgraphs in a graph
15801#About the ratio of the size of a maximum antichain to the size of a maximum level in finite partially ordered sets
15802#Multipartite graph-sparse gra^j Ramsey numbers
15803#A problem of P Seymour on nonbinary matroids
15804#Families of cuts with the MFMC-property
15805#An inequality conjectured by Hajela and Seymour arising in combinatorial geometry
15806#Proof of a conjecture of Kahn for non-binary matroids
15807#Regular subgraphs of dense graphs
15808#On a problem of Erdo¨s and Larson
15809#Maximal tight sets and the Emonds-Gallai decomposition for matchings
15810#Sequential access in splay trees takes linear time
15811#Workstations
15812#Semicustom approach to mixed analog/digital ICs stresses analog performance
15813#Multiprocessor systems power demand for dual-port SRAMs
15814#Board-level image processors enter desktop arena
15815#HP adds more fuel to its strategy of design integration
15816#Unix muscles into minicomputer market
15817#CCD cameras reflect emphasis on size and sharpness
15818#Graphics IC simplifies design, boosts performance
15819#T-carrier chip set adapts to changing network needs
15820#Global accelerators shorten design cycles
15821#Library processing systems and the man/machine interface
15822#From cards to online: the Asian connection
15823#Using CCF: the common communication format
15824#Microcomputer installation and support at the University of Michigan Library
15825#Technology at the Library of Congress: a summary of the proceedings of the LC/LITA Institute
15826#Standard network interconnection
15827#Acquisitions automation at the Library of Congress, 1986
15828#Automating serial management at the Library of Congress: a status report
15829#Overseas data entry
15830#In memoriam: Hugh C Atkinson,1933-1986
15831#SORT-AID with RANK: search postprocessing tools for automating the determination of citation relevance
15832#Tribute to Donald P Hammer
15833#New RISC machines appear as hybrids with both RISC and CISC features
15834#Controller makers jump on 1-Mbit DRAM bandwagon
15835#Link between PLDs and gate arrays slow in coming
15836#Flexible disk cartridges enter removable media fray
15837#Arbitrary waveform generators simplify drive performance testing
15838#Graphics processor boasts virtual memory
15839#Array processors speed radar signal processing
15840#In-circuit emulation makes software development manageable
15841#SCSI optimizes peripherals integration for small systems
15842#Toolkit solves add-on 3-D graphics problems
15843#Current research directions in information systems
15844#Planning and control issues in end-user computing
15845#Participative systems design: user experience, evaluation and conclusions
15846#Multiview—an exploration in information systems development
15847#Planning for hospital information systems using the Lancaster Soft Systems methodology
15848#Guidelines for developing effective decision support systems
15849#Graphical data presentation for decision support systems
15850#Toward integration and beyond
15851#Harvard MBAs could be hazardous to IS managers
15852#Putting the horse before the cart
15853#The first 30 days: dilemmas of a new IS director
15854#Microcomputer security: back to basics
15855#It's no longer a terminal case
15856#Artificial intelligence: a remote promise
15857#What you don't see can hurt you
15858#A marriage of convenience
15859#The ACHPIRST and WESTDOC projects at Footscray Institute of Technology
15860#Voice processing: a present or future technology?
15861#Functional program testing and analysis
15862#Advanced Forth
15863#A practical introduction to denotational semantics
15864#Keys and superkeys for relation schemes
15865#NUT:80an object-oriented language
15866#An alternative approach to the conceptual database design using fragments of nat
15867#On the robot end-effector orientation generation
15868#On compound Lindenmayer systems
15869#Parentheses grammars and Lindenmayer grammars
15870#Proceedings of the 11th colloquium on trees in algebra and programming
15871#A categorical treatment of pre- and post-conditions
15872#Colourings of planar maps and the equality of two languages
15873#On the equivalence of synchronization sets
15874#Inner and mutual compatibility of basic operations on module specifications
15875#Exact computation sequences
15876#An algebraic theory of flowchart schemes
15877#An algebraic formalism for graphs
15878#Membership for growing context sensitive grammars is polynomial
15879#Weighted graphs: a tool for logic programming
15880#Classical and incremental evaluators for attribute grammars
15881#Transformation strategies for deriving on line programs
15882#Probabilistic Ianov's schemes
15883#Alternating bottom-up tree recognizers
15884#Bottom-up recursion in trees
15885#Trie partitioning process: limiting distributions
15886#Random walks, gaussian processes, and list structures
15887#Random walks on trees
15888#Infinite trees, markings and well foundedness
15889#Computable directory queries
15890#Relating type-structures: partial variations on a theme of Friedman and Statman
15891#On applications of algorithmic logic
15892#Proceedings of a tutorial and workshop on Category theory and computer programming
15893#Categories
15894#Elements of categorical reasoning: products and coproducts and some other (co-) limits
15895#Functors and natural transformations
15896#Adjunctions
15897#Cartesian closure—higher types in categories
15898#Algebra categorically
15899#Category theory and logic
15900#Categories, data types and imperative languages
15901#Category theory and programming language semantics: an overview
15902#Weakest preconditions: categorical insights
15903#A categorical view of weakest liberal preconditions
15904#Functor—category semantics of programming languages and logics
15905#Finite approximation of spaces
15906#Categories of partial morphisms and the λp-calculus
15907#A note on distributive laws and power domains
15908#Category theory and models for parallel computation
15909#Categorical models of process cooperation
15910#Galois connections and computer science applications
15911#A study in the foundations of programming methodology: specifications, institutions, charters and parchments
15912#Bits and pieces of the theory of institutions
15913#Extended ML: an institution-independent framework for formal program development
15914#Behavioural program specification
15915#Key extensions of abstract data types, final algebras, and database semantics
15916#Theories as categories
15917#Internal completeness of categories of domains
15918#Formalising the network and hierarchical data models—an application of categorical logic
15919#A categorical unification algorithm
15920#Computing with categories
15921#Proc. of a workshop on the theory and application of cryptographic techniques on Advances in cryptology---EUROCRYPT '85
15922#The contribution of E.B. Fleissner and A. Figl for today's cryptography
15923#On the history of cryptography during WW2, and possible new directions for cryptographic research
15924#Efficient factoring based on partial information
15925#A public-key cryptosystem based on shift register sequences
15926#In this comment we show that a recently proposed public key cryptosystem is not safe for most of the practical cases. Furthermore, it is shown that the security of this system is closely connected with the problem of computing logarithms over a finite field.
15927#Implementation study of public key cryptography protection in an existing electronic mail and document handling system
15928#Cryptanalysis of the Dickson-scheme
15929#We show that c log log P simultaneously secure bits can be extracted from the discrete log function. These bits satisfy the next-bit unpredictability condition of Blum and Micali. Therefore we can construct a cryptographically secure pseudo random number generator which produces c log log P bits per modular exponentiation under the assumption that the discrete log is hard.
15930#In the paper, a public-key cryptosystem that is, as a matter of fact, a modification of the Merkle-Hellman system has been described. However, unlike the Merkle-Hellman system, it has been built using a polynomial ring. Finally, its quality has been given.
15931#The Data Encryption Standard (DES) defines an indexed set of permutations acting on the message space M = {0, l}64. If this set of permutations were closed under functional composition, then DES would be vulnerable to a known-plaintext attack that runs in 228 steps, on the average. It is unknown in the open literature whether or not DES has this weakness.We describe two statistical tests for determining if an indexed set of permutations acting on a finite message space forms a group under functional composition. The first test is a "meet-in-the-middle" algorithm which uses O[驴K) time and space, where K is the size of the key space. The second test, a novel cycling algorithm, uses the same amount of time but only a small constant amount of space. Each test yields a known-plaintext attack against any finite, deterministic cryptosystem that generates a small group.The cycling test takes a pseudo-random walk in the message space until a cycle is detected. For each step of the pseudo-random walk, the previous ciphertext is encrypted under a key chosen by a pseudo-random function of the previous ciphertext. Results of the test are asymmetrical: long cycles are overwhelming evidence that the set of permutations is not a group; short cycles are strong evidence that the set of permutations has a structure different from that expected from a set of randomly chosen permutations.Using a combination of software and special-purpose hardware, we applied the cycling test to DES. Our experiments show, with a high degree of confidence, that DES is not a group.
15932#Two new secret key cryptosystems
15933#A running key generator consisting of a maximum-length (ML) linear feedback shift register (LFSR) and some nonlinear feedforward state filter function is investigated. It is shown how a cryptanalyst can find an equivalent system in a ciphertext-only attack. The analysis uses a Walsh orthogonal expansion of the state filter function and its relation to the crosscorrelation function (CCF) between the ML-sequence and the produced running key sequence.
15934#We describe a method for storing information on a "write-once" memory with the following feature : reading is easy, whereas writing is difficult, except for the designer.
15935#This paper is intended as an overview, presenting several results on the linear complexity of sequences obtained from functions applied to linear shift register sequences. Especially for cryptologic applications it is of course highly desirable that the linear complexity be as large as possible, and not only to get a huge period. The theory reviewed in this paper contains several criteria on how to achieve such goals.
15936#In this paper we discuss non-linear feedforward transforms of arbitrary non-singular linear shift register sequences. The approach is to give an algebraic representation of p-array modules together with description of the structure of such modules. On the basis of this, an algebraic description of the non-linear transformas is given.
15937#Generalized multiplexed sequences
15938#In this paper the linear feedback shift registers are determined that can generate the output sequence of two types of clock controlled shift registers suggested by P. Nyffeler. For one type of clock control sufficient conditions are given which guarantee that maximum linear complexity is obtained. Furthermore, it is shown that the randomness properties for sequences of maximal linear complexity depend on clocking procedure.
15939#This paper discusses the use of an arbitrary bit-sequence generating algorithm as the cryptographic key for a stream cipher. Emphasis is placed on methods for combining stream generators into more complex ones, with and without randomization. Threshold schemes give a generalization of many combination techniques.
15940#On the linear complexity of combined shift register sequences
15941#A new type of nonlinear feedforward logic for binary sequence generators is proposed, i.e. a logic that combines the stages of a linear feedback shift register (LFSR) in a nonlinear way. The sequences generated are analyzed with respect to their transient and ultimately periodic behavior. They are shown to have a balanced zero-one distribution, and a lower bound on their linear complexity is derived which grows exponentially with the length of the LFSR.
15942#The problem of characterizing the randomness of finite sequences arises in cryptographic applications. The idea of randomness clearly reflects the difficulty of predicting the next digit of a sequence from all the previous ones. The approach taken in this paper is to measure the (linear) unpredictability of a sequence (finite or periodic) by the length of the shortest linear feedback shift register (LFSR) that is able to generate the given sequence. This length is often referred to in the literature as the linear complexity of the sequence. It is shown that the expected linear complexity of a sequence of n independent and uniformly distributed binary random variables is very close to n/2 and, that the variance of the linear complexity is virtually independent of the sequence length, i.e. is virtually a constant! For the practically interesting case of periodically repeating a finite truly random sequence of length 2m or 2m-1, it is shown that the linear complexity is close to the period length.
15943#This paper gives a brief survey of the authors' experience in designing and assessing systems for the secure processing and transmission of information in electronic media. It considers the range of encipherment algorithms currently available in the civil field for use in protecting financial transactions and the like. As a consequence of using encipherment, key management must be properly engineered and the right physical environment provided for the various sensitive functions. Finally some of the management aspects of secure systems are addressed.
15944#The chipcard—an identification card with cryptographic protection
15945#Encryption: needs, requirements and solutions in banking networks
15946#The role of encipherment services in distributed systems
15947#Modeling of encryption techniques for secrecy and privacy in multi-user networks
15948#Full encryption in a personal computer system
15949#It is becoming increasingly easy and common for organizations to routinely exchange data on individuals. Because each individual provides most organizations essentially the same uniquely identifying information, such, as social security number, or name, age and place of birth, the records held by one organization on an individual are readily matched or linked with those held by other organizations. Thus, organizations are capable of exchanging information about individuals whenever and to whatever extent they choose. Clearly some such transfers of information are quite useful and beneficial to society. The problems stem from the inability of anyone, particularly the individuals whose data is involved, to control or even effectively monitor such transfers. These problems were not present in completely paper based systems, where the transfer of information about an individual was only through credential documents issued to the individual by one organization and shown by the individual to other organizations.
15950#In usual communication networks, the network operator or an intruder could easily observe when, how much and with whom the users communicate (traffic analysis), even if the users employ end-to-end encryption. When ISDNs are used for almost everything, this becomes a severe threat. Therefore, we summarize basic concepts to keep the recipient and sender or at least their relationship unobservable, consider some possible implementations and necessary hierarchical extensions, and propose some suitable performance and reliability enhancements.
15951#The verifiability of two-party protocols
15952#The practice of authentication
15953#Message protection by spread spectrum modulation in a packet voice radio link
15954#Proc. of the IFIP WG 8.1 working conference on Information systems design methodologies: improving the practice
15955#The evolution of approaches to information systems design methodology
15956#A comparative evaluation of system development methods
15957#A modelling approach to information system development
15958#The ERAE model: a case study
15959#The set-function approach to conceptual modeling
15960#Activity modeling and behavior modeling
15961#Information engineering—an improved, automatable methodology for the design of data sharing systems
15962#Jackson system development (JSD)
15963#An activity model of the working conference problem
15964#Supporting controlled variety in system development environments
15965#Information system methodologies—a research view
15966#Proc. of the IFIP TC 10 working conference on Fifth generation computer architectures
15967#A new parallel inference mechanism based on sequential processing
15968#Parallel logic programming based on an extended machine architecture
15969#Dynamic rule support in Prolog
15970#A simple preprocessing scheme to extract and balance implicit parallelism in the concurrent match of production rules
15971#A knowledge base architecture and its experimental hardware
15972#Initial evaluation of a virtual machine for Or-parallel execution of logic programs
15973#Managing resources in a parallel machine
15974#The dataflow-based parallel inference machine to support two basic languages in KL1
15975#On the working set concept for dataflow machines: policies and their evaluation
15976#Epsilon-reduction: another view of unification
15977#Operator nets
15978#Parallel data driven graph reduction
15979#An architecture for functional programming and term rewriting
15980#Preliminary measurements of the ETL LISP-based data-driven machine
15981#The FAIM-1 user interface—human engineering for the fifth generation
15982#MARS—a hierarchical heterogeneous modular system
15983#Multiprocessor systems with a programmable architecture
15984#A specialized symbol processor
15985#The German parallel Prolog machine development
15986#The Philips object-oriented parallel computer
15987#A reconfigurable highly parallel architecture based on recirculative network
15988#Proc. of the EUROCRYPT 84 workshop on Advances in cryptology: theory and application of cryptographic techniques
15989#Complexity Theories have recently been proposed as a basis for evaluation of crypto machine performance. They are compared to Shannon's model. They shed a new highlight on randomness notion. But it is stressed that the statistical point of view remains the more secure.
15990#In many single-key, symmetric or conventional cryptosystems the elements of a finite field can be regarded as the characters of a plaintext and ciphertext alphabet. Some properties of polynomials or polynomial functions on finite fields can be used for constructing cryptosystems. This note demonstrates by way of examples that great care has to be taken in choosing polynomials for enciphering and deciphering. Often complex looking polynomial functions induce very simple permutations of the elements of a finite field and therefore are not suitable for the construction of cryptosystems. Also an indication is given of some further areas of research in algebraic cryptography.
15991#In the paper, application of idempotent elements to construction of cryptographic systems has been presented. The public key cryptosystem based on idempotent elements and the cryptographic transformation that preserves elementary arithmetic operations have been described.
15992#Non-linear, non-commutative functions for data integrity
15993#Consider the following situation. K data hits are to be encoded into N K bits and transmitted over a noiseless channel. An intruder can observe a subset of his choice of size 碌 N. The encoder is to be designed to maximize the intruder's uncertainty about the data given his N intercepted channel bits, subject to the condition that the intended receiver can recover the K data bits perfectly from the N channel bits. The optimal tradoffs between the parameters K, N, 碌. and the intruder's uncertainty H (H is the "conditional entropy" of the data given the 碌. intercepted channel bits) were found. In particular, it was shown that for 碌 = N - K, a system exists with H 驴 K - 1. Thus, for example, when N = 2K and 碌 = K, it is possible to encode the K data bits into 2K channel bits, so that by looking at any K channel bits, the intruder obtains essentially no information about the data.
15994#Substitution ciphers can be quite weak when the probability distribution of the message letters is distinctly non-uniform. A time-honoured solution to remove this weakness is to "split" each high-probability letter into a number of "homophones" and use a substitution cipher for the resulting extended alphabet. Here the performance of a homophonic cipher is studied from a Shannon-theoretic point of view. The key and message equivocations (conditional entropies given the intercepted cryptogram) are computed both for finite-length messages and "very long" messages. The results obtained are strictly related to those found by Blom and Dunham for substitution ciphers. The key space of a homophonic cipher is specified carefully, so as to avoid misunder standings which appear to have occurred on this subject.
15995#New general properties in the S-boxes were found. Techniques and theorems are presented which allow to evaluate the nonsubstitution effect in f and the key clustering in DES. Examples are given. Its importance related to the security of DES is discussed.
15996#A construction is given for perfect linear ciphers that uses two digits of key per plaintext digit, which appears to be the minimum possible. The construction utilizes two shift-registers that are clocked at different speeds, and suggests a new type of random sequence generator in which two linear feedback shift-registers are clocked at different speeds and their contents combined at the lower clock rate. The effects of variable speed are analyzed, and the linear complexity of the sequences produced by such generators is determined.
15997#The stop-and-go generator
15998#Shift registers are frequently used in generators of pseudo randan sequences (see [1 ]). We will examine how cascade connections of clock controlled shift registers perform when used as generators of pseudo randan sequences. We will derive results for the period, for the linear recursion and for the pseudo-randomness of their output sequences.
15999#On the linear complexity of cascaded sequences
16000#We prove by some novel sampling techniques that the least significant bits of RSA-messages are 0.5+ 驴 - secure. Any oracle which correctly predicts the k-th least significant message bit for at least a 0.5 + 驴 - fraction of all messages can be used to decipher all RSA ciphertexts in random polynomial time (more precisely in time (log n)0(驴-2+k)).
16001#We consider the following problem: Let s be a n-bit string with m ones and n - m zeros. Denote by CEt(s) the number of pairs, of equal bits which are within distance t apart, in the string s. What is the minimum value of CEt(驴), when the minimum is taken over all n-bit strings which consists of m ones and n - m zeros?.We prove a (reasonably) tight lower bound for this combinatorial problem.Implications, on the cryptographic security of the least significant bit of a message encrypted by the RSA scheme, follow. E.g. under the assumption that the RSA is unbreakable; there exist no probabilistic polynomial-time algorithm which guesses the least significant bit of a message (correctly) with probability at least 0.725, when given the encryption of the message using the RSA. This is the best result known concerning the security of RSA's least significant bit.
16002#The Matsumoto-Imai public key scheme was developed to provide very fast signatures. It is based on substitution polynomials over GF(2m). This paper shows in two ways that the Matsumoto-Imai public key scheme is very easy to break. In the faster of the two attacks the time to cryptanalyze the scheme is about proportional to the binary length of the public key. This shows that Matsumoto and Imai greatly overestimated the security of their scheme.
16003#This paper presents a new trapdoor-knapsack public-key-cryptosystem. The encryption equation is based on the general modular knapsack equation, but unlike the Merkle-Hellman scheme the knapsack components do not have to have a superincreasing structure. The trapdoor is based on transformations between the modular and radix form of the knapsack components, via the Chinese Remainder Theorem. The resulting cryptosystem has high density and has a typical message block size of 2000 bits and a public key of 14K bits. The security is based on factoring a number composed of 256 bit prime factors. The major advantage of the scheme when compared with the RSA scheme is one of speed. Typically, knapsack schemes cuch as the one proposed here are capable of throughput speeds which are orders of magnitude faster than the RSA scheme.
16004#We review the issues involved in building a special-purpose chip for performing RSA encryption/decryption, and review a few of the current implementation efforts.
16005#The quadratic sieve factoring algorithm
16006#Status report on factoring (at the Sandia National Labs)
16007#A simple method is given for finding strong, random, large primes of a given number of bits, for use in conjunction with the RSA Public Key Cryptosystem. A strong prime p is a prime satisfying: * p = 1 mod r * p = s-1 mod s * r = 1 mod t, where r,s and t are all large, random primes of a given number of bits. It is shown that the problem of finding strong, random, large primes is only 19% harder than finding random, large primes.
16008#Given a primitive element g of a finite field GF(q), the discrete logarithm of a nonzero element u 驴 GF(q) is that integer k, 1 驴 k 驴 q-1, for which u = gk. The well-known problem of computing discrete logarithms in finite fields has acquired additional importance in recent years due to its applicability in cryptography. Several cryptographic systems would become insecure if an efficient discrete logarithm algorithm were discovered. This paper surveys and analyzes known algorithms in this area, with special attention devoted to algorithms for the fields GF(2n). It appears that in order to be safe from attacks using these algorithms, the value of n for which GF(2n) is used in a cryptosystem has to be very large and carefully chosen. Due in large part to recent discoveries, discrete logarithms in fields GF(2n) are much easier to compute than in fields GF(p) with p prime. Hence the fields GF(2n) ought to be avoided in all cryptographic applications. On the other hand, the fields GF(p) with p prime appear to offer relatively high levels of security.
16009#It is generally accepted that data encipherment is needed for secure distributed data processing systems. It is accepted, moreover, that the enciphering algorithms are either published or must be assumed to be known to those who wish to break the security. Security then lies in the safe keeping of the encipherment keys, which must be generated and stored securely and distributed securely to the intending users.At an intermediate level of detail of a system it may be useful to have functions which manipulate keys explicitly but which hide some of the details of key generation and distribution, both for convenience of use and so that new underlying techniques can be developed. This paper offers a contribution to the discussion. It proposes key manipulation functions which are simple from the user's point of view. It seeks to justify them in terms of the final secure applications and discusses how they may be implemented by lower level techniques described elsewhere. The relationship of the functions to telecommunication standards is discussed and a standard form is proposed for encipherment key information.
16010#It is sometimes required that user pairs in a network share secret information to be used for mutual identification or as a key in a cipher system. If the network is large it becomes impractical or even impossible to store all keys securely at the users. A natural solution then is to supply each user with a relatively small amount of secret data from which he can derive all his keys. A scheme for this purpose will be presented and we call such a scheme a symmetric key generation system (SKGS). However, as all keys will be generated from a small amount of data, dependencies between keys will exist. Therefore by cooperation, users in the system might be able to decrease their uncertainty about keys they should not have access to.The objective of this paper is to present a class of SKGS for which the amount of secret information needed by each user to generate his keys is the least possible while at the same time a certain minimum number of users have to cooperate to resolve the uncertainty of unknown keys.
16011#A novel cryptosystem is presented in which the protection of the messages is based on the special properties of the binary multiplying channel. In the system the receiver is mainly responsible for the protection of the messages and not the transmitte. In the paper a small area network realization with a binary multiplying channel is discussed.
16012#In recent years, much effort has gone into the development of high bandwidth communication networks for use over relatively short (local) distances, e.g. an office, an industrial complex, a research laboratory, etc., The high bandwidth of these networks allows many of the services now requiring separate networks such as facsimile, digitized voice, file transfer and interactive terminal data, to be integrated into a common transmission facility. Manufacturers are currently developing products which conform to the recently established IEEE 802 standard for Local Area Networks (LANs). This standard is based on the concept of a layered, "peer entity" communication protocol put forth in the International Standards Organization's (ISO) seven layer model for Open Systsms Interconnection (OSI).In this paper we define the notions of secrecy and privacy as they relate to a LAN environment and the various services a network is required to provide such as data integrity, authentication and digital signature services. We also describe the cost-benefit tradeoff involved in attaining various levels of privacy and secrecy.
16013#In a paper entitled "The Prisoners' Problem and the Subliminal Channel" [1], the present author showed that a message authentication without secrecy channel providing m bits of overt communication and r bits of message authentication could be perverted to allow an l
16014#The idea of the Oblivious Transfer, developed by Rabin, has been shown to have important applications in cryptography. M. Fischer pointed out that Rabin's original implementation of the Oblivious Transfer was not shown to be secure. Since then it has been an open problem to find a provably secure implementation. We present an implementation which we believe will simplify the development of secure cryptographic protocols. Our protocol is provably secure under the assumptions that factoring is hard and that the message is chosen at random from a large message space.
16015#We consider communication networks in which it is not possible to identify the source of a message which is broadcasted through the network. A natural question is whether it is possible for two users to identify each other concurrently, through a secure two-party protocol. We show that more than the existence of a secure Public Key Cryptosystem should be assumed in order to present a secure protocol for concurrent identification. We present two concurrent identification protocols: The first one relies on the existence of a center who has distributed "identification tags" to the users; while the second protocol relies on the distribution of "experimental sequences" by instances of a pre-protocol which have taken place between every two users.
16016#Selecting permutations for speech scrambling with t.d.m. means to define a suitable weight-function or metric on Sn (the full symmetric group). This can be done in a lot of different ways. We study some of that weight-functions and point out which one should be preferred. An algorithm is given to generate permutations with a prescribed weight. Some hints are given how to compute approximately the distribution function of some weight-functions. Finally rank correlation methods are recommended for testing a t.d.m.- system.
16017#Security of transportable computerized files
16018#This contribution describes the encryption and key management techniques realised with prototype hardware by British Telecom Research for use on the SatStream service offered on the European Communication Satellite. The security objectives, channel unit functions and operation, encryption methods and key management systems are described.
16019#To perform message authentication in a telesurveillance system, the paper proposes a non linear time varying encryption algorithm, based on key layering in three levels (system key, intermediate key, running key) and on encryption organization into two or more sets of three operations (running key rotation, message digit substitution and transposition). The algorithm was designed to be implemented on an 8-bit microprocessor.
16020#The paper presents a software protection system that prevents "software piracy" reliably while allowing to produce an unlimited number of program copies.Based on a combination of smart card technology and cryptographic techniques the system provides not only a high level of security, but also enhanced ease-of-use for the software manufacturer as well as for the user.
16021#Smart cards
16022#Smart card applications in security and data protection
16023#The CP8 smart card has memory and intelligence.These two characteristics joined to its technology, make of it an unfraudable and unduplicable portable strong box.Thus CP8 is a very secure and convenient device to transport, generate or transmit cryptologic keys or data.
16024#We study a family of encryption functions, wich is particularly adapted for the situations that arise in smart cards.Probabilistic arguments show us that "big key" is not synonymous of "good security" for these functions.We think that the security of such functions has to rely on other criteria.
16025#Smart cards are introduced through chip design, card interface, and card security. Applications are divided in three classes : log books, certified records, key carriers.Conditional acces is analyzed with a clear distinction between entitlement checking and entitlement management. The key carrier CP8 card is then described. Smart card cryptology is examined, and also the probable evolution towards digital signatures.
16026#First Page of the Article
16027#First Page of the Article
16028#First Page of the Article
16029#First Page of the Article
16030#First Page of the Article
16031#First Page of the Article
16032#Analytical study of wave-induced nearshore currents
16033#Elasto-plastic large displacement analysis of cable systems
16034#The effects of corrosion on fatigue crack propagation in 2024-T3 aluminium
16035#The life prediction for 2024-T3 aluminium alloy subjected to corrosion fatigue
16036#A strategy for the optimization and economic evaluation of an ORC system for energy recovery
16037#Solution of low Pe´clet number heat transfer with viscous dissipation in the semi-infinite axial region of a tube via functional analytic methods
16038#A method of combining rigid body displacements for the determination of rigid body rotations of structural members in the slope-deflection method
16039#Flow field measurements and physical processes in confined air-water jet
16040#Solution of low Pe´clet number heat transfer with viscous dissipation in the infinite axial region between parallel plates via functional analytic methods
16041#A digital PN signal correlator with improved performance
16042#A limited capacity rehearsal model for psychophysical judgements applied to magnitude estimation
16043#Uniqueness and homogeneity of ordered relational structures
16044#A new version of Bayes' equation—applications to plausible reasoning
16045#Majority rule, hierarchical structures, and democratic totalitarianism: a statistical approach
16046#Biorder families, valued relations and preference modelling
16047#High-level languages
16048#Accelerators break bottlenecks in logic and fault simulation
16049#VFD drivers offer more smarts, more drives and high voltages
16050#DGIS links PC-DOS to high-performance graphics
16051#LAN standards breed a multitude of smart boards
16052#Interactive methods ease analog/digital design
16053#Benchmarking steers logic simulation selection
16054#Image-processing boards boost real-time performance
16055#BOBRA: an expert system for automated language description as a basis for statistical studies
16056#OCR:the Kurzweil data entry machine
16057#'Classical Shape' of the Sophoclean tragedy
16058#Publication and politics, 1640-1661: an SPSS-based account of the Thomason collection of civil war tracts
16059#Computing methodology in the humanities: 1.Software bibliography
16060#A new technique for identifying scientific/technical terms and describing science texts
16061#The authorship controversy of Sir Thomas More
16062#A boundary integral method for the simulation of two-dimensional particle coarsening
16063#Molecular dynamics simulation of flow past a plaste
16064#Efficient solution of non-Markovian covariance evolution equations in fluid turbulence
16065#An analytical and numerical study of the two-dimensional Bratu equation
16066#Starting end-users
16067#Online use and end-users in media and advertising: an overview
16068#Introducing information technology: experiences of a large industrial unit
16069#The value of downloading for database users and database producers
16070#A multivariable self-tuning controller with integral action
16071#Necessary and sufficient conditions for parameter convergence in adaptive control
16072#Non-linear dynamics in adaptive control: chaotic and periodic stabilization
16073#A new theoretical and algorithmical basis for estimation, identification and control
16074#From time series to linear system-Part II. Exact modelling
16075#A decentralized approach to integrated flight control synthesis
16076#On-line estimation of microbial specific growth rates
16077#Time/Fuel optimal control of constrained linear discrete systems
16078#On model reduction of discrete time systems
16079#A higher order approximate model of singularly perturbed systems with white nois
16080#A method for parameter estimation of a class of non-linear distributed systems under noisy observations
16081#A novel narrow band digital filter and its application to multivariable system identification
16082#Automation, work organization and skills: the case of numerical control
16083#Time-optimal control in a single machine problem with resource constraints
16084#Convergence and stability properties of an adaptive regulator with variable forgetting factor
16085#Automatic interpolation methods for mapping Piezometric surfaces
16086#Cheap control problem of a linear uniform rank system: design by composite control
16087#Proc. of the conference on Structure in complexity theory
16088#The complexity of sparse sets in P
16089#Isomorphisms and 1-L reductions
16090#Randomness, relativizations, and polynomial reducibilities
16091#On non-uniform polynomial space
16092#One-way functions and circuit complexity
16093#Relativized alternation
16094#The polynomial hierarchy and intuitionistic bounded arithmetic
16095#With probability one, a random oracle separates PSPACE from the polynomial-time hierarchy
16096#The Boolean hierarchy: hardware over NP
16097#Exponential time and bounded arithmetic
16098#Probabilistic game automata
16099#Two lower bound arguments with “inaccessible” numbers
16100#Resource-bounded Kolmogorov complexity of hard languages
16101#A note on one-way functions and polynomial time isomorphisms
16102#What is a hard instance of a computational problem?
16103#The complexity of optimization problems
16104#The power of the queue
16105#A depth-size and tradeoff for Boolean circuits with unbounded fan-in
16106#An optimal lower bound for Turing machines with one work tape and a two-way input tape
16107#Separation results for bounded alternation
16108#Parallel computation with threshold functions
16109#The topology of provability in complexity theory
16110#Optimal approximations of complete sets
16111#Expanders, randomness, or time versus space
16112#Diagonalization methods in a polynomial setting
16113#Bounded oracles and complexity classes inside linear space
16114#Parallel computation and the NC hierarchy relativized
16115#Probabilistic quantifiers, adversaries, and complexity classes: an overview
16116#Proceedings of Graphics Interface '85 on Computer-generated images: the state of the art
16117#Image synthesis: optical identity or pictorial communication
16118#A theoretical and empirical analysis of coherent ray-tracing
16119#High level descriptions for 3D stochastic models
16120#Frame buffer algorithms for stochastic models
16121#Animating lights and shadows
16122#An analysis and algorithm for filling propagation
16123#Non-rigid body motion
16124#Selection of segment similarity measures for hierarchical picture segmentation
16125#Computer analysis of cardiac wall motion asynchrony
16126#Multi-robot assembly of IC's
16127#A computerized system for spot detection and analysis of two-dimensional electrophoresis images
16128#Hologram-like transmission of pictures
16129#CSG and ray tracing using functional primitives
16130#Geometric continuity with interpolating Be´zier curves
16131#Octree data structures and creation by stacking
16132#ANIMENGINE: an engineering animation system
16133#Dynamics for animation of characters with deformable surfaces
16134#Using dynamic analysis to animate articulated bodies such as humans and robots
16135#Towards an integrated view of 3-D computer animation
16136#Controlling evolution and motion using the CINEMIRA-2 animation sublanguage
16137#Computer animation in distance teaching
16138#The interactive planning work station: a graphics-based UNIX tool for application users and developers
16139#The Higgens UIMS and its efficient implementation of Undo
16140#Graphics interaction in databases
16141#Interface abstractions for an naplps page creation system
16142#Colour coding scales and computer graphics
16143#An innovative user interface for microcomputer-based computer-aided design
16144#A geometric modeller for turbomachinery applications
16145#Low cost geometric modelling system for CAM
16146#The CADME approach to the interface of solid modellers
16147#Generative design in architecture using an expert system
16148#Knowledge engineering application in image processing
16149#Heuristic rules for visualization
16150#Computer graphics for multivariate data
16151#A graphics interface for interactive simulation of packet-switched networks
16152#Design and implementation of an interactive route editor
16153#Business graphics and the stakeholder approach: an exploratory field experiment
16154#An integrated system for printing and publishing applications
16155#Project management using graphics
16156#How map designers can represent their ideas in thematic maps: effective user interfaces for thematic map design
16157#Challenges in the application of graphics technology to the management of geographic information
16158#An image management kernel for the design of relational and pictorial data bases
16159#The scientific and technical issues in integrating remotely sensed imagery with geocoded data bases
16160#Recognition of isolated and simply connected hand-written numerals
16161#A comment on an investigation into the skeletonization approach of Hilditch
16162#Heuristic approach to handwritten numeral recognition
16163#Rapid recognition of object outlines in reduced resolution images
16164#Labeled point pattern matching by Delaunay triangulation and maximal cliques
16165#Minimum error thresholding
16166#Remarks on some statistical properties of the minimum spanning forest
16167#A pyramidal approach for the recognition of neurons using key features
16168#Features selection and `possibility theory'
16169#Matrix method for finding sets of contiguous non-zero elements in a 2-dimensional array
16170#A note on convex hull algorithms
16171#Eye movement analysis system using fundus images
16172#Multivariate data representation and analysis by face pattern using facial expression characteristics
16173#Monte Carlo comparison of six hierarchical clustering methods on random data
16174#Linear discrimination with symmetrical models
16175#Proceedings of the computational techniques and applications conference on Computational techniques and applications, CTAC-85
16176#9th international conference on Advances in invariant subspaces and other results of operator theory
16177#10th international conference on operator theory on Operators in indefinite metric spaces, scattering theory, and other topics
16178#Proceedings of the 2nd international conference on parallel computing on Parallel computing 85
16179#Proceedings of the 6th international research forum in information science on Intelligent information systems for the information society
16180#Proceedings of the 5th international symposium on approximation theory on Approximation theory V
16181#Proceedings of the 4th international symposium on data analysis and informatics on Data analysis and information, IV
16182#Proceedings of the 1985 international conference on PC '85: optimal use of the personal computer
16183#Microprocessor hardware and software concepts
16184#Running with BASIC: a beginner's guide to programming the Apple
16185#Introduction to expert systems
16186#Let's C now
16187#Solutions in C: hundreds of programming tips by the author of "Doctor C's pointers"
16188#Atomic actions in concurrent systems
16189#Turbo Pascal programmer's library
16190#Cyclic designs
16191#Multivariate statistical simulation
16192#Intention-based diagnosis of errors in novice programs
16193#Taking command of Enable
16194#Programming in Occam
16195#Databases in theory and practice
16196#Introduction to computer applications using BASIC (2nd ed.)
16197#The art of C programming
16198#Modulla-2: problem solving and programming with style
16199#Turbo Pascal express: 250 ready-to-run assembly language routines
16200#Program design (2nd ed.)
16201#The power of Turbo Pascal
16202#Graphic introduction to programming
16203#68000 microprocessor handbook (2nd ed.)
16204#Modula-2 programming
16205#Specification and verification of context conditions for programming languages
16206#Verification of recursive programs: a temporal proof approach
16207#Assembly language for the PDP-11: RTRSXUINX (2nd ed.)
16208#The supercomputer era
16209#Expert system technology: development and application
16210#PC secrets: tips for power performance
16211#Structured BASIC programming
16212#Numerical software tools in C
16213#The big tip book for the Apple II series
16214#Microprocessors/microcomputers: architecture, software, and systems (2nd ed.)
16215#Lectures on statistical inference
16216#The MS-DOS handbook (2nd ed.)
16217#Programming the M68000
16218#Statistical design for research
16219#VAX-II BASIC by design: structured programming in BASIC
16220#Exploring statistics: a modern introduction to data analysis and inference
16221#Basic BASIC: a structured approach
16222#Basic Basic: A Structured Approach
16223#Statistical tools for simulation practitioners
16224#How to write Macintosh software
16225#Practical Paradox: applications and programming technique
16226#Eureka on the IBM PC and PCjr
16227#Introduction to sound and graphics on the Atari ST
16228#Linear control theory
16229#Algorithms and software for practical numerical analysis
16230#Discrete mathematical structures for computer science (2nd ed.)
16231#Information technology of the future: the basis for strategic planning in data processing
16232#ISPY: an instruction set analysis tool
16233#Programming with Pascal
16234#An introduction to contemporary statistics (2nd ed.)
16235#Database system concepts
16236#Applied analysis
16237#68000 assembly language: techniques for building programs
16238#Combinatorics: theory and applications
16239#Temporal logic of programs
16240#Instant Pascal illustrated: fear and loathing on the Apple II
16241#Algorithms: their complexity and efficiency (2nd ed.)
16242#Getting the most from utitilies on the IBM PC: perfecting the system environment
16243#Network query optimization made easy
16244#Structured programming concepts
16245#Computer capacity planning: theory and practice
16246#Pascal programming with style: a brief introduction
16247#Security of information: a methodological approach
16248#Pascal programming
16249#Combinatorial heuristic algorithms with FORTRAN
16250#Supercomputers and their use
16251#Asymptotic methods in statistical theory
16252#MVS program development and cataloged procedures: JCL book 3
16253#Ada, a first introduction
16254#Pascal with excellence: programming proverbs
16255#Pascal: programming and problem solving (2nd ed.)
16256#National shop-by-mail directory for personal computer users
16257#The power of Pascal
16258#Using microcomputers: a hands-on introduction
16259#Assembly language programming for the VAX-11 (2nd ed.)
16260#A mother's guide to computers
16261#Expert systems
16262#6502 assembly language programming (2nd ed.)
16263#Microcomputer experimentation with the Intel SDK-86
16264#The cognitive connection: thought and language in man and machine
16265#Compute]'s AmigaDOS reference guide
16266#Elements of C
16267#Advanced dBase III: programming & techniques
16268#The foundations of program verification (2nd ed.)
16269#Latent variable models: an introduction to factor, path, and structural analysis
16270#Logic programming and its applications
16271#Problem solving methods with examples in Ada
16272#Dictionary of information technology (2nd ed.)
16273#The use of information science
16274#VSAM: access method services and application programming
16275#To logo: activities guide
16276#Structured COBOL programming
16277#Intuition to implementation: communicating about systems: toward a language of structure in data processing system development
16278#Principles of programming languages: design, evaluation, and implementation (2nd ed.)
16279#The craft of software engineering
16280#Operation systems: advanced concepts
16281#Prolog: a relational language and its applications
16282#Building Logo skills Apple: book B
16283#Numerical grid generation: foundations and applications
16284#The secret word: a guide to hidden potential of Microsoft Word
16285#Convergence of the Vortex filament method
16286#The convergence of multi-level methods for solving finite-element equations in the presence of singularities
16287#Difference schemes for degenerate parabolic equations
16288#Well-Posedness of one-way wave equations and absorbing boundary conditions
16289#Absorbing boundary conditions for difference approximations to the multi-dimensional wave equation
16290#What is the complexity of related elliptic, parabolic, and hyperbolic problems?
16291#Stability with large step sizes for multistep discretizations of stiff ordinary differential equations
16292#Construction of variable-stepsize multistep formulas
16293#The numerical solution of second-order boundary value problems on nonuniform meshes
16294#Supra-convergent schemes on irregular grids
16295#A uniformly accurate finite-element method for a singularly perturbed one-dimensional reaction-diffusion
16296#Symmetrization of the Sinc-Galerkin method for boundary value problems
16297#Integral equations on the half-line: a modified finite-section approximation
16298#A spectral Galerkin method for a boundary integral equation
16299#A Shamanskii-Like acceleration scheme for nonlinear equations at singular roots
16300#Rates of convergence of Gauss, Lobattom, and Radau integration rules for singular integrands
16301#On the computing Gauss-Kronrod Quadrature Formulae
16302#An estimate of goodness of cubatures for the unit circle in R2
16303#On Gamma function inequalities
16304#Properties of the polynomials associated with the Jacobi polynomials
16305#A double integral containing the modified Bessel function: Asymptotics and computation
16306#Number-theoretic transforms of prescribed length
16307#The primality of R1031
16308#Products of prime powers in binary recurrence sequences, Part I: the hyperbolic case, with an application to the generalized Ramanujan-Nagell equation
16309#Products of prime powers in Binary recurrence sequences, Part II: the elliptic case, with an application to a mixed quadratic-exponential equation
16310#Some remarks on Cohen-Lenstra heuristics
16311#Options multiply for nonimpact page printers
16312#DoD struggles to balance IC reliability and price
16313#Standardization effort focuses on interchange of design data
16314#Changes in CAE/CAD requirements affect workstation design
16315#Testability analysis becomes commonplace in CAE environment
16316#Voice output systems make it hard to distinguish real from synthetic
16317#LANs team up to widen the network connection
16318#Gateways link assorted networks
16319#X.25 standard simplifies linking of different LANs
16320#Choosing the best local area network for any application
16321#Controller IC contends with multiple protocols
16322#Building blocks stack up to high performance
16323#Multibus II designs exploit advanced bus concepts
16324#Computers tailored to efficient expansion
16325#Hypercube architecture leads the way for commercial supercomputers in scientific applications
16326#Microprocessor brings floating-point capability to 32-bit market
16327#EEPROMs move into standard cell libraries
16328#Third-party software aids data management in CAE systems
16329#Comprehensive analyzers ease the pain of LAN performance testing
16330#Terminals add PC features to fulfill multiuse system demands
16331#Controllers drive performance up to meet system demands
16332#Graphics technology
16333#Communications board speeds network integration
16334#Matching hardware to Lisp yields peak performance
16335#Optical systems erode mass storage barriers
16336#First Page of the Article
16337#First Page of the Article
16338#First Page of the Article
16339#First Page of the Article
16340#First Page of the Article
16341#First Page of the Article
16342#First Page of the Article
16343#First Page of the Article
16344#First Page of the Article
16345#First Page of the Article
16346#First Page of the Article
16347#First Page of the Article
16348#First Page of the Article
16349#Distributed programs: an overview of implementations
16350#Vision system based on a single-chip microcomputer
16351#Embedded microprocessor software: case study of an automatic computer exchange
16352#12-bit digital audio time delay using the 6809
16353#Design for testability — a review of advanced methods
16354#Software development tool for target systems and EPROM programmers within a Unix environment
16355#Microprocessor-based digital controller for DC motor speed control
16356#Talking teletext receiver for the blind
16357#The accuracy of combining judgemental and statistical forecasts
16358#Bidding for contracts
16359#Final-offer arbitration
16360#A special case of dynamic pricing policy
16361#Batch size and stocking levels in multi-echelon repairable systems
16362#A primal simplex approach to pure processing networks
16363#Multi-object auctions: sequential vs. simultaneous sales
16364#Comment on “multi-object auctions: Sequential vs. simultaneous sales"
16365#The use of categorical variables in data envelopment analysis
16366#A multiobjective methodology for selecting subsystem automation options
16367#Ordinal ranking and intensity of preference: A linear programming approach
16368#A note on the reversibility and duality of some tandem blocking queueing systems
16369#The managerial economics of civil litigation: A note
16370#A note on PERT times
16371#Fourteenth annual survey of performance-related software packages
16372#Demands of the cybernetization of informational and decisional systems in argriculture
16373#Adjusting the supply process with stocking stochastic models
16374#Model for establishing the competitiveness of the “SPOT” lots in crude oil imports
16375#Using GBASIC in the 2D and 3D applications
16376#Revisiting Phillip's model by applying the root locus method
16377#The scientific activity of the Cybernetics Commission of the Academy of the Socialist Republic of Romania
16378#The Cybernetics of industrial systems
16379#Complex dynamic systems. Contributions of the cybernetics commission of the Academy of the Socialist Republic of Romania
16380#The Romanian School of Economic Cybernetics
16381#The Cybernetics of living systems in the outlook of economic and social development
16382#The Romanian School of Economic Cybernetics and the development of Informatics
16383#Cybernetics education and economic informatics
16384#Intelligent Information Systems: Progress and Prospects
16385#Computers in medicine
16386#Resilient computing systems: vol. 1
16387#Power integrated circuits: Physics, design, and applications
16388#Digital communications
16389#Advances in computer chess
16390#Intelligent machinery: theory and practice
16391#Recent advances in robotics
16392#Computer annual: an introduction to information systems 1985-1986
16393#Artificial intelligence for society
16394#On machine intelligence (2nd ed.)
16395#Distributed systems, Vol I: distributed processing systems
16396#Managing computer impact: an international study of management and organizations
16397#32-Bit microprocessors
16398#Cases in network design
16399#Computational linguistics
16400#An elliptic-parabolic free boundary problem
16401#Asymptotics for some nonlinear O.D.E. of the second order
16402#On a class of parabolic unilateral problems
16403#On some specification of the Dubovitskii-Milyutin method
16404#On the topological degree for mappings of monotone type
16405#On ordinary differential equations in locally convex spaces
16406#Nonlinear viscoelasticity with time-dependent coefficients
16407#Stability for multispecies population models in random environments
16408#Fixed point theorems for a pair of set-valued maps on a metric space
16409#Interior regularity for solutions to obstacle problems
16410#The Lyapunov matrix-function and stability of hybrid systems
16411#Frequency-domain approach to nonlinear oscillations of some third-order differential equations
16412#Existence of solutions for a class of semilinear noncoercive problems
16413#On the single valuedness of Hamilton-Jacobi operators
16414#Addendum to: Existence and uniqueness of solutions to nonlinear dissipative wave equations
16415#A simple proof of the regularity theorem for the variational inequality of the obstacle problem
16416#A semilinear wave equation in one space variable with weak damping: convergence to equilibrium
16417#Expert systems: The DSS of the future
16418#Computer expansion: An issue to be reckoned with
16419#Simplifying paperwork
16420#Effective resource allocation through decision support systems
16421#Human resource planning
16422#We are interested in first-order unification problems and, more specifically, in the hierarchy of equational theories based on the cardinality of the set of most general unifiers. The following result is established in this paper: if T is a suitable first-order equational theory that is not unitary, then T is not bounded; that is, there is no integer n 1 such that for every unification problem (s = t)"T, the cardinality of the set of most general unifiers for (s = t)"T is at most n. Hence, the class of (non-unitary) finitary theories cannot be decomposed into a hierarchy obtained by uniformly bounding the eardinalities of the sets of most general unifiers.
16423#Martin-Lof's Intuitionistic Theory of Types is becoming popular for formal reasoning about computer programs. To handle recursion schemes other than primitive recursion, a theory of well-founded relations is presented. Using primitive recursion over higher types, induction and recursion are formally derived for a large class of well-founded relations. Included are
16424#This paper discusses a Pascal implementation of a fast recursion formula for multiplicities of dominant weights in finite-dimensional irreducible modules for simple complex Lie algebras. The formula (a modification of Freudenthal's) and an algorithm for direct computation of the dominant weights are described in R. V. Moody, J. Patera, Fast recursion formula for weight multiplicities, Bull. Amer. Math. Soc. 7 (1982), 237-242. The program is interactive and was developed on the CDC Cyber 835. The user specifies a Lie algebra and a highest weight; the program computes the dominant weights and multiplicities faster than previous implementations of Freudenthal's formula. All computations are exact.
16425#A complete group presentation consists of a set of generators and a set of replacement rules generating a well-founded and confluent relation on words, thereby solving the word problem for this presentation. Complete presentations for surface, Coxeter, Dyck and symmetric groups are discussed. These complete presentations possess interesting combinatorial properties and provide uniform algorithms for the word problem.
16426#We report on the successful application of the Buehberger algorithm system to determine Grobner bases for the problem of constructing universal unfoldings in singularity and bifurcation theory. Useful extensions are proposed and their relevance to the mapping problem is discussed.
16427#In this paper we present a new approach to automated geometry theorem proving that is based on Buchberger's Grobner bases method. The goal is to automatically prove geometry theorems whose hypotheses and conjecture can be expressed algebraically, i.e. by polynomial equations. After shortly reviewing the problem considered and discussing some new aspects of confirming theorems, we present two different methods for applying Buehberger's algorithm to geometry theorem proving, each of them being more efficient than the other on a certain class of problems. The second method requires a new notion of reduction, which we call pseudoreduction. This pseudoreduction yields results on polynomials over some rational function field by computations that are done merely over the rationals and, therefore, is of general interest also. Finally, computing time statistics on 70 non-trivial examples are given, based on an implementation of the methods in the computer algebra system SAC-2 on an IBM 4341.
16428#The use of Grobner basis computation for reasoning about geometry problems is demonstrated. Two kinds of geometry problems are considered: (i) Given a finite set of geometry relations expressed as polynomial equations, in conjunction with a finite set of subsidiary conditions stated as negations of polynomial equations to rule out certain degenerate eases, check whether another geometry relation expressed as a polynomial equation and given as a conclusion, holds. (ii) Given a finite set of geometry relations expressed as polynomial equations, find a finite set of subsidiary conditions, if any, stated as negations of polynomial equations which rule out certain values of variables, such that another geometry relation expressed as a polynomial equation and given as a conclusion, holds under these conditions. Using a refutational approach for theorem proving, both kinds of problems are converted into reasoning about a finite set of polynomial equations. The first problem is shown to be equivalent to checking whether a set of polynomial equations does not have a solution; this can be decided by computing a Grobner basis of these polynomials and checking whether I is included in such a basis. In addition, it is shown that the second problem can also be solved by computing a Grobner basis and appropriately picking polynomials from it. A number of geometry problems of both kinds have been solved using this approach.
16429#On the greedy algorithm with random costs
16430#Long vectors for quasi-Newton updates
16431#Controlled perturbations for quadratically constrained quadratic programs
16432#Global convergence of the partitioned BFGS algorithm for convex partially separable optimization
16433#An outer-approximation algorithm for a class of mixed-integer nonlinear programs
16434#Trajectory nets connecting all critical points of a smooth function
16435#A stability concept for matrix game optimal strategies and its application to linear programming sensitivity analysis
16436#The priority tree, a HL/HSR approach for PHIGS
16437#A representation of fonts for computer graphics
16438#A functional approach to animation
16439#Biomorphs: Computer displays of biological forms generated from mathematical feedback loops
16440#Reconstruction of 3D objects form orthographic projections
16441#A survey of contouring methods
16442#Artificial intelligence in three-dimensional computer animation
16443#Teaching workshop - December 1985
16444#EUROGRAPHICS '86 - a personal view
16445#Ausgraph '86
16446#The score function approach for sensitivity analysis of computer simulation models
16447#Analytic macroelements combined with finite elements: Application in modelling electromagnetic systems
16448#An application of a Markov chain noise model to wind generator simulation
16449#Numerical study of the effects of variable fluid property and internal heat generation on flat-plate thermometer
16450#Adapting combinator and SECD machines to display snapshots of functional computations
16451#Inserting injection operations to denotational specifications
16452#AID: An alternative implementation of DCBs
16453#A list processing language TAO with multiple programming paradigms
16454#Report on the Third International Conference on Logic Programming
16455#Protocol-realization-oriented model of network communications
16456#Optimum placement of remote information concentrators in a centralized data transmission network taking into account the reliability of communication channels
16457#Evaluating the labor cost of timetabling for computers by the method of a family of solutions
16458#An approximate calculation method for open queuing networks
16459#Comparative analysis of two protocols of random multiple access
16460#Automata-based models of local computer networks
16461#A token-based access method for a small local network
16462#Principles of the design of a local computer network for message switching center
16463#The selection of a servicing discipline in a multiterminal conversational information retrieval system
16464#Shared-use adaptive scheduler for a computer center of an information and scheduling service in a computer network
16465#Minimizing the number of “1” positions in the subsets of code sets corresponding to groups of coded elements in the synthesis of PLA circuits
16466#Linearization methods used in the design of combination devices
16467#Method of constructing flowcharts of simple binary programs for systems of boolean functions
16468#Estimating the number of outputs of a universal logic element
16469#Approximation of the solution of a fourth order boundary value problem with nonsmooth coefficient
16470#Numerical analysis of the equations of small strains quasistatic elastovisoplasticity
16471#A simple rational spline and its application to monotonic interpolation to monotonic data
16472#On the order conditions of Runge-Kutta methods with higher derivatives
16473#Correction of finite element estimates for Stum-Liouville eigenvalues
16474#Analysis of the Kleiser-Schumann method
16475#The average a posteriori error of numerical methods
16476#Computer-based models for policy making: Uses and impacts in the U.S. federal government
16477#Efficiency analysis for exogenously fixed inputs and outputs
16478#A tactical planning model for a job shop
16479#Petroleum reservoir exploitation: Switching from primary to secondary recovery
16480#Optimal design of systems subject to two types of error
16481#Replacement costs under warranty: Cost moments and time variability
16482#Resource-constrained assignment scheduling
16483#Uniformization and hybrid simulation/analytic models of renewal processes
16484#A Monte Carlo sampling plan for estimating network reliability
16485#Stochastic bounds on distributions of optimal value functions with applications to PERT, network flows and reliability
16486#Optimal sequencing by modular decomposition: Polynomial algorithms
16487#A deterministic single-item inventory model with seller holding cost and buyer holding and shortage costs
16488#D/G/1 queues with vacations
16489#Policy bounds for Markov decision processes
16490#Successive approximations for finite horizon, semi-Markov decision processes with application to asset liquidation
16491#Advertising models, stochastic games and myopic strategies
16492#On the weighted selection algorithm for certain linear programs with nested constraint coefficients
16493#Renormalization group analysis of turbulence I. Basic theory
16494#Two-dimensional nonsteady viscous flow simulation on the Navier-Stokes computer mininode
16495#Boundary conditions for incompressible flows
16496#Solid modeling in design and manufacture
16497#Cad — its changing profile
16498#The first section of this article showed how expert systems (ESs) evolved from a branch of the artificial intelligence (AI) field which focused on solving difficult, real world problems. A number of frameworks were put forth to show how ESs compare to other information systems (IS), and to help the practitioner identify valuable and feasible ES applications. Further, it was argued that a well-targeted ES may provide the user with a defensible competitive advantage, and because ESs are currently moving from universities into commerce it is now time to investigate their potential.This section moves on from the discussion of identification of ES opportunity into the issues of development and implementation. In comparison to other IS projects, ESs should prove more demanding. And even though the opportunity for strategic advantage may be available, the execution of a successful ES presents many managerial challenges. The discussion draws on previous literature to help identify issues which are likely to be encountered in practical application of ESs in business. Throughout the discussion, research opportunities are raised and the summary presents a research agenda.
16499#"The basic function of administration appears to be co-alignment, not merely of people in coalitions but of institutionalized action --- of technology and task environment into a viable domain, and of organizational design and structure appropriate to it. Administration, when it works well, keeps the organization at the nexus of several necessary streams of action" [13].
16500#The impact of computer graphics on organizational effectiveness can be considerable. The cost of these benefits can also be substantial, both in system cost and in personnel investment. Most discussions of computer graphics technology are driven by technology rather than by applications. Most managers do not understand the technology, and most of the graphics literature is directed either at engineers or at persuading customers in general to purchase systems. This paper provides information for managers and system designers on the major application areas in computer graphics, and the technological alternatives appropriate to different applications.
16501#This research investigates the role of the information transfer specialist as a technical intermediary and integrating agent in the acceptance and effective utilization of decision support systems (DSS). A multi-dimensional measure of perceived DSS implementation success is presented as the dependent variable, and the facilitative and technical functions of the specialist are specified as the independent variables. Measurement scales are developed for both sets of variables and the psychometric properties of the scales are tested using hierarchic cluster analysis for scale construction and Chronbach's alpha for scale reliability. Forty-five mature decision support systems served to field test the measurement scales and the research hypotheses. The findings show a positive correlation between the presence of an information transfer specialist and perceived DSS implementation success.
16502#What's in a name? Looking for people online—humanities
16503#MARS online marketing intelligence from PTS
16504#Finder: software for text retrieval—A review
16505#INDEXIT: An economical, but limited indexing program
16506#MEDLINE subheadings revisited
16507#WILSONDISC: WILSONLINE on CDROM
16508#Source code—programming for appearance
16509#Full-text newspapers online part 2—subject strengths
16510#Searching STN international
16511#Multi-layered image representation: Structure and application in recognition of parts of brain anatomy
16512#Statistical evaluation of computer markers to detect leukemias
16513#Optical flow and the Taylor expansion
16514#The extraction of boundaries using local measures driven by rules
16515#Application of the singular value method and signal subspace methods to sampled radar images
16516#Fast percentile filtering
16517#Stereo matching using intra- and inter-row dynamic programming
16518#Linear feature detection and enhancement in noisy images via the Radon transform
16519#On-line processing of transmission electron microscopic images
16520#Optical flow fields in Hough transform space
16521#Radar imaging of roughness pattern on the ocean surface
16522#Determination of optimal recognition algorithms in the two-level system
16523#An efficient modified block coding technique
16524#Pattern storage and associative memory in quasi-neural network
16525#Thresholding for edge detection using human psychovisual phenomena
16526#Effect of fuzzy membership on recognition of gray level images
16527#A linear-time algorithm for solving the strong hidden-line problem in a simple polygon
16528#Some experiments on the detection of three-dimensional motion of rigid objects in blocks world
16529#A curve matching problem in astronomy
16530#Analysis of cosmic ray tracks using distributed problem solving
16531#A picture and text query and archiving system
16532#The perceived effect of breakdown and repair on the performance of multiprocessor systems
16533#Bounds for the optimal decentralized access protocol in a local area network
16534#Study of a simulated stream machine for dataflow computation
16535#On the nonconcavity of throughput in certain closed queueing networks
16536#Two processor scheduling with limited preemption
16537#International seminar on teletraffic analysis and computer performance evaluation
16538#Performance analysis of a virtual circuit protocol with local control
16539#Regenerative stochastic Petri nets
16540#Location of a boundary for a diffusion equation of a single server queue
16541#The influence of service-time variability in a closed network of queues
16542#1986 conference EDP performance management
16543#The COSMOS image analyser
16544#A compact set of image processing primitives and their role in a successful application program
16545#Recent advances in error rate estimation
16546#An optimal error rate estimator based on average conditional error rate: Asymptotic results
16547#Adaptive windows: edges, stereopsis and stripes
16548#Measuring the human chest with structured lighting
16549#Detection of abnormalities on carotid agiograms using syntactic techniques
16550#An alternative nearest neighbour classification scheme
16551#Computing Voronoi diagrams in digital pictures
16552#Classification of chromosomes constrained by expected class size
16553#A parallel processor implementation of a chromosome analysis system
16554#Two methods for analyzing pleural smears for the presence of abnormalities
16555#Necessary conditions, controllability and the value function for differential-difference inclusions
16556#A class of nonlinear elliptic-parabolic equations with time-dependent constraints
16557#Periodic boundary value problems for integro-differential equations of Volterra type
16558#Stability of steady solutions of reaction-diffusion equations
16559#Annular chaotic areas
16560#Long time existence and singular perturbation results for quasi-linear hyperbolic equations with small parameter and dissipation term
16561#Multiparameter local bifurcation
16562#Fixed points of weakly inward multis
16563#On nonlinear stablility of stationary of planar Euler flows in an unbounded strip
16564#Transverse homoclinic orbits in periodically perturbed parabolic equations
16565#Some fixed point theorems and applications
16566#On the equation of turbulent filtration in one-dimensional porous media
16567#An iterative method for elliptic problems on regions partitioned into substructures
16568#Finite element technique for optimal pressure recovery from stream function formulation of viscous flows
16569#On a large time-step high resolution scheme
16570#A convergent 3-D vortex method with grid-free stretching
16571#Artificial boundary conditions for the linear advection diffusion equation
16572#The fast adaptive composite grid (FAC) method for elliptic equation
16573#Complexity of indefinite elliptic problems
16574#Approximate solution of boundary value problems on infinite intervals by collocation methods
16575#Numerical solution of nonlinear differential equations with algebraic constraints I: Convergence results for backward differentiation formulas
16576#On two methods for approximating minimal surfaces in parametric form
16577#An efficient algorithm for obtaining the volume of a special kind of pyramid and application to convex polyhedra
16578#Newton's method for the matrix square root
16579#Least squares approximation with constraints
16580#Convex interpolation by splines of arbitrary degree
16581#Rate of convergence of Shepard's global interpolation formula
16582#On weighted Chebyshev type quadrature formulas
16583#Tables of the roots of the associated Legendre function with respect to the degree
16584#Effect of improved multiplication efficiency on exponentiation algorithms derived from addition chains
16585#A conjecture of Frobenius and the sporadic simple groups,II
16586#Effective irrationality measure for certain algebraic numbers
16587#A remark on a theorem of W E H Berwick
16588#Construction of elliptic curves with large rank
16589#Explicit determination of nontrivial torsion structures of elliptic curves over quadratic number fields
16590#A lower bound for the class number of certain cubic number fields
16591#On the zeros of the Riemann zeta function in the critical strip. IV
16592#Integers with Digits 0 or 1
16593#Fast primality tests for numbers less than 50 · 109
16594#On Mordell's equation y2-k=x3. A problem of Stolarsky
16595#On the congruence 2n-k=1(mod n)
16596#284457 Steiner triple systems of order 19 contain a subsystem of order 9
16597#A computer-assisted investigation of Ramanujan pairs
16598#Two triads of squares
16599#Finding the t-join structure of graphs
16600#A convergence theorem of Rosen's gradient projection method
16601#Symmetric minimum-norm updates for use in Gibbs free energy calculations
16602#On the cut polytope
16603#A variation on Karmarkar's algorithm for solving linear programming problems
16604#On projected Newton barrier methods for linear programming and an equivalence to Karmarkar's projective method
16605#Piecewise-linear programming: The compact (CPLP) algorithm
16606#Dominants and submissives of matching polyhedra
16607#On components of random graphs in the n-cube
16608#(Cycles in the structural graph of a finite acyclic digraph)
16609#(On the decomposition of set systems, Boolean functions, and graphs)
16610#On the calculation and approximation of the mean time between failure of a system with two and three component subsystems
16611#Computing and the political world
16612#Technological determinism in social data analysis
16613#Acceptance of computer-based models in local government: information adequacy and implementation
16614#Proc. of the international seminar on Teletraffic analysis and computer performance evaluation
16615#Performance models for distributed systems
16616#General resource sharing systems
16617#Trunk reservation models in telecommunication systems
16618#Blocking and routing in circuit-switched networks
16619#Some results from an asymptotic analysis of a class of simple, circuit-switched networks
16620#An approximation method for analyzing a virtual circuit switched based LAN—solving the simultaneous resource possession problem
16621#Models of two queues—a few new views
16622#An efficient algorithm for the cycle time distribution in two-stages cyclic queues with a non-exponential server
16623#Approximate analysis of priority queueing networks
16624#Measurements and simulation
16625#On inference and transient response for M/G/1 models
16626#Equivalent network, load dependent servers, and perturbation analysis—an experimental study
16627#UNIX process behavior and load balancing among loosely-coupled computers
16628#Overload control for switches of communication systems—a two-phase model for call request processing
16629#An M/G/1 queue with class dependent balking (reneging)
16630#A simple telephone exchange with delayed feedbacks
16631#Sharp approximation models of adaptive routing in mesh networks (preliminary report)
16632#Performance models for computer systems (extended abstract)
16633#Stochastic analysis of storage fragmentation
16634#Some transformed Markov processes
16635#Markovian functionals in teletraffic analysis
16636#Perturbation series expansions for nearly completely-decomposable Markov chains
16637#Insensitivity in two-node blocking models with applications
16638#Discrete-time analysis for the interdeparture distribution of GI/G/1 queues
16639#Queues with locking: the multiclass problem
16640#The movable-boundary multiplexor—stability and decomposability
16641#Mean waiting times in nonpreemptive priority M/G/1 queues with server switchover times
16642#Two queues and one server with threshold switching
16643#A modeling study of the Orwell ring protocol
16644#Flexible networks of tightly and loosely coupled processors
16645#On the time-dependence of information in distributed systems
16646#Expert system applications in system modeling
16647#Performance analysis of a direct access file with random insertions and deletions
16648#Stochastic inequalities for queueing networks
16649#Bounds on conditional steady-state distributions in large Markovian and queueing models
16650#An intuitive approach to geometric continuity for parametric curves and surfaces
16651#The PSG programming system generator developed at the Technical University of Darmstadt produces interactive, language-specific programming environments from formal language definitions. All language-dependent parts of the environment are generated from an entirely nonprocedural specification of the language's syntax, context conditions, and dynamic semantics. The generated environment consists of a language-based editor, supporting systematic program development by named program fragments, an interpreter, and a fragment library system. The major component of the environment is a full-screen editor, which allows both structure and text editing. In structure mode the editor guarantees prevention of both syntactic and semantic errors, whereas in textual mode it guarantees their immediate recognition. PSG editors employ a novel algorithm for incremental semantic analysis which is based on unification. The algorithm will immediately detect semantic errors even in incomplete program fragments. The dynamic semantics of the language are defined in denotational style using a functional language based on the lambda calculus. Program fragments are compiled to terms of the functional language which are executed by an interpreter. The PSG generator has been used to produce environments for Pascal, ALGOL 60, MODULA-2, and the formal language definition language itself.
16652#Syntactic lexicometric programs
16653#The Institute for Applied Forth Research, Inc on Proceedings of the 1986 Rochester Forth Conference
16654#Algorithm for concurrency control in replicated databases
16655#Design considerations for a distributed real-time nuclear reactor safety system
16656#Design of a simple Cambridge Ring interface adapter
16657#Synthesis of queueing networks with block and state-dependent routing
16658#Performance modelling of SERC Prime computer system
16659#Model of error propagation in database systems
16660#Automation of MVS operations: an expert systems approach
16661#Electrical Communication
16662#Design methodology and CAD tools for full-custom VLSI design
16663#Support environment for semi-custom VLSI development
16664#Galileo: model, language, and tools
16665#ITT component information system
16666#Software development for System 12
16667#Integrated printed board design system
16668#Life cycle support for microprocessor-based products
16669#Measurement interface module for the software development environment
16670#Generation of real-time executive systems
16671#Distributed software test environment
16672#Development and maintenance of application software
16673#Unix-based tools for the development of terminal systems
16674#Human factors support for product development
16675#Design of user-system interfaces using a cognitive design aid
16676#Computer assisted video analysis system
16677#Scheduling analysis, modeling, and pricing
16678#Computer aids for mechanical design within the electronics industry
16679#The Institute of Electrical and Electronics Engineers, Inc on Conference on software maintenance--1985
16680#An automated system for controlling operational program and JCL changes
16681#Automated configuration management on a DOD satellite ground system
16682#A database approach to configuration management for large projects
16683#Structured program analysis applied to software maintenance
16684#The automatic restructuring of COBOL
16685#Maintenance and porting of software by design recovery
16686#Controlling the evolution of large scale software systems
16687#Software maintenance management
16688#The validation, verification, and testing of software: an enhancement to software maintainability
16689#A survey of software quality assurance in the Department of Defense during life-cycle software support
16690#An analysis of software changes during maintenance and enhancement
16691#An empirical approach to the study of errors in large software under maintenance
16692#Controlling the maintainability of PL/I and PL/I-like software
16693#Metrics for optimal maintenance management
16694#A framework for risk assessment of software supportability
16695#Predicting software customer support
16696#Display strategies for program browsing
16697#Strategies for documenting delocalized plans
16698#Impact of software structure on maintenance
16699#Upgrading aging software systems using modern software engineering practices:IBM-FSD's conversion of FAA's national airspace system (NAS) en route stage A software from 9020s to S/370 processors
16700#Designing data base systems for maintainability: case study: IDMS and IMS
16701#A history of software maintenance for a complex U.S. Army Battlefield automated system
16702#Help] I have to update an undocumented program
16703#Simple tools to automate documentation
16704#Using a relational query language as a software maintenance tool
16705#Upgradeability: a measurement of quality
16706#Systematic problem solving: the link to maintenance solutions
16707#Proc. of the European symposium on programming on ESOP 86
16708#Compiler generation from relational semantics
16709#Correctness of code generation from a two-level meta-language
16710#A general approach to the optimization of function calls
16711#Lifetime analysis for procedure parameters
16712#Another implementation technique for applicative languages
16713#Graala: a functional programming system with uncurryfied combinators and its reduction machine
16714#A safe approach to parallel combinator reduction
16715#Reducing recursion to iteration by algebraic extension
16716#Design and implementation of a generic, logic and functional programming language
16717#Pragmatic aspects of two-level denotatonal meta-languages
16718#An experiment in practical semantics
16719#The choice of programming primitives for set-like programming languages
16720#Algebraic semantics of exception handling
16721#Data refinement refined
16722#Proving entailment between conceptual state specifications
16723#Automatic parallelization of FORTRAN programs in the presence of procedure-calls
16724#Parallelization by semantic detection of reductions
16725#Denotational semantics of nets with nondeterminism
16726#Specification of a tool for viewing program text
16727#A classical implementation for PROLOG-II
16728#Programs as collections of communicating Prolog units
16729#An AND-parallel execution model of logic programs
16730#Compiling extended concurrent Prolog-single queue compilation
16731#A very intelligent backtracking method for logic programs
16732#An application of abstract interpretation of logic programs: occur check reduction
16733#Experiences with the RAP system-a specification interpreter combining term rewriting and resolution
16734#Rewriting with a nondeterministic choice operator: from algebra to proofs
16735#The John Hopkins University Applied Physics Laboratory on The role of language in problem solving--1
16736#Influence of language on its user
16737#Keynote address: problems of representation in heuristic problem solving
16738#Programs as symbolic representations of solutions to problems
16739#Physics and technology, cognitive psychology, and computer languages: toward an experimental R&D epistemology using languages as a tool
16740#AI languages should express gradualness
16741#Invited address: AI languages for problem solving
16742#Problem solving and the evolution of programming languages
16743#An argument for non-procedural languages
16744#The use of the subjunctive in problem solving
16745#Space age demands for powerful computer languages
16746#XIMM—an expert system for idle materials management: logic programming for corporate strategies
16747#MIRROR: a language for representing programs for reasoning
16748#APL: a pictorial language
16749#Threaded workspaces—an application development environment for APL
16750#PROLOG application in software components reuse
16751#Solving graph problems using LOGRAPH
16752#Language, problem solving and system development
16753#Invited address: overcoming limitations imposed by current programming languages
16754#Panel session: language requirements for effective and efficient problem solving
16755#Panel session: comparative application of computer languages to practical problems
16756#Summary assessment of the symposium
16757#A language for the conceptual schema of a data base
16758#The future of programming languages
16759#Proceedings from the first international workshop on Expert database systems
16760#Expert database systems: a database perspective
16761#Knowledge base management systems: discussions from the working group
16762#Logic programming and databases
16763#Object oriented database systems and knowledge systems
16764#What makes a knowledge base knowledgeable? A view of databases from the knowledge level
16765#Interactive classification of conceptual knowledge
16766#Semantic retrieval and levels of abstraction
16767#Type subsumption as a model of computation
16768#Constructing and utilizing large fact databases using artificial intelligence techniques
16769#Experiences with SRL: an analysis of frame-based knowledge representations
16770#A system-controlled multi-type specialization hierarchy
16771#On integrating logic programming and databases
16772#Logic programming for constructive expert database systems
16773#Prolog: a database query language for all seasons
16774#PROSQL: a Prolog programming interface with SQL/DS
16775#Rule support in Prolog
16776#Mechanisms for concurrency control and recovery in Prolog—a proposal
16777#Towards an integrated database-Prolog system
16778#Constraint management in expert database systems
16779#Implementation of a semantic integrity manager with a knowledge representation system
16780#The role of constraints in databases, expert systems, and knowledge representation
16781#Specification and design of expert database systems
16782#Towards a unified approach for expert and database systems
16783#An expert database system architecture based on an active and extensible dictionary system
16784#An interactive data dictionary facility for CAD/CAM data bases
16785#A database management system based on an object-oriented model
16786#MILK: multi level interactive logic simulator at Keio University—experience in using the CONSTRAINTS language
16787#Handling constraints and meta-data on a generalized data management system
16788#Distributed database considerations in an expert system for radar analysis
16789#Database support for storage of AI reasoning knowledge
16790#Heuristic search in database systems
16791#Relationships between deductive and abductive inference in knowledge-based diagnostic problem solving
16792#A temporal logic for reasoning about changing data bases in the context of natural language question-answering
16793#Expert helpers to data-based information systems
16794#Query generalization: a method for interpreting null answers
16795#The IRUS transportable natural language database interface
16796#Anticipating false implicatures: cooperative responses in question-answer systems
16797#Supporting natural language database update by modeling real world actions
16798#Semantic query optimization in expert systems and database systems
16799#External semantic query simplification: a graph-theoretic approach and its implementation in Prolog
16800#Proceedings of the 2nd IFIP international conference on Computer security: a global challenge
16801#Professional responsibility for information privacy
16802#The use of digital signatures in banking
16803#What about your legal parachute when you data security crashes?
16804#Equity in access to information
16805#Beyond war: implications for computer security and encryption
16806#Some legal aspects of computer security
16807#The future of trusted computer systems
16808#Security guidelines for the management of personal computing systems
16809#Safeguards selection principles
16810#Problem definition: an essential prerequisite to the implementation of security measures
16811#Security and productivity
16812#A proposal for an automated logical access control standard
16813#Computer system access control using passwords
16814#Computer viruses
16815#Selection process for security packages
16816#Incorporating access control in forms systems
16817#Characteristics of good one-way encryption functions for passwords—some rules for creators and evaluators
16818#A topology for secure MVS systems
16819#Measuring computer system security using software security metrics
16820#Formal verification—its purpose and practice
16821#An overview of Multics security
16822#Some security aspects of decision support systems
16823#The integrity lock support environment
16824#Integrity analysis—a methodology for EDP audit and data quality assurance
16825#Retrofitting the EDP auditor—EDP security skill need and requirements
16826#Towards an expert system for computer-facility certification
16827#A composite cost/benefit/risk analysis methodology
16828#The SBA method—a method for testing vulnerability
16829#An automated method for assessing the effectiveness of computer security safeguards
16830#Security threats and planning of computer centers
16831#Data processing security and terrorism—how to safely pass through the plumb years and inherit a trade union problem: the Italian experience
16832#General Electric—an approach to disaster recovery
16833#Industrial relations and contingency planning
16834#The programmer's threat: cases and causes
16835#Introduction to computer crime
16836#Deviancy by bits and bytes: computer abusers and control measures
16837#Characteristics of the computer environment that provide opportunities for crime
16838#EFT—systems and security, practical co-operation between banks in Finland
16839#Security and privacy in cellular telephone systems
16840#Access control models and office structures
16841#Security management in office information systems
16842#Security considerations in the small systems environment
16843#Data protection in a microcomputer environment
16844#Cause-and-effect model for personal computers
16845#The software sieve
16846#An application of the Chinese remainder theorem to multiple-key encryption in data base systems
16847#A high performance encryption algorithm
16848#Implementation issues for master key distribution and protected keyload procedures
16849#Proc. of the sixth conference on Foundations of software technology and theoretical computer science
16850#Software development graphs: a unifying concept for software development?
16851#Concurrent runtime checking of annotated Ada programs
16852#Recovery of noncurrent variables in source-level debugging of optimized code
16853#Automatic retargetable code generation: a new technique
16854#An implementation of OBJ2: an object-oriented language for abstract program specification
16855#Explicit representation of terms defined by counter examples
16856#A framework for intelligent backtracking in logic programs
16857#A generalization of Backus' FP
16858#Shortest-path motion
16859#Via assignment in single row routing
16860#Average-case analysis of the modified harmonic algorithm
16861#Covering minima and lattice point free convex bodies
16862#Binary decompositions and acyclic schemes
16863#Thin homogeneous sets of factors
16864#Irreducible polynomials over finite fields
16865#Basis reduction and evidence for transcendence of certain numbers
16866#A characterization of asynchronous message-passing
16867#Modular synthesis of deadlock-free control structures
16868#Distributed resource sharing in computer networks
16869#On proving communication closedness of distributed layers
16870#A distributed algorithm for edge-disjoint path problem
16871#Scheduling of hard real-time systems
16872#A polynomial approximation scheme for machine scheduling on uniform processors: using the dual approximation approach
16873#Connectivity algorithms using rubber-bands
16874#On simple and creative sets in NP
16875#Complexity of sufficient-completeness
16876#Sampling a population with a semi-random source
16877#An optimal parallel algorithm for dynamic expression evaluation and its applications
16878#Extension of the parallel nested dissection algorithm to path algebra problems
16879#On synthesizing systolic arrays from recurrence equations with linear dependencies
16880#An efficient parallel algorithm for term matching
16881#X-ray lithography
16882#Stability of SiC-masks for high resolution synchrotron X-ray lithography
16883#Silicon X-ray masks: pattern placement and overlay accuracy
16884#Ion-implant compensation of tensile stress in tungsten absorber for low distortion X-ray masks
16885#Influence of thin film thickness variations on pattern fidelity of X-ray masks
16886#Determination of the average stress and its adjustment in thin silicon membranes used in various lithographs
16887#Critical dimension control in X-ray masks with electroplated gold absorbers
16888#Simple method for the defect control in X-ray mask fabrication
16889#Automatic mask alignment for X-ray microlithography
16890#Highly-sensitive novolak-based positive X-ray resist
16891#A MOFSET, manufactured with synchrotron X-ray lithography
16892#A flexible beamshaper
16893#Electron optical column for high speed nanometric lithography
16894#Electron beam/optical mixed lithography at half-micron ground rules
16895#Determination of the proximity parameters in electron beam lithography using doughnut-structures
16896#The study of the electron-electron interaction in electron gun
16897#Progress on the Delft ion beam pattern generator
16898#Maskless ion beam assisted deposition of W and Ta films
16899#Metallurgy and microfabrication applications of gold-silicon-beryllium liquid-metal field-ion sources
16900#Simulation of graded-base bipolar transistor characteristics fabricated with a focused ion beam
16901#Mask and circuit repair applications of focused ion beam deposition
16902#Ion projection lithography in (in)organic resist layers
16903#Quantum transport in microstructures
16904#Submicron MOS devices
16905#Synchrotron lithography for sub-half-micron T-gates in GaAs-FET
16906#Ultrasmall device fabrication using dry etching of GaAs
16907#Nanometer-scale lithography for Aharonov-Bohm magnetoconductance oscillation studies
16908#Direct fabrication of nanometer-scale structures in semiconductors with 500 keV lithography
16909#Fabrication of grating gates for lateral surface superlattice devices using E-beam lithography
16910#Fabrication of low-capacitance Josephson-junctions
16911#Effects of silylation parameters on the lithographic performance of the desired system
16912#Diazopolysiloxanes: unique imageable barrier layers
16913#Poly-4-bromostyrene, a high-performance negative electron resist
16914#Commercial dyes for novolak based multilayer systems
16915#Investigation of structure profiles in negative resists
16916#Fabrication of thin-film warm carrier infrared laser detectors using nitrocellulose self-developing resist
16917#Characterization of UV hardening process
16918#Radiation damage in dry etching
16919#Ion energy and anisotropy in microwave plasma etching of polymers
16920#Mechanism of microwave plasma etching of polyimides in O2 and GF4 gas mixtures
16921#Secondary effects of single crystalline silicon deep-trench etching in a chlorine-containing plasma of 3-dimensional capacitor cells
16922#High-temperature-stable Si3N4 dummy T-gate and lift-off mask
16923#Mini-trench isolation: trench etching, oxidation and refilling planarization
16924#Periodic Si-hole-masks in the &mgr;m and sub-&mgr;m range for electron-multibeamwriting
16925#Advantages of using spin-on-glass layer in interconnection dielectric planarization
16926#Electron beam decomposition of carbonyls on silicon
16927#Laser-induced chemical processes at interfaces
16928#Electronic materials surface processing with excimer lasers
16929#Excimer lasers as deep UV sources for photolithographic system
16930#ArF laser induced lift-off process
16931#Micromachining of polyimide films with focused ion beams
16932#Mask making for synchrotron radiation lithography
16933#The potential of mechanical microlithography for submicron patterning
16934#Silicon micro mechanics (SiMM): Si-beams with rectangular cross-section for atomic force sensing by means of STM
16935#Simulation of focused ion beam milling
16936#An image fidelity approach to measuring the point spread function in electron and ion beam lithographies
16937#Scanning tunneling microscopy
16938#Scanning thermal profiler
16939#Some aspects concerning design for E-beam testability
16940#E-beam testing of high speed electronic devices
16941#A high frequency logic-state tracing method
16942#A dynamic real-time 3-D measurement technique for IC inspection
16943#Energy and time-resolved photoemission in a promising new approach for contactless integrated-circuit testing
16944#Fully-automated optical inspection for VLSI production
16945#Extension of the M.A.L.T. concept to thick layers with emphasis on focusing conditions
16946#Confocal laser microscope for submicron structure measurement
16947#The SEM as inspection and testing tool in the IC industry
16948#A practical submicron lithography system using a conventional source X-ray stepper
16949#Recent developments in X-ray lithography systems
16950#Proc. of the International Conference on Microlithography on Microcircuit engineering 86
16951#Miss Edith Ditmas: an appreciation
16952#Edith Ditmas: bibliography
16953#Improved design of graphic displays in thesauri—through technology and ergonomics
16954#Effects of a relegation programme on the borrowing of books
16955#Cognitive models in information retrieval—an evaluative review
16956#Characterization of interface stress at InGaPAs/GaAs by Cr-related luminescence line in GaAs
16957#The effects of Zn-vapor or Te-vapor heat treatment on the luminescence of ZnTe
16958#Study of the laser-recrystallized film with a control of grain boundary location by using surrounding antireflection cap method
16959#New shallow acceptor levels in GaAs
16960#Equilibruim solidification of Sn-Ag-Sb thermal fatigue-resistant solder alloys
16961#The formation of Cu3Sn intermetallic on the reaction of Cu with 95Pb-5Sn solder
16962#Fluid flows induced in tall narrow containers by A.C.R.T
16963#Bridgman growth of CdxHg1–xTe using ACRT
16964#Comparison of electrical and atomic profiles of Mg24 and Zn64 implanted GaAs samples and GaAsGaAlAs heterostructures for bipolar transistor applications
16965#Open-tube diffusiom techniques for InP/InGaAs heterojunction bipolar transistors
16966#A criterion of quality to measure the partition of petri nets
16967#Screen-based human-computer-interface concerning consumer information
16968#Sizes—A system for planning and controlling production systems with robots
16969#The development and application of a computer program for charting the order in a paper mill
16970#Open systems interconnection (OSI)
16971#Building management data transfer
16972#On expansion of algebraic functions in power and puiseux series, I
16973#Fast multiplication of a recursive block toeplitz matrix by a vector and its application
16974#How powerful is continuous nonlinear information for linear problems?
16975#On the existence of optimal affine methods for approximating linear functionals
16976#An optimal algorithm for search of extrema of a bimodal function
16977#Adaption helps for some nonconvex classes
16978#An analysis of the discontinuous Galerkin method for a scalar hyperbolic equation
16979#Finite element solution of the fundamental equations of semiconductor devices
16980#Convergence of upwind schemes for a stationary shock
16981#A moving mesh numerical method for hyperbolic conservation laws
16982#Boundary integral solutions of the heat equation
16983#An analysis of a superconvergence result for a singularly perturbed boundary value problem
16984#On the numerical solution of singular boundary value problems of second order by a difference method
16985#Natural continuous extensions of Runge-Kutta formulas
16986#Some practical Runge-Kutta formulas
16987#Julia sets and mandelbrot-like sets associated with higher order Schro¨der rational iteration functions: A computer assisted study
16988#Computing volumes of polyhedra
16989#Numerical solution of large sets of algebraic nonlinear equations
16990#A class of cubic splines obtained through minimum conditions
16991#On monotone and convex spline interpolation
16992#Some evaluations for the generalized hypergeometric series
16993#Evaluation of Howland-type integrals involving tanh and coth functions
16994#On the definiteness of Gauss-Kronrod integration rules
16995#Convergence of product integration rules for functions with interior and end point singularities over bounded and unbounded intervals
16996#More quadratically converging algorithms for &pgr;
16997#Computing when multiplications cost nothing
16998#On the number of false witnesses for a composite number
16999#Breeding amicable numbers in abundance
17000#Use of a computer scan to proveQ(#:.PC13#:3W 2:9T+:9T:.NC#:.PC12# :3Wz:H2:9U)#and #Q(#:.PC13# :3Wz:S3:9T+:9T:.NC# :.PC12#:3Wz:H2:9U)
17001#Computing the irreducible characters of the group GL6(2)
17002#A generalization of Swan's theorem
17003#A note on class-number one in certain real quadratic and pure cubic fields
17004#Class numbers of cyclotomic function fields
17005#Weight distributions of some irreducible
17006#Module interconnection languages
17007#Are deeply nested conditionals less readable?
17008#Test sets generation from algebraic specifications using logic programming
17009#Analysis of a modified model for synchronous multiprocessor systems
17010#The software productivity consortium (SPC): an industry initiative to improve the productivity and quality of mission-critical software
17011#A modest proposal: computer education can be raised to professional status
17012#Comprehensive molecular modelling system
17013#Holographic superposition of molecular models
17014#Computer graphics applications of electron deformation densities and electrostatic potentials in coordination chemistry
17015#Polyhedral approximation approach to molecular orbital graphics
17016#Multiangular method for analysing molecular geometry from nuclear overhauser effect results
17017#In-house chemical databases at imperial chemical industries
17018#Current trends in computing: hardware, software, software and nuclear magnetic resonance research
17019#Abstracts from the joint meeting of the groupe graphique molecularie and the molecular graphics society, part I
17020#Streamline diffusion methods for the incompressible Euler and Navier-Stokes equations
17021#On nonlocal monotone difference schemes for scalar conservation laws
17022#Intermediate boundary conditions for time-split methods applied to hyperbolic partial differential equations
17023#Galerkin approximations of abstract parabolic boundary value problems with rough boundary data—Lp theory
17024#On Runge-Kutta methods for parabolic problems with time-dependent coefficients
17025#The construction of preconditioners for elliptic problems by substructuring. I
17026#Logarithmic convexity for discrete harmonic function and the approximation of the Cauchy problem for poisson's equation
17027#Numerical approximation of Mindlin-Reissner plates
17028#On solving singular integral equations via a hyperbolic tangent quadrature rule
17029#Discontinuous polynomial approximations in the theory of one-step, hybrid and multistep methods for nonlinear ordinary differential equations
17030#A stability analysis of incomplete LU factorizations
17031#The convergence of accelerated overrelaxation iterations
17032#Explicit nearly optimal linear rational approximation with preassigned poles
17033#Some asymptotic properties of Padé approximants to e-x
17034#Root neighborhoods of a polynomial
17035#Two formulas for the general multivariate polynomial which interpolates a regular grid on a simplex
17036#Some new aspects of rational interpolation
17037#Quadrature formulas for functions with poles near the interval of integration
17038#A modification of the weeks method for numerical inversion of the Laplace transform
17039#Symmetric FFTs
17040#An asymptotic expansion for the first derivative of the generalized Riemann Zeta function
17041#Counting sums of two squares: The Meissel-Lehmer method
17042#Computation of all the amicable paris below 1010
17043#Analysis of effective radiant temperatures in a Pacific Northwest forest using thermal infrared multispectral scanner data
17044#Relation between :0CL-band soil emittance and soil water content
17045#Soil background effects on the spectral response of a three-component rangeland scene
17046#Scattering from a random layer embedded with dielectric needles
17047#Regression models for vegetation radar-backscattering and radiometric emission
17048#Distinguishing among tallgrass prairie cover types from measurements of multispectral reflectance
17049#Satellite thermal observation of oil slicks on the Persian Gulf
17050#Effect of dew on canopy reflectance and temperature
17051#Characterizing corn hybrid moisture stress sensitivity using canopy temperature measurements
17052#Image restoration and reconstruction
17053#TOAM: A transportable office analysis methodology for the design of synthetic database systems
17054#DSS, information systems and management games
17055#Information systems for sustainable competitive advantage
17056#SSA should limit ADP procurement until further testing is performed, United States general accounting office
17057#Information systems assessment
17058#Software engineering 86
17059#Third International Workshop on Statistical and Scientific Database Management
17060#Flexible manufacturing systems: An industry overview
17061#Automation technology: Past, present, and future
17062#Calculating holding costs for single-level discrete-demand lot sizing
17063#A graphical method for optimizing a continuous review inventory system
17064#A modified LIMIT method for determining optimum lot sizes
17065#Flexible manufacturing systems: Technology and advantages
17066#Finding lot sizes for materials used in projects
17067#MRP re-implementation
17068#Two-level master scheduling: Setting the level of option overplanning and measuring inventory reduction
17069#A system for improving the accuracy of cost estimates
17070#Lot sizing through the Fordyce-Webster heuristic
17071#Factors to consider in automating vehicle preventive maintenance scheduling
17072#Economic order quantities for systems with step-function ordering costs
17073#A nomograph for ordering inventory when the forecast is ridiculous
17074#Lot-size determination with quantity discounts
17075#On the analysis of the unsymmetric successive overrelaxation method when applied to p-cyclic matrices
17076#A nonconforming combined method for solving Laplace's boundary value problems with singularities
17077#On Bateman's method for second kind integral equations
17078#Analysis of a non-linear difference scheme in reaction-diffusion
17079#A remark on the L :3WKbounds of the Ritz operator associated with a finite element approximation
17080#Asymptotic behaviour and acceleration of iterative sequences
17081#Cubature formulae which are exact on spaces P, intermediate between Pk and Qk'
17082#ALTEP-A Cellular processor for high-speed pattern matching
17083#Low cost environment changing in a shallow binding system
17084#The Alexander method-a technique for the processing of recursive axioms in deductive databases
17085#Spreadsheets with incremental queries as a user interface for logic programming
17086#Logic program forms
17087#Users of prolog in implementation of expert systems
17088#Report on the 12th Annual international symposium on computer architecture
17089#Report on the logic programming conference '86
17090#The minimum nonaliased wavelength in an orthogonal multi-dimensional grid
17091#An operational approach to perturbation analysis of closed queuing networks
17092#Explicit group over-relaxation methods for solving elliptic partial differential equations
17093#Modelling and computer simulation on nonlinear biotechnological processes
17094#Simulation of the sea-and land-breezes in Athens
17095#Estimation of non-uniquely identifiable parameters via exhaustive modeling and membership set theory
17096#Proposal for a Monte Carlo simulation of turbulent mixing in reactive flows
17097#Electron beam testing
17098#Electron beam testing of VLSI circuits assisted by focused ion beam etching
17099#Electron beam testing of ultra large scale integrated circuits
17100#Background and applications of electron beam test techniques
17101#Intelligent multivariate process supervision
17102#Chemometrics and Intelligent Laboratory Systems
17103#Fourier transforms: use, theory and applications to spectroscopic and related data
17104#Investigation on the use of chemical mass balance receptor model: numerical computations
17105#Effect of signal-to-noise radio and number of data points upon precision in measurement of peak amplitude, position and width in Fourier transform spectrometry
17106#Chemical transitions measured by Spectra and resolved using singular value decomposition
17107#Calibration with imprecise signals and concentrations based on fuzzy theory
17108#Factor analysis and experiment design in high-performance liquid chromatography. III. Influence of mobile phase modifications on the selectivity of chalcones on a diol stationary phase
17109#Symphony in the analytical laboratory
17110#An expert system for the development of analytical procedures: UV spectrophotometric determination of pharmaceutically active substances in tablets
17111#AXIL-PC: software for the analysis of complex X-ray spectra
17112#A modular operation system for the CRAY-1
17113#Algorithms for BD trees
17114#The llem project: Pascal to Algol in easy stages: Outward Bound
17115#Another approach to the implementation of Synchronization Primitives
17116#Writing concurrent assemblers- A case study in Path Pascal
17117#An alternate smoothing and stripping algorithm for thinning digital binary patterns
17118#Resolution of range and Doppler ambiguities in medium PRF radars in multiple target environment
17119#On discrete stochastic congruences in communications: the one-and two-dimensional problems
17120#Experiments on two-dimensional decimation in time and orthogonal transform domains
17121#Performance analysis of the smoothed least mean square (SLMS) algorithm
17122#Discrete Wigner synthesis
17123#A theory of distributed detection
17124#Estimation of spectral parameters of correlated signals in wavefields
17125#On the evaluation of first passage time densities for Gaussian processes
17126#Some properties of the Shur recursion for the direct computation of the matricial spectral factor
17127#Doppler analysis of multiple-line spectra
17128#Motion compensating field interpolation using a hierarchically structured displacement estimator
17129#A protocol for generalized occam
17130#The automatic generation of Fast Lexical Analysers
17131#Side-effects in automatic file updating
17132#Contextually communicating sequential processes: a software engineering environment
17133#Concurrent C
17134#Profiling under ELXSI UNIX
17135#Numerical analysis
17136#Practical MVS JCL for today's programmer
17137#Proceedings of the Johns Hopkins Univ. applied physics laboratory 2nd symposium on The role of language in problem solving 2
17138#Introduction to systems analysis and design: a structured approach
17139#Problem solving and structured programming in FORTRAN 77 (3rd ed.)
17140#Basic keyboarding skills for information processors
17141#An introduction to Vax assembly language programming
17142#Structured COBOL
17143#Macintosh assembly language: a guide for programmers
17144#Statistical analysis with missing data
17145#System identification: theory for the user
17146#Proceedings of the 4th conference on Logic programming '85
17147#The database book
17148#Complete BASIC programming (2nd ed.)
17149#Computers and information processing: concepts and applications
17150#Computers and information processing: concepts and applications with BASIC (4th ed.)
17151#Introduction to BASIC programming (3rd ed.)
17152#Pascal programming today
17153#Turbo Pascal programming today
17154#Working with application software/Apple II 2. 1B version
17155#Working with application software/IBM 2.1B version
17156#Working with application software/TRS80 2.1B version
17157#The UNIX shell programming language
17158#Multivariate statistical methods: a primer
17159#Mathematical nonparametric statistics
17160#Sturm-Liouville operators and applications
17161#Digital spectral analysis: with applications
17162#Programming the NS32000
17163#Bible BASIC: advanced lessons in computer BASIC using Bible illustrations
17164#Using applications software: tutorials and activities
17165#VSAM: access method, services and programming techniques
17166#Nonlinear operators and differential equations in Banach spaces
17167#Operating systems theory and practice
17168#Algorithms, programming, Pascal
17169#Fundamentals of systems analysis with application design
17170#MS-DOS
17171#Proceedings of the CWI symposium on Mathematics and computer science
17172#Numerical methods for computer science, engineering, and mathematics
17173#Assembly language primer for the Macintosh
17174#Programming languages
17175#IBM assembler: an intuitive approach
17176#Seimgroups of linear operators: an introduction
17177#Software maintenance management
17178#The universal machine: confessions of a technological optimist
17179#A beginner's guide to list processing: the other side of LOGO
17180#The debugger's handbook, Turbo Pascal
17181#Invitation to APL for the IBM-PC
17182#Invitation to C
17183#Basic programming with the IBM PC
17184#Lessons in digital estimation theory
17185#Introduction to probability and statistics (7th ed.)
17186#Database systems and file systems as alternative methods of organizing data in commercial applications: a contribution to management science
17187#Microcomputer software for information management: case studies
17188#Microprocessor fundamentals
17189#Operating systems: concepts and design
17190#Mastering disk operations on the Commodore 128
17191#Commodore 128 data file programming
17192#Basic statistics: a conceptual approach for beginners
17193#File structure using Pascal
17194#Asymptotic theory of finite dimensional normed spaces
17195#Silicon APL—the translation of APL language concepts into processor architectures
17196#Software maintenance criteria for small microprocessor-based systems
17197#Application of titanium RIE to the fabrication of nm-scale structures
17198#The h, p and h-p versions of the finite element method in 1 dimension. Part 1. The error analysis of the p-version.
17199#The h, p and h-p versions of the finite element method in 1 dimension. Part II. The error analysis of the h and h-p versions
17200#The h, p and h-p versions of the finite element methods in 1 dimension . Part III. The adaptive h-p version.
17201#Generalization of the Bauer-Fike theorem
17202#Solving complex chemical equilibria using a geometric-programming based technique
17203#A bank asset and liability management model
17204#An empirical formula for visual search
17205#Dynamic nonlinear pricing in networks with interdependent demand
17206#Network models of spatial oligopoly with an application to deregulation of electricity generation
17207#Alternative models of spatial competition
17208#A queue with starter and a queue with vacations: delay analysis by decomposition
17209#Multivariate imperfect repair
17210#An algorithm to compute the equilibrium distribution of a one-dimensional bounded random walk
17211#Two-stage cyclic queues with nonexponential servers: steady-state and cyclic time
17212#Scheduling cyclic production on several identical machines
17213#Consistency of the disaggregation process in hierarchical planning
17214#Discrete search with directional information
17215#An optimal selection problem for a sequence with a random number of applicants per period
17216#A generalized problem of optimal selection and assignment
17217#Clique tree inequalities and the symmetric travelling salesman problem
17218#A family of simplex variants solving an m×d linear program in expected number of pivot steps depending on d only
17219#Optimal stopping in sequential games with or without a constraint of always terminating
17220#Stochastic comparisons for non-markov processes
17221#Optimal squential assignment
17222#A zero-sum game with incomplete information and compact action spaces
17223#A Gauss-Newton approach to solving generalized inequalities
17224#A parametric subproblem for dual methods in decomposition
17225#Random binary search: A randomizing algorithm for global optimization in R1
17226#The jacobian matrix, global univalence and completely mixed games
17227#Equivalence of solutions to network location problems
17228#On iterated minimization in nonconvex optimization
17229#Letter to the editor: on Borwein's paper, “adjoint process duality”
17230#A 98%-effective lot-sizing rule for a multi-product, multi-stage production/inventory system
17231#Computer literacy and computer science and their relationship to mathematics
17232#Incorporating computer literacy into a mathematics course for preservice elementary are teachers
17233#Inspirals
17234#Synthetic division for polynomials:80more than just P(S)
17235#Prime numbers and fermats little theorem
17236#A discussion of the philosophy of mathematics
17237#Brahmagupta's quadrilateral
17238#Some geometrical constructions of cubic curves
17239#Directional reflectance response in AVHRR red and near-IR bands for three cover types and varying atmospheric conditions
17240#Separation of soil-plant spectral mixture by factor analysis
17241#Analysis of a resistance-energy balance method for estimating daily evaporation from wheat plots using one-time-of-day infrared temperature observations
17242#Identification of major backscattering sources in trees and shrubs at 10 GHz
17243#Application of shuttle imaging radar data for land use investigations
17244#On solving the equality problem in theories defined by Horn clauses
17245#Generalized language equations with multiple solutions
17246#Repetition-free words
17247#Complete semi-Thue systems for abelian groups
17248#An algorithm for generating shift-register cycles
17249#On the impossibility of the homomorphic characterization of context sensitive languages
17250#On Greibach normal form construction
17251#On the equivalence problem for regular Thue systems
17252#A theory for nondeterminism, parallelism, communication, and concurrency
17253#Transducers and repetitions
17254#Manipulating derivation forests by scheduling techniques
17255#A characterization of F-complete assignments
17256#The system F of variable types, fifteen years later
17257#Merging regular processes by means of fixed-point theory
17258#Some complexity bounds for problems concerning finite and 2-dimensional vector addition systems with states
17259#Semantics of infinite tree logic programming
17260#On some equations in free partially commutative monoids
17261#Generalized regular expressions — A language for synthesis of programs with branching in loops
17262#Computability in higher types, P&ohgr; and the completeness of type assignment
17263#Average polynomial time complexity of some NP-complete problems
17264#A simple dynamic logic
17265#The automated proof of a trace transformation for a bitonic sort
17266#An algebraic and algorithmic method for analysing transition systems
17267#Proof of termination of the rewriting system SUBST on CCL
17268#On some variants of the Ehrenfeucht conjecture
17269#Commutative monoids have complete presentations by free (non-commutative) monoids
17270#Lower bounds for the approximative complexity
17271#On nondeterminism in parallel computation
17272#A classification of complexity core lattices
17273#Some observations on the connection between counting and recursion
17274#Finite automata and unary languages
17275#Subword topology
17276#On simple and creative sets in NP
17277#Rapid calculation of shuffles of two words
17278#Searching and pebbling
17279#Self-embedding indexed grammars
17280#The undecidability of self-embedding for finite semi-Thue and Thue systems
17281#The Risch differential equation problem
17282#Data structures for retrieval on square grids
17283#Communication complexity of computing the Hamming distance
17284#Improved bounds for matroid partition and intersection algorithms
17285#An inhomogeneity in the structure of Karp degrees
17286#Heaps on heaps
17287#On approximations and incidence in cylindrical algebraic decompositions
17288#Log depth circuits for division and related problems
17289#On the validity of the direct sum conjecture
17290#On the single-operation worst-case time complexity of the disjoint set union problem
17291#Ranking and unranking of AVL-trees
17292#A simple parallel algorithm for the maximal independent set problem
17293#Finding a maximum clique in an arbitrary graph
17294#Average case analysis of marking algorithms
17295#Searching in trees, series-parallel and interval orders
17296#Processor-shared time-sharing models in heavy traffic
17297#Some observations about the randomness of hard problems
17298#Probabilistic analysis of two heuristics for the 3-satisfiability problem
17299#Worst case bound of an LRF schedule for the mean weighted flow-time problem
17300#On maintaining dynamic information in a concurrent environment
17301#Sums of divisors, perfect numbers and factoring
17302#Completion of a set of rules modulo a set of equations
17303#The Delft Parallel Processor DPP81: Properties and utilization in simulation and related fields
17304#Scientific evidence and policy alternatives: The dispute over acid rain between Canada and the United States
17305#Determination of robust multivariable I-controllers by means of experiments and simulation
17306#Irreversibility by inequality constraints. Part II: The Second Law of Thermodynamics
17307#Accelerated algorithms of the augmented interaction balance method for large-scale system optimization of control
17308#On the applicability of group decision making concepts to wage bargaining
17309#Performance evaluation of simulators
17310#Simulation of firm behavior under economic reform conditions
17311#Simulation of pharmaceutical services management
17312#Superposition procedure — an systematic approach for large-scale ecosystem modelling
17313#A note on asymptotic estimates of the sojourn time variance in the M/G/1 queue with processor-sharing
17314#A fuzzy constructive approach to modelling of complex systems
17315#Some remarks on statistical inference for approximately periodical functions using threshold functions
17316#Man-machine procedures of decision making under uncertainty based on linear programming
17317#New results about decision making through DIMCO method its positional supplementand PARETO optimality
17318#A multi-processor implementation of occam
17319#A practical approach to data modelling in spatial applications
17320#Foreet: a tool for design and documentation of Fortran programs
17321#Logicon: an integration of Prolog into Icon
17322#Communications in Meglos
17323#Segments on bit-mapped graphics displays
17324#An algorithm for the selection problem
17325#A functional processor for the relational algebra on a microcomputer
17326#Specification methodology: an integrated relational approach
17327#An experiment with the Newcastle Connection Protocol
17328#Computing advice at a distance: the 'remote advisory' concept
17329#Three way branching self consistency checking of hardware and software
17330#Analysis of modeling errors in system identification
17331#A graphics based robot simulation
17332#A testbed for the time warp distributed simulation mechanism a modular and hierarchical software system
17333#Modeling tradeoffs in the hierarchical design of VLSI array structures
17334#Transformational program development in a particular problem domain
17335#Small programming exercises 13
17336#Color enhancement of highly correlated images. I. Decorrelation and HSI contrast stretches
17337#Precision in geodetic correction of TM data as a function of the number, spatial distribution, and success in matching of control points: a simulation
17338#The spectral reflectance of stands of Norway Spruce and Scotch Pine, measured from a helicopter
17339#Effect of surface properites on the narrow to broadband spectral relationship in clear sky satellite observations
17340#Preliminary analyses of SIR-B radar data for recent Hawaii lava flows
17341#Moorland plant community recognition using Landstat MSS data
17342#Assessment of grassland phytomass with airborne video imagery
17343#Assigning the 625cm-1 and other high frequency Raman bands of the Z1 form of DNA using a normal modes analysis and computer graphics
17344#Easy projection of stereo movies
17345#Interactive flexible molecular fitting program to be integrated into computer-aided molecular modelling systems
17346#Substrate steering by electrostatics fields of enzymes: visualization by computer graphics
17347#Visualization of energetics and conformations from molecular computer simulations
17348#Intermolecular enzyme-ligand animation in the active site of porcine pancreatic elastase with acetyl-alanine-proline-alanine by means of molecular dynamics calc
17349#Program for the visualization and interactive study of molecules on a calligraphic display system
17350#Protein secondary structural representation using real-time interactive computer graphics
17351#Parsing Korean: A free word order language
17352#Automatic stylistic analysis of lyrical texts
17353#An editor's expert system
17354#The N-V dichotomy in the structure of English noun compounds?
17355#Some thoughts concerning the application of software tools in support of Old English poetic studies
17356#Phonetic character sets: printing, sorting and computing
17357#Statistical considerations on the number of functional elements in modern French
17358#Computing methodology in the humanities. II. Statistics (A-J)
17359#Living with SNA
17360#Sunrise Europe: the dynamics of information technology
17361#Material requirements for fiber optics
17362#Micro-to-mainframe communications
17363#Mid-term 1985 status of the IC industry
17364#Proceedings of the conference held at the Center for operations research and econometrics on Nonlinear analysis and optimization
17365#Proceedings of the 11th Dundee Biennial conference on Numerical analysis
17366#Proceedings of the 4th IIMAS workshop on Numerical analysis
17367#a crash course in Pascal
17368#Introduction to computer science (2nd ed.)
17369#Modula-2 text and reference
17370#Working with Xenix system
17371#A simplified guide to using statistical techniques with computer applications
17372#Pascal on the Macintosh: a graphical approach
17373#The first dictionary of computing
17374#My first computer dictionary
17375#My first book about BASIC
17376#My first book about computers
17377#Numerical derivatives and nonlinear analysis
17378#Nato Advanced Study Institute on control flow and data flow: concepts of distributed programming (1984: Marktoberdorf, Germany) (2nd ed.)
17379#NATO Advanced Study Institute on nonlinear functional analysis and its applications (1985: Maratea, Italy)
17380#New directions for data base systems
17381#New perspectives in theoretical and applied statistics
17382#Schaum's outline of theories and problems of programming with advanced structured COBOL with file processing structured systems deveolpment and interactive cons
17383#Major microprocessors: a unified approach to CALM
17384#Fundamentals of structured COBOL (2nd ed.)
17385#IBM PC shareware: PC-File, PC-Write, PC-Talk, and ExperssCalc
17386#Personal computers for scientists: a byte at a time
17387#Information processing today, with applications
17388#Information processing today, with applications
17389#Information processing today, with applications and BASIC
17390#Information processing today, with applications and BASIC: updat 87/88
17391#Principles of information processing
17392#Papers of John von Neumann on computing and computer theory
17393#Parallelism, communication and synchronization
17394#Understanding computers and data processing: today and tomorrow with BASIC
17395#Microprocessor technology and microcomputers
17396#First steps with BASIC: a gentle introduction to programming
17397#Advanced COBOL (2nd ed.)
17398#The NAG Library: a beginners guide
17399#RSX, a guide for users
17400#Optimization theory with applications
17401#Eigenvalues and s-numbers
17402#A guide to programming in Apple Pascal
17403#A guide to programming in Applesoft (3rd ed.)
17404#A guide to programming in Turbo Pascal
17405#Software engineering: a practitioner's approach (2nd ed.)
17406#Applesoft: fundamentals and style
17407#Designing efficient algorithms for parallel computers
17408#Data handling utilities in C
17409#Quick-start guide for 12 top PC programs
17410#Microcomputer theory and applications with the Intel SDK-85 (2nd ed.)
17411#Single leader election protocols using nonuniform merits
17412#A Turbo prolog primer
17413#Parallel system
17414#Functional analysis and control theory: linear systems
17415#Inside Macintosh
17416#Integrated software for microcomputer systems
17417#Programming the 68000: Macintosh assembly languages
17418#Pascal, an introduction to the art and science of programming
17419#Prgramming expert systems in Modula-2
17420#Turbo Pascal programming
17421#ANS MUMPS programmer's reference manual, 1981 and ANS MUMPS language standard: revision of the MUMPS programmer's reference manual
17422#Discrete mathematics for computer science
17423#Amiga programmer's guide
17424#Semigroups, theory and applications
17425#Programming in Turbo and Apple Pascal
17426#Artificial intelligence programming for the Macintosh
17427#Silicon visions: the future of microcomputer technology
17428#Distributed systems and computer networks
17429#Programming the Intel 80386
17430#The IBM PC/AT programmer”s guide
17431#Mathematical modelling and digital simulation for engineers and scientists (2nd ed.)
17432#Introduction to computers and programming: Pascal
17433#Software reliability
17434#Avoiding microcomputer headaches: how to control the acquisition, use, and security risks of microcomputers
17435#Negation and control in Prolog
17436#Reference manual of FORTRAN program ILLOD-(NOR-B) for optimal NOR networks
17437#Information science dictionary: English, Spanish, French: Spanish, English, French: French, English, Spanish
17438#NATO Advanced Study Institute on relational database machine architecture (1983: Les Arcs, France)
17439#Pitman research notes in mathematics series, 0269-3674; 154 on Oakland conference on partial differential equations and applied mathematics
17440#Object-oriented concurrent programming
17441#Opening windows
17442#Statistics, making sense of data
